// Generated by jextract

package org.python;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

public class Python_h_2 extends Python_h_3 {

    Python_h_2() {
        // Should not be called directly
    }

    private static class _ultoa_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_ultoa_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _ultoa_s(unsigned long _Value, char *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static FunctionDescriptor _ultoa_s$descriptor() {
        return _ultoa_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _ultoa_s(unsigned long _Value, char *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static MethodHandle _ultoa_s$handle() {
        return _ultoa_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _ultoa_s(unsigned long _Value, char *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static MemorySegment _ultoa_s$address() {
        return _ultoa_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _ultoa_s(unsigned long _Value, char *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static int _ultoa_s(int _Value, MemorySegment _Buffer, long _BufferCount, int _Radix) {
        var mh$ = _ultoa_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ultoa_s", _Value, _Buffer, _BufferCount, _Radix);
            }
            return (int)mh$.invokeExact(_Value, _Buffer, _BufferCount, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ultoa {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_ultoa");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *_ultoa(unsigned long _Value, char *_Buffer, int _Radix)
     * }
     */
    public static FunctionDescriptor _ultoa$descriptor() {
        return _ultoa.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *_ultoa(unsigned long _Value, char *_Buffer, int _Radix)
     * }
     */
    public static MethodHandle _ultoa$handle() {
        return _ultoa.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *_ultoa(unsigned long _Value, char *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment _ultoa$address() {
        return _ultoa.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *_ultoa(unsigned long _Value, char *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment _ultoa(int _Value, MemorySegment _Buffer, int _Radix) {
        var mh$ = _ultoa.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ultoa", _Value, _Buffer, _Radix);
            }
            return (MemorySegment)mh$.invokeExact(_Value, _Buffer, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _i64toa_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_i64toa_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _i64toa_s(long long _Value, char *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static FunctionDescriptor _i64toa_s$descriptor() {
        return _i64toa_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _i64toa_s(long long _Value, char *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static MethodHandle _i64toa_s$handle() {
        return _i64toa_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _i64toa_s(long long _Value, char *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static MemorySegment _i64toa_s$address() {
        return _i64toa_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _i64toa_s(long long _Value, char *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static int _i64toa_s(long _Value, MemorySegment _Buffer, long _BufferCount, int _Radix) {
        var mh$ = _i64toa_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_i64toa_s", _Value, _Buffer, _BufferCount, _Radix);
            }
            return (int)mh$.invokeExact(_Value, _Buffer, _BufferCount, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _i64toa {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_i64toa");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *_i64toa(long long _Value, char *_Buffer, int _Radix)
     * }
     */
    public static FunctionDescriptor _i64toa$descriptor() {
        return _i64toa.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *_i64toa(long long _Value, char *_Buffer, int _Radix)
     * }
     */
    public static MethodHandle _i64toa$handle() {
        return _i64toa.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *_i64toa(long long _Value, char *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment _i64toa$address() {
        return _i64toa.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *_i64toa(long long _Value, char *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment _i64toa(long _Value, MemorySegment _Buffer, int _Radix) {
        var mh$ = _i64toa.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_i64toa", _Value, _Buffer, _Radix);
            }
            return (MemorySegment)mh$.invokeExact(_Value, _Buffer, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ui64toa_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_ui64toa_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _ui64toa_s(unsigned long long _Value, char *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static FunctionDescriptor _ui64toa_s$descriptor() {
        return _ui64toa_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _ui64toa_s(unsigned long long _Value, char *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static MethodHandle _ui64toa_s$handle() {
        return _ui64toa_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _ui64toa_s(unsigned long long _Value, char *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static MemorySegment _ui64toa_s$address() {
        return _ui64toa_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _ui64toa_s(unsigned long long _Value, char *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static int _ui64toa_s(long _Value, MemorySegment _Buffer, long _BufferCount, int _Radix) {
        var mh$ = _ui64toa_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ui64toa_s", _Value, _Buffer, _BufferCount, _Radix);
            }
            return (int)mh$.invokeExact(_Value, _Buffer, _BufferCount, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ui64toa {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_ui64toa");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *_ui64toa(unsigned long long _Value, char *_Buffer, int _Radix)
     * }
     */
    public static FunctionDescriptor _ui64toa$descriptor() {
        return _ui64toa.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *_ui64toa(unsigned long long _Value, char *_Buffer, int _Radix)
     * }
     */
    public static MethodHandle _ui64toa$handle() {
        return _ui64toa.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *_ui64toa(unsigned long long _Value, char *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment _ui64toa$address() {
        return _ui64toa.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *_ui64toa(unsigned long long _Value, char *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment _ui64toa(long _Value, MemorySegment _Buffer, int _Radix) {
        var mh$ = _ui64toa.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ui64toa", _Value, _Buffer, _Radix);
            }
            return (MemorySegment)mh$.invokeExact(_Value, _Buffer, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ecvt_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_DOUBLE,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_ecvt_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _ecvt_s(char *_Buffer, size_t _BufferCount, double _Value, int _DigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static FunctionDescriptor _ecvt_s$descriptor() {
        return _ecvt_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _ecvt_s(char *_Buffer, size_t _BufferCount, double _Value, int _DigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static MethodHandle _ecvt_s$handle() {
        return _ecvt_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _ecvt_s(char *_Buffer, size_t _BufferCount, double _Value, int _DigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static MemorySegment _ecvt_s$address() {
        return _ecvt_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _ecvt_s(char *_Buffer, size_t _BufferCount, double _Value, int _DigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static int _ecvt_s(MemorySegment _Buffer, long _BufferCount, double _Value, int _DigitCount, MemorySegment _PtDec, MemorySegment _PtSign) {
        var mh$ = _ecvt_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ecvt_s", _Buffer, _BufferCount, _Value, _DigitCount, _PtDec, _PtSign);
            }
            return (int)mh$.invokeExact(_Buffer, _BufferCount, _Value, _DigitCount, _PtDec, _PtSign);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ecvt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_DOUBLE,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_ecvt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *_ecvt(double _Value, int _DigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static FunctionDescriptor _ecvt$descriptor() {
        return _ecvt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *_ecvt(double _Value, int _DigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static MethodHandle _ecvt$handle() {
        return _ecvt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *_ecvt(double _Value, int _DigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static MemorySegment _ecvt$address() {
        return _ecvt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *_ecvt(double _Value, int _DigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static MemorySegment _ecvt(double _Value, int _DigitCount, MemorySegment _PtDec, MemorySegment _PtSign) {
        var mh$ = _ecvt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ecvt", _Value, _DigitCount, _PtDec, _PtSign);
            }
            return (MemorySegment)mh$.invokeExact(_Value, _DigitCount, _PtDec, _PtSign);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fcvt_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_DOUBLE,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_fcvt_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _fcvt_s(char *_Buffer, size_t _BufferCount, double _Value, int _FractionalDigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static FunctionDescriptor _fcvt_s$descriptor() {
        return _fcvt_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _fcvt_s(char *_Buffer, size_t _BufferCount, double _Value, int _FractionalDigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static MethodHandle _fcvt_s$handle() {
        return _fcvt_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _fcvt_s(char *_Buffer, size_t _BufferCount, double _Value, int _FractionalDigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static MemorySegment _fcvt_s$address() {
        return _fcvt_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _fcvt_s(char *_Buffer, size_t _BufferCount, double _Value, int _FractionalDigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static int _fcvt_s(MemorySegment _Buffer, long _BufferCount, double _Value, int _FractionalDigitCount, MemorySegment _PtDec, MemorySegment _PtSign) {
        var mh$ = _fcvt_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fcvt_s", _Buffer, _BufferCount, _Value, _FractionalDigitCount, _PtDec, _PtSign);
            }
            return (int)mh$.invokeExact(_Buffer, _BufferCount, _Value, _FractionalDigitCount, _PtDec, _PtSign);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fcvt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_DOUBLE,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_fcvt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *_fcvt(double _Value, int _FractionalDigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static FunctionDescriptor _fcvt$descriptor() {
        return _fcvt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *_fcvt(double _Value, int _FractionalDigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static MethodHandle _fcvt$handle() {
        return _fcvt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *_fcvt(double _Value, int _FractionalDigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static MemorySegment _fcvt$address() {
        return _fcvt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *_fcvt(double _Value, int _FractionalDigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static MemorySegment _fcvt(double _Value, int _FractionalDigitCount, MemorySegment _PtDec, MemorySegment _PtSign) {
        var mh$ = _fcvt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fcvt", _Value, _FractionalDigitCount, _PtDec, _PtSign);
            }
            return (MemorySegment)mh$.invokeExact(_Value, _FractionalDigitCount, _PtDec, _PtSign);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _gcvt_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_DOUBLE,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_gcvt_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _gcvt_s(char *_Buffer, size_t _BufferCount, double _Value, int _DigitCount)
     * }
     */
    public static FunctionDescriptor _gcvt_s$descriptor() {
        return _gcvt_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _gcvt_s(char *_Buffer, size_t _BufferCount, double _Value, int _DigitCount)
     * }
     */
    public static MethodHandle _gcvt_s$handle() {
        return _gcvt_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _gcvt_s(char *_Buffer, size_t _BufferCount, double _Value, int _DigitCount)
     * }
     */
    public static MemorySegment _gcvt_s$address() {
        return _gcvt_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _gcvt_s(char *_Buffer, size_t _BufferCount, double _Value, int _DigitCount)
     * }
     */
    public static int _gcvt_s(MemorySegment _Buffer, long _BufferCount, double _Value, int _DigitCount) {
        var mh$ = _gcvt_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_gcvt_s", _Buffer, _BufferCount, _Value, _DigitCount);
            }
            return (int)mh$.invokeExact(_Buffer, _BufferCount, _Value, _DigitCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _gcvt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_DOUBLE,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_gcvt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *_gcvt(double _Value, int _DigitCount, char *_Buffer)
     * }
     */
    public static FunctionDescriptor _gcvt$descriptor() {
        return _gcvt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *_gcvt(double _Value, int _DigitCount, char *_Buffer)
     * }
     */
    public static MethodHandle _gcvt$handle() {
        return _gcvt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *_gcvt(double _Value, int _DigitCount, char *_Buffer)
     * }
     */
    public static MemorySegment _gcvt$address() {
        return _gcvt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *_gcvt(double _Value, int _DigitCount, char *_Buffer)
     * }
     */
    public static MemorySegment _gcvt(double _Value, int _DigitCount, MemorySegment _Buffer) {
        var mh$ = _gcvt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_gcvt", _Value, _DigitCount, _Buffer);
            }
            return (MemorySegment)mh$.invokeExact(_Value, _DigitCount, _Buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ___mb_cur_max_func {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("___mb_cur_max_func");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ___mb_cur_max_func()
     * }
     */
    public static FunctionDescriptor ___mb_cur_max_func$descriptor() {
        return ___mb_cur_max_func.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ___mb_cur_max_func()
     * }
     */
    public static MethodHandle ___mb_cur_max_func$handle() {
        return ___mb_cur_max_func.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ___mb_cur_max_func()
     * }
     */
    public static MemorySegment ___mb_cur_max_func$address() {
        return ___mb_cur_max_func.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ___mb_cur_max_func()
     * }
     */
    public static int ___mb_cur_max_func() {
        var mh$ = ___mb_cur_max_func.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("___mb_cur_max_func");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ___mb_cur_max_l_func {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("___mb_cur_max_l_func");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ___mb_cur_max_l_func(_locale_t _Locale)
     * }
     */
    public static FunctionDescriptor ___mb_cur_max_l_func$descriptor() {
        return ___mb_cur_max_l_func.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ___mb_cur_max_l_func(_locale_t _Locale)
     * }
     */
    public static MethodHandle ___mb_cur_max_l_func$handle() {
        return ___mb_cur_max_l_func.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ___mb_cur_max_l_func(_locale_t _Locale)
     * }
     */
    public static MemorySegment ___mb_cur_max_l_func$address() {
        return ___mb_cur_max_l_func.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ___mb_cur_max_l_func(_locale_t _Locale)
     * }
     */
    public static int ___mb_cur_max_l_func(MemorySegment _Locale) {
        var mh$ = ___mb_cur_max_l_func.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("___mb_cur_max_l_func", _Locale);
            }
            return (int)mh$.invokeExact(_Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mblen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("mblen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mblen(const char *_Ch, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor mblen$descriptor() {
        return mblen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mblen(const char *_Ch, size_t _MaxCount)
     * }
     */
    public static MethodHandle mblen$handle() {
        return mblen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mblen(const char *_Ch, size_t _MaxCount)
     * }
     */
    public static MemorySegment mblen$address() {
        return mblen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mblen(const char *_Ch, size_t _MaxCount)
     * }
     */
    public static int mblen(MemorySegment _Ch, long _MaxCount) {
        var mh$ = mblen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mblen", _Ch, _MaxCount);
            }
            return (int)mh$.invokeExact(_Ch, _MaxCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _mblen_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_mblen_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _mblen_l(const char *_Ch, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _mblen_l$descriptor() {
        return _mblen_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _mblen_l(const char *_Ch, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MethodHandle _mblen_l$handle() {
        return _mblen_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _mblen_l(const char *_Ch, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MemorySegment _mblen_l$address() {
        return _mblen_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _mblen_l(const char *_Ch, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static int _mblen_l(MemorySegment _Ch, long _MaxCount, MemorySegment _Locale) {
        var mh$ = _mblen_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_mblen_l", _Ch, _MaxCount, _Locale);
            }
            return (int)mh$.invokeExact(_Ch, _MaxCount, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _mbstrlen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_mbstrlen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t _mbstrlen(const char *_String)
     * }
     */
    public static FunctionDescriptor _mbstrlen$descriptor() {
        return _mbstrlen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t _mbstrlen(const char *_String)
     * }
     */
    public static MethodHandle _mbstrlen$handle() {
        return _mbstrlen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t _mbstrlen(const char *_String)
     * }
     */
    public static MemorySegment _mbstrlen$address() {
        return _mbstrlen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t _mbstrlen(const char *_String)
     * }
     */
    public static long _mbstrlen(MemorySegment _String) {
        var mh$ = _mbstrlen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_mbstrlen", _String);
            }
            return (long)mh$.invokeExact(_String);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _mbstrlen_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_mbstrlen_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t _mbstrlen_l(const char *_String, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _mbstrlen_l$descriptor() {
        return _mbstrlen_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t _mbstrlen_l(const char *_String, _locale_t _Locale)
     * }
     */
    public static MethodHandle _mbstrlen_l$handle() {
        return _mbstrlen_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t _mbstrlen_l(const char *_String, _locale_t _Locale)
     * }
     */
    public static MemorySegment _mbstrlen_l$address() {
        return _mbstrlen_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t _mbstrlen_l(const char *_String, _locale_t _Locale)
     * }
     */
    public static long _mbstrlen_l(MemorySegment _String, MemorySegment _Locale) {
        var mh$ = _mbstrlen_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_mbstrlen_l", _String, _Locale);
            }
            return (long)mh$.invokeExact(_String, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _mbstrnlen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_mbstrnlen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t _mbstrnlen(const char *_String, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor _mbstrnlen$descriptor() {
        return _mbstrnlen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t _mbstrnlen(const char *_String, size_t _MaxCount)
     * }
     */
    public static MethodHandle _mbstrnlen$handle() {
        return _mbstrnlen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t _mbstrnlen(const char *_String, size_t _MaxCount)
     * }
     */
    public static MemorySegment _mbstrnlen$address() {
        return _mbstrnlen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t _mbstrnlen(const char *_String, size_t _MaxCount)
     * }
     */
    public static long _mbstrnlen(MemorySegment _String, long _MaxCount) {
        var mh$ = _mbstrnlen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_mbstrnlen", _String, _MaxCount);
            }
            return (long)mh$.invokeExact(_String, _MaxCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _mbstrnlen_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_mbstrnlen_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t _mbstrnlen_l(const char *_String, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _mbstrnlen_l$descriptor() {
        return _mbstrnlen_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t _mbstrnlen_l(const char *_String, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MethodHandle _mbstrnlen_l$handle() {
        return _mbstrnlen_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t _mbstrnlen_l(const char *_String, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MemorySegment _mbstrnlen_l$address() {
        return _mbstrnlen_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t _mbstrnlen_l(const char *_String, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static long _mbstrnlen_l(MemorySegment _String, long _MaxCount, MemorySegment _Locale) {
        var mh$ = _mbstrnlen_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_mbstrnlen_l", _String, _MaxCount, _Locale);
            }
            return (long)mh$.invokeExact(_String, _MaxCount, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mbtowc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("mbtowc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mbtowc(wchar_t *_DstCh, const char *_SrcCh, size_t _SrcSizeInBytes)
     * }
     */
    public static FunctionDescriptor mbtowc$descriptor() {
        return mbtowc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mbtowc(wchar_t *_DstCh, const char *_SrcCh, size_t _SrcSizeInBytes)
     * }
     */
    public static MethodHandle mbtowc$handle() {
        return mbtowc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mbtowc(wchar_t *_DstCh, const char *_SrcCh, size_t _SrcSizeInBytes)
     * }
     */
    public static MemorySegment mbtowc$address() {
        return mbtowc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mbtowc(wchar_t *_DstCh, const char *_SrcCh, size_t _SrcSizeInBytes)
     * }
     */
    public static int mbtowc(MemorySegment _DstCh, MemorySegment _SrcCh, long _SrcSizeInBytes) {
        var mh$ = mbtowc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mbtowc", _DstCh, _SrcCh, _SrcSizeInBytes);
            }
            return (int)mh$.invokeExact(_DstCh, _SrcCh, _SrcSizeInBytes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _mbtowc_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_mbtowc_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _mbtowc_l(wchar_t *_DstCh, const char *_SrcCh, size_t _SrcSizeInBytes, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _mbtowc_l$descriptor() {
        return _mbtowc_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _mbtowc_l(wchar_t *_DstCh, const char *_SrcCh, size_t _SrcSizeInBytes, _locale_t _Locale)
     * }
     */
    public static MethodHandle _mbtowc_l$handle() {
        return _mbtowc_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _mbtowc_l(wchar_t *_DstCh, const char *_SrcCh, size_t _SrcSizeInBytes, _locale_t _Locale)
     * }
     */
    public static MemorySegment _mbtowc_l$address() {
        return _mbtowc_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _mbtowc_l(wchar_t *_DstCh, const char *_SrcCh, size_t _SrcSizeInBytes, _locale_t _Locale)
     * }
     */
    public static int _mbtowc_l(MemorySegment _DstCh, MemorySegment _SrcCh, long _SrcSizeInBytes, MemorySegment _Locale) {
        var mh$ = _mbtowc_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_mbtowc_l", _DstCh, _SrcCh, _SrcSizeInBytes, _Locale);
            }
            return (int)mh$.invokeExact(_DstCh, _SrcCh, _SrcSizeInBytes, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mbstowcs_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("mbstowcs_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t mbstowcs_s(size_t *_PtNumOfCharConverted, wchar_t *_DstBuf, size_t _SizeInWords, const char *_SrcBuf, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor mbstowcs_s$descriptor() {
        return mbstowcs_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t mbstowcs_s(size_t *_PtNumOfCharConverted, wchar_t *_DstBuf, size_t _SizeInWords, const char *_SrcBuf, size_t _MaxCount)
     * }
     */
    public static MethodHandle mbstowcs_s$handle() {
        return mbstowcs_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t mbstowcs_s(size_t *_PtNumOfCharConverted, wchar_t *_DstBuf, size_t _SizeInWords, const char *_SrcBuf, size_t _MaxCount)
     * }
     */
    public static MemorySegment mbstowcs_s$address() {
        return mbstowcs_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t mbstowcs_s(size_t *_PtNumOfCharConverted, wchar_t *_DstBuf, size_t _SizeInWords, const char *_SrcBuf, size_t _MaxCount)
     * }
     */
    public static int mbstowcs_s(MemorySegment _PtNumOfCharConverted, MemorySegment _DstBuf, long _SizeInWords, MemorySegment _SrcBuf, long _MaxCount) {
        var mh$ = mbstowcs_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mbstowcs_s", _PtNumOfCharConverted, _DstBuf, _SizeInWords, _SrcBuf, _MaxCount);
            }
            return (int)mh$.invokeExact(_PtNumOfCharConverted, _DstBuf, _SizeInWords, _SrcBuf, _MaxCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mbstowcs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("mbstowcs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t mbstowcs(wchar_t *_Dest, const char *_Source, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor mbstowcs$descriptor() {
        return mbstowcs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t mbstowcs(wchar_t *_Dest, const char *_Source, size_t _MaxCount)
     * }
     */
    public static MethodHandle mbstowcs$handle() {
        return mbstowcs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t mbstowcs(wchar_t *_Dest, const char *_Source, size_t _MaxCount)
     * }
     */
    public static MemorySegment mbstowcs$address() {
        return mbstowcs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t mbstowcs(wchar_t *_Dest, const char *_Source, size_t _MaxCount)
     * }
     */
    public static long mbstowcs(MemorySegment _Dest, MemorySegment _Source, long _MaxCount) {
        var mh$ = mbstowcs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mbstowcs", _Dest, _Source, _MaxCount);
            }
            return (long)mh$.invokeExact(_Dest, _Source, _MaxCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _mbstowcs_s_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_mbstowcs_s_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _mbstowcs_s_l(size_t *_PtNumOfCharConverted, wchar_t *_DstBuf, size_t _SizeInWords, const char *_SrcBuf, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _mbstowcs_s_l$descriptor() {
        return _mbstowcs_s_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _mbstowcs_s_l(size_t *_PtNumOfCharConverted, wchar_t *_DstBuf, size_t _SizeInWords, const char *_SrcBuf, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MethodHandle _mbstowcs_s_l$handle() {
        return _mbstowcs_s_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _mbstowcs_s_l(size_t *_PtNumOfCharConverted, wchar_t *_DstBuf, size_t _SizeInWords, const char *_SrcBuf, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MemorySegment _mbstowcs_s_l$address() {
        return _mbstowcs_s_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _mbstowcs_s_l(size_t *_PtNumOfCharConverted, wchar_t *_DstBuf, size_t _SizeInWords, const char *_SrcBuf, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static int _mbstowcs_s_l(MemorySegment _PtNumOfCharConverted, MemorySegment _DstBuf, long _SizeInWords, MemorySegment _SrcBuf, long _MaxCount, MemorySegment _Locale) {
        var mh$ = _mbstowcs_s_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_mbstowcs_s_l", _PtNumOfCharConverted, _DstBuf, _SizeInWords, _SrcBuf, _MaxCount, _Locale);
            }
            return (int)mh$.invokeExact(_PtNumOfCharConverted, _DstBuf, _SizeInWords, _SrcBuf, _MaxCount, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _mbstowcs_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_mbstowcs_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t _mbstowcs_l(wchar_t *_Dest, const char *_Source, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _mbstowcs_l$descriptor() {
        return _mbstowcs_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t _mbstowcs_l(wchar_t *_Dest, const char *_Source, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MethodHandle _mbstowcs_l$handle() {
        return _mbstowcs_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t _mbstowcs_l(wchar_t *_Dest, const char *_Source, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MemorySegment _mbstowcs_l$address() {
        return _mbstowcs_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t _mbstowcs_l(wchar_t *_Dest, const char *_Source, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static long _mbstowcs_l(MemorySegment _Dest, MemorySegment _Source, long _MaxCount, MemorySegment _Locale) {
        var mh$ = _mbstowcs_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_mbstowcs_l", _Dest, _Source, _MaxCount, _Locale);
            }
            return (long)mh$.invokeExact(_Dest, _Source, _MaxCount, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wctomb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_SHORT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wctomb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int wctomb(char *_MbCh, wchar_t _WCh)
     * }
     */
    public static FunctionDescriptor wctomb$descriptor() {
        return wctomb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int wctomb(char *_MbCh, wchar_t _WCh)
     * }
     */
    public static MethodHandle wctomb$handle() {
        return wctomb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int wctomb(char *_MbCh, wchar_t _WCh)
     * }
     */
    public static MemorySegment wctomb$address() {
        return wctomb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int wctomb(char *_MbCh, wchar_t _WCh)
     * }
     */
    public static int wctomb(MemorySegment _MbCh, short _WCh) {
        var mh$ = wctomb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wctomb", _MbCh, _WCh);
            }
            return (int)mh$.invokeExact(_MbCh, _WCh);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wctomb_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_SHORT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wctomb_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _wctomb_l(char *_MbCh, wchar_t _WCh, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wctomb_l$descriptor() {
        return _wctomb_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _wctomb_l(char *_MbCh, wchar_t _WCh, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wctomb_l$handle() {
        return _wctomb_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _wctomb_l(char *_MbCh, wchar_t _WCh, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wctomb_l$address() {
        return _wctomb_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _wctomb_l(char *_MbCh, wchar_t _WCh, _locale_t _Locale)
     * }
     */
    public static int _wctomb_l(MemorySegment _MbCh, short _WCh, MemorySegment _Locale) {
        var mh$ = _wctomb_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wctomb_l", _MbCh, _WCh, _Locale);
            }
            return (int)mh$.invokeExact(_MbCh, _WCh, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wctomb_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_SHORT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wctomb_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t wctomb_s(int *_SizeConverted, char *_MbCh, rsize_t _SizeInBytes, wchar_t _WCh)
     * }
     */
    public static FunctionDescriptor wctomb_s$descriptor() {
        return wctomb_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t wctomb_s(int *_SizeConverted, char *_MbCh, rsize_t _SizeInBytes, wchar_t _WCh)
     * }
     */
    public static MethodHandle wctomb_s$handle() {
        return wctomb_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t wctomb_s(int *_SizeConverted, char *_MbCh, rsize_t _SizeInBytes, wchar_t _WCh)
     * }
     */
    public static MemorySegment wctomb_s$address() {
        return wctomb_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t wctomb_s(int *_SizeConverted, char *_MbCh, rsize_t _SizeInBytes, wchar_t _WCh)
     * }
     */
    public static int wctomb_s(MemorySegment _SizeConverted, MemorySegment _MbCh, long _SizeInBytes, short _WCh) {
        var mh$ = wctomb_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wctomb_s", _SizeConverted, _MbCh, _SizeInBytes, _WCh);
            }
            return (int)mh$.invokeExact(_SizeConverted, _MbCh, _SizeInBytes, _WCh);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wctomb_s_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_SHORT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wctomb_s_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _wctomb_s_l(int *_SizeConverted, char *_MbCh, size_t _SizeInBytes, wchar_t _WCh, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wctomb_s_l$descriptor() {
        return _wctomb_s_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _wctomb_s_l(int *_SizeConverted, char *_MbCh, size_t _SizeInBytes, wchar_t _WCh, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wctomb_s_l$handle() {
        return _wctomb_s_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _wctomb_s_l(int *_SizeConverted, char *_MbCh, size_t _SizeInBytes, wchar_t _WCh, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wctomb_s_l$address() {
        return _wctomb_s_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _wctomb_s_l(int *_SizeConverted, char *_MbCh, size_t _SizeInBytes, wchar_t _WCh, _locale_t _Locale)
     * }
     */
    public static int _wctomb_s_l(MemorySegment _SizeConverted, MemorySegment _MbCh, long _SizeInBytes, short _WCh, MemorySegment _Locale) {
        var mh$ = _wctomb_s_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wctomb_s_l", _SizeConverted, _MbCh, _SizeInBytes, _WCh, _Locale);
            }
            return (int)mh$.invokeExact(_SizeConverted, _MbCh, _SizeInBytes, _WCh, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcstombs_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcstombs_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t wcstombs_s(size_t *_PtNumOfCharConverted, char *_Dst, size_t _DstSizeInBytes, const wchar_t *_Src, size_t _MaxCountInBytes)
     * }
     */
    public static FunctionDescriptor wcstombs_s$descriptor() {
        return wcstombs_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t wcstombs_s(size_t *_PtNumOfCharConverted, char *_Dst, size_t _DstSizeInBytes, const wchar_t *_Src, size_t _MaxCountInBytes)
     * }
     */
    public static MethodHandle wcstombs_s$handle() {
        return wcstombs_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t wcstombs_s(size_t *_PtNumOfCharConverted, char *_Dst, size_t _DstSizeInBytes, const wchar_t *_Src, size_t _MaxCountInBytes)
     * }
     */
    public static MemorySegment wcstombs_s$address() {
        return wcstombs_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t wcstombs_s(size_t *_PtNumOfCharConverted, char *_Dst, size_t _DstSizeInBytes, const wchar_t *_Src, size_t _MaxCountInBytes)
     * }
     */
    public static int wcstombs_s(MemorySegment _PtNumOfCharConverted, MemorySegment _Dst, long _DstSizeInBytes, MemorySegment _Src, long _MaxCountInBytes) {
        var mh$ = wcstombs_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcstombs_s", _PtNumOfCharConverted, _Dst, _DstSizeInBytes, _Src, _MaxCountInBytes);
            }
            return (int)mh$.invokeExact(_PtNumOfCharConverted, _Dst, _DstSizeInBytes, _Src, _MaxCountInBytes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcstombs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcstombs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t wcstombs(char *_Dest, const wchar_t *_Source, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor wcstombs$descriptor() {
        return wcstombs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t wcstombs(char *_Dest, const wchar_t *_Source, size_t _MaxCount)
     * }
     */
    public static MethodHandle wcstombs$handle() {
        return wcstombs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t wcstombs(char *_Dest, const wchar_t *_Source, size_t _MaxCount)
     * }
     */
    public static MemorySegment wcstombs$address() {
        return wcstombs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t wcstombs(char *_Dest, const wchar_t *_Source, size_t _MaxCount)
     * }
     */
    public static long wcstombs(MemorySegment _Dest, MemorySegment _Source, long _MaxCount) {
        var mh$ = wcstombs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcstombs", _Dest, _Source, _MaxCount);
            }
            return (long)mh$.invokeExact(_Dest, _Source, _MaxCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcstombs_s_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wcstombs_s_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _wcstombs_s_l(size_t *_PtNumOfCharConverted, char *_Dst, size_t _DstSizeInBytes, const wchar_t *_Src, size_t _MaxCountInBytes, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcstombs_s_l$descriptor() {
        return _wcstombs_s_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _wcstombs_s_l(size_t *_PtNumOfCharConverted, char *_Dst, size_t _DstSizeInBytes, const wchar_t *_Src, size_t _MaxCountInBytes, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcstombs_s_l$handle() {
        return _wcstombs_s_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _wcstombs_s_l(size_t *_PtNumOfCharConverted, char *_Dst, size_t _DstSizeInBytes, const wchar_t *_Src, size_t _MaxCountInBytes, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcstombs_s_l$address() {
        return _wcstombs_s_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _wcstombs_s_l(size_t *_PtNumOfCharConverted, char *_Dst, size_t _DstSizeInBytes, const wchar_t *_Src, size_t _MaxCountInBytes, _locale_t _Locale)
     * }
     */
    public static int _wcstombs_s_l(MemorySegment _PtNumOfCharConverted, MemorySegment _Dst, long _DstSizeInBytes, MemorySegment _Src, long _MaxCountInBytes, MemorySegment _Locale) {
        var mh$ = _wcstombs_s_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcstombs_s_l", _PtNumOfCharConverted, _Dst, _DstSizeInBytes, _Src, _MaxCountInBytes, _Locale);
            }
            return (int)mh$.invokeExact(_PtNumOfCharConverted, _Dst, _DstSizeInBytes, _Src, _MaxCountInBytes, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcstombs_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wcstombs_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t _wcstombs_l(char *_Dest, const wchar_t *_Source, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcstombs_l$descriptor() {
        return _wcstombs_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t _wcstombs_l(char *_Dest, const wchar_t *_Source, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcstombs_l$handle() {
        return _wcstombs_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t _wcstombs_l(char *_Dest, const wchar_t *_Source, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcstombs_l$address() {
        return _wcstombs_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t _wcstombs_l(char *_Dest, const wchar_t *_Source, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static long _wcstombs_l(MemorySegment _Dest, MemorySegment _Source, long _MaxCount, MemorySegment _Locale) {
        var mh$ = _wcstombs_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcstombs_l", _Dest, _Source, _MaxCount, _Locale);
            }
            return (long)mh$.invokeExact(_Dest, _Source, _MaxCount, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fullpath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_fullpath");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *_fullpath(char *_Buffer, const char *_Path, size_t _BufferCount)
     * }
     */
    public static FunctionDescriptor _fullpath$descriptor() {
        return _fullpath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *_fullpath(char *_Buffer, const char *_Path, size_t _BufferCount)
     * }
     */
    public static MethodHandle _fullpath$handle() {
        return _fullpath.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *_fullpath(char *_Buffer, const char *_Path, size_t _BufferCount)
     * }
     */
    public static MemorySegment _fullpath$address() {
        return _fullpath.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *_fullpath(char *_Buffer, const char *_Path, size_t _BufferCount)
     * }
     */
    public static MemorySegment _fullpath(MemorySegment _Buffer, MemorySegment _Path, long _BufferCount) {
        var mh$ = _fullpath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fullpath", _Buffer, _Path, _BufferCount);
            }
            return (MemorySegment)mh$.invokeExact(_Buffer, _Path, _BufferCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _makepath_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_makepath_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _makepath_s(char *_Buffer, size_t _BufferCount, const char *_Drive, const char *_Dir, const char *_Filename, const char *_Ext)
     * }
     */
    public static FunctionDescriptor _makepath_s$descriptor() {
        return _makepath_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _makepath_s(char *_Buffer, size_t _BufferCount, const char *_Drive, const char *_Dir, const char *_Filename, const char *_Ext)
     * }
     */
    public static MethodHandle _makepath_s$handle() {
        return _makepath_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _makepath_s(char *_Buffer, size_t _BufferCount, const char *_Drive, const char *_Dir, const char *_Filename, const char *_Ext)
     * }
     */
    public static MemorySegment _makepath_s$address() {
        return _makepath_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _makepath_s(char *_Buffer, size_t _BufferCount, const char *_Drive, const char *_Dir, const char *_Filename, const char *_Ext)
     * }
     */
    public static int _makepath_s(MemorySegment _Buffer, long _BufferCount, MemorySegment _Drive, MemorySegment _Dir, MemorySegment _Filename, MemorySegment _Ext) {
        var mh$ = _makepath_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_makepath_s", _Buffer, _BufferCount, _Drive, _Dir, _Filename, _Ext);
            }
            return (int)mh$.invokeExact(_Buffer, _BufferCount, _Drive, _Dir, _Filename, _Ext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _makepath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_makepath");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _makepath(char *_Buffer, const char *_Drive, const char *_Dir, const char *_Filename, const char *_Ext)
     * }
     */
    public static FunctionDescriptor _makepath$descriptor() {
        return _makepath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _makepath(char *_Buffer, const char *_Drive, const char *_Dir, const char *_Filename, const char *_Ext)
     * }
     */
    public static MethodHandle _makepath$handle() {
        return _makepath.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _makepath(char *_Buffer, const char *_Drive, const char *_Dir, const char *_Filename, const char *_Ext)
     * }
     */
    public static MemorySegment _makepath$address() {
        return _makepath.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _makepath(char *_Buffer, const char *_Drive, const char *_Dir, const char *_Filename, const char *_Ext)
     * }
     */
    public static void _makepath(MemorySegment _Buffer, MemorySegment _Drive, MemorySegment _Dir, MemorySegment _Filename, MemorySegment _Ext) {
        var mh$ = _makepath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_makepath", _Buffer, _Drive, _Dir, _Filename, _Ext);
            }
            mh$.invokeExact(_Buffer, _Drive, _Dir, _Filename, _Ext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _splitpath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_splitpath");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _splitpath(const char *_FullPath, char *_Drive, char *_Dir, char *_Filename, char *_Ext)
     * }
     */
    public static FunctionDescriptor _splitpath$descriptor() {
        return _splitpath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _splitpath(const char *_FullPath, char *_Drive, char *_Dir, char *_Filename, char *_Ext)
     * }
     */
    public static MethodHandle _splitpath$handle() {
        return _splitpath.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _splitpath(const char *_FullPath, char *_Drive, char *_Dir, char *_Filename, char *_Ext)
     * }
     */
    public static MemorySegment _splitpath$address() {
        return _splitpath.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _splitpath(const char *_FullPath, char *_Drive, char *_Dir, char *_Filename, char *_Ext)
     * }
     */
    public static void _splitpath(MemorySegment _FullPath, MemorySegment _Drive, MemorySegment _Dir, MemorySegment _Filename, MemorySegment _Ext) {
        var mh$ = _splitpath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_splitpath", _FullPath, _Drive, _Dir, _Filename, _Ext);
            }
            mh$.invokeExact(_FullPath, _Drive, _Dir, _Filename, _Ext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _splitpath_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_splitpath_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _splitpath_s(const char *_FullPath, char *_Drive, size_t _DriveCount, char *_Dir, size_t _DirCount, char *_Filename, size_t _FilenameCount, char *_Ext, size_t _ExtCount)
     * }
     */
    public static FunctionDescriptor _splitpath_s$descriptor() {
        return _splitpath_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _splitpath_s(const char *_FullPath, char *_Drive, size_t _DriveCount, char *_Dir, size_t _DirCount, char *_Filename, size_t _FilenameCount, char *_Ext, size_t _ExtCount)
     * }
     */
    public static MethodHandle _splitpath_s$handle() {
        return _splitpath_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _splitpath_s(const char *_FullPath, char *_Drive, size_t _DriveCount, char *_Dir, size_t _DirCount, char *_Filename, size_t _FilenameCount, char *_Ext, size_t _ExtCount)
     * }
     */
    public static MemorySegment _splitpath_s$address() {
        return _splitpath_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _splitpath_s(const char *_FullPath, char *_Drive, size_t _DriveCount, char *_Dir, size_t _DirCount, char *_Filename, size_t _FilenameCount, char *_Ext, size_t _ExtCount)
     * }
     */
    public static int _splitpath_s(MemorySegment _FullPath, MemorySegment _Drive, long _DriveCount, MemorySegment _Dir, long _DirCount, MemorySegment _Filename, long _FilenameCount, MemorySegment _Ext, long _ExtCount) {
        var mh$ = _splitpath_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_splitpath_s", _FullPath, _Drive, _DriveCount, _Dir, _DirCount, _Filename, _FilenameCount, _Ext, _ExtCount);
            }
            return (int)mh$.invokeExact(_FullPath, _Drive, _DriveCount, _Dir, _DirCount, _Filename, _FilenameCount, _Ext, _ExtCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getenv_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("getenv_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t getenv_s(size_t *_RequiredCount, char *_Buffer, rsize_t _BufferCount, const char *_VarName)
     * }
     */
    public static FunctionDescriptor getenv_s$descriptor() {
        return getenv_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t getenv_s(size_t *_RequiredCount, char *_Buffer, rsize_t _BufferCount, const char *_VarName)
     * }
     */
    public static MethodHandle getenv_s$handle() {
        return getenv_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t getenv_s(size_t *_RequiredCount, char *_Buffer, rsize_t _BufferCount, const char *_VarName)
     * }
     */
    public static MemorySegment getenv_s$address() {
        return getenv_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t getenv_s(size_t *_RequiredCount, char *_Buffer, rsize_t _BufferCount, const char *_VarName)
     * }
     */
    public static int getenv_s(MemorySegment _RequiredCount, MemorySegment _Buffer, long _BufferCount, MemorySegment _VarName) {
        var mh$ = getenv_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getenv_s", _RequiredCount, _Buffer, _BufferCount, _VarName);
            }
            return (int)mh$.invokeExact(_RequiredCount, _Buffer, _BufferCount, _VarName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __p___argc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("__p___argc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int *__p___argc()
     * }
     */
    public static FunctionDescriptor __p___argc$descriptor() {
        return __p___argc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int *__p___argc()
     * }
     */
    public static MethodHandle __p___argc$handle() {
        return __p___argc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int *__p___argc()
     * }
     */
    public static MemorySegment __p___argc$address() {
        return __p___argc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int *__p___argc()
     * }
     */
    public static MemorySegment __p___argc() {
        var mh$ = __p___argc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__p___argc");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __p___argv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("__p___argv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char ***__p___argv()
     * }
     */
    public static FunctionDescriptor __p___argv$descriptor() {
        return __p___argv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char ***__p___argv()
     * }
     */
    public static MethodHandle __p___argv$handle() {
        return __p___argv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char ***__p___argv()
     * }
     */
    public static MemorySegment __p___argv$address() {
        return __p___argv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char ***__p___argv()
     * }
     */
    public static MemorySegment __p___argv() {
        var mh$ = __p___argv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__p___argv");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __p___wargv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("__p___wargv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t ***__p___wargv()
     * }
     */
    public static FunctionDescriptor __p___wargv$descriptor() {
        return __p___wargv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t ***__p___wargv()
     * }
     */
    public static MethodHandle __p___wargv$handle() {
        return __p___wargv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t ***__p___wargv()
     * }
     */
    public static MemorySegment __p___wargv$address() {
        return __p___wargv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t ***__p___wargv()
     * }
     */
    public static MemorySegment __p___wargv() {
        var mh$ = __p___wargv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__p___wargv");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __p__environ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("__p__environ");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char ***__p__environ()
     * }
     */
    public static FunctionDescriptor __p__environ$descriptor() {
        return __p__environ.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char ***__p__environ()
     * }
     */
    public static MethodHandle __p__environ$handle() {
        return __p__environ.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char ***__p__environ()
     * }
     */
    public static MemorySegment __p__environ$address() {
        return __p__environ.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char ***__p__environ()
     * }
     */
    public static MemorySegment __p__environ() {
        var mh$ = __p__environ.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__p__environ");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __p__wenviron {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("__p__wenviron");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t ***__p__wenviron()
     * }
     */
    public static FunctionDescriptor __p__wenviron$descriptor() {
        return __p__wenviron.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t ***__p__wenviron()
     * }
     */
    public static MethodHandle __p__wenviron$handle() {
        return __p__wenviron.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t ***__p__wenviron()
     * }
     */
    public static MemorySegment __p__wenviron$address() {
        return __p__wenviron.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t ***__p__wenviron()
     * }
     */
    public static MemorySegment __p__wenviron() {
        var mh$ = __p__wenviron.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__p__wenviron");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("getenv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *getenv(const char *_VarName)
     * }
     */
    public static FunctionDescriptor getenv$descriptor() {
        return getenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *getenv(const char *_VarName)
     * }
     */
    public static MethodHandle getenv$handle() {
        return getenv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *getenv(const char *_VarName)
     * }
     */
    public static MemorySegment getenv$address() {
        return getenv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *getenv(const char *_VarName)
     * }
     */
    public static MemorySegment getenv(MemorySegment _VarName) {
        var mh$ = getenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getenv", _VarName);
            }
            return (MemorySegment)mh$.invokeExact(_VarName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _dupenv_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_dupenv_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _dupenv_s(char **_Buffer, size_t *_BufferCount, const char *_VarName)
     * }
     */
    public static FunctionDescriptor _dupenv_s$descriptor() {
        return _dupenv_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _dupenv_s(char **_Buffer, size_t *_BufferCount, const char *_VarName)
     * }
     */
    public static MethodHandle _dupenv_s$handle() {
        return _dupenv_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _dupenv_s(char **_Buffer, size_t *_BufferCount, const char *_VarName)
     * }
     */
    public static MemorySegment _dupenv_s$address() {
        return _dupenv_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _dupenv_s(char **_Buffer, size_t *_BufferCount, const char *_VarName)
     * }
     */
    public static int _dupenv_s(MemorySegment _Buffer, MemorySegment _BufferCount, MemorySegment _VarName) {
        var mh$ = _dupenv_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_dupenv_s", _Buffer, _BufferCount, _VarName);
            }
            return (int)mh$.invokeExact(_Buffer, _BufferCount, _VarName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class system {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("system");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int system(const char *_Command)
     * }
     */
    public static FunctionDescriptor system$descriptor() {
        return system.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int system(const char *_Command)
     * }
     */
    public static MethodHandle system$handle() {
        return system.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int system(const char *_Command)
     * }
     */
    public static MemorySegment system$address() {
        return system.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int system(const char *_Command)
     * }
     */
    public static int system(MemorySegment _Command) {
        var mh$ = system.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("system", _Command);
            }
            return (int)mh$.invokeExact(_Command);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _putenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_putenv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _putenv(const char *_EnvString)
     * }
     */
    public static FunctionDescriptor _putenv$descriptor() {
        return _putenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _putenv(const char *_EnvString)
     * }
     */
    public static MethodHandle _putenv$handle() {
        return _putenv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _putenv(const char *_EnvString)
     * }
     */
    public static MemorySegment _putenv$address() {
        return _putenv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _putenv(const char *_EnvString)
     * }
     */
    public static int _putenv(MemorySegment _EnvString) {
        var mh$ = _putenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_putenv", _EnvString);
            }
            return (int)mh$.invokeExact(_EnvString);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _putenv_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_putenv_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _putenv_s(const char *_Name, const char *_Value)
     * }
     */
    public static FunctionDescriptor _putenv_s$descriptor() {
        return _putenv_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _putenv_s(const char *_Name, const char *_Value)
     * }
     */
    public static MethodHandle _putenv_s$handle() {
        return _putenv_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _putenv_s(const char *_Name, const char *_Value)
     * }
     */
    public static MemorySegment _putenv_s$address() {
        return _putenv_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _putenv_s(const char *_Name, const char *_Value)
     * }
     */
    public static int _putenv_s(MemorySegment _Name, MemorySegment _Value) {
        var mh$ = _putenv_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_putenv_s", _Name, _Value);
            }
            return (int)mh$.invokeExact(_Name, _Value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _searchenv_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_searchenv_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _searchenv_s(const char *_Filename, const char *_VarName, char *_Buffer, size_t _BufferCount)
     * }
     */
    public static FunctionDescriptor _searchenv_s$descriptor() {
        return _searchenv_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _searchenv_s(const char *_Filename, const char *_VarName, char *_Buffer, size_t _BufferCount)
     * }
     */
    public static MethodHandle _searchenv_s$handle() {
        return _searchenv_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _searchenv_s(const char *_Filename, const char *_VarName, char *_Buffer, size_t _BufferCount)
     * }
     */
    public static MemorySegment _searchenv_s$address() {
        return _searchenv_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _searchenv_s(const char *_Filename, const char *_VarName, char *_Buffer, size_t _BufferCount)
     * }
     */
    public static int _searchenv_s(MemorySegment _Filename, MemorySegment _VarName, MemorySegment _Buffer, long _BufferCount) {
        var mh$ = _searchenv_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_searchenv_s", _Filename, _VarName, _Buffer, _BufferCount);
            }
            return (int)mh$.invokeExact(_Filename, _VarName, _Buffer, _BufferCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _searchenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_searchenv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _searchenv(const char *_Filename, const char *_VarName, char *_Buffer)
     * }
     */
    public static FunctionDescriptor _searchenv$descriptor() {
        return _searchenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _searchenv(const char *_Filename, const char *_VarName, char *_Buffer)
     * }
     */
    public static MethodHandle _searchenv$handle() {
        return _searchenv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _searchenv(const char *_Filename, const char *_VarName, char *_Buffer)
     * }
     */
    public static MemorySegment _searchenv$address() {
        return _searchenv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _searchenv(const char *_Filename, const char *_VarName, char *_Buffer)
     * }
     */
    public static void _searchenv(MemorySegment _Filename, MemorySegment _VarName, MemorySegment _Buffer) {
        var mh$ = _searchenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_searchenv", _Filename, _VarName, _Buffer);
            }
            mh$.invokeExact(_Filename, _VarName, _Buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _seterrormode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_seterrormode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _seterrormode(int _Mode)
     * }
     */
    public static FunctionDescriptor _seterrormode$descriptor() {
        return _seterrormode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _seterrormode(int _Mode)
     * }
     */
    public static MethodHandle _seterrormode$handle() {
        return _seterrormode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _seterrormode(int _Mode)
     * }
     */
    public static MemorySegment _seterrormode$address() {
        return _seterrormode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _seterrormode(int _Mode)
     * }
     */
    public static void _seterrormode(int _Mode) {
        var mh$ = _seterrormode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_seterrormode", _Mode);
            }
            mh$.invokeExact(_Mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _beep {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_beep");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _beep(unsigned int _Frequency, unsigned int _Duration)
     * }
     */
    public static FunctionDescriptor _beep$descriptor() {
        return _beep.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _beep(unsigned int _Frequency, unsigned int _Duration)
     * }
     */
    public static MethodHandle _beep$handle() {
        return _beep.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _beep(unsigned int _Frequency, unsigned int _Duration)
     * }
     */
    public static MemorySegment _beep$address() {
        return _beep.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _beep(unsigned int _Frequency, unsigned int _Duration)
     * }
     */
    public static void _beep(int _Frequency, int _Duration) {
        var mh$ = _beep.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_beep", _Frequency, _Duration);
            }
            mh$.invokeExact(_Frequency, _Duration);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _sleep {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_sleep");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _sleep(unsigned long _Duration)
     * }
     */
    public static FunctionDescriptor _sleep$descriptor() {
        return _sleep.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _sleep(unsigned long _Duration)
     * }
     */
    public static MethodHandle _sleep$handle() {
        return _sleep.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _sleep(unsigned long _Duration)
     * }
     */
    public static MemorySegment _sleep$address() {
        return _sleep.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _sleep(unsigned long _Duration)
     * }
     */
    public static void _sleep(int _Duration) {
        var mh$ = _sleep.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_sleep", _Duration);
            }
            mh$.invokeExact(_Duration);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecvt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_DOUBLE,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("ecvt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *ecvt(double _Value, int _DigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static FunctionDescriptor ecvt$descriptor() {
        return ecvt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *ecvt(double _Value, int _DigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static MethodHandle ecvt$handle() {
        return ecvt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *ecvt(double _Value, int _DigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static MemorySegment ecvt$address() {
        return ecvt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *ecvt(double _Value, int _DigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static MemorySegment ecvt(double _Value, int _DigitCount, MemorySegment _PtDec, MemorySegment _PtSign) {
        var mh$ = ecvt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecvt", _Value, _DigitCount, _PtDec, _PtSign);
            }
            return (MemorySegment)mh$.invokeExact(_Value, _DigitCount, _PtDec, _PtSign);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fcvt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_DOUBLE,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fcvt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *fcvt(double _Value, int _FractionalDigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static FunctionDescriptor fcvt$descriptor() {
        return fcvt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *fcvt(double _Value, int _FractionalDigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static MethodHandle fcvt$handle() {
        return fcvt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *fcvt(double _Value, int _FractionalDigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static MemorySegment fcvt$address() {
        return fcvt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *fcvt(double _Value, int _FractionalDigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static MemorySegment fcvt(double _Value, int _FractionalDigitCount, MemorySegment _PtDec, MemorySegment _PtSign) {
        var mh$ = fcvt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fcvt", _Value, _FractionalDigitCount, _PtDec, _PtSign);
            }
            return (MemorySegment)mh$.invokeExact(_Value, _FractionalDigitCount, _PtDec, _PtSign);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gcvt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_DOUBLE,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("gcvt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *gcvt(double _Value, int _DigitCount, char *_DstBuf)
     * }
     */
    public static FunctionDescriptor gcvt$descriptor() {
        return gcvt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *gcvt(double _Value, int _DigitCount, char *_DstBuf)
     * }
     */
    public static MethodHandle gcvt$handle() {
        return gcvt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *gcvt(double _Value, int _DigitCount, char *_DstBuf)
     * }
     */
    public static MemorySegment gcvt$address() {
        return gcvt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *gcvt(double _Value, int _DigitCount, char *_DstBuf)
     * }
     */
    public static MemorySegment gcvt(double _Value, int _DigitCount, MemorySegment _DstBuf) {
        var mh$ = gcvt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gcvt", _Value, _DigitCount, _DstBuf);
            }
            return (MemorySegment)mh$.invokeExact(_Value, _DigitCount, _DstBuf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class itoa {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("itoa");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *itoa(int _Value, char *_Buffer, int _Radix)
     * }
     */
    public static FunctionDescriptor itoa$descriptor() {
        return itoa.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *itoa(int _Value, char *_Buffer, int _Radix)
     * }
     */
    public static MethodHandle itoa$handle() {
        return itoa.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *itoa(int _Value, char *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment itoa$address() {
        return itoa.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *itoa(int _Value, char *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment itoa(int _Value, MemorySegment _Buffer, int _Radix) {
        var mh$ = itoa.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("itoa", _Value, _Buffer, _Radix);
            }
            return (MemorySegment)mh$.invokeExact(_Value, _Buffer, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ltoa {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("ltoa");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *ltoa(long _Value, char *_Buffer, int _Radix)
     * }
     */
    public static FunctionDescriptor ltoa$descriptor() {
        return ltoa.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *ltoa(long _Value, char *_Buffer, int _Radix)
     * }
     */
    public static MethodHandle ltoa$handle() {
        return ltoa.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *ltoa(long _Value, char *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment ltoa$address() {
        return ltoa.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *ltoa(long _Value, char *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment ltoa(int _Value, MemorySegment _Buffer, int _Radix) {
        var mh$ = ltoa.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ltoa", _Value, _Buffer, _Radix);
            }
            return (MemorySegment)mh$.invokeExact(_Value, _Buffer, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class swab {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("swab");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void swab(char *_Buf1, char *_Buf2, int _SizeInBytes)
     * }
     */
    public static FunctionDescriptor swab$descriptor() {
        return swab.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void swab(char *_Buf1, char *_Buf2, int _SizeInBytes)
     * }
     */
    public static MethodHandle swab$handle() {
        return swab.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void swab(char *_Buf1, char *_Buf2, int _SizeInBytes)
     * }
     */
    public static MemorySegment swab$address() {
        return swab.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void swab(char *_Buf1, char *_Buf2, int _SizeInBytes)
     * }
     */
    public static void swab(MemorySegment _Buf1, MemorySegment _Buf2, int _SizeInBytes) {
        var mh$ = swab.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("swab", _Buf1, _Buf2, _SizeInBytes);
            }
            mh$.invokeExact(_Buf1, _Buf2, _SizeInBytes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ultoa {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("ultoa");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *ultoa(unsigned long _Value, char *_Buffer, int _Radix)
     * }
     */
    public static FunctionDescriptor ultoa$descriptor() {
        return ultoa.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *ultoa(unsigned long _Value, char *_Buffer, int _Radix)
     * }
     */
    public static MethodHandle ultoa$handle() {
        return ultoa.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *ultoa(unsigned long _Value, char *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment ultoa$address() {
        return ultoa.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *ultoa(unsigned long _Value, char *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment ultoa(int _Value, MemorySegment _Buffer, int _Radix) {
        var mh$ = ultoa.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ultoa", _Value, _Buffer, _Radix);
            }
            return (MemorySegment)mh$.invokeExact(_Value, _Buffer, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("putenv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int putenv(const char *_EnvString)
     * }
     */
    public static FunctionDescriptor putenv$descriptor() {
        return putenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int putenv(const char *_EnvString)
     * }
     */
    public static MethodHandle putenv$handle() {
        return putenv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int putenv(const char *_EnvString)
     * }
     */
    public static MemorySegment putenv$address() {
        return putenv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int putenv(const char *_EnvString)
     * }
     */
    public static int putenv(MemorySegment _EnvString) {
        var mh$ = putenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putenv", _EnvString);
            }
            return (int)mh$.invokeExact(_EnvString);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class onexit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("onexit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _onexit_t onexit(_onexit_t _Func)
     * }
     */
    public static FunctionDescriptor onexit$descriptor() {
        return onexit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _onexit_t onexit(_onexit_t _Func)
     * }
     */
    public static MethodHandle onexit$handle() {
        return onexit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _onexit_t onexit(_onexit_t _Func)
     * }
     */
    public static MemorySegment onexit$address() {
        return onexit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _onexit_t onexit(_onexit_t _Func)
     * }
     */
    public static MemorySegment onexit(MemorySegment _Func) {
        var mh$ = onexit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("onexit", _Func);
            }
            return (MemorySegment)mh$.invokeExact(_Func);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memchr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("memchr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *memchr(const void *_Buf, int _Val, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor memchr$descriptor() {
        return memchr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *memchr(const void *_Buf, int _Val, size_t _MaxCount)
     * }
     */
    public static MethodHandle memchr$handle() {
        return memchr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *memchr(const void *_Buf, int _Val, size_t _MaxCount)
     * }
     */
    public static MemorySegment memchr$address() {
        return memchr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *memchr(const void *_Buf, int _Val, size_t _MaxCount)
     * }
     */
    public static MemorySegment memchr(MemorySegment _Buf, int _Val, long _MaxCount) {
        var mh$ = memchr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memchr", _Buf, _Val, _MaxCount);
            }
            return (MemorySegment)mh$.invokeExact(_Buf, _Val, _MaxCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memcmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("memcmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int memcmp(const void *_Buf1, const void *_Buf2, size_t _Size)
     * }
     */
    public static FunctionDescriptor memcmp$descriptor() {
        return memcmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int memcmp(const void *_Buf1, const void *_Buf2, size_t _Size)
     * }
     */
    public static MethodHandle memcmp$handle() {
        return memcmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int memcmp(const void *_Buf1, const void *_Buf2, size_t _Size)
     * }
     */
    public static MemorySegment memcmp$address() {
        return memcmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int memcmp(const void *_Buf1, const void *_Buf2, size_t _Size)
     * }
     */
    public static int memcmp(MemorySegment _Buf1, MemorySegment _Buf2, long _Size) {
        var mh$ = memcmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memcmp", _Buf1, _Buf2, _Size);
            }
            return (int)mh$.invokeExact(_Buf1, _Buf2, _Size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memcpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("memcpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *memcpy(void *_Dst, const void *_Src, size_t _Size)
     * }
     */
    public static FunctionDescriptor memcpy$descriptor() {
        return memcpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *memcpy(void *_Dst, const void *_Src, size_t _Size)
     * }
     */
    public static MethodHandle memcpy$handle() {
        return memcpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *memcpy(void *_Dst, const void *_Src, size_t _Size)
     * }
     */
    public static MemorySegment memcpy$address() {
        return memcpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *memcpy(void *_Dst, const void *_Src, size_t _Size)
     * }
     */
    public static MemorySegment memcpy(MemorySegment _Dst, MemorySegment _Src, long _Size) {
        var mh$ = memcpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memcpy", _Dst, _Src, _Size);
            }
            return (MemorySegment)mh$.invokeExact(_Dst, _Src, _Size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memmove {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("memmove");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *memmove(void *_Dst, const void *_Src, size_t _Size)
     * }
     */
    public static FunctionDescriptor memmove$descriptor() {
        return memmove.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *memmove(void *_Dst, const void *_Src, size_t _Size)
     * }
     */
    public static MethodHandle memmove$handle() {
        return memmove.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *memmove(void *_Dst, const void *_Src, size_t _Size)
     * }
     */
    public static MemorySegment memmove$address() {
        return memmove.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *memmove(void *_Dst, const void *_Src, size_t _Size)
     * }
     */
    public static MemorySegment memmove(MemorySegment _Dst, MemorySegment _Src, long _Size) {
        var mh$ = memmove.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memmove", _Dst, _Src, _Size);
            }
            return (MemorySegment)mh$.invokeExact(_Dst, _Src, _Size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("memset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *memset(void *_Dst, int _Val, size_t _Size)
     * }
     */
    public static FunctionDescriptor memset$descriptor() {
        return memset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *memset(void *_Dst, int _Val, size_t _Size)
     * }
     */
    public static MethodHandle memset$handle() {
        return memset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *memset(void *_Dst, int _Val, size_t _Size)
     * }
     */
    public static MemorySegment memset$address() {
        return memset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *memset(void *_Dst, int _Val, size_t _Size)
     * }
     */
    public static MemorySegment memset(MemorySegment _Dst, int _Val, long _Size) {
        var mh$ = memset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memset", _Dst, _Val, _Size);
            }
            return (MemorySegment)mh$.invokeExact(_Dst, _Val, _Size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strchr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("strchr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strchr(const char *_Str, int _Val)
     * }
     */
    public static FunctionDescriptor strchr$descriptor() {
        return strchr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strchr(const char *_Str, int _Val)
     * }
     */
    public static MethodHandle strchr$handle() {
        return strchr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strchr(const char *_Str, int _Val)
     * }
     */
    public static MemorySegment strchr$address() {
        return strchr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strchr(const char *_Str, int _Val)
     * }
     */
    public static MemorySegment strchr(MemorySegment _Str, int _Val) {
        var mh$ = strchr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strchr", _Str, _Val);
            }
            return (MemorySegment)mh$.invokeExact(_Str, _Val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strrchr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("strrchr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strrchr(const char *_Str, int _Ch)
     * }
     */
    public static FunctionDescriptor strrchr$descriptor() {
        return strrchr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strrchr(const char *_Str, int _Ch)
     * }
     */
    public static MethodHandle strrchr$handle() {
        return strrchr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strrchr(const char *_Str, int _Ch)
     * }
     */
    public static MemorySegment strrchr$address() {
        return strrchr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strrchr(const char *_Str, int _Ch)
     * }
     */
    public static MemorySegment strrchr(MemorySegment _Str, int _Ch) {
        var mh$ = strrchr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strrchr", _Str, _Ch);
            }
            return (MemorySegment)mh$.invokeExact(_Str, _Ch);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strstr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("strstr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strstr(const char *_Str, const char *_SubStr)
     * }
     */
    public static FunctionDescriptor strstr$descriptor() {
        return strstr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strstr(const char *_Str, const char *_SubStr)
     * }
     */
    public static MethodHandle strstr$handle() {
        return strstr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strstr(const char *_Str, const char *_SubStr)
     * }
     */
    public static MemorySegment strstr$address() {
        return strstr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strstr(const char *_Str, const char *_SubStr)
     * }
     */
    public static MemorySegment strstr(MemorySegment _Str, MemorySegment _SubStr) {
        var mh$ = strstr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strstr", _Str, _SubStr);
            }
            return (MemorySegment)mh$.invokeExact(_Str, _SubStr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcschr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_SHORT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcschr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned short *wcschr(const wchar_t *_Str, wchar_t _Ch)
     * }
     */
    public static FunctionDescriptor wcschr$descriptor() {
        return wcschr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned short *wcschr(const wchar_t *_Str, wchar_t _Ch)
     * }
     */
    public static MethodHandle wcschr$handle() {
        return wcschr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned short *wcschr(const wchar_t *_Str, wchar_t _Ch)
     * }
     */
    public static MemorySegment wcschr$address() {
        return wcschr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned short *wcschr(const wchar_t *_Str, wchar_t _Ch)
     * }
     */
    public static MemorySegment wcschr(MemorySegment _Str, short _Ch) {
        var mh$ = wcschr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcschr", _Str, _Ch);
            }
            return (MemorySegment)mh$.invokeExact(_Str, _Ch);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsrchr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_SHORT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcsrchr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *wcsrchr(const wchar_t *_Str, wchar_t _Ch)
     * }
     */
    public static FunctionDescriptor wcsrchr$descriptor() {
        return wcsrchr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *wcsrchr(const wchar_t *_Str, wchar_t _Ch)
     * }
     */
    public static MethodHandle wcsrchr$handle() {
        return wcsrchr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *wcsrchr(const wchar_t *_Str, wchar_t _Ch)
     * }
     */
    public static MemorySegment wcsrchr$address() {
        return wcsrchr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *wcsrchr(const wchar_t *_Str, wchar_t _Ch)
     * }
     */
    public static MemorySegment wcsrchr(MemorySegment _Str, short _Ch) {
        var mh$ = wcsrchr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsrchr", _Str, _Ch);
            }
            return (MemorySegment)mh$.invokeExact(_Str, _Ch);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsstr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcsstr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *wcsstr(const wchar_t *_Str, const wchar_t *_SubStr)
     * }
     */
    public static FunctionDescriptor wcsstr$descriptor() {
        return wcsstr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *wcsstr(const wchar_t *_Str, const wchar_t *_SubStr)
     * }
     */
    public static MethodHandle wcsstr$handle() {
        return wcsstr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *wcsstr(const wchar_t *_Str, const wchar_t *_SubStr)
     * }
     */
    public static MemorySegment wcsstr$address() {
        return wcsstr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *wcsstr(const wchar_t *_Str, const wchar_t *_SubStr)
     * }
     */
    public static MemorySegment wcsstr(MemorySegment _Str, MemorySegment _SubStr) {
        var mh$ = wcsstr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsstr", _Str, _SubStr);
            }
            return (MemorySegment)mh$.invokeExact(_Str, _SubStr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _memicmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_memicmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _memicmp(const void *_Buf1, const void *_Buf2, size_t _Size)
     * }
     */
    public static FunctionDescriptor _memicmp$descriptor() {
        return _memicmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _memicmp(const void *_Buf1, const void *_Buf2, size_t _Size)
     * }
     */
    public static MethodHandle _memicmp$handle() {
        return _memicmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _memicmp(const void *_Buf1, const void *_Buf2, size_t _Size)
     * }
     */
    public static MemorySegment _memicmp$address() {
        return _memicmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _memicmp(const void *_Buf1, const void *_Buf2, size_t _Size)
     * }
     */
    public static int _memicmp(MemorySegment _Buf1, MemorySegment _Buf2, long _Size) {
        var mh$ = _memicmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_memicmp", _Buf1, _Buf2, _Size);
            }
            return (int)mh$.invokeExact(_Buf1, _Buf2, _Size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _memicmp_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_memicmp_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _memicmp_l(const void *_Buf1, const void *_Buf2, size_t _Size, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _memicmp_l$descriptor() {
        return _memicmp_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _memicmp_l(const void *_Buf1, const void *_Buf2, size_t _Size, _locale_t _Locale)
     * }
     */
    public static MethodHandle _memicmp_l$handle() {
        return _memicmp_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _memicmp_l(const void *_Buf1, const void *_Buf2, size_t _Size, _locale_t _Locale)
     * }
     */
    public static MemorySegment _memicmp_l$address() {
        return _memicmp_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _memicmp_l(const void *_Buf1, const void *_Buf2, size_t _Size, _locale_t _Locale)
     * }
     */
    public static int _memicmp_l(MemorySegment _Buf1, MemorySegment _Buf2, long _Size, MemorySegment _Locale) {
        var mh$ = _memicmp_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_memicmp_l", _Buf1, _Buf2, _Size, _Locale);
            }
            return (int)mh$.invokeExact(_Buf1, _Buf2, _Size, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memccpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("memccpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *memccpy(void *_Dst, const void *_Src, int _Val, size_t _Size)
     * }
     */
    public static FunctionDescriptor memccpy$descriptor() {
        return memccpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *memccpy(void *_Dst, const void *_Src, int _Val, size_t _Size)
     * }
     */
    public static MethodHandle memccpy$handle() {
        return memccpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *memccpy(void *_Dst, const void *_Src, int _Val, size_t _Size)
     * }
     */
    public static MemorySegment memccpy$address() {
        return memccpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *memccpy(void *_Dst, const void *_Src, int _Val, size_t _Size)
     * }
     */
    public static MemorySegment memccpy(MemorySegment _Dst, MemorySegment _Src, int _Val, long _Size) {
        var mh$ = memccpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memccpy", _Dst, _Src, _Val, _Size);
            }
            return (MemorySegment)mh$.invokeExact(_Dst, _Src, _Val, _Size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memicmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("memicmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int memicmp(const void *_Buf1, const void *_Buf2, size_t _Size)
     * }
     */
    public static FunctionDescriptor memicmp$descriptor() {
        return memicmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int memicmp(const void *_Buf1, const void *_Buf2, size_t _Size)
     * }
     */
    public static MethodHandle memicmp$handle() {
        return memicmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int memicmp(const void *_Buf1, const void *_Buf2, size_t _Size)
     * }
     */
    public static MemorySegment memicmp$address() {
        return memicmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int memicmp(const void *_Buf1, const void *_Buf2, size_t _Size)
     * }
     */
    public static int memicmp(MemorySegment _Buf1, MemorySegment _Buf2, long _Size) {
        var mh$ = memicmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memicmp", _Buf1, _Buf2, _Size);
            }
            return (int)mh$.invokeExact(_Buf1, _Buf2, _Size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcscat_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcscat_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t wcscat_s(wchar_t *_Destination, rsize_t _SizeInWords, const wchar_t *_Source)
     * }
     */
    public static FunctionDescriptor wcscat_s$descriptor() {
        return wcscat_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t wcscat_s(wchar_t *_Destination, rsize_t _SizeInWords, const wchar_t *_Source)
     * }
     */
    public static MethodHandle wcscat_s$handle() {
        return wcscat_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t wcscat_s(wchar_t *_Destination, rsize_t _SizeInWords, const wchar_t *_Source)
     * }
     */
    public static MemorySegment wcscat_s$address() {
        return wcscat_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t wcscat_s(wchar_t *_Destination, rsize_t _SizeInWords, const wchar_t *_Source)
     * }
     */
    public static int wcscat_s(MemorySegment _Destination, long _SizeInWords, MemorySegment _Source) {
        var mh$ = wcscat_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcscat_s", _Destination, _SizeInWords, _Source);
            }
            return (int)mh$.invokeExact(_Destination, _SizeInWords, _Source);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcscpy_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcscpy_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t wcscpy_s(wchar_t *_Destination, rsize_t _SizeInWords, const wchar_t *_Source)
     * }
     */
    public static FunctionDescriptor wcscpy_s$descriptor() {
        return wcscpy_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t wcscpy_s(wchar_t *_Destination, rsize_t _SizeInWords, const wchar_t *_Source)
     * }
     */
    public static MethodHandle wcscpy_s$handle() {
        return wcscpy_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t wcscpy_s(wchar_t *_Destination, rsize_t _SizeInWords, const wchar_t *_Source)
     * }
     */
    public static MemorySegment wcscpy_s$address() {
        return wcscpy_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t wcscpy_s(wchar_t *_Destination, rsize_t _SizeInWords, const wchar_t *_Source)
     * }
     */
    public static int wcscpy_s(MemorySegment _Destination, long _SizeInWords, MemorySegment _Source) {
        var mh$ = wcscpy_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcscpy_s", _Destination, _SizeInWords, _Source);
            }
            return (int)mh$.invokeExact(_Destination, _SizeInWords, _Source);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsncat_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcsncat_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t wcsncat_s(wchar_t *_Destination, rsize_t _SizeInWords, const wchar_t *_Source, rsize_t _MaxCount)
     * }
     */
    public static FunctionDescriptor wcsncat_s$descriptor() {
        return wcsncat_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t wcsncat_s(wchar_t *_Destination, rsize_t _SizeInWords, const wchar_t *_Source, rsize_t _MaxCount)
     * }
     */
    public static MethodHandle wcsncat_s$handle() {
        return wcsncat_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t wcsncat_s(wchar_t *_Destination, rsize_t _SizeInWords, const wchar_t *_Source, rsize_t _MaxCount)
     * }
     */
    public static MemorySegment wcsncat_s$address() {
        return wcsncat_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t wcsncat_s(wchar_t *_Destination, rsize_t _SizeInWords, const wchar_t *_Source, rsize_t _MaxCount)
     * }
     */
    public static int wcsncat_s(MemorySegment _Destination, long _SizeInWords, MemorySegment _Source, long _MaxCount) {
        var mh$ = wcsncat_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsncat_s", _Destination, _SizeInWords, _Source, _MaxCount);
            }
            return (int)mh$.invokeExact(_Destination, _SizeInWords, _Source, _MaxCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsncpy_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcsncpy_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t wcsncpy_s(wchar_t *_Destination, rsize_t _SizeInWords, const wchar_t *_Source, rsize_t _MaxCount)
     * }
     */
    public static FunctionDescriptor wcsncpy_s$descriptor() {
        return wcsncpy_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t wcsncpy_s(wchar_t *_Destination, rsize_t _SizeInWords, const wchar_t *_Source, rsize_t _MaxCount)
     * }
     */
    public static MethodHandle wcsncpy_s$handle() {
        return wcsncpy_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t wcsncpy_s(wchar_t *_Destination, rsize_t _SizeInWords, const wchar_t *_Source, rsize_t _MaxCount)
     * }
     */
    public static MemorySegment wcsncpy_s$address() {
        return wcsncpy_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t wcsncpy_s(wchar_t *_Destination, rsize_t _SizeInWords, const wchar_t *_Source, rsize_t _MaxCount)
     * }
     */
    public static int wcsncpy_s(MemorySegment _Destination, long _SizeInWords, MemorySegment _Source, long _MaxCount) {
        var mh$ = wcsncpy_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsncpy_s", _Destination, _SizeInWords, _Source, _MaxCount);
            }
            return (int)mh$.invokeExact(_Destination, _SizeInWords, _Source, _MaxCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcstok_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcstok_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *wcstok_s(wchar_t *_String, const wchar_t *_Delimiter, wchar_t **_Context)
     * }
     */
    public static FunctionDescriptor wcstok_s$descriptor() {
        return wcstok_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *wcstok_s(wchar_t *_String, const wchar_t *_Delimiter, wchar_t **_Context)
     * }
     */
    public static MethodHandle wcstok_s$handle() {
        return wcstok_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *wcstok_s(wchar_t *_String, const wchar_t *_Delimiter, wchar_t **_Context)
     * }
     */
    public static MemorySegment wcstok_s$address() {
        return wcstok_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *wcstok_s(wchar_t *_String, const wchar_t *_Delimiter, wchar_t **_Context)
     * }
     */
    public static MemorySegment wcstok_s(MemorySegment _String, MemorySegment _Delimiter, MemorySegment _Context) {
        var mh$ = wcstok_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcstok_s", _String, _Delimiter, _Context);
            }
            return (MemorySegment)mh$.invokeExact(_String, _Delimiter, _Context);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcsdup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wcsdup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *_wcsdup(const wchar_t *_String)
     * }
     */
    public static FunctionDescriptor _wcsdup$descriptor() {
        return _wcsdup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *_wcsdup(const wchar_t *_String)
     * }
     */
    public static MethodHandle _wcsdup$handle() {
        return _wcsdup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *_wcsdup(const wchar_t *_String)
     * }
     */
    public static MemorySegment _wcsdup$address() {
        return _wcsdup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *_wcsdup(const wchar_t *_String)
     * }
     */
    public static MemorySegment _wcsdup(MemorySegment _String) {
        var mh$ = _wcsdup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcsdup", _String);
            }
            return (MemorySegment)mh$.invokeExact(_String);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcscat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcscat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *wcscat(wchar_t *_Destination, const wchar_t *_Source)
     * }
     */
    public static FunctionDescriptor wcscat$descriptor() {
        return wcscat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *wcscat(wchar_t *_Destination, const wchar_t *_Source)
     * }
     */
    public static MethodHandle wcscat$handle() {
        return wcscat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *wcscat(wchar_t *_Destination, const wchar_t *_Source)
     * }
     */
    public static MemorySegment wcscat$address() {
        return wcscat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *wcscat(wchar_t *_Destination, const wchar_t *_Source)
     * }
     */
    public static MemorySegment wcscat(MemorySegment _Destination, MemorySegment _Source) {
        var mh$ = wcscat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcscat", _Destination, _Source);
            }
            return (MemorySegment)mh$.invokeExact(_Destination, _Source);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcscmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcscmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int wcscmp(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static FunctionDescriptor wcscmp$descriptor() {
        return wcscmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int wcscmp(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static MethodHandle wcscmp$handle() {
        return wcscmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int wcscmp(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static MemorySegment wcscmp$address() {
        return wcscmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int wcscmp(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static int wcscmp(MemorySegment _String1, MemorySegment _String2) {
        var mh$ = wcscmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcscmp", _String1, _String2);
            }
            return (int)mh$.invokeExact(_String1, _String2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcscpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcscpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *wcscpy(wchar_t *_Destination, const wchar_t *_Source)
     * }
     */
    public static FunctionDescriptor wcscpy$descriptor() {
        return wcscpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *wcscpy(wchar_t *_Destination, const wchar_t *_Source)
     * }
     */
    public static MethodHandle wcscpy$handle() {
        return wcscpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *wcscpy(wchar_t *_Destination, const wchar_t *_Source)
     * }
     */
    public static MemorySegment wcscpy$address() {
        return wcscpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *wcscpy(wchar_t *_Destination, const wchar_t *_Source)
     * }
     */
    public static MemorySegment wcscpy(MemorySegment _Destination, MemorySegment _Source) {
        var mh$ = wcscpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcscpy", _Destination, _Source);
            }
            return (MemorySegment)mh$.invokeExact(_Destination, _Source);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcscspn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcscspn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t wcscspn(const wchar_t *_String, const wchar_t *_Control)
     * }
     */
    public static FunctionDescriptor wcscspn$descriptor() {
        return wcscspn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t wcscspn(const wchar_t *_String, const wchar_t *_Control)
     * }
     */
    public static MethodHandle wcscspn$handle() {
        return wcscspn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t wcscspn(const wchar_t *_String, const wchar_t *_Control)
     * }
     */
    public static MemorySegment wcscspn$address() {
        return wcscspn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t wcscspn(const wchar_t *_String, const wchar_t *_Control)
     * }
     */
    public static long wcscspn(MemorySegment _String, MemorySegment _Control) {
        var mh$ = wcscspn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcscspn", _String, _Control);
            }
            return (long)mh$.invokeExact(_String, _Control);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcslen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcslen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long long wcslen(const wchar_t *_String)
     * }
     */
    public static FunctionDescriptor wcslen$descriptor() {
        return wcslen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long long wcslen(const wchar_t *_String)
     * }
     */
    public static MethodHandle wcslen$handle() {
        return wcslen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long long wcslen(const wchar_t *_String)
     * }
     */
    public static MemorySegment wcslen$address() {
        return wcslen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long long wcslen(const wchar_t *_String)
     * }
     */
    public static long wcslen(MemorySegment _String) {
        var mh$ = wcslen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcslen", _String);
            }
            return (long)mh$.invokeExact(_String);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsnlen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcsnlen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t wcsnlen(const wchar_t *_Source, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor wcsnlen$descriptor() {
        return wcsnlen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t wcsnlen(const wchar_t *_Source, size_t _MaxCount)
     * }
     */
    public static MethodHandle wcsnlen$handle() {
        return wcsnlen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t wcsnlen(const wchar_t *_Source, size_t _MaxCount)
     * }
     */
    public static MemorySegment wcsnlen$address() {
        return wcsnlen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t wcsnlen(const wchar_t *_Source, size_t _MaxCount)
     * }
     */
    public static long wcsnlen(MemorySegment _Source, long _MaxCount) {
        var mh$ = wcsnlen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsnlen", _Source, _MaxCount);
            }
            return (long)mh$.invokeExact(_Source, _MaxCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsncat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcsncat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *wcsncat(wchar_t *_Destination, const wchar_t *_Source, size_t _Count)
     * }
     */
    public static FunctionDescriptor wcsncat$descriptor() {
        return wcsncat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *wcsncat(wchar_t *_Destination, const wchar_t *_Source, size_t _Count)
     * }
     */
    public static MethodHandle wcsncat$handle() {
        return wcsncat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *wcsncat(wchar_t *_Destination, const wchar_t *_Source, size_t _Count)
     * }
     */
    public static MemorySegment wcsncat$address() {
        return wcsncat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *wcsncat(wchar_t *_Destination, const wchar_t *_Source, size_t _Count)
     * }
     */
    public static MemorySegment wcsncat(MemorySegment _Destination, MemorySegment _Source, long _Count) {
        var mh$ = wcsncat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsncat", _Destination, _Source, _Count);
            }
            return (MemorySegment)mh$.invokeExact(_Destination, _Source, _Count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsncmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcsncmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int wcsncmp(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor wcsncmp$descriptor() {
        return wcsncmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int wcsncmp(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount)
     * }
     */
    public static MethodHandle wcsncmp$handle() {
        return wcsncmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int wcsncmp(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount)
     * }
     */
    public static MemorySegment wcsncmp$address() {
        return wcsncmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int wcsncmp(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount)
     * }
     */
    public static int wcsncmp(MemorySegment _String1, MemorySegment _String2, long _MaxCount) {
        var mh$ = wcsncmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsncmp", _String1, _String2, _MaxCount);
            }
            return (int)mh$.invokeExact(_String1, _String2, _MaxCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsncpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcsncpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *wcsncpy(wchar_t *_Destination, const wchar_t *_Source, size_t _Count)
     * }
     */
    public static FunctionDescriptor wcsncpy$descriptor() {
        return wcsncpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *wcsncpy(wchar_t *_Destination, const wchar_t *_Source, size_t _Count)
     * }
     */
    public static MethodHandle wcsncpy$handle() {
        return wcsncpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *wcsncpy(wchar_t *_Destination, const wchar_t *_Source, size_t _Count)
     * }
     */
    public static MemorySegment wcsncpy$address() {
        return wcsncpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *wcsncpy(wchar_t *_Destination, const wchar_t *_Source, size_t _Count)
     * }
     */
    public static MemorySegment wcsncpy(MemorySegment _Destination, MemorySegment _Source, long _Count) {
        var mh$ = wcsncpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsncpy", _Destination, _Source, _Count);
            }
            return (MemorySegment)mh$.invokeExact(_Destination, _Source, _Count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcspbrk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcspbrk");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *wcspbrk(const wchar_t *_String, const wchar_t *_Control)
     * }
     */
    public static FunctionDescriptor wcspbrk$descriptor() {
        return wcspbrk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *wcspbrk(const wchar_t *_String, const wchar_t *_Control)
     * }
     */
    public static MethodHandle wcspbrk$handle() {
        return wcspbrk.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *wcspbrk(const wchar_t *_String, const wchar_t *_Control)
     * }
     */
    public static MemorySegment wcspbrk$address() {
        return wcspbrk.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *wcspbrk(const wchar_t *_String, const wchar_t *_Control)
     * }
     */
    public static MemorySegment wcspbrk(MemorySegment _String, MemorySegment _Control) {
        var mh$ = wcspbrk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcspbrk", _String, _Control);
            }
            return (MemorySegment)mh$.invokeExact(_String, _Control);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsspn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcsspn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t wcsspn(const wchar_t *_String, const wchar_t *_Control)
     * }
     */
    public static FunctionDescriptor wcsspn$descriptor() {
        return wcsspn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t wcsspn(const wchar_t *_String, const wchar_t *_Control)
     * }
     */
    public static MethodHandle wcsspn$handle() {
        return wcsspn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t wcsspn(const wchar_t *_String, const wchar_t *_Control)
     * }
     */
    public static MemorySegment wcsspn$address() {
        return wcsspn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t wcsspn(const wchar_t *_String, const wchar_t *_Control)
     * }
     */
    public static long wcsspn(MemorySegment _String, MemorySegment _Control) {
        var mh$ = wcsspn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsspn", _String, _Control);
            }
            return (long)mh$.invokeExact(_String, _Control);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcstok {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcstok");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *wcstok(wchar_t *_String, const wchar_t *_Delimiter, wchar_t **_Context)
     * }
     */
    public static FunctionDescriptor wcstok$descriptor() {
        return wcstok.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *wcstok(wchar_t *_String, const wchar_t *_Delimiter, wchar_t **_Context)
     * }
     */
    public static MethodHandle wcstok$handle() {
        return wcstok.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *wcstok(wchar_t *_String, const wchar_t *_Delimiter, wchar_t **_Context)
     * }
     */
    public static MemorySegment wcstok$address() {
        return wcstok.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *wcstok(wchar_t *_String, const wchar_t *_Delimiter, wchar_t **_Context)
     * }
     */
    public static MemorySegment wcstok(MemorySegment _String, MemorySegment _Delimiter, MemorySegment _Context) {
        var mh$ = wcstok.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcstok", _String, _Delimiter, _Context);
            }
            return (MemorySegment)mh$.invokeExact(_String, _Delimiter, _Context);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcserror {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wcserror");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *_wcserror(int _ErrorNumber)
     * }
     */
    public static FunctionDescriptor _wcserror$descriptor() {
        return _wcserror.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *_wcserror(int _ErrorNumber)
     * }
     */
    public static MethodHandle _wcserror$handle() {
        return _wcserror.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *_wcserror(int _ErrorNumber)
     * }
     */
    public static MemorySegment _wcserror$address() {
        return _wcserror.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *_wcserror(int _ErrorNumber)
     * }
     */
    public static MemorySegment _wcserror(int _ErrorNumber) {
        var mh$ = _wcserror.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcserror", _ErrorNumber);
            }
            return (MemorySegment)mh$.invokeExact(_ErrorNumber);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcserror_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wcserror_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _wcserror_s(wchar_t *_Buffer, size_t _SizeInWords, int _ErrorNumber)
     * }
     */
    public static FunctionDescriptor _wcserror_s$descriptor() {
        return _wcserror_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _wcserror_s(wchar_t *_Buffer, size_t _SizeInWords, int _ErrorNumber)
     * }
     */
    public static MethodHandle _wcserror_s$handle() {
        return _wcserror_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _wcserror_s(wchar_t *_Buffer, size_t _SizeInWords, int _ErrorNumber)
     * }
     */
    public static MemorySegment _wcserror_s$address() {
        return _wcserror_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _wcserror_s(wchar_t *_Buffer, size_t _SizeInWords, int _ErrorNumber)
     * }
     */
    public static int _wcserror_s(MemorySegment _Buffer, long _SizeInWords, int _ErrorNumber) {
        var mh$ = _wcserror_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcserror_s", _Buffer, _SizeInWords, _ErrorNumber);
            }
            return (int)mh$.invokeExact(_Buffer, _SizeInWords, _ErrorNumber);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __wcserror {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("__wcserror");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *__wcserror(const wchar_t *_String)
     * }
     */
    public static FunctionDescriptor __wcserror$descriptor() {
        return __wcserror.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *__wcserror(const wchar_t *_String)
     * }
     */
    public static MethodHandle __wcserror$handle() {
        return __wcserror.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *__wcserror(const wchar_t *_String)
     * }
     */
    public static MemorySegment __wcserror$address() {
        return __wcserror.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *__wcserror(const wchar_t *_String)
     * }
     */
    public static MemorySegment __wcserror(MemorySegment _String) {
        var mh$ = __wcserror.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__wcserror", _String);
            }
            return (MemorySegment)mh$.invokeExact(_String);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __wcserror_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("__wcserror_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t __wcserror_s(wchar_t *_Buffer, size_t _SizeInWords, const wchar_t *_ErrorMessage)
     * }
     */
    public static FunctionDescriptor __wcserror_s$descriptor() {
        return __wcserror_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t __wcserror_s(wchar_t *_Buffer, size_t _SizeInWords, const wchar_t *_ErrorMessage)
     * }
     */
    public static MethodHandle __wcserror_s$handle() {
        return __wcserror_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t __wcserror_s(wchar_t *_Buffer, size_t _SizeInWords, const wchar_t *_ErrorMessage)
     * }
     */
    public static MemorySegment __wcserror_s$address() {
        return __wcserror_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t __wcserror_s(wchar_t *_Buffer, size_t _SizeInWords, const wchar_t *_ErrorMessage)
     * }
     */
    public static int __wcserror_s(MemorySegment _Buffer, long _SizeInWords, MemorySegment _ErrorMessage) {
        var mh$ = __wcserror_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__wcserror_s", _Buffer, _SizeInWords, _ErrorMessage);
            }
            return (int)mh$.invokeExact(_Buffer, _SizeInWords, _ErrorMessage);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcsicmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wcsicmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _wcsicmp(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static FunctionDescriptor _wcsicmp$descriptor() {
        return _wcsicmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _wcsicmp(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static MethodHandle _wcsicmp$handle() {
        return _wcsicmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _wcsicmp(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static MemorySegment _wcsicmp$address() {
        return _wcsicmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _wcsicmp(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static int _wcsicmp(MemorySegment _String1, MemorySegment _String2) {
        var mh$ = _wcsicmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcsicmp", _String1, _String2);
            }
            return (int)mh$.invokeExact(_String1, _String2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcsicmp_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wcsicmp_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _wcsicmp_l(const wchar_t *_String1, const wchar_t *_String2, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcsicmp_l$descriptor() {
        return _wcsicmp_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _wcsicmp_l(const wchar_t *_String1, const wchar_t *_String2, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcsicmp_l$handle() {
        return _wcsicmp_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _wcsicmp_l(const wchar_t *_String1, const wchar_t *_String2, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcsicmp_l$address() {
        return _wcsicmp_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _wcsicmp_l(const wchar_t *_String1, const wchar_t *_String2, _locale_t _Locale)
     * }
     */
    public static int _wcsicmp_l(MemorySegment _String1, MemorySegment _String2, MemorySegment _Locale) {
        var mh$ = _wcsicmp_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcsicmp_l", _String1, _String2, _Locale);
            }
            return (int)mh$.invokeExact(_String1, _String2, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcsnicmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wcsnicmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _wcsnicmp(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor _wcsnicmp$descriptor() {
        return _wcsnicmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _wcsnicmp(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount)
     * }
     */
    public static MethodHandle _wcsnicmp$handle() {
        return _wcsnicmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _wcsnicmp(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount)
     * }
     */
    public static MemorySegment _wcsnicmp$address() {
        return _wcsnicmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _wcsnicmp(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount)
     * }
     */
    public static int _wcsnicmp(MemorySegment _String1, MemorySegment _String2, long _MaxCount) {
        var mh$ = _wcsnicmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcsnicmp", _String1, _String2, _MaxCount);
            }
            return (int)mh$.invokeExact(_String1, _String2, _MaxCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcsnicmp_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wcsnicmp_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _wcsnicmp_l(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcsnicmp_l$descriptor() {
        return _wcsnicmp_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _wcsnicmp_l(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcsnicmp_l$handle() {
        return _wcsnicmp_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _wcsnicmp_l(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcsnicmp_l$address() {
        return _wcsnicmp_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _wcsnicmp_l(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static int _wcsnicmp_l(MemorySegment _String1, MemorySegment _String2, long _MaxCount, MemorySegment _Locale) {
        var mh$ = _wcsnicmp_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcsnicmp_l", _String1, _String2, _MaxCount, _Locale);
            }
            return (int)mh$.invokeExact(_String1, _String2, _MaxCount, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcsnset_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_SHORT,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wcsnset_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _wcsnset_s(wchar_t *_Destination, size_t _SizeInWords, wchar_t _Value, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor _wcsnset_s$descriptor() {
        return _wcsnset_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _wcsnset_s(wchar_t *_Destination, size_t _SizeInWords, wchar_t _Value, size_t _MaxCount)
     * }
     */
    public static MethodHandle _wcsnset_s$handle() {
        return _wcsnset_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _wcsnset_s(wchar_t *_Destination, size_t _SizeInWords, wchar_t _Value, size_t _MaxCount)
     * }
     */
    public static MemorySegment _wcsnset_s$address() {
        return _wcsnset_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _wcsnset_s(wchar_t *_Destination, size_t _SizeInWords, wchar_t _Value, size_t _MaxCount)
     * }
     */
    public static int _wcsnset_s(MemorySegment _Destination, long _SizeInWords, short _Value, long _MaxCount) {
        var mh$ = _wcsnset_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcsnset_s", _Destination, _SizeInWords, _Value, _MaxCount);
            }
            return (int)mh$.invokeExact(_Destination, _SizeInWords, _Value, _MaxCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcsnset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_SHORT,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wcsnset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *_wcsnset(wchar_t *_String, wchar_t _Value, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor _wcsnset$descriptor() {
        return _wcsnset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *_wcsnset(wchar_t *_String, wchar_t _Value, size_t _MaxCount)
     * }
     */
    public static MethodHandle _wcsnset$handle() {
        return _wcsnset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *_wcsnset(wchar_t *_String, wchar_t _Value, size_t _MaxCount)
     * }
     */
    public static MemorySegment _wcsnset$address() {
        return _wcsnset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *_wcsnset(wchar_t *_String, wchar_t _Value, size_t _MaxCount)
     * }
     */
    public static MemorySegment _wcsnset(MemorySegment _String, short _Value, long _MaxCount) {
        var mh$ = _wcsnset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcsnset", _String, _Value, _MaxCount);
            }
            return (MemorySegment)mh$.invokeExact(_String, _Value, _MaxCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcsrev {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wcsrev");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *_wcsrev(wchar_t *_String)
     * }
     */
    public static FunctionDescriptor _wcsrev$descriptor() {
        return _wcsrev.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *_wcsrev(wchar_t *_String)
     * }
     */
    public static MethodHandle _wcsrev$handle() {
        return _wcsrev.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *_wcsrev(wchar_t *_String)
     * }
     */
    public static MemorySegment _wcsrev$address() {
        return _wcsrev.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *_wcsrev(wchar_t *_String)
     * }
     */
    public static MemorySegment _wcsrev(MemorySegment _String) {
        var mh$ = _wcsrev.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcsrev", _String);
            }
            return (MemorySegment)mh$.invokeExact(_String);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcsset_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_SHORT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wcsset_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _wcsset_s(wchar_t *_Destination, size_t _SizeInWords, wchar_t _Value)
     * }
     */
    public static FunctionDescriptor _wcsset_s$descriptor() {
        return _wcsset_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _wcsset_s(wchar_t *_Destination, size_t _SizeInWords, wchar_t _Value)
     * }
     */
    public static MethodHandle _wcsset_s$handle() {
        return _wcsset_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _wcsset_s(wchar_t *_Destination, size_t _SizeInWords, wchar_t _Value)
     * }
     */
    public static MemorySegment _wcsset_s$address() {
        return _wcsset_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _wcsset_s(wchar_t *_Destination, size_t _SizeInWords, wchar_t _Value)
     * }
     */
    public static int _wcsset_s(MemorySegment _Destination, long _SizeInWords, short _Value) {
        var mh$ = _wcsset_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcsset_s", _Destination, _SizeInWords, _Value);
            }
            return (int)mh$.invokeExact(_Destination, _SizeInWords, _Value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcsset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_SHORT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wcsset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *_wcsset(wchar_t *_String, wchar_t _Value)
     * }
     */
    public static FunctionDescriptor _wcsset$descriptor() {
        return _wcsset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *_wcsset(wchar_t *_String, wchar_t _Value)
     * }
     */
    public static MethodHandle _wcsset$handle() {
        return _wcsset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *_wcsset(wchar_t *_String, wchar_t _Value)
     * }
     */
    public static MemorySegment _wcsset$address() {
        return _wcsset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *_wcsset(wchar_t *_String, wchar_t _Value)
     * }
     */
    public static MemorySegment _wcsset(MemorySegment _String, short _Value) {
        var mh$ = _wcsset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcsset", _String, _Value);
            }
            return (MemorySegment)mh$.invokeExact(_String, _Value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcslwr_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wcslwr_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _wcslwr_s(wchar_t *_String, size_t _SizeInWords)
     * }
     */
    public static FunctionDescriptor _wcslwr_s$descriptor() {
        return _wcslwr_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _wcslwr_s(wchar_t *_String, size_t _SizeInWords)
     * }
     */
    public static MethodHandle _wcslwr_s$handle() {
        return _wcslwr_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _wcslwr_s(wchar_t *_String, size_t _SizeInWords)
     * }
     */
    public static MemorySegment _wcslwr_s$address() {
        return _wcslwr_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _wcslwr_s(wchar_t *_String, size_t _SizeInWords)
     * }
     */
    public static int _wcslwr_s(MemorySegment _String, long _SizeInWords) {
        var mh$ = _wcslwr_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcslwr_s", _String, _SizeInWords);
            }
            return (int)mh$.invokeExact(_String, _SizeInWords);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcslwr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wcslwr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *_wcslwr(wchar_t *_String)
     * }
     */
    public static FunctionDescriptor _wcslwr$descriptor() {
        return _wcslwr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *_wcslwr(wchar_t *_String)
     * }
     */
    public static MethodHandle _wcslwr$handle() {
        return _wcslwr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *_wcslwr(wchar_t *_String)
     * }
     */
    public static MemorySegment _wcslwr$address() {
        return _wcslwr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *_wcslwr(wchar_t *_String)
     * }
     */
    public static MemorySegment _wcslwr(MemorySegment _String) {
        var mh$ = _wcslwr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcslwr", _String);
            }
            return (MemorySegment)mh$.invokeExact(_String);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcslwr_s_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wcslwr_s_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _wcslwr_s_l(wchar_t *_String, size_t _SizeInWords, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcslwr_s_l$descriptor() {
        return _wcslwr_s_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _wcslwr_s_l(wchar_t *_String, size_t _SizeInWords, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcslwr_s_l$handle() {
        return _wcslwr_s_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _wcslwr_s_l(wchar_t *_String, size_t _SizeInWords, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcslwr_s_l$address() {
        return _wcslwr_s_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _wcslwr_s_l(wchar_t *_String, size_t _SizeInWords, _locale_t _Locale)
     * }
     */
    public static int _wcslwr_s_l(MemorySegment _String, long _SizeInWords, MemorySegment _Locale) {
        var mh$ = _wcslwr_s_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcslwr_s_l", _String, _SizeInWords, _Locale);
            }
            return (int)mh$.invokeExact(_String, _SizeInWords, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcslwr_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wcslwr_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *_wcslwr_l(wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcslwr_l$descriptor() {
        return _wcslwr_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *_wcslwr_l(wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcslwr_l$handle() {
        return _wcslwr_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *_wcslwr_l(wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcslwr_l$address() {
        return _wcslwr_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *_wcslwr_l(wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcslwr_l(MemorySegment _String, MemorySegment _Locale) {
        var mh$ = _wcslwr_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcslwr_l", _String, _Locale);
            }
            return (MemorySegment)mh$.invokeExact(_String, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcsupr_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wcsupr_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _wcsupr_s(wchar_t *_String, size_t _Size)
     * }
     */
    public static FunctionDescriptor _wcsupr_s$descriptor() {
        return _wcsupr_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _wcsupr_s(wchar_t *_String, size_t _Size)
     * }
     */
    public static MethodHandle _wcsupr_s$handle() {
        return _wcsupr_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _wcsupr_s(wchar_t *_String, size_t _Size)
     * }
     */
    public static MemorySegment _wcsupr_s$address() {
        return _wcsupr_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _wcsupr_s(wchar_t *_String, size_t _Size)
     * }
     */
    public static int _wcsupr_s(MemorySegment _String, long _Size) {
        var mh$ = _wcsupr_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcsupr_s", _String, _Size);
            }
            return (int)mh$.invokeExact(_String, _Size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcsupr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wcsupr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *_wcsupr(wchar_t *_String)
     * }
     */
    public static FunctionDescriptor _wcsupr$descriptor() {
        return _wcsupr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *_wcsupr(wchar_t *_String)
     * }
     */
    public static MethodHandle _wcsupr$handle() {
        return _wcsupr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *_wcsupr(wchar_t *_String)
     * }
     */
    public static MemorySegment _wcsupr$address() {
        return _wcsupr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *_wcsupr(wchar_t *_String)
     * }
     */
    public static MemorySegment _wcsupr(MemorySegment _String) {
        var mh$ = _wcsupr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcsupr", _String);
            }
            return (MemorySegment)mh$.invokeExact(_String);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcsupr_s_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wcsupr_s_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _wcsupr_s_l(wchar_t *_String, size_t _Size, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcsupr_s_l$descriptor() {
        return _wcsupr_s_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _wcsupr_s_l(wchar_t *_String, size_t _Size, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcsupr_s_l$handle() {
        return _wcsupr_s_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _wcsupr_s_l(wchar_t *_String, size_t _Size, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcsupr_s_l$address() {
        return _wcsupr_s_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _wcsupr_s_l(wchar_t *_String, size_t _Size, _locale_t _Locale)
     * }
     */
    public static int _wcsupr_s_l(MemorySegment _String, long _Size, MemorySegment _Locale) {
        var mh$ = _wcsupr_s_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcsupr_s_l", _String, _Size, _Locale);
            }
            return (int)mh$.invokeExact(_String, _Size, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcsupr_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wcsupr_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *_wcsupr_l(wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcsupr_l$descriptor() {
        return _wcsupr_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *_wcsupr_l(wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcsupr_l$handle() {
        return _wcsupr_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *_wcsupr_l(wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcsupr_l$address() {
        return _wcsupr_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *_wcsupr_l(wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcsupr_l(MemorySegment _String, MemorySegment _Locale) {
        var mh$ = _wcsupr_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcsupr_l", _String, _Locale);
            }
            return (MemorySegment)mh$.invokeExact(_String, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsxfrm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcsxfrm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t wcsxfrm(wchar_t *_Destination, const wchar_t *_Source, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor wcsxfrm$descriptor() {
        return wcsxfrm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t wcsxfrm(wchar_t *_Destination, const wchar_t *_Source, size_t _MaxCount)
     * }
     */
    public static MethodHandle wcsxfrm$handle() {
        return wcsxfrm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t wcsxfrm(wchar_t *_Destination, const wchar_t *_Source, size_t _MaxCount)
     * }
     */
    public static MemorySegment wcsxfrm$address() {
        return wcsxfrm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t wcsxfrm(wchar_t *_Destination, const wchar_t *_Source, size_t _MaxCount)
     * }
     */
    public static long wcsxfrm(MemorySegment _Destination, MemorySegment _Source, long _MaxCount) {
        var mh$ = wcsxfrm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsxfrm", _Destination, _Source, _MaxCount);
            }
            return (long)mh$.invokeExact(_Destination, _Source, _MaxCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcsxfrm_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wcsxfrm_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t _wcsxfrm_l(wchar_t *_Destination, const wchar_t *_Source, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcsxfrm_l$descriptor() {
        return _wcsxfrm_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t _wcsxfrm_l(wchar_t *_Destination, const wchar_t *_Source, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcsxfrm_l$handle() {
        return _wcsxfrm_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t _wcsxfrm_l(wchar_t *_Destination, const wchar_t *_Source, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcsxfrm_l$address() {
        return _wcsxfrm_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t _wcsxfrm_l(wchar_t *_Destination, const wchar_t *_Source, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static long _wcsxfrm_l(MemorySegment _Destination, MemorySegment _Source, long _MaxCount, MemorySegment _Locale) {
        var mh$ = _wcsxfrm_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcsxfrm_l", _Destination, _Source, _MaxCount, _Locale);
            }
            return (long)mh$.invokeExact(_Destination, _Source, _MaxCount, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcscoll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcscoll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int wcscoll(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static FunctionDescriptor wcscoll$descriptor() {
        return wcscoll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int wcscoll(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static MethodHandle wcscoll$handle() {
        return wcscoll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int wcscoll(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static MemorySegment wcscoll$address() {
        return wcscoll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int wcscoll(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static int wcscoll(MemorySegment _String1, MemorySegment _String2) {
        var mh$ = wcscoll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcscoll", _String1, _String2);
            }
            return (int)mh$.invokeExact(_String1, _String2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcscoll_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wcscoll_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _wcscoll_l(const wchar_t *_String1, const wchar_t *_String2, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcscoll_l$descriptor() {
        return _wcscoll_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _wcscoll_l(const wchar_t *_String1, const wchar_t *_String2, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcscoll_l$handle() {
        return _wcscoll_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _wcscoll_l(const wchar_t *_String1, const wchar_t *_String2, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcscoll_l$address() {
        return _wcscoll_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _wcscoll_l(const wchar_t *_String1, const wchar_t *_String2, _locale_t _Locale)
     * }
     */
    public static int _wcscoll_l(MemorySegment _String1, MemorySegment _String2, MemorySegment _Locale) {
        var mh$ = _wcscoll_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcscoll_l", _String1, _String2, _Locale);
            }
            return (int)mh$.invokeExact(_String1, _String2, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcsicoll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wcsicoll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _wcsicoll(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static FunctionDescriptor _wcsicoll$descriptor() {
        return _wcsicoll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _wcsicoll(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static MethodHandle _wcsicoll$handle() {
        return _wcsicoll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _wcsicoll(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static MemorySegment _wcsicoll$address() {
        return _wcsicoll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _wcsicoll(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static int _wcsicoll(MemorySegment _String1, MemorySegment _String2) {
        var mh$ = _wcsicoll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcsicoll", _String1, _String2);
            }
            return (int)mh$.invokeExact(_String1, _String2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcsicoll_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wcsicoll_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _wcsicoll_l(const wchar_t *_String1, const wchar_t *_String2, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcsicoll_l$descriptor() {
        return _wcsicoll_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _wcsicoll_l(const wchar_t *_String1, const wchar_t *_String2, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcsicoll_l$handle() {
        return _wcsicoll_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _wcsicoll_l(const wchar_t *_String1, const wchar_t *_String2, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcsicoll_l$address() {
        return _wcsicoll_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _wcsicoll_l(const wchar_t *_String1, const wchar_t *_String2, _locale_t _Locale)
     * }
     */
    public static int _wcsicoll_l(MemorySegment _String1, MemorySegment _String2, MemorySegment _Locale) {
        var mh$ = _wcsicoll_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcsicoll_l", _String1, _String2, _Locale);
            }
            return (int)mh$.invokeExact(_String1, _String2, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcsncoll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wcsncoll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _wcsncoll(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor _wcsncoll$descriptor() {
        return _wcsncoll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _wcsncoll(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount)
     * }
     */
    public static MethodHandle _wcsncoll$handle() {
        return _wcsncoll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _wcsncoll(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount)
     * }
     */
    public static MemorySegment _wcsncoll$address() {
        return _wcsncoll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _wcsncoll(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount)
     * }
     */
    public static int _wcsncoll(MemorySegment _String1, MemorySegment _String2, long _MaxCount) {
        var mh$ = _wcsncoll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcsncoll", _String1, _String2, _MaxCount);
            }
            return (int)mh$.invokeExact(_String1, _String2, _MaxCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcsncoll_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wcsncoll_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _wcsncoll_l(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcsncoll_l$descriptor() {
        return _wcsncoll_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _wcsncoll_l(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcsncoll_l$handle() {
        return _wcsncoll_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _wcsncoll_l(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcsncoll_l$address() {
        return _wcsncoll_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _wcsncoll_l(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static int _wcsncoll_l(MemorySegment _String1, MemorySegment _String2, long _MaxCount, MemorySegment _Locale) {
        var mh$ = _wcsncoll_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcsncoll_l", _String1, _String2, _MaxCount, _Locale);
            }
            return (int)mh$.invokeExact(_String1, _String2, _MaxCount, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcsnicoll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wcsnicoll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _wcsnicoll(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor _wcsnicoll$descriptor() {
        return _wcsnicoll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _wcsnicoll(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount)
     * }
     */
    public static MethodHandle _wcsnicoll$handle() {
        return _wcsnicoll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _wcsnicoll(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount)
     * }
     */
    public static MemorySegment _wcsnicoll$address() {
        return _wcsnicoll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _wcsnicoll(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount)
     * }
     */
    public static int _wcsnicoll(MemorySegment _String1, MemorySegment _String2, long _MaxCount) {
        var mh$ = _wcsnicoll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcsnicoll", _String1, _String2, _MaxCount);
            }
            return (int)mh$.invokeExact(_String1, _String2, _MaxCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcsnicoll_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wcsnicoll_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _wcsnicoll_l(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcsnicoll_l$descriptor() {
        return _wcsnicoll_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _wcsnicoll_l(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcsnicoll_l$handle() {
        return _wcsnicoll_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _wcsnicoll_l(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcsnicoll_l$address() {
        return _wcsnicoll_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _wcsnicoll_l(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static int _wcsnicoll_l(MemorySegment _String1, MemorySegment _String2, long _MaxCount, MemorySegment _Locale) {
        var mh$ = _wcsnicoll_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcsnicoll_l", _String1, _String2, _MaxCount, _Locale);
            }
            return (int)mh$.invokeExact(_String1, _String2, _MaxCount, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsdup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcsdup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *wcsdup(const wchar_t *_String)
     * }
     */
    public static FunctionDescriptor wcsdup$descriptor() {
        return wcsdup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *wcsdup(const wchar_t *_String)
     * }
     */
    public static MethodHandle wcsdup$handle() {
        return wcsdup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *wcsdup(const wchar_t *_String)
     * }
     */
    public static MemorySegment wcsdup$address() {
        return wcsdup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *wcsdup(const wchar_t *_String)
     * }
     */
    public static MemorySegment wcsdup(MemorySegment _String) {
        var mh$ = wcsdup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsdup", _String);
            }
            return (MemorySegment)mh$.invokeExact(_String);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsicmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcsicmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int wcsicmp(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static FunctionDescriptor wcsicmp$descriptor() {
        return wcsicmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int wcsicmp(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static MethodHandle wcsicmp$handle() {
        return wcsicmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int wcsicmp(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static MemorySegment wcsicmp$address() {
        return wcsicmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int wcsicmp(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static int wcsicmp(MemorySegment _String1, MemorySegment _String2) {
        var mh$ = wcsicmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsicmp", _String1, _String2);
            }
            return (int)mh$.invokeExact(_String1, _String2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsnicmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcsnicmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int wcsnicmp(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor wcsnicmp$descriptor() {
        return wcsnicmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int wcsnicmp(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount)
     * }
     */
    public static MethodHandle wcsnicmp$handle() {
        return wcsnicmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int wcsnicmp(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount)
     * }
     */
    public static MemorySegment wcsnicmp$address() {
        return wcsnicmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int wcsnicmp(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount)
     * }
     */
    public static int wcsnicmp(MemorySegment _String1, MemorySegment _String2, long _MaxCount) {
        var mh$ = wcsnicmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsnicmp", _String1, _String2, _MaxCount);
            }
            return (int)mh$.invokeExact(_String1, _String2, _MaxCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsnset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_SHORT,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcsnset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *wcsnset(wchar_t *_String, wchar_t _Value, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor wcsnset$descriptor() {
        return wcsnset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *wcsnset(wchar_t *_String, wchar_t _Value, size_t _MaxCount)
     * }
     */
    public static MethodHandle wcsnset$handle() {
        return wcsnset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *wcsnset(wchar_t *_String, wchar_t _Value, size_t _MaxCount)
     * }
     */
    public static MemorySegment wcsnset$address() {
        return wcsnset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *wcsnset(wchar_t *_String, wchar_t _Value, size_t _MaxCount)
     * }
     */
    public static MemorySegment wcsnset(MemorySegment _String, short _Value, long _MaxCount) {
        var mh$ = wcsnset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsnset", _String, _Value, _MaxCount);
            }
            return (MemorySegment)mh$.invokeExact(_String, _Value, _MaxCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsrev {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcsrev");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *wcsrev(wchar_t *_String)
     * }
     */
    public static FunctionDescriptor wcsrev$descriptor() {
        return wcsrev.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *wcsrev(wchar_t *_String)
     * }
     */
    public static MethodHandle wcsrev$handle() {
        return wcsrev.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *wcsrev(wchar_t *_String)
     * }
     */
    public static MemorySegment wcsrev$address() {
        return wcsrev.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *wcsrev(wchar_t *_String)
     * }
     */
    public static MemorySegment wcsrev(MemorySegment _String) {
        var mh$ = wcsrev.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsrev", _String);
            }
            return (MemorySegment)mh$.invokeExact(_String);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_SHORT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcsset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *wcsset(wchar_t *_String, wchar_t _Value)
     * }
     */
    public static FunctionDescriptor wcsset$descriptor() {
        return wcsset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *wcsset(wchar_t *_String, wchar_t _Value)
     * }
     */
    public static MethodHandle wcsset$handle() {
        return wcsset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *wcsset(wchar_t *_String, wchar_t _Value)
     * }
     */
    public static MemorySegment wcsset$address() {
        return wcsset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *wcsset(wchar_t *_String, wchar_t _Value)
     * }
     */
    public static MemorySegment wcsset(MemorySegment _String, short _Value) {
        var mh$ = wcsset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsset", _String, _Value);
            }
            return (MemorySegment)mh$.invokeExact(_String, _Value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcslwr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcslwr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *wcslwr(wchar_t *_String)
     * }
     */
    public static FunctionDescriptor wcslwr$descriptor() {
        return wcslwr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *wcslwr(wchar_t *_String)
     * }
     */
    public static MethodHandle wcslwr$handle() {
        return wcslwr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *wcslwr(wchar_t *_String)
     * }
     */
    public static MemorySegment wcslwr$address() {
        return wcslwr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *wcslwr(wchar_t *_String)
     * }
     */
    public static MemorySegment wcslwr(MemorySegment _String) {
        var mh$ = wcslwr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcslwr", _String);
            }
            return (MemorySegment)mh$.invokeExact(_String);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsupr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcsupr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *wcsupr(wchar_t *_String)
     * }
     */
    public static FunctionDescriptor wcsupr$descriptor() {
        return wcsupr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *wcsupr(wchar_t *_String)
     * }
     */
    public static MethodHandle wcsupr$handle() {
        return wcsupr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *wcsupr(wchar_t *_String)
     * }
     */
    public static MemorySegment wcsupr$address() {
        return wcsupr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *wcsupr(wchar_t *_String)
     * }
     */
    public static MemorySegment wcsupr(MemorySegment _String) {
        var mh$ = wcsupr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsupr", _String);
            }
            return (MemorySegment)mh$.invokeExact(_String);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsicoll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcsicoll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int wcsicoll(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static FunctionDescriptor wcsicoll$descriptor() {
        return wcsicoll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int wcsicoll(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static MethodHandle wcsicoll$handle() {
        return wcsicoll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int wcsicoll(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static MemorySegment wcsicoll$address() {
        return wcsicoll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int wcsicoll(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static int wcsicoll(MemorySegment _String1, MemorySegment _String2) {
        var mh$ = wcsicoll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsicoll", _String1, _String2);
            }
            return (int)mh$.invokeExact(_String1, _String2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcpy_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("strcpy_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t strcpy_s(char *_Destination, rsize_t _SizeInBytes, const char *_Source)
     * }
     */
    public static FunctionDescriptor strcpy_s$descriptor() {
        return strcpy_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t strcpy_s(char *_Destination, rsize_t _SizeInBytes, const char *_Source)
     * }
     */
    public static MethodHandle strcpy_s$handle() {
        return strcpy_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t strcpy_s(char *_Destination, rsize_t _SizeInBytes, const char *_Source)
     * }
     */
    public static MemorySegment strcpy_s$address() {
        return strcpy_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t strcpy_s(char *_Destination, rsize_t _SizeInBytes, const char *_Source)
     * }
     */
    public static int strcpy_s(MemorySegment _Destination, long _SizeInBytes, MemorySegment _Source) {
        var mh$ = strcpy_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcpy_s", _Destination, _SizeInBytes, _Source);
            }
            return (int)mh$.invokeExact(_Destination, _SizeInBytes, _Source);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcat_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("strcat_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t strcat_s(char *_Destination, rsize_t _SizeInBytes, const char *_Source)
     * }
     */
    public static FunctionDescriptor strcat_s$descriptor() {
        return strcat_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t strcat_s(char *_Destination, rsize_t _SizeInBytes, const char *_Source)
     * }
     */
    public static MethodHandle strcat_s$handle() {
        return strcat_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t strcat_s(char *_Destination, rsize_t _SizeInBytes, const char *_Source)
     * }
     */
    public static MemorySegment strcat_s$address() {
        return strcat_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t strcat_s(char *_Destination, rsize_t _SizeInBytes, const char *_Source)
     * }
     */
    public static int strcat_s(MemorySegment _Destination, long _SizeInBytes, MemorySegment _Source) {
        var mh$ = strcat_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcat_s", _Destination, _SizeInBytes, _Source);
            }
            return (int)mh$.invokeExact(_Destination, _SizeInBytes, _Source);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strerror_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("strerror_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t strerror_s(char *_Buffer, size_t _SizeInBytes, int _ErrorNumber)
     * }
     */
    public static FunctionDescriptor strerror_s$descriptor() {
        return strerror_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t strerror_s(char *_Buffer, size_t _SizeInBytes, int _ErrorNumber)
     * }
     */
    public static MethodHandle strerror_s$handle() {
        return strerror_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t strerror_s(char *_Buffer, size_t _SizeInBytes, int _ErrorNumber)
     * }
     */
    public static MemorySegment strerror_s$address() {
        return strerror_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t strerror_s(char *_Buffer, size_t _SizeInBytes, int _ErrorNumber)
     * }
     */
    public static int strerror_s(MemorySegment _Buffer, long _SizeInBytes, int _ErrorNumber) {
        var mh$ = strerror_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strerror_s", _Buffer, _SizeInBytes, _ErrorNumber);
            }
            return (int)mh$.invokeExact(_Buffer, _SizeInBytes, _ErrorNumber);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strncat_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("strncat_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t strncat_s(char *_Destination, rsize_t _SizeInBytes, const char *_Source, rsize_t _MaxCount)
     * }
     */
    public static FunctionDescriptor strncat_s$descriptor() {
        return strncat_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t strncat_s(char *_Destination, rsize_t _SizeInBytes, const char *_Source, rsize_t _MaxCount)
     * }
     */
    public static MethodHandle strncat_s$handle() {
        return strncat_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t strncat_s(char *_Destination, rsize_t _SizeInBytes, const char *_Source, rsize_t _MaxCount)
     * }
     */
    public static MemorySegment strncat_s$address() {
        return strncat_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t strncat_s(char *_Destination, rsize_t _SizeInBytes, const char *_Source, rsize_t _MaxCount)
     * }
     */
    public static int strncat_s(MemorySegment _Destination, long _SizeInBytes, MemorySegment _Source, long _MaxCount) {
        var mh$ = strncat_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strncat_s", _Destination, _SizeInBytes, _Source, _MaxCount);
            }
            return (int)mh$.invokeExact(_Destination, _SizeInBytes, _Source, _MaxCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strncpy_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("strncpy_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t strncpy_s(char *_Destination, rsize_t _SizeInBytes, const char *_Source, rsize_t _MaxCount)
     * }
     */
    public static FunctionDescriptor strncpy_s$descriptor() {
        return strncpy_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t strncpy_s(char *_Destination, rsize_t _SizeInBytes, const char *_Source, rsize_t _MaxCount)
     * }
     */
    public static MethodHandle strncpy_s$handle() {
        return strncpy_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t strncpy_s(char *_Destination, rsize_t _SizeInBytes, const char *_Source, rsize_t _MaxCount)
     * }
     */
    public static MemorySegment strncpy_s$address() {
        return strncpy_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t strncpy_s(char *_Destination, rsize_t _SizeInBytes, const char *_Source, rsize_t _MaxCount)
     * }
     */
    public static int strncpy_s(MemorySegment _Destination, long _SizeInBytes, MemorySegment _Source, long _MaxCount) {
        var mh$ = strncpy_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strncpy_s", _Destination, _SizeInBytes, _Source, _MaxCount);
            }
            return (int)mh$.invokeExact(_Destination, _SizeInBytes, _Source, _MaxCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtok_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("strtok_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strtok_s(char *_String, const char *_Delimiter, char **_Context)
     * }
     */
    public static FunctionDescriptor strtok_s$descriptor() {
        return strtok_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strtok_s(char *_String, const char *_Delimiter, char **_Context)
     * }
     */
    public static MethodHandle strtok_s$handle() {
        return strtok_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strtok_s(char *_String, const char *_Delimiter, char **_Context)
     * }
     */
    public static MemorySegment strtok_s$address() {
        return strtok_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strtok_s(char *_String, const char *_Delimiter, char **_Context)
     * }
     */
    public static MemorySegment strtok_s(MemorySegment _String, MemorySegment _Delimiter, MemorySegment _Context) {
        var mh$ = strtok_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtok_s", _String, _Delimiter, _Context);
            }
            return (MemorySegment)mh$.invokeExact(_String, _Delimiter, _Context);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _memccpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_memccpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *_memccpy(void *_Dst, const void *_Src, int _Val, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor _memccpy$descriptor() {
        return _memccpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *_memccpy(void *_Dst, const void *_Src, int _Val, size_t _MaxCount)
     * }
     */
    public static MethodHandle _memccpy$handle() {
        return _memccpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *_memccpy(void *_Dst, const void *_Src, int _Val, size_t _MaxCount)
     * }
     */
    public static MemorySegment _memccpy$address() {
        return _memccpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *_memccpy(void *_Dst, const void *_Src, int _Val, size_t _MaxCount)
     * }
     */
    public static MemorySegment _memccpy(MemorySegment _Dst, MemorySegment _Src, int _Val, long _MaxCount) {
        var mh$ = _memccpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_memccpy", _Dst, _Src, _Val, _MaxCount);
            }
            return (MemorySegment)mh$.invokeExact(_Dst, _Src, _Val, _MaxCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("strcat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strcat(char *_Destination, const char *_Source)
     * }
     */
    public static FunctionDescriptor strcat$descriptor() {
        return strcat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strcat(char *_Destination, const char *_Source)
     * }
     */
    public static MethodHandle strcat$handle() {
        return strcat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strcat(char *_Destination, const char *_Source)
     * }
     */
    public static MemorySegment strcat$address() {
        return strcat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strcat(char *_Destination, const char *_Source)
     * }
     */
    public static MemorySegment strcat(MemorySegment _Destination, MemorySegment _Source) {
        var mh$ = strcat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcat", _Destination, _Source);
            }
            return (MemorySegment)mh$.invokeExact(_Destination, _Source);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("strcmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int strcmp(const char *_Str1, const char *_Str2)
     * }
     */
    public static FunctionDescriptor strcmp$descriptor() {
        return strcmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int strcmp(const char *_Str1, const char *_Str2)
     * }
     */
    public static MethodHandle strcmp$handle() {
        return strcmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int strcmp(const char *_Str1, const char *_Str2)
     * }
     */
    public static MemorySegment strcmp$address() {
        return strcmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int strcmp(const char *_Str1, const char *_Str2)
     * }
     */
    public static int strcmp(MemorySegment _Str1, MemorySegment _Str2) {
        var mh$ = strcmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcmp", _Str1, _Str2);
            }
            return (int)mh$.invokeExact(_Str1, _Str2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strcmpi {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_strcmpi");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _strcmpi(const char *_String1, const char *_String2)
     * }
     */
    public static FunctionDescriptor _strcmpi$descriptor() {
        return _strcmpi.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _strcmpi(const char *_String1, const char *_String2)
     * }
     */
    public static MethodHandle _strcmpi$handle() {
        return _strcmpi.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _strcmpi(const char *_String1, const char *_String2)
     * }
     */
    public static MemorySegment _strcmpi$address() {
        return _strcmpi.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _strcmpi(const char *_String1, const char *_String2)
     * }
     */
    public static int _strcmpi(MemorySegment _String1, MemorySegment _String2) {
        var mh$ = _strcmpi.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strcmpi", _String1, _String2);
            }
            return (int)mh$.invokeExact(_String1, _String2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcoll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("strcoll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int strcoll(const char *_String1, const char *_String2)
     * }
     */
    public static FunctionDescriptor strcoll$descriptor() {
        return strcoll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int strcoll(const char *_String1, const char *_String2)
     * }
     */
    public static MethodHandle strcoll$handle() {
        return strcoll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int strcoll(const char *_String1, const char *_String2)
     * }
     */
    public static MemorySegment strcoll$address() {
        return strcoll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int strcoll(const char *_String1, const char *_String2)
     * }
     */
    public static int strcoll(MemorySegment _String1, MemorySegment _String2) {
        var mh$ = strcoll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcoll", _String1, _String2);
            }
            return (int)mh$.invokeExact(_String1, _String2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strcoll_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_strcoll_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _strcoll_l(const char *_String1, const char *_String2, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _strcoll_l$descriptor() {
        return _strcoll_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _strcoll_l(const char *_String1, const char *_String2, _locale_t _Locale)
     * }
     */
    public static MethodHandle _strcoll_l$handle() {
        return _strcoll_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _strcoll_l(const char *_String1, const char *_String2, _locale_t _Locale)
     * }
     */
    public static MemorySegment _strcoll_l$address() {
        return _strcoll_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _strcoll_l(const char *_String1, const char *_String2, _locale_t _Locale)
     * }
     */
    public static int _strcoll_l(MemorySegment _String1, MemorySegment _String2, MemorySegment _Locale) {
        var mh$ = _strcoll_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strcoll_l", _String1, _String2, _Locale);
            }
            return (int)mh$.invokeExact(_String1, _String2, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("strcpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strcpy(char *_Destination, const char *_Source)
     * }
     */
    public static FunctionDescriptor strcpy$descriptor() {
        return strcpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strcpy(char *_Destination, const char *_Source)
     * }
     */
    public static MethodHandle strcpy$handle() {
        return strcpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strcpy(char *_Destination, const char *_Source)
     * }
     */
    public static MemorySegment strcpy$address() {
        return strcpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strcpy(char *_Destination, const char *_Source)
     * }
     */
    public static MemorySegment strcpy(MemorySegment _Destination, MemorySegment _Source) {
        var mh$ = strcpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcpy", _Destination, _Source);
            }
            return (MemorySegment)mh$.invokeExact(_Destination, _Source);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcspn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("strcspn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long long strcspn(const char *_Str, const char *_Control)
     * }
     */
    public static FunctionDescriptor strcspn$descriptor() {
        return strcspn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long long strcspn(const char *_Str, const char *_Control)
     * }
     */
    public static MethodHandle strcspn$handle() {
        return strcspn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long long strcspn(const char *_Str, const char *_Control)
     * }
     */
    public static MemorySegment strcspn$address() {
        return strcspn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long long strcspn(const char *_Str, const char *_Control)
     * }
     */
    public static long strcspn(MemorySegment _Str, MemorySegment _Control) {
        var mh$ = strcspn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcspn", _Str, _Control);
            }
            return (long)mh$.invokeExact(_Str, _Control);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strdup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_strdup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *_strdup(const char *_Source)
     * }
     */
    public static FunctionDescriptor _strdup$descriptor() {
        return _strdup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *_strdup(const char *_Source)
     * }
     */
    public static MethodHandle _strdup$handle() {
        return _strdup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *_strdup(const char *_Source)
     * }
     */
    public static MemorySegment _strdup$address() {
        return _strdup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *_strdup(const char *_Source)
     * }
     */
    public static MemorySegment _strdup(MemorySegment _Source) {
        var mh$ = _strdup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strdup", _Source);
            }
            return (MemorySegment)mh$.invokeExact(_Source);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strerror {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_strerror");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *_strerror(const char *_ErrorMessage)
     * }
     */
    public static FunctionDescriptor _strerror$descriptor() {
        return _strerror.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *_strerror(const char *_ErrorMessage)
     * }
     */
    public static MethodHandle _strerror$handle() {
        return _strerror.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *_strerror(const char *_ErrorMessage)
     * }
     */
    public static MemorySegment _strerror$address() {
        return _strerror.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *_strerror(const char *_ErrorMessage)
     * }
     */
    public static MemorySegment _strerror(MemorySegment _ErrorMessage) {
        var mh$ = _strerror.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strerror", _ErrorMessage);
            }
            return (MemorySegment)mh$.invokeExact(_ErrorMessage);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strerror_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_strerror_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _strerror_s(char *_Buffer, size_t _SizeInBytes, const char *_ErrorMessage)
     * }
     */
    public static FunctionDescriptor _strerror_s$descriptor() {
        return _strerror_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _strerror_s(char *_Buffer, size_t _SizeInBytes, const char *_ErrorMessage)
     * }
     */
    public static MethodHandle _strerror_s$handle() {
        return _strerror_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _strerror_s(char *_Buffer, size_t _SizeInBytes, const char *_ErrorMessage)
     * }
     */
    public static MemorySegment _strerror_s$address() {
        return _strerror_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _strerror_s(char *_Buffer, size_t _SizeInBytes, const char *_ErrorMessage)
     * }
     */
    public static int _strerror_s(MemorySegment _Buffer, long _SizeInBytes, MemorySegment _ErrorMessage) {
        var mh$ = _strerror_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strerror_s", _Buffer, _SizeInBytes, _ErrorMessage);
            }
            return (int)mh$.invokeExact(_Buffer, _SizeInBytes, _ErrorMessage);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strerror {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("strerror");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strerror(int _ErrorMessage)
     * }
     */
    public static FunctionDescriptor strerror$descriptor() {
        return strerror.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strerror(int _ErrorMessage)
     * }
     */
    public static MethodHandle strerror$handle() {
        return strerror.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strerror(int _ErrorMessage)
     * }
     */
    public static MemorySegment strerror$address() {
        return strerror.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strerror(int _ErrorMessage)
     * }
     */
    public static MemorySegment strerror(int _ErrorMessage) {
        var mh$ = strerror.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strerror", _ErrorMessage);
            }
            return (MemorySegment)mh$.invokeExact(_ErrorMessage);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _stricmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_stricmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _stricmp(const char *_String1, const char *_String2)
     * }
     */
    public static FunctionDescriptor _stricmp$descriptor() {
        return _stricmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _stricmp(const char *_String1, const char *_String2)
     * }
     */
    public static MethodHandle _stricmp$handle() {
        return _stricmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _stricmp(const char *_String1, const char *_String2)
     * }
     */
    public static MemorySegment _stricmp$address() {
        return _stricmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _stricmp(const char *_String1, const char *_String2)
     * }
     */
    public static int _stricmp(MemorySegment _String1, MemorySegment _String2) {
        var mh$ = _stricmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_stricmp", _String1, _String2);
            }
            return (int)mh$.invokeExact(_String1, _String2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _stricoll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_stricoll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _stricoll(const char *_String1, const char *_String2)
     * }
     */
    public static FunctionDescriptor _stricoll$descriptor() {
        return _stricoll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _stricoll(const char *_String1, const char *_String2)
     * }
     */
    public static MethodHandle _stricoll$handle() {
        return _stricoll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _stricoll(const char *_String1, const char *_String2)
     * }
     */
    public static MemorySegment _stricoll$address() {
        return _stricoll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _stricoll(const char *_String1, const char *_String2)
     * }
     */
    public static int _stricoll(MemorySegment _String1, MemorySegment _String2) {
        var mh$ = _stricoll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_stricoll", _String1, _String2);
            }
            return (int)mh$.invokeExact(_String1, _String2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _stricoll_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_stricoll_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _stricoll_l(const char *_String1, const char *_String2, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _stricoll_l$descriptor() {
        return _stricoll_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _stricoll_l(const char *_String1, const char *_String2, _locale_t _Locale)
     * }
     */
    public static MethodHandle _stricoll_l$handle() {
        return _stricoll_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _stricoll_l(const char *_String1, const char *_String2, _locale_t _Locale)
     * }
     */
    public static MemorySegment _stricoll_l$address() {
        return _stricoll_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _stricoll_l(const char *_String1, const char *_String2, _locale_t _Locale)
     * }
     */
    public static int _stricoll_l(MemorySegment _String1, MemorySegment _String2, MemorySegment _Locale) {
        var mh$ = _stricoll_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_stricoll_l", _String1, _String2, _Locale);
            }
            return (int)mh$.invokeExact(_String1, _String2, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _stricmp_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_stricmp_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _stricmp_l(const char *_String1, const char *_String2, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _stricmp_l$descriptor() {
        return _stricmp_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _stricmp_l(const char *_String1, const char *_String2, _locale_t _Locale)
     * }
     */
    public static MethodHandle _stricmp_l$handle() {
        return _stricmp_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _stricmp_l(const char *_String1, const char *_String2, _locale_t _Locale)
     * }
     */
    public static MemorySegment _stricmp_l$address() {
        return _stricmp_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _stricmp_l(const char *_String1, const char *_String2, _locale_t _Locale)
     * }
     */
    public static int _stricmp_l(MemorySegment _String1, MemorySegment _String2, MemorySegment _Locale) {
        var mh$ = _stricmp_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_stricmp_l", _String1, _String2, _Locale);
            }
            return (int)mh$.invokeExact(_String1, _String2, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strlen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("strlen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long long strlen(const char *_Str)
     * }
     */
    public static FunctionDescriptor strlen$descriptor() {
        return strlen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long long strlen(const char *_Str)
     * }
     */
    public static MethodHandle strlen$handle() {
        return strlen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long long strlen(const char *_Str)
     * }
     */
    public static MemorySegment strlen$address() {
        return strlen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long long strlen(const char *_Str)
     * }
     */
    public static long strlen(MemorySegment _Str) {
        var mh$ = strlen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strlen", _Str);
            }
            return (long)mh$.invokeExact(_Str);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strlwr_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_strlwr_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _strlwr_s(char *_String, size_t _Size)
     * }
     */
    public static FunctionDescriptor _strlwr_s$descriptor() {
        return _strlwr_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _strlwr_s(char *_String, size_t _Size)
     * }
     */
    public static MethodHandle _strlwr_s$handle() {
        return _strlwr_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _strlwr_s(char *_String, size_t _Size)
     * }
     */
    public static MemorySegment _strlwr_s$address() {
        return _strlwr_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _strlwr_s(char *_String, size_t _Size)
     * }
     */
    public static int _strlwr_s(MemorySegment _String, long _Size) {
        var mh$ = _strlwr_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strlwr_s", _String, _Size);
            }
            return (int)mh$.invokeExact(_String, _Size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strlwr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_strlwr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *_strlwr(char *_String)
     * }
     */
    public static FunctionDescriptor _strlwr$descriptor() {
        return _strlwr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *_strlwr(char *_String)
     * }
     */
    public static MethodHandle _strlwr$handle() {
        return _strlwr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *_strlwr(char *_String)
     * }
     */
    public static MemorySegment _strlwr$address() {
        return _strlwr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *_strlwr(char *_String)
     * }
     */
    public static MemorySegment _strlwr(MemorySegment _String) {
        var mh$ = _strlwr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strlwr", _String);
            }
            return (MemorySegment)mh$.invokeExact(_String);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strlwr_s_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_strlwr_s_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _strlwr_s_l(char *_String, size_t _Size, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _strlwr_s_l$descriptor() {
        return _strlwr_s_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _strlwr_s_l(char *_String, size_t _Size, _locale_t _Locale)
     * }
     */
    public static MethodHandle _strlwr_s_l$handle() {
        return _strlwr_s_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _strlwr_s_l(char *_String, size_t _Size, _locale_t _Locale)
     * }
     */
    public static MemorySegment _strlwr_s_l$address() {
        return _strlwr_s_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _strlwr_s_l(char *_String, size_t _Size, _locale_t _Locale)
     * }
     */
    public static int _strlwr_s_l(MemorySegment _String, long _Size, MemorySegment _Locale) {
        var mh$ = _strlwr_s_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strlwr_s_l", _String, _Size, _Locale);
            }
            return (int)mh$.invokeExact(_String, _Size, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strlwr_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_strlwr_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *_strlwr_l(char *_String, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _strlwr_l$descriptor() {
        return _strlwr_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *_strlwr_l(char *_String, _locale_t _Locale)
     * }
     */
    public static MethodHandle _strlwr_l$handle() {
        return _strlwr_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *_strlwr_l(char *_String, _locale_t _Locale)
     * }
     */
    public static MemorySegment _strlwr_l$address() {
        return _strlwr_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *_strlwr_l(char *_String, _locale_t _Locale)
     * }
     */
    public static MemorySegment _strlwr_l(MemorySegment _String, MemorySegment _Locale) {
        var mh$ = _strlwr_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strlwr_l", _String, _Locale);
            }
            return (MemorySegment)mh$.invokeExact(_String, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strncat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("strncat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strncat(char *_Destination, const char *_Source, size_t _Count)
     * }
     */
    public static FunctionDescriptor strncat$descriptor() {
        return strncat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strncat(char *_Destination, const char *_Source, size_t _Count)
     * }
     */
    public static MethodHandle strncat$handle() {
        return strncat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strncat(char *_Destination, const char *_Source, size_t _Count)
     * }
     */
    public static MemorySegment strncat$address() {
        return strncat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strncat(char *_Destination, const char *_Source, size_t _Count)
     * }
     */
    public static MemorySegment strncat(MemorySegment _Destination, MemorySegment _Source, long _Count) {
        var mh$ = strncat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strncat", _Destination, _Source, _Count);
            }
            return (MemorySegment)mh$.invokeExact(_Destination, _Source, _Count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strncmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("strncmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int strncmp(const char *_Str1, const char *_Str2, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor strncmp$descriptor() {
        return strncmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int strncmp(const char *_Str1, const char *_Str2, size_t _MaxCount)
     * }
     */
    public static MethodHandle strncmp$handle() {
        return strncmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int strncmp(const char *_Str1, const char *_Str2, size_t _MaxCount)
     * }
     */
    public static MemorySegment strncmp$address() {
        return strncmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int strncmp(const char *_Str1, const char *_Str2, size_t _MaxCount)
     * }
     */
    public static int strncmp(MemorySegment _Str1, MemorySegment _Str2, long _MaxCount) {
        var mh$ = strncmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strncmp", _Str1, _Str2, _MaxCount);
            }
            return (int)mh$.invokeExact(_Str1, _Str2, _MaxCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strnicmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_strnicmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _strnicmp(const char *_String1, const char *_String2, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor _strnicmp$descriptor() {
        return _strnicmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _strnicmp(const char *_String1, const char *_String2, size_t _MaxCount)
     * }
     */
    public static MethodHandle _strnicmp$handle() {
        return _strnicmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _strnicmp(const char *_String1, const char *_String2, size_t _MaxCount)
     * }
     */
    public static MemorySegment _strnicmp$address() {
        return _strnicmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _strnicmp(const char *_String1, const char *_String2, size_t _MaxCount)
     * }
     */
    public static int _strnicmp(MemorySegment _String1, MemorySegment _String2, long _MaxCount) {
        var mh$ = _strnicmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strnicmp", _String1, _String2, _MaxCount);
            }
            return (int)mh$.invokeExact(_String1, _String2, _MaxCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strnicmp_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_strnicmp_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _strnicmp_l(const char *_String1, const char *_String2, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _strnicmp_l$descriptor() {
        return _strnicmp_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _strnicmp_l(const char *_String1, const char *_String2, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MethodHandle _strnicmp_l$handle() {
        return _strnicmp_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _strnicmp_l(const char *_String1, const char *_String2, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MemorySegment _strnicmp_l$address() {
        return _strnicmp_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _strnicmp_l(const char *_String1, const char *_String2, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static int _strnicmp_l(MemorySegment _String1, MemorySegment _String2, long _MaxCount, MemorySegment _Locale) {
        var mh$ = _strnicmp_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strnicmp_l", _String1, _String2, _MaxCount, _Locale);
            }
            return (int)mh$.invokeExact(_String1, _String2, _MaxCount, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strnicoll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_strnicoll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _strnicoll(const char *_String1, const char *_String2, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor _strnicoll$descriptor() {
        return _strnicoll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _strnicoll(const char *_String1, const char *_String2, size_t _MaxCount)
     * }
     */
    public static MethodHandle _strnicoll$handle() {
        return _strnicoll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _strnicoll(const char *_String1, const char *_String2, size_t _MaxCount)
     * }
     */
    public static MemorySegment _strnicoll$address() {
        return _strnicoll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _strnicoll(const char *_String1, const char *_String2, size_t _MaxCount)
     * }
     */
    public static int _strnicoll(MemorySegment _String1, MemorySegment _String2, long _MaxCount) {
        var mh$ = _strnicoll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strnicoll", _String1, _String2, _MaxCount);
            }
            return (int)mh$.invokeExact(_String1, _String2, _MaxCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strnicoll_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_strnicoll_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _strnicoll_l(const char *_String1, const char *_String2, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _strnicoll_l$descriptor() {
        return _strnicoll_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _strnicoll_l(const char *_String1, const char *_String2, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MethodHandle _strnicoll_l$handle() {
        return _strnicoll_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _strnicoll_l(const char *_String1, const char *_String2, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MemorySegment _strnicoll_l$address() {
        return _strnicoll_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _strnicoll_l(const char *_String1, const char *_String2, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static int _strnicoll_l(MemorySegment _String1, MemorySegment _String2, long _MaxCount, MemorySegment _Locale) {
        var mh$ = _strnicoll_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strnicoll_l", _String1, _String2, _MaxCount, _Locale);
            }
            return (int)mh$.invokeExact(_String1, _String2, _MaxCount, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strncoll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_strncoll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _strncoll(const char *_String1, const char *_String2, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor _strncoll$descriptor() {
        return _strncoll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _strncoll(const char *_String1, const char *_String2, size_t _MaxCount)
     * }
     */
    public static MethodHandle _strncoll$handle() {
        return _strncoll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _strncoll(const char *_String1, const char *_String2, size_t _MaxCount)
     * }
     */
    public static MemorySegment _strncoll$address() {
        return _strncoll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _strncoll(const char *_String1, const char *_String2, size_t _MaxCount)
     * }
     */
    public static int _strncoll(MemorySegment _String1, MemorySegment _String2, long _MaxCount) {
        var mh$ = _strncoll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strncoll", _String1, _String2, _MaxCount);
            }
            return (int)mh$.invokeExact(_String1, _String2, _MaxCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strncoll_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_strncoll_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _strncoll_l(const char *_String1, const char *_String2, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _strncoll_l$descriptor() {
        return _strncoll_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _strncoll_l(const char *_String1, const char *_String2, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MethodHandle _strncoll_l$handle() {
        return _strncoll_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _strncoll_l(const char *_String1, const char *_String2, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MemorySegment _strncoll_l$address() {
        return _strncoll_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _strncoll_l(const char *_String1, const char *_String2, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static int _strncoll_l(MemorySegment _String1, MemorySegment _String2, long _MaxCount, MemorySegment _Locale) {
        var mh$ = _strncoll_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strncoll_l", _String1, _String2, _MaxCount, _Locale);
            }
            return (int)mh$.invokeExact(_String1, _String2, _MaxCount, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __strncnt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("__strncnt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t __strncnt(const char *_String, size_t _Count)
     * }
     */
    public static FunctionDescriptor __strncnt$descriptor() {
        return __strncnt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t __strncnt(const char *_String, size_t _Count)
     * }
     */
    public static MethodHandle __strncnt$handle() {
        return __strncnt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t __strncnt(const char *_String, size_t _Count)
     * }
     */
    public static MemorySegment __strncnt$address() {
        return __strncnt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t __strncnt(const char *_String, size_t _Count)
     * }
     */
    public static long __strncnt(MemorySegment _String, long _Count) {
        var mh$ = __strncnt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__strncnt", _String, _Count);
            }
            return (long)mh$.invokeExact(_String, _Count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strncpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("strncpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strncpy(char *_Destination, const char *_Source, size_t _Count)
     * }
     */
    public static FunctionDescriptor strncpy$descriptor() {
        return strncpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strncpy(char *_Destination, const char *_Source, size_t _Count)
     * }
     */
    public static MethodHandle strncpy$handle() {
        return strncpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strncpy(char *_Destination, const char *_Source, size_t _Count)
     * }
     */
    public static MemorySegment strncpy$address() {
        return strncpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strncpy(char *_Destination, const char *_Source, size_t _Count)
     * }
     */
    public static MemorySegment strncpy(MemorySegment _Destination, MemorySegment _Source, long _Count) {
        var mh$ = strncpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strncpy", _Destination, _Source, _Count);
            }
            return (MemorySegment)mh$.invokeExact(_Destination, _Source, _Count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strnlen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("strnlen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t strnlen(const char *_String, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor strnlen$descriptor() {
        return strnlen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t strnlen(const char *_String, size_t _MaxCount)
     * }
     */
    public static MethodHandle strnlen$handle() {
        return strnlen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t strnlen(const char *_String, size_t _MaxCount)
     * }
     */
    public static MemorySegment strnlen$address() {
        return strnlen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t strnlen(const char *_String, size_t _MaxCount)
     * }
     */
    public static long strnlen(MemorySegment _String, long _MaxCount) {
        var mh$ = strnlen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strnlen", _String, _MaxCount);
            }
            return (long)mh$.invokeExact(_String, _MaxCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strnset_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_INT,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_strnset_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _strnset_s(char *_String, size_t _SizeInBytes, int _Value, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor _strnset_s$descriptor() {
        return _strnset_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _strnset_s(char *_String, size_t _SizeInBytes, int _Value, size_t _MaxCount)
     * }
     */
    public static MethodHandle _strnset_s$handle() {
        return _strnset_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _strnset_s(char *_String, size_t _SizeInBytes, int _Value, size_t _MaxCount)
     * }
     */
    public static MemorySegment _strnset_s$address() {
        return _strnset_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _strnset_s(char *_String, size_t _SizeInBytes, int _Value, size_t _MaxCount)
     * }
     */
    public static int _strnset_s(MemorySegment _String, long _SizeInBytes, int _Value, long _MaxCount) {
        var mh$ = _strnset_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strnset_s", _String, _SizeInBytes, _Value, _MaxCount);
            }
            return (int)mh$.invokeExact(_String, _SizeInBytes, _Value, _MaxCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strnset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_strnset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *_strnset(char *_Destination, int _Value, size_t _Count)
     * }
     */
    public static FunctionDescriptor _strnset$descriptor() {
        return _strnset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *_strnset(char *_Destination, int _Value, size_t _Count)
     * }
     */
    public static MethodHandle _strnset$handle() {
        return _strnset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *_strnset(char *_Destination, int _Value, size_t _Count)
     * }
     */
    public static MemorySegment _strnset$address() {
        return _strnset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *_strnset(char *_Destination, int _Value, size_t _Count)
     * }
     */
    public static MemorySegment _strnset(MemorySegment _Destination, int _Value, long _Count) {
        var mh$ = _strnset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strnset", _Destination, _Value, _Count);
            }
            return (MemorySegment)mh$.invokeExact(_Destination, _Value, _Count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strpbrk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("strpbrk");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strpbrk(const char *_Str, const char *_Control)
     * }
     */
    public static FunctionDescriptor strpbrk$descriptor() {
        return strpbrk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strpbrk(const char *_Str, const char *_Control)
     * }
     */
    public static MethodHandle strpbrk$handle() {
        return strpbrk.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strpbrk(const char *_Str, const char *_Control)
     * }
     */
    public static MemorySegment strpbrk$address() {
        return strpbrk.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strpbrk(const char *_Str, const char *_Control)
     * }
     */
    public static MemorySegment strpbrk(MemorySegment _Str, MemorySegment _Control) {
        var mh$ = strpbrk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strpbrk", _Str, _Control);
            }
            return (MemorySegment)mh$.invokeExact(_Str, _Control);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strrev {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_strrev");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *_strrev(char *_Str)
     * }
     */
    public static FunctionDescriptor _strrev$descriptor() {
        return _strrev.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *_strrev(char *_Str)
     * }
     */
    public static MethodHandle _strrev$handle() {
        return _strrev.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *_strrev(char *_Str)
     * }
     */
    public static MemorySegment _strrev$address() {
        return _strrev.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *_strrev(char *_Str)
     * }
     */
    public static MemorySegment _strrev(MemorySegment _Str) {
        var mh$ = _strrev.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strrev", _Str);
            }
            return (MemorySegment)mh$.invokeExact(_Str);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strset_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_strset_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _strset_s(char *_Destination, size_t _DestinationSize, int _Value)
     * }
     */
    public static FunctionDescriptor _strset_s$descriptor() {
        return _strset_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _strset_s(char *_Destination, size_t _DestinationSize, int _Value)
     * }
     */
    public static MethodHandle _strset_s$handle() {
        return _strset_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _strset_s(char *_Destination, size_t _DestinationSize, int _Value)
     * }
     */
    public static MemorySegment _strset_s$address() {
        return _strset_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _strset_s(char *_Destination, size_t _DestinationSize, int _Value)
     * }
     */
    public static int _strset_s(MemorySegment _Destination, long _DestinationSize, int _Value) {
        var mh$ = _strset_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strset_s", _Destination, _DestinationSize, _Value);
            }
            return (int)mh$.invokeExact(_Destination, _DestinationSize, _Value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_strset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *_strset(char *_Destination, int _Value)
     * }
     */
    public static FunctionDescriptor _strset$descriptor() {
        return _strset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *_strset(char *_Destination, int _Value)
     * }
     */
    public static MethodHandle _strset$handle() {
        return _strset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *_strset(char *_Destination, int _Value)
     * }
     */
    public static MemorySegment _strset$address() {
        return _strset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *_strset(char *_Destination, int _Value)
     * }
     */
    public static MemorySegment _strset(MemorySegment _Destination, int _Value) {
        var mh$ = _strset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strset", _Destination, _Value);
            }
            return (MemorySegment)mh$.invokeExact(_Destination, _Value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strspn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("strspn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long long strspn(const char *_Str, const char *_Control)
     * }
     */
    public static FunctionDescriptor strspn$descriptor() {
        return strspn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long long strspn(const char *_Str, const char *_Control)
     * }
     */
    public static MethodHandle strspn$handle() {
        return strspn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long long strspn(const char *_Str, const char *_Control)
     * }
     */
    public static MemorySegment strspn$address() {
        return strspn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long long strspn(const char *_Str, const char *_Control)
     * }
     */
    public static long strspn(MemorySegment _Str, MemorySegment _Control) {
        var mh$ = strspn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strspn", _Str, _Control);
            }
            return (long)mh$.invokeExact(_Str, _Control);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtok {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("strtok");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strtok(char *_String, const char *_Delimiter)
     * }
     */
    public static FunctionDescriptor strtok$descriptor() {
        return strtok.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strtok(char *_String, const char *_Delimiter)
     * }
     */
    public static MethodHandle strtok$handle() {
        return strtok.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strtok(char *_String, const char *_Delimiter)
     * }
     */
    public static MemorySegment strtok$address() {
        return strtok.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strtok(char *_String, const char *_Delimiter)
     * }
     */
    public static MemorySegment strtok(MemorySegment _String, MemorySegment _Delimiter) {
        var mh$ = strtok.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtok", _String, _Delimiter);
            }
            return (MemorySegment)mh$.invokeExact(_String, _Delimiter);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strupr_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_strupr_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _strupr_s(char *_String, size_t _Size)
     * }
     */
    public static FunctionDescriptor _strupr_s$descriptor() {
        return _strupr_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _strupr_s(char *_String, size_t _Size)
     * }
     */
    public static MethodHandle _strupr_s$handle() {
        return _strupr_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _strupr_s(char *_String, size_t _Size)
     * }
     */
    public static MemorySegment _strupr_s$address() {
        return _strupr_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _strupr_s(char *_String, size_t _Size)
     * }
     */
    public static int _strupr_s(MemorySegment _String, long _Size) {
        var mh$ = _strupr_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strupr_s", _String, _Size);
            }
            return (int)mh$.invokeExact(_String, _Size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strupr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_strupr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *_strupr(char *_String)
     * }
     */
    public static FunctionDescriptor _strupr$descriptor() {
        return _strupr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *_strupr(char *_String)
     * }
     */
    public static MethodHandle _strupr$handle() {
        return _strupr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *_strupr(char *_String)
     * }
     */
    public static MemorySegment _strupr$address() {
        return _strupr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *_strupr(char *_String)
     * }
     */
    public static MemorySegment _strupr(MemorySegment _String) {
        var mh$ = _strupr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strupr", _String);
            }
            return (MemorySegment)mh$.invokeExact(_String);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strupr_s_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_strupr_s_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _strupr_s_l(char *_String, size_t _Size, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _strupr_s_l$descriptor() {
        return _strupr_s_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _strupr_s_l(char *_String, size_t _Size, _locale_t _Locale)
     * }
     */
    public static MethodHandle _strupr_s_l$handle() {
        return _strupr_s_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _strupr_s_l(char *_String, size_t _Size, _locale_t _Locale)
     * }
     */
    public static MemorySegment _strupr_s_l$address() {
        return _strupr_s_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _strupr_s_l(char *_String, size_t _Size, _locale_t _Locale)
     * }
     */
    public static int _strupr_s_l(MemorySegment _String, long _Size, MemorySegment _Locale) {
        var mh$ = _strupr_s_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strupr_s_l", _String, _Size, _Locale);
            }
            return (int)mh$.invokeExact(_String, _Size, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strupr_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_strupr_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *_strupr_l(char *_String, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _strupr_l$descriptor() {
        return _strupr_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *_strupr_l(char *_String, _locale_t _Locale)
     * }
     */
    public static MethodHandle _strupr_l$handle() {
        return _strupr_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *_strupr_l(char *_String, _locale_t _Locale)
     * }
     */
    public static MemorySegment _strupr_l$address() {
        return _strupr_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *_strupr_l(char *_String, _locale_t _Locale)
     * }
     */
    public static MemorySegment _strupr_l(MemorySegment _String, MemorySegment _Locale) {
        var mh$ = _strupr_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strupr_l", _String, _Locale);
            }
            return (MemorySegment)mh$.invokeExact(_String, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strxfrm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("strxfrm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long long strxfrm(char *_Destination, const char *_Source, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor strxfrm$descriptor() {
        return strxfrm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long long strxfrm(char *_Destination, const char *_Source, size_t _MaxCount)
     * }
     */
    public static MethodHandle strxfrm$handle() {
        return strxfrm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long long strxfrm(char *_Destination, const char *_Source, size_t _MaxCount)
     * }
     */
    public static MemorySegment strxfrm$address() {
        return strxfrm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long long strxfrm(char *_Destination, const char *_Source, size_t _MaxCount)
     * }
     */
    public static long strxfrm(MemorySegment _Destination, MemorySegment _Source, long _MaxCount) {
        var mh$ = strxfrm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strxfrm", _Destination, _Source, _MaxCount);
            }
            return (long)mh$.invokeExact(_Destination, _Source, _MaxCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strxfrm_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_strxfrm_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t _strxfrm_l(char *_Destination, const char *_Source, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _strxfrm_l$descriptor() {
        return _strxfrm_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t _strxfrm_l(char *_Destination, const char *_Source, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MethodHandle _strxfrm_l$handle() {
        return _strxfrm_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t _strxfrm_l(char *_Destination, const char *_Source, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MemorySegment _strxfrm_l$address() {
        return _strxfrm_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t _strxfrm_l(char *_Destination, const char *_Source, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static long _strxfrm_l(MemorySegment _Destination, MemorySegment _Source, long _MaxCount, MemorySegment _Locale) {
        var mh$ = _strxfrm_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strxfrm_l", _Destination, _Source, _MaxCount, _Locale);
            }
            return (long)mh$.invokeExact(_Destination, _Source, _MaxCount, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strdup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("strdup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strdup(const char *_String)
     * }
     */
    public static FunctionDescriptor strdup$descriptor() {
        return strdup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strdup(const char *_String)
     * }
     */
    public static MethodHandle strdup$handle() {
        return strdup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strdup(const char *_String)
     * }
     */
    public static MemorySegment strdup$address() {
        return strdup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strdup(const char *_String)
     * }
     */
    public static MemorySegment strdup(MemorySegment _String) {
        var mh$ = strdup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strdup", _String);
            }
            return (MemorySegment)mh$.invokeExact(_String);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcmpi {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("strcmpi");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int strcmpi(const char *_String1, const char *_String2)
     * }
     */
    public static FunctionDescriptor strcmpi$descriptor() {
        return strcmpi.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int strcmpi(const char *_String1, const char *_String2)
     * }
     */
    public static MethodHandle strcmpi$handle() {
        return strcmpi.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int strcmpi(const char *_String1, const char *_String2)
     * }
     */
    public static MemorySegment strcmpi$address() {
        return strcmpi.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int strcmpi(const char *_String1, const char *_String2)
     * }
     */
    public static int strcmpi(MemorySegment _String1, MemorySegment _String2) {
        var mh$ = strcmpi.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcmpi", _String1, _String2);
            }
            return (int)mh$.invokeExact(_String1, _String2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class stricmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("stricmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int stricmp(const char *_String1, const char *_String2)
     * }
     */
    public static FunctionDescriptor stricmp$descriptor() {
        return stricmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int stricmp(const char *_String1, const char *_String2)
     * }
     */
    public static MethodHandle stricmp$handle() {
        return stricmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int stricmp(const char *_String1, const char *_String2)
     * }
     */
    public static MemorySegment stricmp$address() {
        return stricmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int stricmp(const char *_String1, const char *_String2)
     * }
     */
    public static int stricmp(MemorySegment _String1, MemorySegment _String2) {
        var mh$ = stricmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("stricmp", _String1, _String2);
            }
            return (int)mh$.invokeExact(_String1, _String2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strlwr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("strlwr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strlwr(char *_String)
     * }
     */
    public static FunctionDescriptor strlwr$descriptor() {
        return strlwr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strlwr(char *_String)
     * }
     */
    public static MethodHandle strlwr$handle() {
        return strlwr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strlwr(char *_String)
     * }
     */
    public static MemorySegment strlwr$address() {
        return strlwr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strlwr(char *_String)
     * }
     */
    public static MemorySegment strlwr(MemorySegment _String) {
        var mh$ = strlwr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strlwr", _String);
            }
            return (MemorySegment)mh$.invokeExact(_String);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strnicmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("strnicmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int strnicmp(const char *_String1, const char *_String2, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor strnicmp$descriptor() {
        return strnicmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int strnicmp(const char *_String1, const char *_String2, size_t _MaxCount)
     * }
     */
    public static MethodHandle strnicmp$handle() {
        return strnicmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int strnicmp(const char *_String1, const char *_String2, size_t _MaxCount)
     * }
     */
    public static MemorySegment strnicmp$address() {
        return strnicmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int strnicmp(const char *_String1, const char *_String2, size_t _MaxCount)
     * }
     */
    public static int strnicmp(MemorySegment _String1, MemorySegment _String2, long _MaxCount) {
        var mh$ = strnicmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strnicmp", _String1, _String2, _MaxCount);
            }
            return (int)mh$.invokeExact(_String1, _String2, _MaxCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strnset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("strnset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strnset(char *_String, int _Value, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor strnset$descriptor() {
        return strnset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strnset(char *_String, int _Value, size_t _MaxCount)
     * }
     */
    public static MethodHandle strnset$handle() {
        return strnset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strnset(char *_String, int _Value, size_t _MaxCount)
     * }
     */
    public static MemorySegment strnset$address() {
        return strnset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strnset(char *_String, int _Value, size_t _MaxCount)
     * }
     */
    public static MemorySegment strnset(MemorySegment _String, int _Value, long _MaxCount) {
        var mh$ = strnset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strnset", _String, _Value, _MaxCount);
            }
            return (MemorySegment)mh$.invokeExact(_String, _Value, _MaxCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strrev {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("strrev");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strrev(char *_String)
     * }
     */
    public static FunctionDescriptor strrev$descriptor() {
        return strrev.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strrev(char *_String)
     * }
     */
    public static MethodHandle strrev$handle() {
        return strrev.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strrev(char *_String)
     * }
     */
    public static MemorySegment strrev$address() {
        return strrev.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strrev(char *_String)
     * }
     */
    public static MemorySegment strrev(MemorySegment _String) {
        var mh$ = strrev.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strrev", _String);
            }
            return (MemorySegment)mh$.invokeExact(_String);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("strset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strset(char *_String, int _Value)
     * }
     */
    public static FunctionDescriptor strset$descriptor() {
        return strset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strset(char *_String, int _Value)
     * }
     */
    public static MethodHandle strset$handle() {
        return strset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strset(char *_String, int _Value)
     * }
     */
    public static MemorySegment strset$address() {
        return strset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strset(char *_String, int _Value)
     * }
     */
    public static MemorySegment strset(MemorySegment _String, int _Value) {
        var mh$ = strset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strset", _String, _Value);
            }
            return (MemorySegment)mh$.invokeExact(_String, _Value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strupr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("strupr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strupr(char *_String)
     * }
     */
    public static FunctionDescriptor strupr$descriptor() {
        return strupr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strupr(char *_String)
     * }
     */
    public static MethodHandle strupr$handle() {
        return strupr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strupr(char *_String)
     * }
     */
    public static MemorySegment strupr$address() {
        return strupr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strupr(char *_String)
     * }
     */
    public static MemorySegment strupr(MemorySegment _String) {
        var mh$ = strupr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strupr", _String);
            }
            return (MemorySegment)mh$.invokeExact(_String);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wassert {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wassert");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _wassert(const wchar_t *_Message, const wchar_t *_File, unsigned int _Line)
     * }
     */
    public static FunctionDescriptor _wassert$descriptor() {
        return _wassert.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _wassert(const wchar_t *_Message, const wchar_t *_File, unsigned int _Line)
     * }
     */
    public static MethodHandle _wassert$handle() {
        return _wassert.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _wassert(const wchar_t *_Message, const wchar_t *_File, unsigned int _Line)
     * }
     */
    public static MemorySegment _wassert$address() {
        return _wassert.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _wassert(const wchar_t *_Message, const wchar_t *_File, unsigned int _Line)
     * }
     */
    public static void _wassert(MemorySegment _Message, MemorySegment _File, int _Line) {
        var mh$ = _wassert.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wassert", _Message, _File, _Line);
            }
            mh$.invokeExact(_Message, _File, _Line);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _cgetws_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_cgetws_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _cgetws_s(wchar_t *_Buffer, size_t _BufferCount, size_t *_SizeRead)
     * }
     */
    public static FunctionDescriptor _cgetws_s$descriptor() {
        return _cgetws_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _cgetws_s(wchar_t *_Buffer, size_t _BufferCount, size_t *_SizeRead)
     * }
     */
    public static MethodHandle _cgetws_s$handle() {
        return _cgetws_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _cgetws_s(wchar_t *_Buffer, size_t _BufferCount, size_t *_SizeRead)
     * }
     */
    public static MemorySegment _cgetws_s$address() {
        return _cgetws_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _cgetws_s(wchar_t *_Buffer, size_t _BufferCount, size_t *_SizeRead)
     * }
     */
    public static int _cgetws_s(MemorySegment _Buffer, long _BufferCount, MemorySegment _SizeRead) {
        var mh$ = _cgetws_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_cgetws_s", _Buffer, _BufferCount, _SizeRead);
            }
            return (int)mh$.invokeExact(_Buffer, _BufferCount, _SizeRead);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _cputws {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_cputws");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _cputws(const wchar_t *_Buffer)
     * }
     */
    public static FunctionDescriptor _cputws$descriptor() {
        return _cputws.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _cputws(const wchar_t *_Buffer)
     * }
     */
    public static MethodHandle _cputws$handle() {
        return _cputws.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _cputws(const wchar_t *_Buffer)
     * }
     */
    public static MemorySegment _cputws$address() {
        return _cputws.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _cputws(const wchar_t *_Buffer)
     * }
     */
    public static int _cputws(MemorySegment _Buffer) {
        var mh$ = _cputws.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_cputws", _Buffer);
            }
            return (int)mh$.invokeExact(_Buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _getwch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_SHORT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_getwch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wint_t _getwch()
     * }
     */
    public static FunctionDescriptor _getwch$descriptor() {
        return _getwch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wint_t _getwch()
     * }
     */
    public static MethodHandle _getwch$handle() {
        return _getwch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wint_t _getwch()
     * }
     */
    public static MemorySegment _getwch$address() {
        return _getwch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wint_t _getwch()
     * }
     */
    public static short _getwch() {
        var mh$ = _getwch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_getwch");
            }
            return (short)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _getwche {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_SHORT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_getwche");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wint_t _getwche()
     * }
     */
    public static FunctionDescriptor _getwche$descriptor() {
        return _getwche.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wint_t _getwche()
     * }
     */
    public static MethodHandle _getwche$handle() {
        return _getwche.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wint_t _getwche()
     * }
     */
    public static MemorySegment _getwche$address() {
        return _getwche.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wint_t _getwche()
     * }
     */
    public static short _getwche() {
        var mh$ = _getwche.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_getwche");
            }
            return (short)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _putwch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_SHORT,
            Python_h.C_SHORT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_putwch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wint_t _putwch(wchar_t _Character)
     * }
     */
    public static FunctionDescriptor _putwch$descriptor() {
        return _putwch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wint_t _putwch(wchar_t _Character)
     * }
     */
    public static MethodHandle _putwch$handle() {
        return _putwch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wint_t _putwch(wchar_t _Character)
     * }
     */
    public static MemorySegment _putwch$address() {
        return _putwch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wint_t _putwch(wchar_t _Character)
     * }
     */
    public static short _putwch(short _Character) {
        var mh$ = _putwch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_putwch", _Character);
            }
            return (short)mh$.invokeExact(_Character);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ungetwch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_SHORT,
            Python_h.C_SHORT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_ungetwch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wint_t _ungetwch(wint_t _Character)
     * }
     */
    public static FunctionDescriptor _ungetwch$descriptor() {
        return _ungetwch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wint_t _ungetwch(wint_t _Character)
     * }
     */
    public static MethodHandle _ungetwch$handle() {
        return _ungetwch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wint_t _ungetwch(wint_t _Character)
     * }
     */
    public static MemorySegment _ungetwch$address() {
        return _ungetwch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wint_t _ungetwch(wint_t _Character)
     * }
     */
    public static short _ungetwch(short _Character) {
        var mh$ = _ungetwch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ungetwch", _Character);
            }
            return (short)mh$.invokeExact(_Character);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _getwch_nolock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_SHORT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_getwch_nolock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wint_t _getwch_nolock()
     * }
     */
    public static FunctionDescriptor _getwch_nolock$descriptor() {
        return _getwch_nolock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wint_t _getwch_nolock()
     * }
     */
    public static MethodHandle _getwch_nolock$handle() {
        return _getwch_nolock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wint_t _getwch_nolock()
     * }
     */
    public static MemorySegment _getwch_nolock$address() {
        return _getwch_nolock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wint_t _getwch_nolock()
     * }
     */
    public static short _getwch_nolock() {
        var mh$ = _getwch_nolock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_getwch_nolock");
            }
            return (short)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _getwche_nolock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_SHORT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_getwche_nolock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wint_t _getwche_nolock()
     * }
     */
    public static FunctionDescriptor _getwche_nolock$descriptor() {
        return _getwche_nolock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wint_t _getwche_nolock()
     * }
     */
    public static MethodHandle _getwche_nolock$handle() {
        return _getwche_nolock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wint_t _getwche_nolock()
     * }
     */
    public static MemorySegment _getwche_nolock$address() {
        return _getwche_nolock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wint_t _getwche_nolock()
     * }
     */
    public static short _getwche_nolock() {
        var mh$ = _getwche_nolock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_getwche_nolock");
            }
            return (short)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _putwch_nolock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_SHORT,
            Python_h.C_SHORT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_putwch_nolock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wint_t _putwch_nolock(wchar_t _Character)
     * }
     */
    public static FunctionDescriptor _putwch_nolock$descriptor() {
        return _putwch_nolock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wint_t _putwch_nolock(wchar_t _Character)
     * }
     */
    public static MethodHandle _putwch_nolock$handle() {
        return _putwch_nolock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wint_t _putwch_nolock(wchar_t _Character)
     * }
     */
    public static MemorySegment _putwch_nolock$address() {
        return _putwch_nolock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wint_t _putwch_nolock(wchar_t _Character)
     * }
     */
    public static short _putwch_nolock(short _Character) {
        var mh$ = _putwch_nolock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_putwch_nolock", _Character);
            }
            return (short)mh$.invokeExact(_Character);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ungetwch_nolock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_SHORT,
            Python_h.C_SHORT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_ungetwch_nolock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wint_t _ungetwch_nolock(wint_t _Character)
     * }
     */
    public static FunctionDescriptor _ungetwch_nolock$descriptor() {
        return _ungetwch_nolock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wint_t _ungetwch_nolock(wint_t _Character)
     * }
     */
    public static MethodHandle _ungetwch_nolock$handle() {
        return _ungetwch_nolock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wint_t _ungetwch_nolock(wint_t _Character)
     * }
     */
    public static MemorySegment _ungetwch_nolock$address() {
        return _ungetwch_nolock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wint_t _ungetwch_nolock(wint_t _Character)
     * }
     */
    public static short _ungetwch_nolock(short _Character) {
        var mh$ = _ungetwch_nolock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ungetwch_nolock", _Character);
            }
            return (short)mh$.invokeExact(_Character);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __conio_common_vcwprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("__conio_common_vcwprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __conio_common_vcwprintf(unsigned long long _Options, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static FunctionDescriptor __conio_common_vcwprintf$descriptor() {
        return __conio_common_vcwprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __conio_common_vcwprintf(unsigned long long _Options, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MethodHandle __conio_common_vcwprintf$handle() {
        return __conio_common_vcwprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __conio_common_vcwprintf(unsigned long long _Options, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MemorySegment __conio_common_vcwprintf$address() {
        return __conio_common_vcwprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __conio_common_vcwprintf(unsigned long long _Options, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static int __conio_common_vcwprintf(long _Options, MemorySegment _Format, MemorySegment _Locale, MemorySegment _ArgList) {
        var mh$ = __conio_common_vcwprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__conio_common_vcwprintf", _Options, _Format, _Locale, _ArgList);
            }
            return (int)mh$.invokeExact(_Options, _Format, _Locale, _ArgList);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __conio_common_vcwprintf_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("__conio_common_vcwprintf_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __conio_common_vcwprintf_s(unsigned long long _Options, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static FunctionDescriptor __conio_common_vcwprintf_s$descriptor() {
        return __conio_common_vcwprintf_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __conio_common_vcwprintf_s(unsigned long long _Options, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MethodHandle __conio_common_vcwprintf_s$handle() {
        return __conio_common_vcwprintf_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __conio_common_vcwprintf_s(unsigned long long _Options, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MemorySegment __conio_common_vcwprintf_s$address() {
        return __conio_common_vcwprintf_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __conio_common_vcwprintf_s(unsigned long long _Options, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static int __conio_common_vcwprintf_s(long _Options, MemorySegment _Format, MemorySegment _Locale, MemorySegment _ArgList) {
        var mh$ = __conio_common_vcwprintf_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__conio_common_vcwprintf_s", _Options, _Format, _Locale, _ArgList);
            }
            return (int)mh$.invokeExact(_Options, _Format, _Locale, _ArgList);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __conio_common_vcwprintf_p {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("__conio_common_vcwprintf_p");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __conio_common_vcwprintf_p(unsigned long long _Options, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static FunctionDescriptor __conio_common_vcwprintf_p$descriptor() {
        return __conio_common_vcwprintf_p.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __conio_common_vcwprintf_p(unsigned long long _Options, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MethodHandle __conio_common_vcwprintf_p$handle() {
        return __conio_common_vcwprintf_p.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __conio_common_vcwprintf_p(unsigned long long _Options, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MemorySegment __conio_common_vcwprintf_p$address() {
        return __conio_common_vcwprintf_p.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __conio_common_vcwprintf_p(unsigned long long _Options, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static int __conio_common_vcwprintf_p(long _Options, MemorySegment _Format, MemorySegment _Locale, MemorySegment _ArgList) {
        var mh$ = __conio_common_vcwprintf_p.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__conio_common_vcwprintf_p", _Options, _Format, _Locale, _ArgList);
            }
            return (int)mh$.invokeExact(_Options, _Format, _Locale, _ArgList);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __conio_common_vcwscanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("__conio_common_vcwscanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __conio_common_vcwscanf(unsigned long long _Options, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static FunctionDescriptor __conio_common_vcwscanf$descriptor() {
        return __conio_common_vcwscanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __conio_common_vcwscanf(unsigned long long _Options, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MethodHandle __conio_common_vcwscanf$handle() {
        return __conio_common_vcwscanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __conio_common_vcwscanf(unsigned long long _Options, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MemorySegment __conio_common_vcwscanf$address() {
        return __conio_common_vcwscanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __conio_common_vcwscanf(unsigned long long _Options, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static int __conio_common_vcwscanf(long _Options, MemorySegment _Format, MemorySegment _Locale, MemorySegment _ArgList) {
        var mh$ = __conio_common_vcwscanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__conio_common_vcwscanf", _Options, _Format, _Locale, _ArgList);
            }
            return (int)mh$.invokeExact(_Options, _Format, _Locale, _ArgList);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __pctype_func {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("__pctype_func");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const unsigned short *__pctype_func()
     * }
     */
    public static FunctionDescriptor __pctype_func$descriptor() {
        return __pctype_func.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const unsigned short *__pctype_func()
     * }
     */
    public static MethodHandle __pctype_func$handle() {
        return __pctype_func.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const unsigned short *__pctype_func()
     * }
     */
    public static MemorySegment __pctype_func$address() {
        return __pctype_func.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const unsigned short *__pctype_func()
     * }
     */
    public static MemorySegment __pctype_func() {
        var mh$ = __pctype_func.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__pctype_func");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __pwctype_func {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("__pwctype_func");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const wctype_t *__pwctype_func()
     * }
     */
    public static FunctionDescriptor __pwctype_func$descriptor() {
        return __pwctype_func.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const wctype_t *__pwctype_func()
     * }
     */
    public static MethodHandle __pwctype_func$handle() {
        return __pwctype_func.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const wctype_t *__pwctype_func()
     * }
     */
    public static MemorySegment __pwctype_func$address() {
        return __pwctype_func.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const wctype_t *__pwctype_func()
     * }
     */
    public static MemorySegment __pwctype_func() {
        var mh$ = __pwctype_func.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__pwctype_func");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class iswalnum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_SHORT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("iswalnum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int iswalnum(wint_t _C)
     * }
     */
    public static FunctionDescriptor iswalnum$descriptor() {
        return iswalnum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int iswalnum(wint_t _C)
     * }
     */
    public static MethodHandle iswalnum$handle() {
        return iswalnum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int iswalnum(wint_t _C)
     * }
     */
    public static MemorySegment iswalnum$address() {
        return iswalnum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int iswalnum(wint_t _C)
     * }
     */
    public static int iswalnum(short _C) {
        var mh$ = iswalnum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("iswalnum", _C);
            }
            return (int)mh$.invokeExact(_C);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class iswalpha {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_SHORT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("iswalpha");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int iswalpha(wint_t _C)
     * }
     */
    public static FunctionDescriptor iswalpha$descriptor() {
        return iswalpha.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int iswalpha(wint_t _C)
     * }
     */
    public static MethodHandle iswalpha$handle() {
        return iswalpha.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int iswalpha(wint_t _C)
     * }
     */
    public static MemorySegment iswalpha$address() {
        return iswalpha.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int iswalpha(wint_t _C)
     * }
     */
    public static int iswalpha(short _C) {
        var mh$ = iswalpha.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("iswalpha", _C);
            }
            return (int)mh$.invokeExact(_C);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class iswascii {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_SHORT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("iswascii");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int iswascii(wint_t _C)
     * }
     */
    public static FunctionDescriptor iswascii$descriptor() {
        return iswascii.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int iswascii(wint_t _C)
     * }
     */
    public static MethodHandle iswascii$handle() {
        return iswascii.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int iswascii(wint_t _C)
     * }
     */
    public static MemorySegment iswascii$address() {
        return iswascii.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int iswascii(wint_t _C)
     * }
     */
    public static int iswascii(short _C) {
        var mh$ = iswascii.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("iswascii", _C);
            }
            return (int)mh$.invokeExact(_C);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class iswblank {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_SHORT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("iswblank");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int iswblank(wint_t _C)
     * }
     */
    public static FunctionDescriptor iswblank$descriptor() {
        return iswblank.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int iswblank(wint_t _C)
     * }
     */
    public static MethodHandle iswblank$handle() {
        return iswblank.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int iswblank(wint_t _C)
     * }
     */
    public static MemorySegment iswblank$address() {
        return iswblank.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int iswblank(wint_t _C)
     * }
     */
    public static int iswblank(short _C) {
        var mh$ = iswblank.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("iswblank", _C);
            }
            return (int)mh$.invokeExact(_C);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class iswcntrl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_SHORT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("iswcntrl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int iswcntrl(wint_t _C)
     * }
     */
    public static FunctionDescriptor iswcntrl$descriptor() {
        return iswcntrl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int iswcntrl(wint_t _C)
     * }
     */
    public static MethodHandle iswcntrl$handle() {
        return iswcntrl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int iswcntrl(wint_t _C)
     * }
     */
    public static MemorySegment iswcntrl$address() {
        return iswcntrl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int iswcntrl(wint_t _C)
     * }
     */
    public static int iswcntrl(short _C) {
        var mh$ = iswcntrl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("iswcntrl", _C);
            }
            return (int)mh$.invokeExact(_C);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class iswdigit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_SHORT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("iswdigit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int iswdigit(wint_t _C)
     * }
     */
    public static FunctionDescriptor iswdigit$descriptor() {
        return iswdigit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int iswdigit(wint_t _C)
     * }
     */
    public static MethodHandle iswdigit$handle() {
        return iswdigit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int iswdigit(wint_t _C)
     * }
     */
    public static MemorySegment iswdigit$address() {
        return iswdigit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int iswdigit(wint_t _C)
     * }
     */
    public static int iswdigit(short _C) {
        var mh$ = iswdigit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("iswdigit", _C);
            }
            return (int)mh$.invokeExact(_C);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class iswgraph {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_SHORT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("iswgraph");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int iswgraph(wint_t _C)
     * }
     */
    public static FunctionDescriptor iswgraph$descriptor() {
        return iswgraph.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int iswgraph(wint_t _C)
     * }
     */
    public static MethodHandle iswgraph$handle() {
        return iswgraph.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int iswgraph(wint_t _C)
     * }
     */
    public static MemorySegment iswgraph$address() {
        return iswgraph.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int iswgraph(wint_t _C)
     * }
     */
    public static int iswgraph(short _C) {
        var mh$ = iswgraph.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("iswgraph", _C);
            }
            return (int)mh$.invokeExact(_C);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class iswlower {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_SHORT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("iswlower");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int iswlower(wint_t _C)
     * }
     */
    public static FunctionDescriptor iswlower$descriptor() {
        return iswlower.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int iswlower(wint_t _C)
     * }
     */
    public static MethodHandle iswlower$handle() {
        return iswlower.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int iswlower(wint_t _C)
     * }
     */
    public static MemorySegment iswlower$address() {
        return iswlower.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int iswlower(wint_t _C)
     * }
     */
    public static int iswlower(short _C) {
        var mh$ = iswlower.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("iswlower", _C);
            }
            return (int)mh$.invokeExact(_C);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class iswprint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_SHORT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("iswprint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int iswprint(wint_t _C)
     * }
     */
    public static FunctionDescriptor iswprint$descriptor() {
        return iswprint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int iswprint(wint_t _C)
     * }
     */
    public static MethodHandle iswprint$handle() {
        return iswprint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int iswprint(wint_t _C)
     * }
     */
    public static MemorySegment iswprint$address() {
        return iswprint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int iswprint(wint_t _C)
     * }
     */
    public static int iswprint(short _C) {
        var mh$ = iswprint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("iswprint", _C);
            }
            return (int)mh$.invokeExact(_C);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class iswpunct {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_SHORT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("iswpunct");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int iswpunct(wint_t _C)
     * }
     */
    public static FunctionDescriptor iswpunct$descriptor() {
        return iswpunct.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int iswpunct(wint_t _C)
     * }
     */
    public static MethodHandle iswpunct$handle() {
        return iswpunct.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int iswpunct(wint_t _C)
     * }
     */
    public static MemorySegment iswpunct$address() {
        return iswpunct.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int iswpunct(wint_t _C)
     * }
     */
    public static int iswpunct(short _C) {
        var mh$ = iswpunct.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("iswpunct", _C);
            }
            return (int)mh$.invokeExact(_C);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class iswspace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_SHORT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("iswspace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int iswspace(wint_t _C)
     * }
     */
    public static FunctionDescriptor iswspace$descriptor() {
        return iswspace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int iswspace(wint_t _C)
     * }
     */
    public static MethodHandle iswspace$handle() {
        return iswspace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int iswspace(wint_t _C)
     * }
     */
    public static MemorySegment iswspace$address() {
        return iswspace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int iswspace(wint_t _C)
     * }
     */
    public static int iswspace(short _C) {
        var mh$ = iswspace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("iswspace", _C);
            }
            return (int)mh$.invokeExact(_C);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class iswupper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_SHORT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("iswupper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int iswupper(wint_t _C)
     * }
     */
    public static FunctionDescriptor iswupper$descriptor() {
        return iswupper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int iswupper(wint_t _C)
     * }
     */
    public static MethodHandle iswupper$handle() {
        return iswupper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int iswupper(wint_t _C)
     * }
     */
    public static MemorySegment iswupper$address() {
        return iswupper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int iswupper(wint_t _C)
     * }
     */
    public static int iswupper(short _C) {
        var mh$ = iswupper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("iswupper", _C);
            }
            return (int)mh$.invokeExact(_C);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class iswxdigit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_SHORT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("iswxdigit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int iswxdigit(wint_t _C)
     * }
     */
    public static FunctionDescriptor iswxdigit$descriptor() {
        return iswxdigit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int iswxdigit(wint_t _C)
     * }
     */
    public static MethodHandle iswxdigit$handle() {
        return iswxdigit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int iswxdigit(wint_t _C)
     * }
     */
    public static MemorySegment iswxdigit$address() {
        return iswxdigit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int iswxdigit(wint_t _C)
     * }
     */
    public static int iswxdigit(short _C) {
        var mh$ = iswxdigit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("iswxdigit", _C);
            }
            return (int)mh$.invokeExact(_C);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __iswcsymf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_SHORT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("__iswcsymf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __iswcsymf(wint_t _C)
     * }
     */
    public static FunctionDescriptor __iswcsymf$descriptor() {
        return __iswcsymf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __iswcsymf(wint_t _C)
     * }
     */
    public static MethodHandle __iswcsymf$handle() {
        return __iswcsymf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __iswcsymf(wint_t _C)
     * }
     */
    public static MemorySegment __iswcsymf$address() {
        return __iswcsymf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __iswcsymf(wint_t _C)
     * }
     */
    public static int __iswcsymf(short _C) {
        var mh$ = __iswcsymf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__iswcsymf", _C);
            }
            return (int)mh$.invokeExact(_C);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __iswcsym {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_SHORT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("__iswcsym");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __iswcsym(wint_t _C)
     * }
     */
    public static FunctionDescriptor __iswcsym$descriptor() {
        return __iswcsym.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __iswcsym(wint_t _C)
     * }
     */
    public static MethodHandle __iswcsym$handle() {
        return __iswcsym.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __iswcsym(wint_t _C)
     * }
     */
    public static MemorySegment __iswcsym$address() {
        return __iswcsym.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __iswcsym(wint_t _C)
     * }
     */
    public static int __iswcsym(short _C) {
        var mh$ = __iswcsym.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__iswcsym", _C);
            }
            return (int)mh$.invokeExact(_C);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _iswalnum_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_SHORT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_iswalnum_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _iswalnum_l(wint_t _C, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _iswalnum_l$descriptor() {
        return _iswalnum_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _iswalnum_l(wint_t _C, _locale_t _Locale)
     * }
     */
    public static MethodHandle _iswalnum_l$handle() {
        return _iswalnum_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _iswalnum_l(wint_t _C, _locale_t _Locale)
     * }
     */
    public static MemorySegment _iswalnum_l$address() {
        return _iswalnum_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _iswalnum_l(wint_t _C, _locale_t _Locale)
     * }
     */
    public static int _iswalnum_l(short _C, MemorySegment _Locale) {
        var mh$ = _iswalnum_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_iswalnum_l", _C, _Locale);
            }
            return (int)mh$.invokeExact(_C, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _iswalpha_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_SHORT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_iswalpha_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _iswalpha_l(wint_t _C, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _iswalpha_l$descriptor() {
        return _iswalpha_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _iswalpha_l(wint_t _C, _locale_t _Locale)
     * }
     */
    public static MethodHandle _iswalpha_l$handle() {
        return _iswalpha_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _iswalpha_l(wint_t _C, _locale_t _Locale)
     * }
     */
    public static MemorySegment _iswalpha_l$address() {
        return _iswalpha_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _iswalpha_l(wint_t _C, _locale_t _Locale)
     * }
     */
    public static int _iswalpha_l(short _C, MemorySegment _Locale) {
        var mh$ = _iswalpha_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_iswalpha_l", _C, _Locale);
            }
            return (int)mh$.invokeExact(_C, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _iswblank_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_SHORT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_iswblank_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _iswblank_l(wint_t _C, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _iswblank_l$descriptor() {
        return _iswblank_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _iswblank_l(wint_t _C, _locale_t _Locale)
     * }
     */
    public static MethodHandle _iswblank_l$handle() {
        return _iswblank_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _iswblank_l(wint_t _C, _locale_t _Locale)
     * }
     */
    public static MemorySegment _iswblank_l$address() {
        return _iswblank_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _iswblank_l(wint_t _C, _locale_t _Locale)
     * }
     */
    public static int _iswblank_l(short _C, MemorySegment _Locale) {
        var mh$ = _iswblank_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_iswblank_l", _C, _Locale);
            }
            return (int)mh$.invokeExact(_C, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _iswcntrl_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_SHORT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_iswcntrl_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _iswcntrl_l(wint_t _C, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _iswcntrl_l$descriptor() {
        return _iswcntrl_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _iswcntrl_l(wint_t _C, _locale_t _Locale)
     * }
     */
    public static MethodHandle _iswcntrl_l$handle() {
        return _iswcntrl_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _iswcntrl_l(wint_t _C, _locale_t _Locale)
     * }
     */
    public static MemorySegment _iswcntrl_l$address() {
        return _iswcntrl_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _iswcntrl_l(wint_t _C, _locale_t _Locale)
     * }
     */
    public static int _iswcntrl_l(short _C, MemorySegment _Locale) {
        var mh$ = _iswcntrl_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_iswcntrl_l", _C, _Locale);
            }
            return (int)mh$.invokeExact(_C, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _iswdigit_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_SHORT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_iswdigit_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _iswdigit_l(wint_t _C, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _iswdigit_l$descriptor() {
        return _iswdigit_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _iswdigit_l(wint_t _C, _locale_t _Locale)
     * }
     */
    public static MethodHandle _iswdigit_l$handle() {
        return _iswdigit_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _iswdigit_l(wint_t _C, _locale_t _Locale)
     * }
     */
    public static MemorySegment _iswdigit_l$address() {
        return _iswdigit_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _iswdigit_l(wint_t _C, _locale_t _Locale)
     * }
     */
    public static int _iswdigit_l(short _C, MemorySegment _Locale) {
        var mh$ = _iswdigit_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_iswdigit_l", _C, _Locale);
            }
            return (int)mh$.invokeExact(_C, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _iswgraph_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_SHORT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_iswgraph_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _iswgraph_l(wint_t _C, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _iswgraph_l$descriptor() {
        return _iswgraph_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _iswgraph_l(wint_t _C, _locale_t _Locale)
     * }
     */
    public static MethodHandle _iswgraph_l$handle() {
        return _iswgraph_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _iswgraph_l(wint_t _C, _locale_t _Locale)
     * }
     */
    public static MemorySegment _iswgraph_l$address() {
        return _iswgraph_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _iswgraph_l(wint_t _C, _locale_t _Locale)
     * }
     */
    public static int _iswgraph_l(short _C, MemorySegment _Locale) {
        var mh$ = _iswgraph_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_iswgraph_l", _C, _Locale);
            }
            return (int)mh$.invokeExact(_C, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _iswlower_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_SHORT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_iswlower_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _iswlower_l(wint_t _C, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _iswlower_l$descriptor() {
        return _iswlower_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _iswlower_l(wint_t _C, _locale_t _Locale)
     * }
     */
    public static MethodHandle _iswlower_l$handle() {
        return _iswlower_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _iswlower_l(wint_t _C, _locale_t _Locale)
     * }
     */
    public static MemorySegment _iswlower_l$address() {
        return _iswlower_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _iswlower_l(wint_t _C, _locale_t _Locale)
     * }
     */
    public static int _iswlower_l(short _C, MemorySegment _Locale) {
        var mh$ = _iswlower_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_iswlower_l", _C, _Locale);
            }
            return (int)mh$.invokeExact(_C, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _iswprint_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_SHORT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_iswprint_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _iswprint_l(wint_t _C, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _iswprint_l$descriptor() {
        return _iswprint_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _iswprint_l(wint_t _C, _locale_t _Locale)
     * }
     */
    public static MethodHandle _iswprint_l$handle() {
        return _iswprint_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _iswprint_l(wint_t _C, _locale_t _Locale)
     * }
     */
    public static MemorySegment _iswprint_l$address() {
        return _iswprint_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _iswprint_l(wint_t _C, _locale_t _Locale)
     * }
     */
    public static int _iswprint_l(short _C, MemorySegment _Locale) {
        var mh$ = _iswprint_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_iswprint_l", _C, _Locale);
            }
            return (int)mh$.invokeExact(_C, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _iswpunct_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_SHORT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_iswpunct_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _iswpunct_l(wint_t _C, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _iswpunct_l$descriptor() {
        return _iswpunct_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _iswpunct_l(wint_t _C, _locale_t _Locale)
     * }
     */
    public static MethodHandle _iswpunct_l$handle() {
        return _iswpunct_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _iswpunct_l(wint_t _C, _locale_t _Locale)
     * }
     */
    public static MemorySegment _iswpunct_l$address() {
        return _iswpunct_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _iswpunct_l(wint_t _C, _locale_t _Locale)
     * }
     */
    public static int _iswpunct_l(short _C, MemorySegment _Locale) {
        var mh$ = _iswpunct_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_iswpunct_l", _C, _Locale);
            }
            return (int)mh$.invokeExact(_C, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _iswspace_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_SHORT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_iswspace_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _iswspace_l(wint_t _C, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _iswspace_l$descriptor() {
        return _iswspace_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _iswspace_l(wint_t _C, _locale_t _Locale)
     * }
     */
    public static MethodHandle _iswspace_l$handle() {
        return _iswspace_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _iswspace_l(wint_t _C, _locale_t _Locale)
     * }
     */
    public static MemorySegment _iswspace_l$address() {
        return _iswspace_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _iswspace_l(wint_t _C, _locale_t _Locale)
     * }
     */
    public static int _iswspace_l(short _C, MemorySegment _Locale) {
        var mh$ = _iswspace_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_iswspace_l", _C, _Locale);
            }
            return (int)mh$.invokeExact(_C, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _iswupper_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_SHORT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_iswupper_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _iswupper_l(wint_t _C, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _iswupper_l$descriptor() {
        return _iswupper_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _iswupper_l(wint_t _C, _locale_t _Locale)
     * }
     */
    public static MethodHandle _iswupper_l$handle() {
        return _iswupper_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _iswupper_l(wint_t _C, _locale_t _Locale)
     * }
     */
    public static MemorySegment _iswupper_l$address() {
        return _iswupper_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _iswupper_l(wint_t _C, _locale_t _Locale)
     * }
     */
    public static int _iswupper_l(short _C, MemorySegment _Locale) {
        var mh$ = _iswupper_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_iswupper_l", _C, _Locale);
            }
            return (int)mh$.invokeExact(_C, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _iswxdigit_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_SHORT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_iswxdigit_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _iswxdigit_l(wint_t _C, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _iswxdigit_l$descriptor() {
        return _iswxdigit_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _iswxdigit_l(wint_t _C, _locale_t _Locale)
     * }
     */
    public static MethodHandle _iswxdigit_l$handle() {
        return _iswxdigit_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _iswxdigit_l(wint_t _C, _locale_t _Locale)
     * }
     */
    public static MemorySegment _iswxdigit_l$address() {
        return _iswxdigit_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _iswxdigit_l(wint_t _C, _locale_t _Locale)
     * }
     */
    public static int _iswxdigit_l(short _C, MemorySegment _Locale) {
        var mh$ = _iswxdigit_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_iswxdigit_l", _C, _Locale);
            }
            return (int)mh$.invokeExact(_C, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _iswcsymf_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_SHORT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_iswcsymf_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _iswcsymf_l(wint_t _C, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _iswcsymf_l$descriptor() {
        return _iswcsymf_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _iswcsymf_l(wint_t _C, _locale_t _Locale)
     * }
     */
    public static MethodHandle _iswcsymf_l$handle() {
        return _iswcsymf_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _iswcsymf_l(wint_t _C, _locale_t _Locale)
     * }
     */
    public static MemorySegment _iswcsymf_l$address() {
        return _iswcsymf_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _iswcsymf_l(wint_t _C, _locale_t _Locale)
     * }
     */
    public static int _iswcsymf_l(short _C, MemorySegment _Locale) {
        var mh$ = _iswcsymf_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_iswcsymf_l", _C, _Locale);
            }
            return (int)mh$.invokeExact(_C, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _iswcsym_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_SHORT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_iswcsym_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _iswcsym_l(wint_t _C, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _iswcsym_l$descriptor() {
        return _iswcsym_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _iswcsym_l(wint_t _C, _locale_t _Locale)
     * }
     */
    public static MethodHandle _iswcsym_l$handle() {
        return _iswcsym_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _iswcsym_l(wint_t _C, _locale_t _Locale)
     * }
     */
    public static MemorySegment _iswcsym_l$address() {
        return _iswcsym_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _iswcsym_l(wint_t _C, _locale_t _Locale)
     * }
     */
    public static int _iswcsym_l(short _C, MemorySegment _Locale) {
        var mh$ = _iswcsym_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_iswcsym_l", _C, _Locale);
            }
            return (int)mh$.invokeExact(_C, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class towupper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_SHORT,
            Python_h.C_SHORT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("towupper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wint_t towupper(wint_t _C)
     * }
     */
    public static FunctionDescriptor towupper$descriptor() {
        return towupper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wint_t towupper(wint_t _C)
     * }
     */
    public static MethodHandle towupper$handle() {
        return towupper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wint_t towupper(wint_t _C)
     * }
     */
    public static MemorySegment towupper$address() {
        return towupper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wint_t towupper(wint_t _C)
     * }
     */
    public static short towupper(short _C) {
        var mh$ = towupper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("towupper", _C);
            }
            return (short)mh$.invokeExact(_C);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class towlower {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_SHORT,
            Python_h.C_SHORT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("towlower");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wint_t towlower(wint_t _C)
     * }
     */
    public static FunctionDescriptor towlower$descriptor() {
        return towlower.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wint_t towlower(wint_t _C)
     * }
     */
    public static MethodHandle towlower$handle() {
        return towlower.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wint_t towlower(wint_t _C)
     * }
     */
    public static MemorySegment towlower$address() {
        return towlower.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wint_t towlower(wint_t _C)
     * }
     */
    public static short towlower(short _C) {
        var mh$ = towlower.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("towlower", _C);
            }
            return (short)mh$.invokeExact(_C);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class iswctype {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_SHORT,
            Python_h.C_SHORT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("iswctype");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int iswctype(wint_t _C, wctype_t _Type)
     * }
     */
    public static FunctionDescriptor iswctype$descriptor() {
        return iswctype.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int iswctype(wint_t _C, wctype_t _Type)
     * }
     */
    public static MethodHandle iswctype$handle() {
        return iswctype.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int iswctype(wint_t _C, wctype_t _Type)
     * }
     */
    public static MemorySegment iswctype$address() {
        return iswctype.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int iswctype(wint_t _C, wctype_t _Type)
     * }
     */
    public static int iswctype(short _C, short _Type) {
        var mh$ = iswctype.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("iswctype", _C, _Type);
            }
            return (int)mh$.invokeExact(_C, _Type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _towupper_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_SHORT,
            Python_h.C_SHORT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_towupper_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wint_t _towupper_l(wint_t _C, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _towupper_l$descriptor() {
        return _towupper_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wint_t _towupper_l(wint_t _C, _locale_t _Locale)
     * }
     */
    public static MethodHandle _towupper_l$handle() {
        return _towupper_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wint_t _towupper_l(wint_t _C, _locale_t _Locale)
     * }
     */
    public static MemorySegment _towupper_l$address() {
        return _towupper_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wint_t _towupper_l(wint_t _C, _locale_t _Locale)
     * }
     */
    public static short _towupper_l(short _C, MemorySegment _Locale) {
        var mh$ = _towupper_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_towupper_l", _C, _Locale);
            }
            return (short)mh$.invokeExact(_C, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _towlower_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_SHORT,
            Python_h.C_SHORT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_towlower_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wint_t _towlower_l(wint_t _C, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _towlower_l$descriptor() {
        return _towlower_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wint_t _towlower_l(wint_t _C, _locale_t _Locale)
     * }
     */
    public static MethodHandle _towlower_l$handle() {
        return _towlower_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wint_t _towlower_l(wint_t _C, _locale_t _Locale)
     * }
     */
    public static MemorySegment _towlower_l$address() {
        return _towlower_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wint_t _towlower_l(wint_t _C, _locale_t _Locale)
     * }
     */
    public static short _towlower_l(short _C, MemorySegment _Locale) {
        var mh$ = _towlower_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_towlower_l", _C, _Locale);
            }
            return (short)mh$.invokeExact(_C, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _iswctype_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_SHORT,
            Python_h.C_SHORT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_iswctype_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _iswctype_l(wint_t _C, wctype_t _Type, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _iswctype_l$descriptor() {
        return _iswctype_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _iswctype_l(wint_t _C, wctype_t _Type, _locale_t _Locale)
     * }
     */
    public static MethodHandle _iswctype_l$handle() {
        return _iswctype_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _iswctype_l(wint_t _C, wctype_t _Type, _locale_t _Locale)
     * }
     */
    public static MemorySegment _iswctype_l$address() {
        return _iswctype_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _iswctype_l(wint_t _C, wctype_t _Type, _locale_t _Locale)
     * }
     */
    public static int _iswctype_l(short _C, short _Type, MemorySegment _Locale) {
        var mh$ = _iswctype_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_iswctype_l", _C, _Type, _Locale);
            }
            return (int)mh$.invokeExact(_C, _Type, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class isleadbyte {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("isleadbyte");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int isleadbyte(int _C)
     * }
     */
    public static FunctionDescriptor isleadbyte$descriptor() {
        return isleadbyte.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int isleadbyte(int _C)
     * }
     */
    public static MethodHandle isleadbyte$handle() {
        return isleadbyte.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int isleadbyte(int _C)
     * }
     */
    public static MemorySegment isleadbyte$address() {
        return isleadbyte.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int isleadbyte(int _C)
     * }
     */
    public static int isleadbyte(int _C) {
        var mh$ = isleadbyte.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("isleadbyte", _C);
            }
            return (int)mh$.invokeExact(_C);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _isleadbyte_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_isleadbyte_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _isleadbyte_l(int _C, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _isleadbyte_l$descriptor() {
        return _isleadbyte_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _isleadbyte_l(int _C, _locale_t _Locale)
     * }
     */
    public static MethodHandle _isleadbyte_l$handle() {
        return _isleadbyte_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _isleadbyte_l(int _C, _locale_t _Locale)
     * }
     */
    public static MemorySegment _isleadbyte_l$address() {
        return _isleadbyte_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _isleadbyte_l(int _C, _locale_t _Locale)
     * }
     */
    public static int _isleadbyte_l(int _C, MemorySegment _Locale) {
        var mh$ = _isleadbyte_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_isleadbyte_l", _C, _Locale);
            }
            return (int)mh$.invokeExact(_C, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class is_wctype {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_SHORT,
            Python_h.C_SHORT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("is_wctype");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int is_wctype(wint_t _C, wctype_t _Type)
     * }
     */
    public static FunctionDescriptor is_wctype$descriptor() {
        return is_wctype.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int is_wctype(wint_t _C, wctype_t _Type)
     * }
     */
    public static MethodHandle is_wctype$handle() {
        return is_wctype.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int is_wctype(wint_t _C, wctype_t _Type)
     * }
     */
    public static MemorySegment is_wctype$address() {
        return is_wctype.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int is_wctype(wint_t _C, wctype_t _Type)
     * }
     */
    public static int is_wctype(short _C, short _Type) {
        var mh$ = is_wctype.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("is_wctype", _C, _Type);
            }
            return (int)mh$.invokeExact(_C, _Type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wgetcwd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wgetcwd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *_wgetcwd(wchar_t *_DstBuf, int _SizeInWords)
     * }
     */
    public static FunctionDescriptor _wgetcwd$descriptor() {
        return _wgetcwd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *_wgetcwd(wchar_t *_DstBuf, int _SizeInWords)
     * }
     */
    public static MethodHandle _wgetcwd$handle() {
        return _wgetcwd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *_wgetcwd(wchar_t *_DstBuf, int _SizeInWords)
     * }
     */
    public static MemorySegment _wgetcwd$address() {
        return _wgetcwd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *_wgetcwd(wchar_t *_DstBuf, int _SizeInWords)
     * }
     */
    public static MemorySegment _wgetcwd(MemorySegment _DstBuf, int _SizeInWords) {
        var mh$ = _wgetcwd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wgetcwd", _DstBuf, _SizeInWords);
            }
            return (MemorySegment)mh$.invokeExact(_DstBuf, _SizeInWords);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wgetdcwd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wgetdcwd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *_wgetdcwd(int _Drive, wchar_t *_DstBuf, int _SizeInWords)
     * }
     */
    public static FunctionDescriptor _wgetdcwd$descriptor() {
        return _wgetdcwd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *_wgetdcwd(int _Drive, wchar_t *_DstBuf, int _SizeInWords)
     * }
     */
    public static MethodHandle _wgetdcwd$handle() {
        return _wgetdcwd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *_wgetdcwd(int _Drive, wchar_t *_DstBuf, int _SizeInWords)
     * }
     */
    public static MemorySegment _wgetdcwd$address() {
        return _wgetdcwd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *_wgetdcwd(int _Drive, wchar_t *_DstBuf, int _SizeInWords)
     * }
     */
    public static MemorySegment _wgetdcwd(int _Drive, MemorySegment _DstBuf, int _SizeInWords) {
        var mh$ = _wgetdcwd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wgetdcwd", _Drive, _DstBuf, _SizeInWords);
            }
            return (MemorySegment)mh$.invokeExact(_Drive, _DstBuf, _SizeInWords);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wchdir {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wchdir");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _wchdir(const wchar_t *_Path)
     * }
     */
    public static FunctionDescriptor _wchdir$descriptor() {
        return _wchdir.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _wchdir(const wchar_t *_Path)
     * }
     */
    public static MethodHandle _wchdir$handle() {
        return _wchdir.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _wchdir(const wchar_t *_Path)
     * }
     */
    public static MemorySegment _wchdir$address() {
        return _wchdir.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _wchdir(const wchar_t *_Path)
     * }
     */
    public static int _wchdir(MemorySegment _Path) {
        var mh$ = _wchdir.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wchdir", _Path);
            }
            return (int)mh$.invokeExact(_Path);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wmkdir {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wmkdir");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _wmkdir(const wchar_t *_Path)
     * }
     */
    public static FunctionDescriptor _wmkdir$descriptor() {
        return _wmkdir.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _wmkdir(const wchar_t *_Path)
     * }
     */
    public static MethodHandle _wmkdir$handle() {
        return _wmkdir.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _wmkdir(const wchar_t *_Path)
     * }
     */
    public static MemorySegment _wmkdir$address() {
        return _wmkdir.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _wmkdir(const wchar_t *_Path)
     * }
     */
    public static int _wmkdir(MemorySegment _Path) {
        var mh$ = _wmkdir.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wmkdir", _Path);
            }
            return (int)mh$.invokeExact(_Path);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wrmdir {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wrmdir");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _wrmdir(const wchar_t *_Path)
     * }
     */
    public static FunctionDescriptor _wrmdir$descriptor() {
        return _wrmdir.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _wrmdir(const wchar_t *_Path)
     * }
     */
    public static MethodHandle _wrmdir$handle() {
        return _wrmdir.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _wrmdir(const wchar_t *_Path)
     * }
     */
    public static MemorySegment _wrmdir$address() {
        return _wrmdir.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _wrmdir(const wchar_t *_Path)
     * }
     */
    public static int _wrmdir(MemorySegment _Path) {
        var mh$ = _wrmdir.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wrmdir", _Path);
            }
            return (int)mh$.invokeExact(_Path);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * intptr_t _wexecl(const wchar_t *_FileName, const wchar_t *_ArgList, ...)
     * }
     */
    public static class _wexecl {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_LONG_LONG,
                Python_h.C_POINTER,
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("_wexecl");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private _wexecl(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * intptr_t _wexecl(const wchar_t *_FileName, const wchar_t *_ArgList, ...)
         * }
         */
        public static _wexecl makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new _wexecl(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public long apply(MemorySegment _FileName, MemorySegment _ArgList, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("_wexecl", _FileName, _ArgList, x2);
                }
                return (long)spreader.invokeExact(_FileName, _ArgList, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * intptr_t _wexecle(const wchar_t *_FileName, const wchar_t *_ArgList, ...)
     * }
     */
    public static class _wexecle {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_LONG_LONG,
                Python_h.C_POINTER,
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("_wexecle");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private _wexecle(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * intptr_t _wexecle(const wchar_t *_FileName, const wchar_t *_ArgList, ...)
         * }
         */
        public static _wexecle makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new _wexecle(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public long apply(MemorySegment _FileName, MemorySegment _ArgList, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("_wexecle", _FileName, _ArgList, x2);
                }
                return (long)spreader.invokeExact(_FileName, _ArgList, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * intptr_t _wexeclp(const wchar_t *_FileName, const wchar_t *_ArgList, ...)
     * }
     */
    public static class _wexeclp {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_LONG_LONG,
                Python_h.C_POINTER,
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("_wexeclp");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private _wexeclp(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * intptr_t _wexeclp(const wchar_t *_FileName, const wchar_t *_ArgList, ...)
         * }
         */
        public static _wexeclp makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new _wexeclp(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public long apply(MemorySegment _FileName, MemorySegment _ArgList, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("_wexeclp", _FileName, _ArgList, x2);
                }
                return (long)spreader.invokeExact(_FileName, _ArgList, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * intptr_t _wexeclpe(const wchar_t *_FileName, const wchar_t *_ArgList, ...)
     * }
     */
    public static class _wexeclpe {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_LONG_LONG,
                Python_h.C_POINTER,
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("_wexeclpe");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private _wexeclpe(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * intptr_t _wexeclpe(const wchar_t *_FileName, const wchar_t *_ArgList, ...)
         * }
         */
        public static _wexeclpe makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new _wexeclpe(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public long apply(MemorySegment _FileName, MemorySegment _ArgList, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("_wexeclpe", _FileName, _ArgList, x2);
                }
                return (long)spreader.invokeExact(_FileName, _ArgList, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class _wexecv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wexecv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * intptr_t _wexecv(const wchar_t *_FileName, const wchar_t *const *_ArgList)
     * }
     */
    public static FunctionDescriptor _wexecv$descriptor() {
        return _wexecv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * intptr_t _wexecv(const wchar_t *_FileName, const wchar_t *const *_ArgList)
     * }
     */
    public static MethodHandle _wexecv$handle() {
        return _wexecv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * intptr_t _wexecv(const wchar_t *_FileName, const wchar_t *const *_ArgList)
     * }
     */
    public static MemorySegment _wexecv$address() {
        return _wexecv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * intptr_t _wexecv(const wchar_t *_FileName, const wchar_t *const *_ArgList)
     * }
     */
    public static long _wexecv(MemorySegment _FileName, MemorySegment _ArgList) {
        var mh$ = _wexecv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wexecv", _FileName, _ArgList);
            }
            return (long)mh$.invokeExact(_FileName, _ArgList);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wexecve {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wexecve");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * intptr_t _wexecve(const wchar_t *_FileName, const wchar_t *const *_ArgList, const wchar_t *const *_Env)
     * }
     */
    public static FunctionDescriptor _wexecve$descriptor() {
        return _wexecve.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * intptr_t _wexecve(const wchar_t *_FileName, const wchar_t *const *_ArgList, const wchar_t *const *_Env)
     * }
     */
    public static MethodHandle _wexecve$handle() {
        return _wexecve.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * intptr_t _wexecve(const wchar_t *_FileName, const wchar_t *const *_ArgList, const wchar_t *const *_Env)
     * }
     */
    public static MemorySegment _wexecve$address() {
        return _wexecve.ADDR;
    }

    /**
     * {@snippet lang=c :
     * intptr_t _wexecve(const wchar_t *_FileName, const wchar_t *const *_ArgList, const wchar_t *const *_Env)
     * }
     */
    public static long _wexecve(MemorySegment _FileName, MemorySegment _ArgList, MemorySegment _Env) {
        var mh$ = _wexecve.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wexecve", _FileName, _ArgList, _Env);
            }
            return (long)mh$.invokeExact(_FileName, _ArgList, _Env);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wexecvp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wexecvp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * intptr_t _wexecvp(const wchar_t *_FileName, const wchar_t *const *_ArgList)
     * }
     */
    public static FunctionDescriptor _wexecvp$descriptor() {
        return _wexecvp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * intptr_t _wexecvp(const wchar_t *_FileName, const wchar_t *const *_ArgList)
     * }
     */
    public static MethodHandle _wexecvp$handle() {
        return _wexecvp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * intptr_t _wexecvp(const wchar_t *_FileName, const wchar_t *const *_ArgList)
     * }
     */
    public static MemorySegment _wexecvp$address() {
        return _wexecvp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * intptr_t _wexecvp(const wchar_t *_FileName, const wchar_t *const *_ArgList)
     * }
     */
    public static long _wexecvp(MemorySegment _FileName, MemorySegment _ArgList) {
        var mh$ = _wexecvp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wexecvp", _FileName, _ArgList);
            }
            return (long)mh$.invokeExact(_FileName, _ArgList);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wexecvpe {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wexecvpe");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * intptr_t _wexecvpe(const wchar_t *_FileName, const wchar_t *const *_ArgList, const wchar_t *const *_Env)
     * }
     */
    public static FunctionDescriptor _wexecvpe$descriptor() {
        return _wexecvpe.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * intptr_t _wexecvpe(const wchar_t *_FileName, const wchar_t *const *_ArgList, const wchar_t *const *_Env)
     * }
     */
    public static MethodHandle _wexecvpe$handle() {
        return _wexecvpe.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * intptr_t _wexecvpe(const wchar_t *_FileName, const wchar_t *const *_ArgList, const wchar_t *const *_Env)
     * }
     */
    public static MemorySegment _wexecvpe$address() {
        return _wexecvpe.ADDR;
    }

    /**
     * {@snippet lang=c :
     * intptr_t _wexecvpe(const wchar_t *_FileName, const wchar_t *const *_ArgList, const wchar_t *const *_Env)
     * }
     */
    public static long _wexecvpe(MemorySegment _FileName, MemorySegment _ArgList, MemorySegment _Env) {
        var mh$ = _wexecvpe.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wexecvpe", _FileName, _ArgList, _Env);
            }
            return (long)mh$.invokeExact(_FileName, _ArgList, _Env);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * intptr_t _wspawnl(int _Mode, const wchar_t *_FileName, const wchar_t *_ArgList, ...)
     * }
     */
    public static class _wspawnl {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_LONG_LONG,
                Python_h.C_INT,
                Python_h.C_POINTER,
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("_wspawnl");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private _wspawnl(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * intptr_t _wspawnl(int _Mode, const wchar_t *_FileName, const wchar_t *_ArgList, ...)
         * }
         */
        public static _wspawnl makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new _wspawnl(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public long apply(int _Mode, MemorySegment _FileName, MemorySegment _ArgList, Object... x3) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("_wspawnl", _Mode, _FileName, _ArgList, x3);
                }
                return (long)spreader.invokeExact(_Mode, _FileName, _ArgList, x3);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * intptr_t _wspawnle(int _Mode, const wchar_t *_FileName, const wchar_t *_ArgList, ...)
     * }
     */
    public static class _wspawnle {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_LONG_LONG,
                Python_h.C_INT,
                Python_h.C_POINTER,
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("_wspawnle");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private _wspawnle(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * intptr_t _wspawnle(int _Mode, const wchar_t *_FileName, const wchar_t *_ArgList, ...)
         * }
         */
        public static _wspawnle makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new _wspawnle(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public long apply(int _Mode, MemorySegment _FileName, MemorySegment _ArgList, Object... x3) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("_wspawnle", _Mode, _FileName, _ArgList, x3);
                }
                return (long)spreader.invokeExact(_Mode, _FileName, _ArgList, x3);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * intptr_t _wspawnlp(int _Mode, const wchar_t *_FileName, const wchar_t *_ArgList, ...)
     * }
     */
    public static class _wspawnlp {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_LONG_LONG,
                Python_h.C_INT,
                Python_h.C_POINTER,
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("_wspawnlp");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private _wspawnlp(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * intptr_t _wspawnlp(int _Mode, const wchar_t *_FileName, const wchar_t *_ArgList, ...)
         * }
         */
        public static _wspawnlp makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new _wspawnlp(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public long apply(int _Mode, MemorySegment _FileName, MemorySegment _ArgList, Object... x3) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("_wspawnlp", _Mode, _FileName, _ArgList, x3);
                }
                return (long)spreader.invokeExact(_Mode, _FileName, _ArgList, x3);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * intptr_t _wspawnlpe(int _Mode, const wchar_t *_FileName, const wchar_t *_ArgList, ...)
     * }
     */
    public static class _wspawnlpe {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_LONG_LONG,
                Python_h.C_INT,
                Python_h.C_POINTER,
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("_wspawnlpe");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private _wspawnlpe(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * intptr_t _wspawnlpe(int _Mode, const wchar_t *_FileName, const wchar_t *_ArgList, ...)
         * }
         */
        public static _wspawnlpe makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new _wspawnlpe(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public long apply(int _Mode, MemorySegment _FileName, MemorySegment _ArgList, Object... x3) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("_wspawnlpe", _Mode, _FileName, _ArgList, x3);
                }
                return (long)spreader.invokeExact(_Mode, _FileName, _ArgList, x3);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class _wspawnv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wspawnv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * intptr_t _wspawnv(int _Mode, const wchar_t *_FileName, const wchar_t *const *_ArgList)
     * }
     */
    public static FunctionDescriptor _wspawnv$descriptor() {
        return _wspawnv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * intptr_t _wspawnv(int _Mode, const wchar_t *_FileName, const wchar_t *const *_ArgList)
     * }
     */
    public static MethodHandle _wspawnv$handle() {
        return _wspawnv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * intptr_t _wspawnv(int _Mode, const wchar_t *_FileName, const wchar_t *const *_ArgList)
     * }
     */
    public static MemorySegment _wspawnv$address() {
        return _wspawnv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * intptr_t _wspawnv(int _Mode, const wchar_t *_FileName, const wchar_t *const *_ArgList)
     * }
     */
    public static long _wspawnv(int _Mode, MemorySegment _FileName, MemorySegment _ArgList) {
        var mh$ = _wspawnv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wspawnv", _Mode, _FileName, _ArgList);
            }
            return (long)mh$.invokeExact(_Mode, _FileName, _ArgList);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wspawnve {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wspawnve");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * intptr_t _wspawnve(int _Mode, const wchar_t *_FileName, const wchar_t *const *_ArgList, const wchar_t *const *_Env)
     * }
     */
    public static FunctionDescriptor _wspawnve$descriptor() {
        return _wspawnve.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * intptr_t _wspawnve(int _Mode, const wchar_t *_FileName, const wchar_t *const *_ArgList, const wchar_t *const *_Env)
     * }
     */
    public static MethodHandle _wspawnve$handle() {
        return _wspawnve.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * intptr_t _wspawnve(int _Mode, const wchar_t *_FileName, const wchar_t *const *_ArgList, const wchar_t *const *_Env)
     * }
     */
    public static MemorySegment _wspawnve$address() {
        return _wspawnve.ADDR;
    }

    /**
     * {@snippet lang=c :
     * intptr_t _wspawnve(int _Mode, const wchar_t *_FileName, const wchar_t *const *_ArgList, const wchar_t *const *_Env)
     * }
     */
    public static long _wspawnve(int _Mode, MemorySegment _FileName, MemorySegment _ArgList, MemorySegment _Env) {
        var mh$ = _wspawnve.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wspawnve", _Mode, _FileName, _ArgList, _Env);
            }
            return (long)mh$.invokeExact(_Mode, _FileName, _ArgList, _Env);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wspawnvp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wspawnvp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * intptr_t _wspawnvp(int _Mode, const wchar_t *_FileName, const wchar_t *const *_ArgList)
     * }
     */
    public static FunctionDescriptor _wspawnvp$descriptor() {
        return _wspawnvp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * intptr_t _wspawnvp(int _Mode, const wchar_t *_FileName, const wchar_t *const *_ArgList)
     * }
     */
    public static MethodHandle _wspawnvp$handle() {
        return _wspawnvp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * intptr_t _wspawnvp(int _Mode, const wchar_t *_FileName, const wchar_t *const *_ArgList)
     * }
     */
    public static MemorySegment _wspawnvp$address() {
        return _wspawnvp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * intptr_t _wspawnvp(int _Mode, const wchar_t *_FileName, const wchar_t *const *_ArgList)
     * }
     */
    public static long _wspawnvp(int _Mode, MemorySegment _FileName, MemorySegment _ArgList) {
        var mh$ = _wspawnvp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wspawnvp", _Mode, _FileName, _ArgList);
            }
            return (long)mh$.invokeExact(_Mode, _FileName, _ArgList);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wspawnvpe {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wspawnvpe");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * intptr_t _wspawnvpe(int _Mode, const wchar_t *_FileName, const wchar_t *const *_ArgList, const wchar_t *const *_Env)
     * }
     */
    public static FunctionDescriptor _wspawnvpe$descriptor() {
        return _wspawnvpe.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * intptr_t _wspawnvpe(int _Mode, const wchar_t *_FileName, const wchar_t *const *_ArgList, const wchar_t *const *_Env)
     * }
     */
    public static MethodHandle _wspawnvpe$handle() {
        return _wspawnvpe.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * intptr_t _wspawnvpe(int _Mode, const wchar_t *_FileName, const wchar_t *const *_ArgList, const wchar_t *const *_Env)
     * }
     */
    public static MemorySegment _wspawnvpe$address() {
        return _wspawnvpe.ADDR;
    }

    /**
     * {@snippet lang=c :
     * intptr_t _wspawnvpe(int _Mode, const wchar_t *_FileName, const wchar_t *const *_ArgList, const wchar_t *const *_Env)
     * }
     */
    public static long _wspawnvpe(int _Mode, MemorySegment _FileName, MemorySegment _ArgList, MemorySegment _Env) {
        var mh$ = _wspawnvpe.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wspawnvpe", _Mode, _FileName, _ArgList, _Env);
            }
            return (long)mh$.invokeExact(_Mode, _FileName, _ArgList, _Env);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wasctime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wasctime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *_wasctime(const struct tm *_Tm)
     * }
     */
    public static FunctionDescriptor _wasctime$descriptor() {
        return _wasctime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *_wasctime(const struct tm *_Tm)
     * }
     */
    public static MethodHandle _wasctime$handle() {
        return _wasctime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *_wasctime(const struct tm *_Tm)
     * }
     */
    public static MemorySegment _wasctime$address() {
        return _wasctime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *_wasctime(const struct tm *_Tm)
     * }
     */
    public static MemorySegment _wasctime(MemorySegment _Tm) {
        var mh$ = _wasctime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wasctime", _Tm);
            }
            return (MemorySegment)mh$.invokeExact(_Tm);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wasctime_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wasctime_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _wasctime_s(wchar_t *_Buffer, size_t _SizeInWords, const struct tm *_Tm)
     * }
     */
    public static FunctionDescriptor _wasctime_s$descriptor() {
        return _wasctime_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _wasctime_s(wchar_t *_Buffer, size_t _SizeInWords, const struct tm *_Tm)
     * }
     */
    public static MethodHandle _wasctime_s$handle() {
        return _wasctime_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _wasctime_s(wchar_t *_Buffer, size_t _SizeInWords, const struct tm *_Tm)
     * }
     */
    public static MemorySegment _wasctime_s$address() {
        return _wasctime_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _wasctime_s(wchar_t *_Buffer, size_t _SizeInWords, const struct tm *_Tm)
     * }
     */
    public static int _wasctime_s(MemorySegment _Buffer, long _SizeInWords, MemorySegment _Tm) {
        var mh$ = _wasctime_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wasctime_s", _Buffer, _SizeInWords, _Tm);
            }
            return (int)mh$.invokeExact(_Buffer, _SizeInWords, _Tm);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsftime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcsftime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t wcsftime(wchar_t *_Buffer, size_t _SizeInWords, const wchar_t *_Format, const struct tm *_Tm)
     * }
     */
    public static FunctionDescriptor wcsftime$descriptor() {
        return wcsftime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t wcsftime(wchar_t *_Buffer, size_t _SizeInWords, const wchar_t *_Format, const struct tm *_Tm)
     * }
     */
    public static MethodHandle wcsftime$handle() {
        return wcsftime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t wcsftime(wchar_t *_Buffer, size_t _SizeInWords, const wchar_t *_Format, const struct tm *_Tm)
     * }
     */
    public static MemorySegment wcsftime$address() {
        return wcsftime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t wcsftime(wchar_t *_Buffer, size_t _SizeInWords, const wchar_t *_Format, const struct tm *_Tm)
     * }
     */
    public static long wcsftime(MemorySegment _Buffer, long _SizeInWords, MemorySegment _Format, MemorySegment _Tm) {
        var mh$ = wcsftime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsftime", _Buffer, _SizeInWords, _Format, _Tm);
            }
            return (long)mh$.invokeExact(_Buffer, _SizeInWords, _Format, _Tm);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcsftime_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wcsftime_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t _wcsftime_l(wchar_t *_Buffer, size_t _SizeInWords, const wchar_t *_Format, const struct tm *_Tm, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcsftime_l$descriptor() {
        return _wcsftime_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t _wcsftime_l(wchar_t *_Buffer, size_t _SizeInWords, const wchar_t *_Format, const struct tm *_Tm, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcsftime_l$handle() {
        return _wcsftime_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t _wcsftime_l(wchar_t *_Buffer, size_t _SizeInWords, const wchar_t *_Format, const struct tm *_Tm, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcsftime_l$address() {
        return _wcsftime_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t _wcsftime_l(wchar_t *_Buffer, size_t _SizeInWords, const wchar_t *_Format, const struct tm *_Tm, _locale_t _Locale)
     * }
     */
    public static long _wcsftime_l(MemorySegment _Buffer, long _SizeInWords, MemorySegment _Format, MemorySegment _Tm, MemorySegment _Locale) {
        var mh$ = _wcsftime_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcsftime_l", _Buffer, _SizeInWords, _Format, _Tm, _Locale);
            }
            return (long)mh$.invokeExact(_Buffer, _SizeInWords, _Format, _Tm, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wctime32 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wctime32");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *_wctime32(const __time32_t *_Time)
     * }
     */
    public static FunctionDescriptor _wctime32$descriptor() {
        return _wctime32.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *_wctime32(const __time32_t *_Time)
     * }
     */
    public static MethodHandle _wctime32$handle() {
        return _wctime32.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *_wctime32(const __time32_t *_Time)
     * }
     */
    public static MemorySegment _wctime32$address() {
        return _wctime32.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *_wctime32(const __time32_t *_Time)
     * }
     */
    public static MemorySegment _wctime32(MemorySegment _Time) {
        var mh$ = _wctime32.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wctime32", _Time);
            }
            return (MemorySegment)mh$.invokeExact(_Time);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wctime32_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wctime32_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _wctime32_s(wchar_t *_Buffer, size_t _SizeInWords, const __time32_t *_Time)
     * }
     */
    public static FunctionDescriptor _wctime32_s$descriptor() {
        return _wctime32_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _wctime32_s(wchar_t *_Buffer, size_t _SizeInWords, const __time32_t *_Time)
     * }
     */
    public static MethodHandle _wctime32_s$handle() {
        return _wctime32_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _wctime32_s(wchar_t *_Buffer, size_t _SizeInWords, const __time32_t *_Time)
     * }
     */
    public static MemorySegment _wctime32_s$address() {
        return _wctime32_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _wctime32_s(wchar_t *_Buffer, size_t _SizeInWords, const __time32_t *_Time)
     * }
     */
    public static int _wctime32_s(MemorySegment _Buffer, long _SizeInWords, MemorySegment _Time) {
        var mh$ = _wctime32_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wctime32_s", _Buffer, _SizeInWords, _Time);
            }
            return (int)mh$.invokeExact(_Buffer, _SizeInWords, _Time);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wctime64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wctime64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *_wctime64(const __time64_t *_Time)
     * }
     */
    public static FunctionDescriptor _wctime64$descriptor() {
        return _wctime64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *_wctime64(const __time64_t *_Time)
     * }
     */
    public static MethodHandle _wctime64$handle() {
        return _wctime64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *_wctime64(const __time64_t *_Time)
     * }
     */
    public static MemorySegment _wctime64$address() {
        return _wctime64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *_wctime64(const __time64_t *_Time)
     * }
     */
    public static MemorySegment _wctime64(MemorySegment _Time) {
        var mh$ = _wctime64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wctime64", _Time);
            }
            return (MemorySegment)mh$.invokeExact(_Time);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wctime64_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wctime64_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _wctime64_s(wchar_t *_Buffer, size_t _SizeInWords, const __time64_t *_Time)
     * }
     */
    public static FunctionDescriptor _wctime64_s$descriptor() {
        return _wctime64_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _wctime64_s(wchar_t *_Buffer, size_t _SizeInWords, const __time64_t *_Time)
     * }
     */
    public static MethodHandle _wctime64_s$handle() {
        return _wctime64_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _wctime64_s(wchar_t *_Buffer, size_t _SizeInWords, const __time64_t *_Time)
     * }
     */
    public static MemorySegment _wctime64_s$address() {
        return _wctime64_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _wctime64_s(wchar_t *_Buffer, size_t _SizeInWords, const __time64_t *_Time)
     * }
     */
    public static int _wctime64_s(MemorySegment _Buffer, long _SizeInWords, MemorySegment _Time) {
        var mh$ = _wctime64_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wctime64_s", _Buffer, _SizeInWords, _Time);
            }
            return (int)mh$.invokeExact(_Buffer, _SizeInWords, _Time);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wstrdate_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wstrdate_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _wstrdate_s(wchar_t *_Buffer, size_t _SizeInWords)
     * }
     */
    public static FunctionDescriptor _wstrdate_s$descriptor() {
        return _wstrdate_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _wstrdate_s(wchar_t *_Buffer, size_t _SizeInWords)
     * }
     */
    public static MethodHandle _wstrdate_s$handle() {
        return _wstrdate_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _wstrdate_s(wchar_t *_Buffer, size_t _SizeInWords)
     * }
     */
    public static MemorySegment _wstrdate_s$address() {
        return _wstrdate_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _wstrdate_s(wchar_t *_Buffer, size_t _SizeInWords)
     * }
     */
    public static int _wstrdate_s(MemorySegment _Buffer, long _SizeInWords) {
        var mh$ = _wstrdate_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wstrdate_s", _Buffer, _SizeInWords);
            }
            return (int)mh$.invokeExact(_Buffer, _SizeInWords);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wstrdate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wstrdate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *_wstrdate(wchar_t *_Buffer)
     * }
     */
    public static FunctionDescriptor _wstrdate$descriptor() {
        return _wstrdate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *_wstrdate(wchar_t *_Buffer)
     * }
     */
    public static MethodHandle _wstrdate$handle() {
        return _wstrdate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *_wstrdate(wchar_t *_Buffer)
     * }
     */
    public static MemorySegment _wstrdate$address() {
        return _wstrdate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *_wstrdate(wchar_t *_Buffer)
     * }
     */
    public static MemorySegment _wstrdate(MemorySegment _Buffer) {
        var mh$ = _wstrdate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wstrdate", _Buffer);
            }
            return (MemorySegment)mh$.invokeExact(_Buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wstrtime_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wstrtime_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _wstrtime_s(wchar_t *_Buffer, size_t _SizeInWords)
     * }
     */
    public static FunctionDescriptor _wstrtime_s$descriptor() {
        return _wstrtime_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _wstrtime_s(wchar_t *_Buffer, size_t _SizeInWords)
     * }
     */
    public static MethodHandle _wstrtime_s$handle() {
        return _wstrtime_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _wstrtime_s(wchar_t *_Buffer, size_t _SizeInWords)
     * }
     */
    public static MemorySegment _wstrtime_s$address() {
        return _wstrtime_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _wstrtime_s(wchar_t *_Buffer, size_t _SizeInWords)
     * }
     */
    public static int _wstrtime_s(MemorySegment _Buffer, long _SizeInWords) {
        var mh$ = _wstrtime_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wstrtime_s", _Buffer, _SizeInWords);
            }
            return (int)mh$.invokeExact(_Buffer, _SizeInWords);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wstrtime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wstrtime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *_wstrtime(wchar_t *_Buffer)
     * }
     */
    public static FunctionDescriptor _wstrtime$descriptor() {
        return _wstrtime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *_wstrtime(wchar_t *_Buffer)
     * }
     */
    public static MethodHandle _wstrtime$handle() {
        return _wstrtime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *_wstrtime(wchar_t *_Buffer)
     * }
     */
    public static MemorySegment _wstrtime$address() {
        return _wstrtime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *_wstrtime(wchar_t *_Buffer)
     * }
     */
    public static MemorySegment _wstrtime(MemorySegment _Buffer) {
        var mh$ = _wstrtime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wstrtime", _Buffer);
            }
            return (MemorySegment)mh$.invokeExact(_Buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef unsigned short _ino_t
     * }
     */
    public static final OfShort _ino_t = Python_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef _ino_t ino_t
     * }
     */
    public static final OfShort ino_t = Python_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int _dev_t
     * }
     */
    public static final OfInt _dev_t = Python_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef _dev_t dev_t
     * }
     */
    public static final OfInt dev_t = Python_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long _off_t
     * }
     */
    public static final OfInt _off_t = Python_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef _off_t off_t
     * }
     */
    public static final OfInt off_t = Python_h.C_LONG;

    private static class _fstat32 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_fstat32");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _fstat32(int _FileHandle, struct _stat32 *_Stat)
     * }
     */
    public static FunctionDescriptor _fstat32$descriptor() {
        return _fstat32.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _fstat32(int _FileHandle, struct _stat32 *_Stat)
     * }
     */
    public static MethodHandle _fstat32$handle() {
        return _fstat32.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _fstat32(int _FileHandle, struct _stat32 *_Stat)
     * }
     */
    public static MemorySegment _fstat32$address() {
        return _fstat32.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _fstat32(int _FileHandle, struct _stat32 *_Stat)
     * }
     */
    public static int _fstat32(int _FileHandle, MemorySegment _Stat) {
        var mh$ = _fstat32.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fstat32", _FileHandle, _Stat);
            }
            return (int)mh$.invokeExact(_FileHandle, _Stat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fstat32i64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_fstat32i64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _fstat32i64(int _FileHandle, struct _stat32i64 *_Stat)
     * }
     */
    public static FunctionDescriptor _fstat32i64$descriptor() {
        return _fstat32i64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _fstat32i64(int _FileHandle, struct _stat32i64 *_Stat)
     * }
     */
    public static MethodHandle _fstat32i64$handle() {
        return _fstat32i64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _fstat32i64(int _FileHandle, struct _stat32i64 *_Stat)
     * }
     */
    public static MemorySegment _fstat32i64$address() {
        return _fstat32i64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _fstat32i64(int _FileHandle, struct _stat32i64 *_Stat)
     * }
     */
    public static int _fstat32i64(int _FileHandle, MemorySegment _Stat) {
        var mh$ = _fstat32i64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fstat32i64", _FileHandle, _Stat);
            }
            return (int)mh$.invokeExact(_FileHandle, _Stat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fstat64i32 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_fstat64i32");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _fstat64i32(int _FileHandle, struct _stat64i32 *_Stat)
     * }
     */
    public static FunctionDescriptor _fstat64i32$descriptor() {
        return _fstat64i32.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _fstat64i32(int _FileHandle, struct _stat64i32 *_Stat)
     * }
     */
    public static MethodHandle _fstat64i32$handle() {
        return _fstat64i32.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _fstat64i32(int _FileHandle, struct _stat64i32 *_Stat)
     * }
     */
    public static MemorySegment _fstat64i32$address() {
        return _fstat64i32.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _fstat64i32(int _FileHandle, struct _stat64i32 *_Stat)
     * }
     */
    public static int _fstat64i32(int _FileHandle, MemorySegment _Stat) {
        var mh$ = _fstat64i32.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fstat64i32", _FileHandle, _Stat);
            }
            return (int)mh$.invokeExact(_FileHandle, _Stat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fstat64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_fstat64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _fstat64(int _FileHandle, struct _stat64 *_Stat)
     * }
     */
    public static FunctionDescriptor _fstat64$descriptor() {
        return _fstat64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _fstat64(int _FileHandle, struct _stat64 *_Stat)
     * }
     */
    public static MethodHandle _fstat64$handle() {
        return _fstat64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _fstat64(int _FileHandle, struct _stat64 *_Stat)
     * }
     */
    public static MemorySegment _fstat64$address() {
        return _fstat64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _fstat64(int _FileHandle, struct _stat64 *_Stat)
     * }
     */
    public static int _fstat64(int _FileHandle, MemorySegment _Stat) {
        var mh$ = _fstat64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fstat64", _FileHandle, _Stat);
            }
            return (int)mh$.invokeExact(_FileHandle, _Stat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _stat32 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_stat32");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _stat32(const char *_FileName, struct _stat32 *_Stat)
     * }
     */
    public static FunctionDescriptor _stat32$descriptor() {
        return _stat32.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _stat32(const char *_FileName, struct _stat32 *_Stat)
     * }
     */
    public static MethodHandle _stat32$handle() {
        return _stat32.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _stat32(const char *_FileName, struct _stat32 *_Stat)
     * }
     */
    public static MemorySegment _stat32$address() {
        return _stat32.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _stat32(const char *_FileName, struct _stat32 *_Stat)
     * }
     */
    public static int _stat32(MemorySegment _FileName, MemorySegment _Stat) {
        var mh$ = _stat32.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_stat32", _FileName, _Stat);
            }
            return (int)mh$.invokeExact(_FileName, _Stat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _stat32i64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_stat32i64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _stat32i64(const char *_FileName, struct _stat32i64 *_Stat)
     * }
     */
    public static FunctionDescriptor _stat32i64$descriptor() {
        return _stat32i64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _stat32i64(const char *_FileName, struct _stat32i64 *_Stat)
     * }
     */
    public static MethodHandle _stat32i64$handle() {
        return _stat32i64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _stat32i64(const char *_FileName, struct _stat32i64 *_Stat)
     * }
     */
    public static MemorySegment _stat32i64$address() {
        return _stat32i64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _stat32i64(const char *_FileName, struct _stat32i64 *_Stat)
     * }
     */
    public static int _stat32i64(MemorySegment _FileName, MemorySegment _Stat) {
        var mh$ = _stat32i64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_stat32i64", _FileName, _Stat);
            }
            return (int)mh$.invokeExact(_FileName, _Stat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _stat64i32 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_stat64i32");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _stat64i32(const char *_FileName, struct _stat64i32 *_Stat)
     * }
     */
    public static FunctionDescriptor _stat64i32$descriptor() {
        return _stat64i32.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _stat64i32(const char *_FileName, struct _stat64i32 *_Stat)
     * }
     */
    public static MethodHandle _stat64i32$handle() {
        return _stat64i32.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _stat64i32(const char *_FileName, struct _stat64i32 *_Stat)
     * }
     */
    public static MemorySegment _stat64i32$address() {
        return _stat64i32.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _stat64i32(const char *_FileName, struct _stat64i32 *_Stat)
     * }
     */
    public static int _stat64i32(MemorySegment _FileName, MemorySegment _Stat) {
        var mh$ = _stat64i32.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_stat64i32", _FileName, _Stat);
            }
            return (int)mh$.invokeExact(_FileName, _Stat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _stat64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_stat64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _stat64(const char *_FileName, struct _stat64 *_Stat)
     * }
     */
    public static FunctionDescriptor _stat64$descriptor() {
        return _stat64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _stat64(const char *_FileName, struct _stat64 *_Stat)
     * }
     */
    public static MethodHandle _stat64$handle() {
        return _stat64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _stat64(const char *_FileName, struct _stat64 *_Stat)
     * }
     */
    public static MemorySegment _stat64$address() {
        return _stat64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _stat64(const char *_FileName, struct _stat64 *_Stat)
     * }
     */
    public static int _stat64(MemorySegment _FileName, MemorySegment _Stat) {
        var mh$ = _stat64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_stat64", _FileName, _Stat);
            }
            return (int)mh$.invokeExact(_FileName, _Stat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wstat32 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wstat32");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _wstat32(const wchar_t *_FileName, struct _stat32 *_Stat)
     * }
     */
    public static FunctionDescriptor _wstat32$descriptor() {
        return _wstat32.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _wstat32(const wchar_t *_FileName, struct _stat32 *_Stat)
     * }
     */
    public static MethodHandle _wstat32$handle() {
        return _wstat32.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _wstat32(const wchar_t *_FileName, struct _stat32 *_Stat)
     * }
     */
    public static MemorySegment _wstat32$address() {
        return _wstat32.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _wstat32(const wchar_t *_FileName, struct _stat32 *_Stat)
     * }
     */
    public static int _wstat32(MemorySegment _FileName, MemorySegment _Stat) {
        var mh$ = _wstat32.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wstat32", _FileName, _Stat);
            }
            return (int)mh$.invokeExact(_FileName, _Stat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wstat32i64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wstat32i64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _wstat32i64(const wchar_t *_FileName, struct _stat32i64 *_Stat)
     * }
     */
    public static FunctionDescriptor _wstat32i64$descriptor() {
        return _wstat32i64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _wstat32i64(const wchar_t *_FileName, struct _stat32i64 *_Stat)
     * }
     */
    public static MethodHandle _wstat32i64$handle() {
        return _wstat32i64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _wstat32i64(const wchar_t *_FileName, struct _stat32i64 *_Stat)
     * }
     */
    public static MemorySegment _wstat32i64$address() {
        return _wstat32i64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _wstat32i64(const wchar_t *_FileName, struct _stat32i64 *_Stat)
     * }
     */
    public static int _wstat32i64(MemorySegment _FileName, MemorySegment _Stat) {
        var mh$ = _wstat32i64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wstat32i64", _FileName, _Stat);
            }
            return (int)mh$.invokeExact(_FileName, _Stat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wstat64i32 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wstat64i32");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _wstat64i32(const wchar_t *_FileName, struct _stat64i32 *_Stat)
     * }
     */
    public static FunctionDescriptor _wstat64i32$descriptor() {
        return _wstat64i32.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _wstat64i32(const wchar_t *_FileName, struct _stat64i32 *_Stat)
     * }
     */
    public static MethodHandle _wstat64i32$handle() {
        return _wstat64i32.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _wstat64i32(const wchar_t *_FileName, struct _stat64i32 *_Stat)
     * }
     */
    public static MemorySegment _wstat64i32$address() {
        return _wstat64i32.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _wstat64i32(const wchar_t *_FileName, struct _stat64i32 *_Stat)
     * }
     */
    public static int _wstat64i32(MemorySegment _FileName, MemorySegment _Stat) {
        var mh$ = _wstat64i32.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wstat64i32", _FileName, _Stat);
            }
            return (int)mh$.invokeExact(_FileName, _Stat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wstat64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wstat64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _wstat64(const wchar_t *_FileName, struct _stat64 *_Stat)
     * }
     */
    public static FunctionDescriptor _wstat64$descriptor() {
        return _wstat64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _wstat64(const wchar_t *_FileName, struct _stat64 *_Stat)
     * }
     */
    public static MethodHandle _wstat64$handle() {
        return _wstat64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _wstat64(const wchar_t *_FileName, struct _stat64 *_Stat)
     * }
     */
    public static MemorySegment _wstat64$address() {
        return _wstat64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _wstat64(const wchar_t *_FileName, struct _stat64 *_Stat)
     * }
     */
    public static int _wstat64(MemorySegment _FileName, MemorySegment _Stat) {
        var mh$ = _wstat64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wstat64", _FileName, _Stat);
            }
            return (int)mh$.invokeExact(_FileName, _Stat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef wchar_t _Wint_t
     * }
     */
    public static final OfShort _Wint_t = Python_h.C_SHORT;

    private static class _wsetlocale {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wsetlocale");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *_wsetlocale(int _Category, const wchar_t *_Locale)
     * }
     */
    public static FunctionDescriptor _wsetlocale$descriptor() {
        return _wsetlocale.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *_wsetlocale(int _Category, const wchar_t *_Locale)
     * }
     */
    public static MethodHandle _wsetlocale$handle() {
        return _wsetlocale.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *_wsetlocale(int _Category, const wchar_t *_Locale)
     * }
     */
    public static MemorySegment _wsetlocale$address() {
        return _wsetlocale.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *_wsetlocale(int _Category, const wchar_t *_Locale)
     * }
     */
    public static MemorySegment _wsetlocale(int _Category, MemorySegment _Locale) {
        var mh$ = _wsetlocale.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wsetlocale", _Category, _Locale);
            }
            return (MemorySegment)mh$.invokeExact(_Category, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcreate_locale {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wcreate_locale");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _locale_t _wcreate_locale(int _Category, const wchar_t *_Locale)
     * }
     */
    public static FunctionDescriptor _wcreate_locale$descriptor() {
        return _wcreate_locale.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _locale_t _wcreate_locale(int _Category, const wchar_t *_Locale)
     * }
     */
    public static MethodHandle _wcreate_locale$handle() {
        return _wcreate_locale.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _locale_t _wcreate_locale(int _Category, const wchar_t *_Locale)
     * }
     */
    public static MemorySegment _wcreate_locale$address() {
        return _wcreate_locale.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _locale_t _wcreate_locale(int _Category, const wchar_t *_Locale)
     * }
     */
    public static MemorySegment _wcreate_locale(int _Category, MemorySegment _Locale) {
        var mh$ = _wcreate_locale.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcreate_locale", _Category, _Locale);
            }
            return (MemorySegment)mh$.invokeExact(_Category, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class btowc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_SHORT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("btowc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wint_t btowc(int _Ch)
     * }
     */
    public static FunctionDescriptor btowc$descriptor() {
        return btowc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wint_t btowc(int _Ch)
     * }
     */
    public static MethodHandle btowc$handle() {
        return btowc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wint_t btowc(int _Ch)
     * }
     */
    public static MemorySegment btowc$address() {
        return btowc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wint_t btowc(int _Ch)
     * }
     */
    public static short btowc(int _Ch) {
        var mh$ = btowc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("btowc", _Ch);
            }
            return (short)mh$.invokeExact(_Ch);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mbrlen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("mbrlen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t mbrlen(const char *_Ch, size_t _SizeInBytes, mbstate_t *_State)
     * }
     */
    public static FunctionDescriptor mbrlen$descriptor() {
        return mbrlen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t mbrlen(const char *_Ch, size_t _SizeInBytes, mbstate_t *_State)
     * }
     */
    public static MethodHandle mbrlen$handle() {
        return mbrlen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t mbrlen(const char *_Ch, size_t _SizeInBytes, mbstate_t *_State)
     * }
     */
    public static MemorySegment mbrlen$address() {
        return mbrlen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t mbrlen(const char *_Ch, size_t _SizeInBytes, mbstate_t *_State)
     * }
     */
    public static long mbrlen(MemorySegment _Ch, long _SizeInBytes, MemorySegment _State) {
        var mh$ = mbrlen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mbrlen", _Ch, _SizeInBytes, _State);
            }
            return (long)mh$.invokeExact(_Ch, _SizeInBytes, _State);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mbrtowc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("mbrtowc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t mbrtowc(wchar_t *_DstCh, const char *_SrcCh, size_t _SizeInBytes, mbstate_t *_State)
     * }
     */
    public static FunctionDescriptor mbrtowc$descriptor() {
        return mbrtowc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t mbrtowc(wchar_t *_DstCh, const char *_SrcCh, size_t _SizeInBytes, mbstate_t *_State)
     * }
     */
    public static MethodHandle mbrtowc$handle() {
        return mbrtowc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t mbrtowc(wchar_t *_DstCh, const char *_SrcCh, size_t _SizeInBytes, mbstate_t *_State)
     * }
     */
    public static MemorySegment mbrtowc$address() {
        return mbrtowc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t mbrtowc(wchar_t *_DstCh, const char *_SrcCh, size_t _SizeInBytes, mbstate_t *_State)
     * }
     */
    public static long mbrtowc(MemorySegment _DstCh, MemorySegment _SrcCh, long _SizeInBytes, MemorySegment _State) {
        var mh$ = mbrtowc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mbrtowc", _DstCh, _SrcCh, _SizeInBytes, _State);
            }
            return (long)mh$.invokeExact(_DstCh, _SrcCh, _SizeInBytes, _State);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mbsrtowcs_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("mbsrtowcs_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t mbsrtowcs_s(size_t *_Retval, wchar_t *_Dst, size_t _Size, const char **_PSrc, size_t _N, mbstate_t *_State)
     * }
     */
    public static FunctionDescriptor mbsrtowcs_s$descriptor() {
        return mbsrtowcs_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t mbsrtowcs_s(size_t *_Retval, wchar_t *_Dst, size_t _Size, const char **_PSrc, size_t _N, mbstate_t *_State)
     * }
     */
    public static MethodHandle mbsrtowcs_s$handle() {
        return mbsrtowcs_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t mbsrtowcs_s(size_t *_Retval, wchar_t *_Dst, size_t _Size, const char **_PSrc, size_t _N, mbstate_t *_State)
     * }
     */
    public static MemorySegment mbsrtowcs_s$address() {
        return mbsrtowcs_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t mbsrtowcs_s(size_t *_Retval, wchar_t *_Dst, size_t _Size, const char **_PSrc, size_t _N, mbstate_t *_State)
     * }
     */
    public static int mbsrtowcs_s(MemorySegment _Retval, MemorySegment _Dst, long _Size, MemorySegment _PSrc, long _N, MemorySegment _State) {
        var mh$ = mbsrtowcs_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mbsrtowcs_s", _Retval, _Dst, _Size, _PSrc, _N, _State);
            }
            return (int)mh$.invokeExact(_Retval, _Dst, _Size, _PSrc, _N, _State);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mbsrtowcs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("mbsrtowcs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t mbsrtowcs(wchar_t *_Dest, const char **_PSrc, size_t _Count, mbstate_t *_State)
     * }
     */
    public static FunctionDescriptor mbsrtowcs$descriptor() {
        return mbsrtowcs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t mbsrtowcs(wchar_t *_Dest, const char **_PSrc, size_t _Count, mbstate_t *_State)
     * }
     */
    public static MethodHandle mbsrtowcs$handle() {
        return mbsrtowcs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t mbsrtowcs(wchar_t *_Dest, const char **_PSrc, size_t _Count, mbstate_t *_State)
     * }
     */
    public static MemorySegment mbsrtowcs$address() {
        return mbsrtowcs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t mbsrtowcs(wchar_t *_Dest, const char **_PSrc, size_t _Count, mbstate_t *_State)
     * }
     */
    public static long mbsrtowcs(MemorySegment _Dest, MemorySegment _PSrc, long _Count, MemorySegment _State) {
        var mh$ = mbsrtowcs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mbsrtowcs", _Dest, _PSrc, _Count, _State);
            }
            return (long)mh$.invokeExact(_Dest, _PSrc, _Count, _State);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcrtomb_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_SHORT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcrtomb_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t wcrtomb_s(size_t *_Retval, char *_Dst, size_t _SizeInBytes, wchar_t _Ch, mbstate_t *_State)
     * }
     */
    public static FunctionDescriptor wcrtomb_s$descriptor() {
        return wcrtomb_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t wcrtomb_s(size_t *_Retval, char *_Dst, size_t _SizeInBytes, wchar_t _Ch, mbstate_t *_State)
     * }
     */
    public static MethodHandle wcrtomb_s$handle() {
        return wcrtomb_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t wcrtomb_s(size_t *_Retval, char *_Dst, size_t _SizeInBytes, wchar_t _Ch, mbstate_t *_State)
     * }
     */
    public static MemorySegment wcrtomb_s$address() {
        return wcrtomb_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t wcrtomb_s(size_t *_Retval, char *_Dst, size_t _SizeInBytes, wchar_t _Ch, mbstate_t *_State)
     * }
     */
    public static int wcrtomb_s(MemorySegment _Retval, MemorySegment _Dst, long _SizeInBytes, short _Ch, MemorySegment _State) {
        var mh$ = wcrtomb_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcrtomb_s", _Retval, _Dst, _SizeInBytes, _Ch, _State);
            }
            return (int)mh$.invokeExact(_Retval, _Dst, _SizeInBytes, _Ch, _State);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcrtomb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_SHORT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcrtomb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t wcrtomb(char *_Dest, wchar_t _Source, mbstate_t *_State)
     * }
     */
    public static FunctionDescriptor wcrtomb$descriptor() {
        return wcrtomb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t wcrtomb(char *_Dest, wchar_t _Source, mbstate_t *_State)
     * }
     */
    public static MethodHandle wcrtomb$handle() {
        return wcrtomb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t wcrtomb(char *_Dest, wchar_t _Source, mbstate_t *_State)
     * }
     */
    public static MemorySegment wcrtomb$address() {
        return wcrtomb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t wcrtomb(char *_Dest, wchar_t _Source, mbstate_t *_State)
     * }
     */
    public static long wcrtomb(MemorySegment _Dest, short _Source, MemorySegment _State) {
        var mh$ = wcrtomb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcrtomb", _Dest, _Source, _State);
            }
            return (long)mh$.invokeExact(_Dest, _Source, _State);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsrtombs_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcsrtombs_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t wcsrtombs_s(size_t *_Retval, char *_Dst, size_t _SizeInBytes, const wchar_t **_Src, size_t _Size, mbstate_t *_State)
     * }
     */
    public static FunctionDescriptor wcsrtombs_s$descriptor() {
        return wcsrtombs_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t wcsrtombs_s(size_t *_Retval, char *_Dst, size_t _SizeInBytes, const wchar_t **_Src, size_t _Size, mbstate_t *_State)
     * }
     */
    public static MethodHandle wcsrtombs_s$handle() {
        return wcsrtombs_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t wcsrtombs_s(size_t *_Retval, char *_Dst, size_t _SizeInBytes, const wchar_t **_Src, size_t _Size, mbstate_t *_State)
     * }
     */
    public static MemorySegment wcsrtombs_s$address() {
        return wcsrtombs_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t wcsrtombs_s(size_t *_Retval, char *_Dst, size_t _SizeInBytes, const wchar_t **_Src, size_t _Size, mbstate_t *_State)
     * }
     */
    public static int wcsrtombs_s(MemorySegment _Retval, MemorySegment _Dst, long _SizeInBytes, MemorySegment _Src, long _Size, MemorySegment _State) {
        var mh$ = wcsrtombs_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsrtombs_s", _Retval, _Dst, _SizeInBytes, _Src, _Size, _State);
            }
            return (int)mh$.invokeExact(_Retval, _Dst, _SizeInBytes, _Src, _Size, _State);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsrtombs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcsrtombs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t wcsrtombs(char *_Dest, const wchar_t **_PSource, size_t _Count, mbstate_t *_State)
     * }
     */
    public static FunctionDescriptor wcsrtombs$descriptor() {
        return wcsrtombs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t wcsrtombs(char *_Dest, const wchar_t **_PSource, size_t _Count, mbstate_t *_State)
     * }
     */
    public static MethodHandle wcsrtombs$handle() {
        return wcsrtombs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t wcsrtombs(char *_Dest, const wchar_t **_PSource, size_t _Count, mbstate_t *_State)
     * }
     */
    public static MemorySegment wcsrtombs$address() {
        return wcsrtombs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t wcsrtombs(char *_Dest, const wchar_t **_PSource, size_t _Count, mbstate_t *_State)
     * }
     */
    public static long wcsrtombs(MemorySegment _Dest, MemorySegment _PSource, long _Count, MemorySegment _State) {
        var mh$ = wcsrtombs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsrtombs", _Dest, _PSource, _Count, _State);
            }
            return (long)mh$.invokeExact(_Dest, _PSource, _Count, _State);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wctob {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_SHORT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wctob");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int wctob(wint_t _WCh)
     * }
     */
    public static FunctionDescriptor wctob$descriptor() {
        return wctob.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int wctob(wint_t _WCh)
     * }
     */
    public static MethodHandle wctob$handle() {
        return wctob.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int wctob(wint_t _WCh)
     * }
     */
    public static MemorySegment wctob$address() {
        return wctob.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int wctob(wint_t _WCh)
     * }
     */
    public static int wctob(short _WCh) {
        var mh$ = wctob.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wctob", _WCh);
            }
            return (int)mh$.invokeExact(_WCh);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wmemcpy_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wmemcpy_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t wmemcpy_s(wchar_t *_S1, rsize_t _N1, const wchar_t *_S2, rsize_t _N)
     * }
     */
    public static FunctionDescriptor wmemcpy_s$descriptor() {
        return wmemcpy_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t wmemcpy_s(wchar_t *_S1, rsize_t _N1, const wchar_t *_S2, rsize_t _N)
     * }
     */
    public static MethodHandle wmemcpy_s$handle() {
        return wmemcpy_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t wmemcpy_s(wchar_t *_S1, rsize_t _N1, const wchar_t *_S2, rsize_t _N)
     * }
     */
    public static MemorySegment wmemcpy_s$address() {
        return wmemcpy_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t wmemcpy_s(wchar_t *_S1, rsize_t _N1, const wchar_t *_S2, rsize_t _N)
     * }
     */
    public static int wmemcpy_s(MemorySegment _S1, long _N1, MemorySegment _S2, long _N) {
        var mh$ = wmemcpy_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wmemcpy_s", _S1, _N1, _S2, _N);
            }
            return (int)mh$.invokeExact(_S1, _N1, _S2, _N);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wmemmove_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wmemmove_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t wmemmove_s(wchar_t *_S1, rsize_t _N1, const wchar_t *_S2, rsize_t _N)
     * }
     */
    public static FunctionDescriptor wmemmove_s$descriptor() {
        return wmemmove_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t wmemmove_s(wchar_t *_S1, rsize_t _N1, const wchar_t *_S2, rsize_t _N)
     * }
     */
    public static MethodHandle wmemmove_s$handle() {
        return wmemmove_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t wmemmove_s(wchar_t *_S1, rsize_t _N1, const wchar_t *_S2, rsize_t _N)
     * }
     */
    public static MemorySegment wmemmove_s$address() {
        return wmemmove_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t wmemmove_s(wchar_t *_S1, rsize_t _N1, const wchar_t *_S2, rsize_t _N)
     * }
     */
    public static int wmemmove_s(MemorySegment _S1, long _N1, MemorySegment _S2, long _N) {
        var mh$ = wmemmove_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wmemmove_s", _S1, _N1, _S2, _N);
            }
            return (int)mh$.invokeExact(_S1, _N1, _S2, _N);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef signed char int8_t
     * }
     */
    public static final OfByte int8_t = Python_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef short int16_t
     * }
     */
    public static final OfShort int16_t = Python_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef int int32_t
     * }
     */
    public static final OfInt int32_t = Python_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long long int64_t
     * }
     */
    public static final OfLong int64_t = Python_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned char uint8_t
     * }
     */
    public static final OfByte uint8_t = Python_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned short uint16_t
     * }
     */
    public static final OfShort uint16_t = Python_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int uint32_t
     * }
     */
    public static final OfInt uint32_t = Python_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long long uint64_t
     * }
     */
    public static final OfLong uint64_t = Python_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef signed char int_least8_t
     * }
     */
    public static final OfByte int_least8_t = Python_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef short int_least16_t
     * }
     */
    public static final OfShort int_least16_t = Python_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef int int_least32_t
     * }
     */
    public static final OfInt int_least32_t = Python_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long long int_least64_t
     * }
     */
    public static final OfLong int_least64_t = Python_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned char uint_least8_t
     * }
     */
    public static final OfByte uint_least8_t = Python_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned short uint_least16_t
     * }
     */
    public static final OfShort uint_least16_t = Python_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int uint_least32_t
     * }
     */
    public static final OfInt uint_least32_t = Python_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long long uint_least64_t
     * }
     */
    public static final OfLong uint_least64_t = Python_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef signed char int_fast8_t
     * }
     */
    public static final OfByte int_fast8_t = Python_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef int int_fast16_t
     * }
     */
    public static final OfInt int_fast16_t = Python_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int int_fast32_t
     * }
     */
    public static final OfInt int_fast32_t = Python_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long long int_fast64_t
     * }
     */
    public static final OfLong int_fast64_t = Python_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned char uint_fast8_t
     * }
     */
    public static final OfByte uint_fast8_t = Python_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned int uint_fast16_t
     * }
     */
    public static final OfInt uint_fast16_t = Python_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int uint_fast32_t
     * }
     */
    public static final OfInt uint_fast32_t = Python_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long long uint_fast64_t
     * }
     */
    public static final OfLong uint_fast64_t = Python_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef long long intmax_t
     * }
     */
    public static final OfLong intmax_t = Python_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long long uintmax_t
     * }
     */
    public static final OfLong uintmax_t = Python_h.C_LONG_LONG;

    private static class imaxabs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("imaxabs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * intmax_t imaxabs(intmax_t _Number)
     * }
     */
    public static FunctionDescriptor imaxabs$descriptor() {
        return imaxabs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * intmax_t imaxabs(intmax_t _Number)
     * }
     */
    public static MethodHandle imaxabs$handle() {
        return imaxabs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * intmax_t imaxabs(intmax_t _Number)
     * }
     */
    public static MemorySegment imaxabs$address() {
        return imaxabs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * intmax_t imaxabs(intmax_t _Number)
     * }
     */
    public static long imaxabs(long _Number) {
        var mh$ = imaxabs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("imaxabs", _Number);
            }
            return (long)mh$.invokeExact(_Number);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class imaxdiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            _Lldiv_t$4.layout(),
            Python_h.C_LONG_LONG,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("imaxdiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * imaxdiv_t imaxdiv(intmax_t _Numerator, intmax_t _Denominator)
     * }
     */
    public static FunctionDescriptor imaxdiv$descriptor() {
        return imaxdiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * imaxdiv_t imaxdiv(intmax_t _Numerator, intmax_t _Denominator)
     * }
     */
    public static MethodHandle imaxdiv$handle() {
        return imaxdiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * imaxdiv_t imaxdiv(intmax_t _Numerator, intmax_t _Denominator)
     * }
     */
    public static MemorySegment imaxdiv$address() {
        return imaxdiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * imaxdiv_t imaxdiv(intmax_t _Numerator, intmax_t _Denominator)
     * }
     */
    public static MemorySegment imaxdiv(SegmentAllocator allocator, long _Numerator, long _Denominator) {
        var mh$ = imaxdiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("imaxdiv", allocator, _Numerator, _Denominator);
            }
            return (MemorySegment)mh$.invokeExact(allocator, _Numerator, _Denominator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtoimax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("strtoimax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * intmax_t strtoimax(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static FunctionDescriptor strtoimax$descriptor() {
        return strtoimax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * intmax_t strtoimax(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static MethodHandle strtoimax$handle() {
        return strtoimax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * intmax_t strtoimax(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static MemorySegment strtoimax$address() {
        return strtoimax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * intmax_t strtoimax(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static long strtoimax(MemorySegment _String, MemorySegment _EndPtr, int _Radix) {
        var mh$ = strtoimax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtoimax", _String, _EndPtr, _Radix);
            }
            return (long)mh$.invokeExact(_String, _EndPtr, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strtoimax_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_strtoimax_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * intmax_t _strtoimax_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _strtoimax_l$descriptor() {
        return _strtoimax_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * intmax_t _strtoimax_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MethodHandle _strtoimax_l$handle() {
        return _strtoimax_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * intmax_t _strtoimax_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MemorySegment _strtoimax_l$address() {
        return _strtoimax_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * intmax_t _strtoimax_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static long _strtoimax_l(MemorySegment _String, MemorySegment _EndPtr, int _Radix, MemorySegment _Locale) {
        var mh$ = _strtoimax_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strtoimax_l", _String, _EndPtr, _Radix, _Locale);
            }
            return (long)mh$.invokeExact(_String, _EndPtr, _Radix, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtoumax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("strtoumax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uintmax_t strtoumax(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static FunctionDescriptor strtoumax$descriptor() {
        return strtoumax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uintmax_t strtoumax(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static MethodHandle strtoumax$handle() {
        return strtoumax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uintmax_t strtoumax(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static MemorySegment strtoumax$address() {
        return strtoumax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uintmax_t strtoumax(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static long strtoumax(MemorySegment _String, MemorySegment _EndPtr, int _Radix) {
        var mh$ = strtoumax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtoumax", _String, _EndPtr, _Radix);
            }
            return (long)mh$.invokeExact(_String, _EndPtr, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strtoumax_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_strtoumax_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uintmax_t _strtoumax_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _strtoumax_l$descriptor() {
        return _strtoumax_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uintmax_t _strtoumax_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MethodHandle _strtoumax_l$handle() {
        return _strtoumax_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uintmax_t _strtoumax_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MemorySegment _strtoumax_l$address() {
        return _strtoumax_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uintmax_t _strtoumax_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static long _strtoumax_l(MemorySegment _String, MemorySegment _EndPtr, int _Radix, MemorySegment _Locale) {
        var mh$ = _strtoumax_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strtoumax_l", _String, _EndPtr, _Radix, _Locale);
            }
            return (long)mh$.invokeExact(_String, _EndPtr, _Radix, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcstoimax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcstoimax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * intmax_t wcstoimax(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static FunctionDescriptor wcstoimax$descriptor() {
        return wcstoimax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * intmax_t wcstoimax(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static MethodHandle wcstoimax$handle() {
        return wcstoimax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * intmax_t wcstoimax(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static MemorySegment wcstoimax$address() {
        return wcstoimax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * intmax_t wcstoimax(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static long wcstoimax(MemorySegment _String, MemorySegment _EndPtr, int _Radix) {
        var mh$ = wcstoimax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcstoimax", _String, _EndPtr, _Radix);
            }
            return (long)mh$.invokeExact(_String, _EndPtr, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcstoimax_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wcstoimax_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * intmax_t _wcstoimax_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcstoimax_l$descriptor() {
        return _wcstoimax_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * intmax_t _wcstoimax_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcstoimax_l$handle() {
        return _wcstoimax_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * intmax_t _wcstoimax_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcstoimax_l$address() {
        return _wcstoimax_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * intmax_t _wcstoimax_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static long _wcstoimax_l(MemorySegment _String, MemorySegment _EndPtr, int _Radix, MemorySegment _Locale) {
        var mh$ = _wcstoimax_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcstoimax_l", _String, _EndPtr, _Radix, _Locale);
            }
            return (long)mh$.invokeExact(_String, _EndPtr, _Radix, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcstoumax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcstoumax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uintmax_t wcstoumax(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static FunctionDescriptor wcstoumax$descriptor() {
        return wcstoumax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uintmax_t wcstoumax(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static MethodHandle wcstoumax$handle() {
        return wcstoumax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uintmax_t wcstoumax(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static MemorySegment wcstoumax$address() {
        return wcstoumax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uintmax_t wcstoumax(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static long wcstoumax(MemorySegment _String, MemorySegment _EndPtr, int _Radix) {
        var mh$ = wcstoumax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcstoumax", _String, _EndPtr, _Radix);
            }
            return (long)mh$.invokeExact(_String, _EndPtr, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcstoumax_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wcstoumax_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uintmax_t _wcstoumax_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcstoumax_l$descriptor() {
        return _wcstoumax_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uintmax_t _wcstoumax_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcstoumax_l$handle() {
        return _wcstoumax_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uintmax_t _wcstoumax_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcstoumax_l$address() {
        return _wcstoumax_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uintmax_t _wcstoumax_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static long _wcstoumax_l(MemorySegment _String, MemorySegment _EndPtr, int _Radix, MemorySegment _Locale) {
        var mh$ = _wcstoumax_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcstoumax_l", _String, _EndPtr, _Radix, _Locale);
            }
            return (long)mh$.invokeExact(_String, _EndPtr, _Radix, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef uintptr_t Py_uintptr_t
     * }
     */
    public static final OfLong Py_uintptr_t = Python_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef intptr_t Py_intptr_t
     * }
     */
    public static final OfLong Py_intptr_t = Python_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef Py_ssize_t Py_hash_t
     * }
     */
    public static final OfLong Py_hash_t = Python_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef size_t Py_uhash_t
     * }
     */
    public static final OfLong Py_uhash_t = Python_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef Py_ssize_t Py_ssize_clean_t
     * }
     */
    public static final OfLong Py_ssize_clean_t = Python_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef float float_t
     * }
     */
    public static final OfFloat float_t = Python_h.C_FLOAT;
    /**
     * {@snippet lang=c :
     * typedef double double_t
     * }
     */
    public static final OfDouble double_t = Python_h.C_DOUBLE;

    private static class _HUGE$constants {
        public static final OfDouble LAYOUT = Python_h.C_DOUBLE;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("_HUGE").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const double _HUGE
     * }
     */
    public static OfDouble _HUGE$layout() {
        return _HUGE$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const double _HUGE
     * }
     */
    public static MemorySegment _HUGE$segment() {
        return _HUGE$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const double _HUGE
     * }
     */
    public static double _HUGE() {
        return _HUGE$constants.SEGMENT.get(_HUGE$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const double _HUGE
     * }
     */
    public static void _HUGE(double varValue) {
        _HUGE$constants.SEGMENT.set(_HUGE$constants.LAYOUT, 0L, varValue);
    }

    private static class _fperrraise {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_fperrraise");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _fperrraise(int _Except)
     * }
     */
    public static FunctionDescriptor _fperrraise$descriptor() {
        return _fperrraise.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _fperrraise(int _Except)
     * }
     */
    public static MethodHandle _fperrraise$handle() {
        return _fperrraise.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _fperrraise(int _Except)
     * }
     */
    public static MemorySegment _fperrraise$address() {
        return _fperrraise.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _fperrraise(int _Except)
     * }
     */
    public static void _fperrraise(int _Except) {
        var mh$ = _fperrraise.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fperrraise", _Except);
            }
            mh$.invokeExact(_Except);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _dclass {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_SHORT,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_dclass");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * short _dclass(double _X)
     * }
     */
    public static FunctionDescriptor _dclass$descriptor() {
        return _dclass.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * short _dclass(double _X)
     * }
     */
    public static MethodHandle _dclass$handle() {
        return _dclass.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * short _dclass(double _X)
     * }
     */
    public static MemorySegment _dclass$address() {
        return _dclass.ADDR;
    }

    /**
     * {@snippet lang=c :
     * short _dclass(double _X)
     * }
     */
    public static short _dclass(double _X) {
        var mh$ = _dclass.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_dclass", _X);
            }
            return (short)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ldclass {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_SHORT,
            Python_h.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_ldclass");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * short _ldclass(long double _X)
     * }
     */
    public static FunctionDescriptor _ldclass$descriptor() {
        return _ldclass.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * short _ldclass(long double _X)
     * }
     */
    public static MethodHandle _ldclass$handle() {
        return _ldclass.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * short _ldclass(long double _X)
     * }
     */
    public static MemorySegment _ldclass$address() {
        return _ldclass.ADDR;
    }

    /**
     * {@snippet lang=c :
     * short _ldclass(long double _X)
     * }
     */
    public static short _ldclass(double _X) {
        var mh$ = _ldclass.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ldclass", _X);
            }
            return (short)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fdclass {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_SHORT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_fdclass");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * short _fdclass(float _X)
     * }
     */
    public static FunctionDescriptor _fdclass$descriptor() {
        return _fdclass.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * short _fdclass(float _X)
     * }
     */
    public static MethodHandle _fdclass$handle() {
        return _fdclass.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * short _fdclass(float _X)
     * }
     */
    public static MemorySegment _fdclass$address() {
        return _fdclass.ADDR;
    }

    /**
     * {@snippet lang=c :
     * short _fdclass(float _X)
     * }
     */
    public static short _fdclass(float _X) {
        var mh$ = _fdclass.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fdclass", _X);
            }
            return (short)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _dsign {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_dsign");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _dsign(double _X)
     * }
     */
    public static FunctionDescriptor _dsign$descriptor() {
        return _dsign.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _dsign(double _X)
     * }
     */
    public static MethodHandle _dsign$handle() {
        return _dsign.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _dsign(double _X)
     * }
     */
    public static MemorySegment _dsign$address() {
        return _dsign.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _dsign(double _X)
     * }
     */
    public static int _dsign(double _X) {
        var mh$ = _dsign.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_dsign", _X);
            }
            return (int)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ldsign {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_ldsign");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _ldsign(long double _X)
     * }
     */
    public static FunctionDescriptor _ldsign$descriptor() {
        return _ldsign.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _ldsign(long double _X)
     * }
     */
    public static MethodHandle _ldsign$handle() {
        return _ldsign.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _ldsign(long double _X)
     * }
     */
    public static MemorySegment _ldsign$address() {
        return _ldsign.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _ldsign(long double _X)
     * }
     */
    public static int _ldsign(double _X) {
        var mh$ = _ldsign.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ldsign", _X);
            }
            return (int)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fdsign {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_fdsign");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _fdsign(float _X)
     * }
     */
    public static FunctionDescriptor _fdsign$descriptor() {
        return _fdsign.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _fdsign(float _X)
     * }
     */
    public static MethodHandle _fdsign$handle() {
        return _fdsign.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _fdsign(float _X)
     * }
     */
    public static MemorySegment _fdsign$address() {
        return _fdsign.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _fdsign(float _X)
     * }
     */
    public static int _fdsign(float _X) {
        var mh$ = _fdsign.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fdsign", _X);
            }
            return (int)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _dpcomp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_dpcomp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _dpcomp(double _X, double _Y)
     * }
     */
    public static FunctionDescriptor _dpcomp$descriptor() {
        return _dpcomp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _dpcomp(double _X, double _Y)
     * }
     */
    public static MethodHandle _dpcomp$handle() {
        return _dpcomp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _dpcomp(double _X, double _Y)
     * }
     */
    public static MemorySegment _dpcomp$address() {
        return _dpcomp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _dpcomp(double _X, double _Y)
     * }
     */
    public static int _dpcomp(double _X, double _Y) {
        var mh$ = _dpcomp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_dpcomp", _X, _Y);
            }
            return (int)mh$.invokeExact(_X, _Y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ldpcomp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_LONG_DOUBLE,
            Python_h.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_ldpcomp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _ldpcomp(long double _X, long double _Y)
     * }
     */
    public static FunctionDescriptor _ldpcomp$descriptor() {
        return _ldpcomp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _ldpcomp(long double _X, long double _Y)
     * }
     */
    public static MethodHandle _ldpcomp$handle() {
        return _ldpcomp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _ldpcomp(long double _X, long double _Y)
     * }
     */
    public static MemorySegment _ldpcomp$address() {
        return _ldpcomp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _ldpcomp(long double _X, long double _Y)
     * }
     */
    public static int _ldpcomp(double _X, double _Y) {
        var mh$ = _ldpcomp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ldpcomp", _X, _Y);
            }
            return (int)mh$.invokeExact(_X, _Y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fdpcomp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_fdpcomp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _fdpcomp(float _X, float _Y)
     * }
     */
    public static FunctionDescriptor _fdpcomp$descriptor() {
        return _fdpcomp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _fdpcomp(float _X, float _Y)
     * }
     */
    public static MethodHandle _fdpcomp$handle() {
        return _fdpcomp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _fdpcomp(float _X, float _Y)
     * }
     */
    public static MemorySegment _fdpcomp$address() {
        return _fdpcomp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _fdpcomp(float _X, float _Y)
     * }
     */
    public static int _fdpcomp(float _X, float _Y) {
        var mh$ = _fdpcomp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fdpcomp", _X, _Y);
            }
            return (int)mh$.invokeExact(_X, _Y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _dtest {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_SHORT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_dtest");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * short _dtest(double *_Px)
     * }
     */
    public static FunctionDescriptor _dtest$descriptor() {
        return _dtest.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * short _dtest(double *_Px)
     * }
     */
    public static MethodHandle _dtest$handle() {
        return _dtest.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * short _dtest(double *_Px)
     * }
     */
    public static MemorySegment _dtest$address() {
        return _dtest.ADDR;
    }

    /**
     * {@snippet lang=c :
     * short _dtest(double *_Px)
     * }
     */
    public static short _dtest(MemorySegment _Px) {
        var mh$ = _dtest.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_dtest", _Px);
            }
            return (short)mh$.invokeExact(_Px);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ldtest {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_SHORT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_ldtest");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * short _ldtest(long double *_Px)
     * }
     */
    public static FunctionDescriptor _ldtest$descriptor() {
        return _ldtest.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * short _ldtest(long double *_Px)
     * }
     */
    public static MethodHandle _ldtest$handle() {
        return _ldtest.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * short _ldtest(long double *_Px)
     * }
     */
    public static MemorySegment _ldtest$address() {
        return _ldtest.ADDR;
    }

    /**
     * {@snippet lang=c :
     * short _ldtest(long double *_Px)
     * }
     */
    public static short _ldtest(MemorySegment _Px) {
        var mh$ = _ldtest.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ldtest", _Px);
            }
            return (short)mh$.invokeExact(_Px);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fdtest {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_SHORT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_fdtest");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * short _fdtest(float *_Px)
     * }
     */
    public static FunctionDescriptor _fdtest$descriptor() {
        return _fdtest.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * short _fdtest(float *_Px)
     * }
     */
    public static MethodHandle _fdtest$handle() {
        return _fdtest.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * short _fdtest(float *_Px)
     * }
     */
    public static MemorySegment _fdtest$address() {
        return _fdtest.ADDR;
    }

    /**
     * {@snippet lang=c :
     * short _fdtest(float *_Px)
     * }
     */
    public static short _fdtest(MemorySegment _Px) {
        var mh$ = _fdtest.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fdtest", _Px);
            }
            return (short)mh$.invokeExact(_Px);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _d_int {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_SHORT,
            Python_h.C_POINTER,
            Python_h.C_SHORT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_d_int");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * short _d_int(double *_Px, short _Xexp)
     * }
     */
    public static FunctionDescriptor _d_int$descriptor() {
        return _d_int.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * short _d_int(double *_Px, short _Xexp)
     * }
     */
    public static MethodHandle _d_int$handle() {
        return _d_int.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * short _d_int(double *_Px, short _Xexp)
     * }
     */
    public static MemorySegment _d_int$address() {
        return _d_int.ADDR;
    }

    /**
     * {@snippet lang=c :
     * short _d_int(double *_Px, short _Xexp)
     * }
     */
    public static short _d_int(MemorySegment _Px, short _Xexp) {
        var mh$ = _d_int.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_d_int", _Px, _Xexp);
            }
            return (short)mh$.invokeExact(_Px, _Xexp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ld_int {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_SHORT,
            Python_h.C_POINTER,
            Python_h.C_SHORT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_ld_int");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * short _ld_int(long double *_Px, short _Xexp)
     * }
     */
    public static FunctionDescriptor _ld_int$descriptor() {
        return _ld_int.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * short _ld_int(long double *_Px, short _Xexp)
     * }
     */
    public static MethodHandle _ld_int$handle() {
        return _ld_int.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * short _ld_int(long double *_Px, short _Xexp)
     * }
     */
    public static MemorySegment _ld_int$address() {
        return _ld_int.ADDR;
    }

    /**
     * {@snippet lang=c :
     * short _ld_int(long double *_Px, short _Xexp)
     * }
     */
    public static short _ld_int(MemorySegment _Px, short _Xexp) {
        var mh$ = _ld_int.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ld_int", _Px, _Xexp);
            }
            return (short)mh$.invokeExact(_Px, _Xexp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fd_int {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_SHORT,
            Python_h.C_POINTER,
            Python_h.C_SHORT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_fd_int");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * short _fd_int(float *_Px, short _Xexp)
     * }
     */
    public static FunctionDescriptor _fd_int$descriptor() {
        return _fd_int.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * short _fd_int(float *_Px, short _Xexp)
     * }
     */
    public static MethodHandle _fd_int$handle() {
        return _fd_int.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * short _fd_int(float *_Px, short _Xexp)
     * }
     */
    public static MemorySegment _fd_int$address() {
        return _fd_int.ADDR;
    }

    /**
     * {@snippet lang=c :
     * short _fd_int(float *_Px, short _Xexp)
     * }
     */
    public static short _fd_int(MemorySegment _Px, short _Xexp) {
        var mh$ = _fd_int.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fd_int", _Px, _Xexp);
            }
            return (short)mh$.invokeExact(_Px, _Xexp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _dscale {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_SHORT,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_dscale");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * short _dscale(double *_Px, long _Lexp)
     * }
     */
    public static FunctionDescriptor _dscale$descriptor() {
        return _dscale.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * short _dscale(double *_Px, long _Lexp)
     * }
     */
    public static MethodHandle _dscale$handle() {
        return _dscale.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * short _dscale(double *_Px, long _Lexp)
     * }
     */
    public static MemorySegment _dscale$address() {
        return _dscale.ADDR;
    }

    /**
     * {@snippet lang=c :
     * short _dscale(double *_Px, long _Lexp)
     * }
     */
    public static short _dscale(MemorySegment _Px, int _Lexp) {
        var mh$ = _dscale.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_dscale", _Px, _Lexp);
            }
            return (short)mh$.invokeExact(_Px, _Lexp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ldscale {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_SHORT,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_ldscale");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * short _ldscale(long double *_Px, long _Lexp)
     * }
     */
    public static FunctionDescriptor _ldscale$descriptor() {
        return _ldscale.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * short _ldscale(long double *_Px, long _Lexp)
     * }
     */
    public static MethodHandle _ldscale$handle() {
        return _ldscale.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * short _ldscale(long double *_Px, long _Lexp)
     * }
     */
    public static MemorySegment _ldscale$address() {
        return _ldscale.ADDR;
    }

    /**
     * {@snippet lang=c :
     * short _ldscale(long double *_Px, long _Lexp)
     * }
     */
    public static short _ldscale(MemorySegment _Px, int _Lexp) {
        var mh$ = _ldscale.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ldscale", _Px, _Lexp);
            }
            return (short)mh$.invokeExact(_Px, _Lexp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fdscale {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_SHORT,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_fdscale");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * short _fdscale(float *_Px, long _Lexp)
     * }
     */
    public static FunctionDescriptor _fdscale$descriptor() {
        return _fdscale.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * short _fdscale(float *_Px, long _Lexp)
     * }
     */
    public static MethodHandle _fdscale$handle() {
        return _fdscale.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * short _fdscale(float *_Px, long _Lexp)
     * }
     */
    public static MemorySegment _fdscale$address() {
        return _fdscale.ADDR;
    }

    /**
     * {@snippet lang=c :
     * short _fdscale(float *_Px, long _Lexp)
     * }
     */
    public static short _fdscale(MemorySegment _Px, int _Lexp) {
        var mh$ = _fdscale.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fdscale", _Px, _Lexp);
            }
            return (short)mh$.invokeExact(_Px, _Lexp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _dunscale {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_SHORT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_dunscale");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * short _dunscale(short *_Pex, double *_Px)
     * }
     */
    public static FunctionDescriptor _dunscale$descriptor() {
        return _dunscale.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * short _dunscale(short *_Pex, double *_Px)
     * }
     */
    public static MethodHandle _dunscale$handle() {
        return _dunscale.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * short _dunscale(short *_Pex, double *_Px)
     * }
     */
    public static MemorySegment _dunscale$address() {
        return _dunscale.ADDR;
    }

    /**
     * {@snippet lang=c :
     * short _dunscale(short *_Pex, double *_Px)
     * }
     */
    public static short _dunscale(MemorySegment _Pex, MemorySegment _Px) {
        var mh$ = _dunscale.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_dunscale", _Pex, _Px);
            }
            return (short)mh$.invokeExact(_Pex, _Px);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ldunscale {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_SHORT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_ldunscale");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * short _ldunscale(short *_Pex, long double *_Px)
     * }
     */
    public static FunctionDescriptor _ldunscale$descriptor() {
        return _ldunscale.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * short _ldunscale(short *_Pex, long double *_Px)
     * }
     */
    public static MethodHandle _ldunscale$handle() {
        return _ldunscale.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * short _ldunscale(short *_Pex, long double *_Px)
     * }
     */
    public static MemorySegment _ldunscale$address() {
        return _ldunscale.ADDR;
    }

    /**
     * {@snippet lang=c :
     * short _ldunscale(short *_Pex, long double *_Px)
     * }
     */
    public static short _ldunscale(MemorySegment _Pex, MemorySegment _Px) {
        var mh$ = _ldunscale.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ldunscale", _Pex, _Px);
            }
            return (short)mh$.invokeExact(_Pex, _Px);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fdunscale {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_SHORT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_fdunscale");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * short _fdunscale(short *_Pex, float *_Px)
     * }
     */
    public static FunctionDescriptor _fdunscale$descriptor() {
        return _fdunscale.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * short _fdunscale(short *_Pex, float *_Px)
     * }
     */
    public static MethodHandle _fdunscale$handle() {
        return _fdunscale.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * short _fdunscale(short *_Pex, float *_Px)
     * }
     */
    public static MemorySegment _fdunscale$address() {
        return _fdunscale.ADDR;
    }

    /**
     * {@snippet lang=c :
     * short _fdunscale(short *_Pex, float *_Px)
     * }
     */
    public static short _fdunscale(MemorySegment _Pex, MemorySegment _Px) {
        var mh$ = _fdunscale.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fdunscale", _Pex, _Px);
            }
            return (short)mh$.invokeExact(_Pex, _Px);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _dexp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_SHORT,
            Python_h.C_POINTER,
            Python_h.C_DOUBLE,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_dexp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * short _dexp(double *_Px, double _Y, long _Eoff)
     * }
     */
    public static FunctionDescriptor _dexp$descriptor() {
        return _dexp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * short _dexp(double *_Px, double _Y, long _Eoff)
     * }
     */
    public static MethodHandle _dexp$handle() {
        return _dexp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * short _dexp(double *_Px, double _Y, long _Eoff)
     * }
     */
    public static MemorySegment _dexp$address() {
        return _dexp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * short _dexp(double *_Px, double _Y, long _Eoff)
     * }
     */
    public static short _dexp(MemorySegment _Px, double _Y, int _Eoff) {
        var mh$ = _dexp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_dexp", _Px, _Y, _Eoff);
            }
            return (short)mh$.invokeExact(_Px, _Y, _Eoff);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ldexp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_SHORT,
            Python_h.C_POINTER,
            Python_h.C_LONG_DOUBLE,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_ldexp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * short _ldexp(long double *_Px, long double _Y, long _Eoff)
     * }
     */
    public static FunctionDescriptor _ldexp$descriptor() {
        return _ldexp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * short _ldexp(long double *_Px, long double _Y, long _Eoff)
     * }
     */
    public static MethodHandle _ldexp$handle() {
        return _ldexp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * short _ldexp(long double *_Px, long double _Y, long _Eoff)
     * }
     */
    public static MemorySegment _ldexp$address() {
        return _ldexp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * short _ldexp(long double *_Px, long double _Y, long _Eoff)
     * }
     */
    public static short _ldexp(MemorySegment _Px, double _Y, int _Eoff) {
        var mh$ = _ldexp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ldexp", _Px, _Y, _Eoff);
            }
            return (short)mh$.invokeExact(_Px, _Y, _Eoff);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fdexp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_SHORT,
            Python_h.C_POINTER,
            Python_h.C_FLOAT,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_fdexp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * short _fdexp(float *_Px, float _Y, long _Eoff)
     * }
     */
    public static FunctionDescriptor _fdexp$descriptor() {
        return _fdexp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * short _fdexp(float *_Px, float _Y, long _Eoff)
     * }
     */
    public static MethodHandle _fdexp$handle() {
        return _fdexp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * short _fdexp(float *_Px, float _Y, long _Eoff)
     * }
     */
    public static MemorySegment _fdexp$address() {
        return _fdexp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * short _fdexp(float *_Px, float _Y, long _Eoff)
     * }
     */
    public static short _fdexp(MemorySegment _Px, float _Y, int _Eoff) {
        var mh$ = _fdexp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fdexp", _Px, _Y, _Eoff);
            }
            return (short)mh$.invokeExact(_Px, _Y, _Eoff);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _dnorm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_SHORT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_dnorm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * short _dnorm(unsigned short *_Ps)
     * }
     */
    public static FunctionDescriptor _dnorm$descriptor() {
        return _dnorm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * short _dnorm(unsigned short *_Ps)
     * }
     */
    public static MethodHandle _dnorm$handle() {
        return _dnorm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * short _dnorm(unsigned short *_Ps)
     * }
     */
    public static MemorySegment _dnorm$address() {
        return _dnorm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * short _dnorm(unsigned short *_Ps)
     * }
     */
    public static short _dnorm(MemorySegment _Ps) {
        var mh$ = _dnorm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_dnorm", _Ps);
            }
            return (short)mh$.invokeExact(_Ps);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fdnorm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_SHORT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_fdnorm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * short _fdnorm(unsigned short *_Ps)
     * }
     */
    public static FunctionDescriptor _fdnorm$descriptor() {
        return _fdnorm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * short _fdnorm(unsigned short *_Ps)
     * }
     */
    public static MethodHandle _fdnorm$handle() {
        return _fdnorm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * short _fdnorm(unsigned short *_Ps)
     * }
     */
    public static MemorySegment _fdnorm$address() {
        return _fdnorm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * short _fdnorm(unsigned short *_Ps)
     * }
     */
    public static short _fdnorm(MemorySegment _Ps) {
        var mh$ = _fdnorm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fdnorm", _Ps);
            }
            return (short)mh$.invokeExact(_Ps);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _dpoly {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_dpoly");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double _dpoly(double _X, const double *_Tab, int _N)
     * }
     */
    public static FunctionDescriptor _dpoly$descriptor() {
        return _dpoly.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double _dpoly(double _X, const double *_Tab, int _N)
     * }
     */
    public static MethodHandle _dpoly$handle() {
        return _dpoly.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double _dpoly(double _X, const double *_Tab, int _N)
     * }
     */
    public static MemorySegment _dpoly$address() {
        return _dpoly.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double _dpoly(double _X, const double *_Tab, int _N)
     * }
     */
    public static double _dpoly(double _X, MemorySegment _Tab, int _N) {
        var mh$ = _dpoly.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_dpoly", _X, _Tab, _N);
            }
            return (double)mh$.invokeExact(_X, _Tab, _N);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ldpoly {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_DOUBLE,
            Python_h.C_LONG_DOUBLE,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_ldpoly");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double _ldpoly(long double _X, const long double *_Tab, int _N)
     * }
     */
    public static FunctionDescriptor _ldpoly$descriptor() {
        return _ldpoly.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double _ldpoly(long double _X, const long double *_Tab, int _N)
     * }
     */
    public static MethodHandle _ldpoly$handle() {
        return _ldpoly.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double _ldpoly(long double _X, const long double *_Tab, int _N)
     * }
     */
    public static MemorySegment _ldpoly$address() {
        return _ldpoly.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double _ldpoly(long double _X, const long double *_Tab, int _N)
     * }
     */
    public static double _ldpoly(double _X, MemorySegment _Tab, int _N) {
        var mh$ = _ldpoly.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ldpoly", _X, _Tab, _N);
            }
            return (double)mh$.invokeExact(_X, _Tab, _N);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fdpoly {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_fdpoly");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float _fdpoly(float _X, const float *_Tab, int _N)
     * }
     */
    public static FunctionDescriptor _fdpoly$descriptor() {
        return _fdpoly.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float _fdpoly(float _X, const float *_Tab, int _N)
     * }
     */
    public static MethodHandle _fdpoly$handle() {
        return _fdpoly.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float _fdpoly(float _X, const float *_Tab, int _N)
     * }
     */
    public static MemorySegment _fdpoly$address() {
        return _fdpoly.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float _fdpoly(float _X, const float *_Tab, int _N)
     * }
     */
    public static float _fdpoly(float _X, MemorySegment _Tab, int _N) {
        var mh$ = _fdpoly.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fdpoly", _X, _Tab, _N);
            }
            return (float)mh$.invokeExact(_X, _Tab, _N);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _dlog {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_dlog");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double _dlog(double _X, int _Baseflag)
     * }
     */
    public static FunctionDescriptor _dlog$descriptor() {
        return _dlog.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double _dlog(double _X, int _Baseflag)
     * }
     */
    public static MethodHandle _dlog$handle() {
        return _dlog.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double _dlog(double _X, int _Baseflag)
     * }
     */
    public static MemorySegment _dlog$address() {
        return _dlog.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double _dlog(double _X, int _Baseflag)
     * }
     */
    public static double _dlog(double _X, int _Baseflag) {
        var mh$ = _dlog.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_dlog", _X, _Baseflag);
            }
            return (double)mh$.invokeExact(_X, _Baseflag);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ldlog {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_DOUBLE,
            Python_h.C_LONG_DOUBLE,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_ldlog");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double _ldlog(long double _X, int _Baseflag)
     * }
     */
    public static FunctionDescriptor _ldlog$descriptor() {
        return _ldlog.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double _ldlog(long double _X, int _Baseflag)
     * }
     */
    public static MethodHandle _ldlog$handle() {
        return _ldlog.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double _ldlog(long double _X, int _Baseflag)
     * }
     */
    public static MemorySegment _ldlog$address() {
        return _ldlog.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double _ldlog(long double _X, int _Baseflag)
     * }
     */
    public static double _ldlog(double _X, int _Baseflag) {
        var mh$ = _ldlog.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ldlog", _X, _Baseflag);
            }
            return (double)mh$.invokeExact(_X, _Baseflag);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fdlog {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_fdlog");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float _fdlog(float _X, int _Baseflag)
     * }
     */
    public static FunctionDescriptor _fdlog$descriptor() {
        return _fdlog.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float _fdlog(float _X, int _Baseflag)
     * }
     */
    public static MethodHandle _fdlog$handle() {
        return _fdlog.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float _fdlog(float _X, int _Baseflag)
     * }
     */
    public static MemorySegment _fdlog$address() {
        return _fdlog.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float _fdlog(float _X, int _Baseflag)
     * }
     */
    public static float _fdlog(float _X, int _Baseflag) {
        var mh$ = _fdlog.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fdlog", _X, _Baseflag);
            }
            return (float)mh$.invokeExact(_X, _Baseflag);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _dsin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_dsin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double _dsin(double _X, unsigned int _Qoff)
     * }
     */
    public static FunctionDescriptor _dsin$descriptor() {
        return _dsin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double _dsin(double _X, unsigned int _Qoff)
     * }
     */
    public static MethodHandle _dsin$handle() {
        return _dsin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double _dsin(double _X, unsigned int _Qoff)
     * }
     */
    public static MemorySegment _dsin$address() {
        return _dsin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double _dsin(double _X, unsigned int _Qoff)
     * }
     */
    public static double _dsin(double _X, int _Qoff) {
        var mh$ = _dsin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_dsin", _X, _Qoff);
            }
            return (double)mh$.invokeExact(_X, _Qoff);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ldsin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_DOUBLE,
            Python_h.C_LONG_DOUBLE,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_ldsin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double _ldsin(long double _X, unsigned int _Qoff)
     * }
     */
    public static FunctionDescriptor _ldsin$descriptor() {
        return _ldsin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double _ldsin(long double _X, unsigned int _Qoff)
     * }
     */
    public static MethodHandle _ldsin$handle() {
        return _ldsin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double _ldsin(long double _X, unsigned int _Qoff)
     * }
     */
    public static MemorySegment _ldsin$address() {
        return _ldsin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double _ldsin(long double _X, unsigned int _Qoff)
     * }
     */
    public static double _ldsin(double _X, int _Qoff) {
        var mh$ = _ldsin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ldsin", _X, _Qoff);
            }
            return (double)mh$.invokeExact(_X, _Qoff);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fdsin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_fdsin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float _fdsin(float _X, unsigned int _Qoff)
     * }
     */
    public static FunctionDescriptor _fdsin$descriptor() {
        return _fdsin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float _fdsin(float _X, unsigned int _Qoff)
     * }
     */
    public static MethodHandle _fdsin$handle() {
        return _fdsin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float _fdsin(float _X, unsigned int _Qoff)
     * }
     */
    public static MemorySegment _fdsin$address() {
        return _fdsin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float _fdsin(float _X, unsigned int _Qoff)
     * }
     */
    public static float _fdsin(float _X, int _Qoff) {
        var mh$ = _fdsin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fdsin", _X, _Qoff);
            }
            return (float)mh$.invokeExact(_X, _Qoff);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _Denorm_C$constants {
        public static final GroupLayout LAYOUT = _float_const.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("_Denorm_C").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const _float_const _Denorm_C
     * }
     */
    public static GroupLayout _Denorm_C$layout() {
        return _Denorm_C$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const _float_const _Denorm_C
     * }
     */
    public static MemorySegment _Denorm_C() {
        return _Denorm_C$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const _float_const _Denorm_C
     * }
     */
    public static void _Denorm_C(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, _Denorm_C$constants.SEGMENT, 0L, _Denorm_C$constants.LAYOUT.byteSize());
    }

    private static class _Inf_C$constants {
        public static final GroupLayout LAYOUT = _float_const.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("_Inf_C").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const _float_const _Inf_C
     * }
     */
    public static GroupLayout _Inf_C$layout() {
        return _Inf_C$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const _float_const _Inf_C
     * }
     */
    public static MemorySegment _Inf_C() {
        return _Inf_C$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const _float_const _Inf_C
     * }
     */
    public static void _Inf_C(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, _Inf_C$constants.SEGMENT, 0L, _Inf_C$constants.LAYOUT.byteSize());
    }

    private static class _Nan_C$constants {
        public static final GroupLayout LAYOUT = _float_const.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("_Nan_C").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const _float_const _Nan_C
     * }
     */
    public static GroupLayout _Nan_C$layout() {
        return _Nan_C$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const _float_const _Nan_C
     * }
     */
    public static MemorySegment _Nan_C() {
        return _Nan_C$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const _float_const _Nan_C
     * }
     */
    public static void _Nan_C(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, _Nan_C$constants.SEGMENT, 0L, _Nan_C$constants.LAYOUT.byteSize());
    }

    private static class _Snan_C$constants {
        public static final GroupLayout LAYOUT = _float_const.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("_Snan_C").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const _float_const _Snan_C
     * }
     */
    public static GroupLayout _Snan_C$layout() {
        return _Snan_C$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const _float_const _Snan_C
     * }
     */
    public static MemorySegment _Snan_C() {
        return _Snan_C$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const _float_const _Snan_C
     * }
     */
    public static void _Snan_C(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, _Snan_C$constants.SEGMENT, 0L, _Snan_C$constants.LAYOUT.byteSize());
    }

    private static class _Hugeval_C$constants {
        public static final GroupLayout LAYOUT = _float_const.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("_Hugeval_C").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const _float_const _Hugeval_C
     * }
     */
    public static GroupLayout _Hugeval_C$layout() {
        return _Hugeval_C$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const _float_const _Hugeval_C
     * }
     */
    public static MemorySegment _Hugeval_C() {
        return _Hugeval_C$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const _float_const _Hugeval_C
     * }
     */
    public static void _Hugeval_C(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, _Hugeval_C$constants.SEGMENT, 0L, _Hugeval_C$constants.LAYOUT.byteSize());
    }

    private static class _FDenorm_C$constants {
        public static final GroupLayout LAYOUT = _float_const.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("_FDenorm_C").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const _float_const _FDenorm_C
     * }
     */
    public static GroupLayout _FDenorm_C$layout() {
        return _FDenorm_C$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const _float_const _FDenorm_C
     * }
     */
    public static MemorySegment _FDenorm_C() {
        return _FDenorm_C$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const _float_const _FDenorm_C
     * }
     */
    public static void _FDenorm_C(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, _FDenorm_C$constants.SEGMENT, 0L, _FDenorm_C$constants.LAYOUT.byteSize());
    }

    private static class _FInf_C$constants {
        public static final GroupLayout LAYOUT = _float_const.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("_FInf_C").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const _float_const _FInf_C
     * }
     */
    public static GroupLayout _FInf_C$layout() {
        return _FInf_C$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const _float_const _FInf_C
     * }
     */
    public static MemorySegment _FInf_C() {
        return _FInf_C$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const _float_const _FInf_C
     * }
     */
    public static void _FInf_C(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, _FInf_C$constants.SEGMENT, 0L, _FInf_C$constants.LAYOUT.byteSize());
    }

    private static class _FNan_C$constants {
        public static final GroupLayout LAYOUT = _float_const.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("_FNan_C").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const _float_const _FNan_C
     * }
     */
    public static GroupLayout _FNan_C$layout() {
        return _FNan_C$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const _float_const _FNan_C
     * }
     */
    public static MemorySegment _FNan_C() {
        return _FNan_C$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const _float_const _FNan_C
     * }
     */
    public static void _FNan_C(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, _FNan_C$constants.SEGMENT, 0L, _FNan_C$constants.LAYOUT.byteSize());
    }

    private static class _FSnan_C$constants {
        public static final GroupLayout LAYOUT = _float_const.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("_FSnan_C").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const _float_const _FSnan_C
     * }
     */
    public static GroupLayout _FSnan_C$layout() {
        return _FSnan_C$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const _float_const _FSnan_C
     * }
     */
    public static MemorySegment _FSnan_C() {
        return _FSnan_C$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const _float_const _FSnan_C
     * }
     */
    public static void _FSnan_C(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, _FSnan_C$constants.SEGMENT, 0L, _FSnan_C$constants.LAYOUT.byteSize());
    }

    private static class _LDenorm_C$constants {
        public static final GroupLayout LAYOUT = _float_const.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("_LDenorm_C").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const _float_const _LDenorm_C
     * }
     */
    public static GroupLayout _LDenorm_C$layout() {
        return _LDenorm_C$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const _float_const _LDenorm_C
     * }
     */
    public static MemorySegment _LDenorm_C() {
        return _LDenorm_C$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const _float_const _LDenorm_C
     * }
     */
    public static void _LDenorm_C(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, _LDenorm_C$constants.SEGMENT, 0L, _LDenorm_C$constants.LAYOUT.byteSize());
    }

    private static class _LInf_C$constants {
        public static final GroupLayout LAYOUT = _float_const.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("_LInf_C").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const _float_const _LInf_C
     * }
     */
    public static GroupLayout _LInf_C$layout() {
        return _LInf_C$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const _float_const _LInf_C
     * }
     */
    public static MemorySegment _LInf_C() {
        return _LInf_C$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const _float_const _LInf_C
     * }
     */
    public static void _LInf_C(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, _LInf_C$constants.SEGMENT, 0L, _LInf_C$constants.LAYOUT.byteSize());
    }

    private static class _LNan_C$constants {
        public static final GroupLayout LAYOUT = _float_const.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("_LNan_C").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const _float_const _LNan_C
     * }
     */
    public static GroupLayout _LNan_C$layout() {
        return _LNan_C$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const _float_const _LNan_C
     * }
     */
    public static MemorySegment _LNan_C() {
        return _LNan_C$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const _float_const _LNan_C
     * }
     */
    public static void _LNan_C(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, _LNan_C$constants.SEGMENT, 0L, _LNan_C$constants.LAYOUT.byteSize());
    }

    private static class _LSnan_C$constants {
        public static final GroupLayout LAYOUT = _float_const.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("_LSnan_C").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const _float_const _LSnan_C
     * }
     */
    public static GroupLayout _LSnan_C$layout() {
        return _LSnan_C$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const _float_const _LSnan_C
     * }
     */
    public static MemorySegment _LSnan_C() {
        return _LSnan_C$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const _float_const _LSnan_C
     * }
     */
    public static void _LSnan_C(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, _LSnan_C$constants.SEGMENT, 0L, _LSnan_C$constants.LAYOUT.byteSize());
    }

    private static class _Eps_C$constants {
        public static final GroupLayout LAYOUT = _float_const.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("_Eps_C").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const _float_const _Eps_C
     * }
     */
    public static GroupLayout _Eps_C$layout() {
        return _Eps_C$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const _float_const _Eps_C
     * }
     */
    public static MemorySegment _Eps_C() {
        return _Eps_C$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const _float_const _Eps_C
     * }
     */
    public static void _Eps_C(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, _Eps_C$constants.SEGMENT, 0L, _Eps_C$constants.LAYOUT.byteSize());
    }

    private static class _Rteps_C$constants {
        public static final GroupLayout LAYOUT = _float_const.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("_Rteps_C").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const _float_const _Rteps_C
     * }
     */
    public static GroupLayout _Rteps_C$layout() {
        return _Rteps_C$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const _float_const _Rteps_C
     * }
     */
    public static MemorySegment _Rteps_C() {
        return _Rteps_C$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const _float_const _Rteps_C
     * }
     */
    public static void _Rteps_C(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, _Rteps_C$constants.SEGMENT, 0L, _Rteps_C$constants.LAYOUT.byteSize());
    }

    private static class _FEps_C$constants {
        public static final GroupLayout LAYOUT = _float_const.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("_FEps_C").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const _float_const _FEps_C
     * }
     */
    public static GroupLayout _FEps_C$layout() {
        return _FEps_C$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const _float_const _FEps_C
     * }
     */
    public static MemorySegment _FEps_C() {
        return _FEps_C$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const _float_const _FEps_C
     * }
     */
    public static void _FEps_C(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, _FEps_C$constants.SEGMENT, 0L, _FEps_C$constants.LAYOUT.byteSize());
    }

    private static class _FRteps_C$constants {
        public static final GroupLayout LAYOUT = _float_const.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("_FRteps_C").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const _float_const _FRteps_C
     * }
     */
    public static GroupLayout _FRteps_C$layout() {
        return _FRteps_C$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const _float_const _FRteps_C
     * }
     */
    public static MemorySegment _FRteps_C() {
        return _FRteps_C$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const _float_const _FRteps_C
     * }
     */
    public static void _FRteps_C(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, _FRteps_C$constants.SEGMENT, 0L, _FRteps_C$constants.LAYOUT.byteSize());
    }

    private static class _LEps_C$constants {
        public static final GroupLayout LAYOUT = _float_const.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("_LEps_C").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const _float_const _LEps_C
     * }
     */
    public static GroupLayout _LEps_C$layout() {
        return _LEps_C$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const _float_const _LEps_C
     * }
     */
    public static MemorySegment _LEps_C() {
        return _LEps_C$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const _float_const _LEps_C
     * }
     */
    public static void _LEps_C(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, _LEps_C$constants.SEGMENT, 0L, _LEps_C$constants.LAYOUT.byteSize());
    }

    private static class _LRteps_C$constants {
        public static final GroupLayout LAYOUT = _float_const.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("_LRteps_C").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const _float_const _LRteps_C
     * }
     */
    public static GroupLayout _LRteps_C$layout() {
        return _LRteps_C$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const _float_const _LRteps_C
     * }
     */
    public static MemorySegment _LRteps_C() {
        return _LRteps_C$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const _float_const _LRteps_C
     * }
     */
    public static void _LRteps_C(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, _LRteps_C$constants.SEGMENT, 0L, _LRteps_C$constants.LAYOUT.byteSize());
    }

    private static class _Zero_C$constants {
        public static final OfDouble LAYOUT = Python_h.C_DOUBLE;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("_Zero_C").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const double _Zero_C
     * }
     */
    public static OfDouble _Zero_C$layout() {
        return _Zero_C$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const double _Zero_C
     * }
     */
    public static MemorySegment _Zero_C$segment() {
        return _Zero_C$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const double _Zero_C
     * }
     */
    public static double _Zero_C() {
        return _Zero_C$constants.SEGMENT.get(_Zero_C$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const double _Zero_C
     * }
     */
    public static void _Zero_C(double varValue) {
        _Zero_C$constants.SEGMENT.set(_Zero_C$constants.LAYOUT, 0L, varValue);
    }

    private static class _Xbig_C$constants {
        public static final OfDouble LAYOUT = Python_h.C_DOUBLE;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("_Xbig_C").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const double _Xbig_C
     * }
     */
    public static OfDouble _Xbig_C$layout() {
        return _Xbig_C$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const double _Xbig_C
     * }
     */
    public static MemorySegment _Xbig_C$segment() {
        return _Xbig_C$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const double _Xbig_C
     * }
     */
    public static double _Xbig_C() {
        return _Xbig_C$constants.SEGMENT.get(_Xbig_C$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const double _Xbig_C
     * }
     */
    public static void _Xbig_C(double varValue) {
        _Xbig_C$constants.SEGMENT.set(_Xbig_C$constants.LAYOUT, 0L, varValue);
    }

    private static class _FZero_C$constants {
        public static final OfFloat LAYOUT = Python_h.C_FLOAT;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("_FZero_C").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const float _FZero_C
     * }
     */
    public static OfFloat _FZero_C$layout() {
        return _FZero_C$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const float _FZero_C
     * }
     */
    public static MemorySegment _FZero_C$segment() {
        return _FZero_C$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const float _FZero_C
     * }
     */
    public static float _FZero_C() {
        return _FZero_C$constants.SEGMENT.get(_FZero_C$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const float _FZero_C
     * }
     */
    public static void _FZero_C(float varValue) {
        _FZero_C$constants.SEGMENT.set(_FZero_C$constants.LAYOUT, 0L, varValue);
    }

    private static class _FXbig_C$constants {
        public static final OfFloat LAYOUT = Python_h.C_FLOAT;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("_FXbig_C").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const float _FXbig_C
     * }
     */
    public static OfFloat _FXbig_C$layout() {
        return _FXbig_C$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const float _FXbig_C
     * }
     */
    public static MemorySegment _FXbig_C$segment() {
        return _FXbig_C$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const float _FXbig_C
     * }
     */
    public static float _FXbig_C() {
        return _FXbig_C$constants.SEGMENT.get(_FXbig_C$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const float _FXbig_C
     * }
     */
    public static void _FXbig_C(float varValue) {
        _FXbig_C$constants.SEGMENT.set(_FXbig_C$constants.LAYOUT, 0L, varValue);
    }

    private static class _LZero_C$constants {
        public static final OfDouble LAYOUT = Python_h.C_LONG_DOUBLE;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("_LZero_C").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const long double _LZero_C
     * }
     */
    public static OfDouble _LZero_C$layout() {
        return _LZero_C$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const long double _LZero_C
     * }
     */
    public static MemorySegment _LZero_C$segment() {
        return _LZero_C$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const long double _LZero_C
     * }
     */
    public static double _LZero_C() {
        return _LZero_C$constants.SEGMENT.get(_LZero_C$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const long double _LZero_C
     * }
     */
    public static void _LZero_C(double varValue) {
        _LZero_C$constants.SEGMENT.set(_LZero_C$constants.LAYOUT, 0L, varValue);
    }

    private static class _LXbig_C$constants {
        public static final OfDouble LAYOUT = Python_h.C_LONG_DOUBLE;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("_LXbig_C").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const long double _LXbig_C
     * }
     */
    public static OfDouble _LXbig_C$layout() {
        return _LXbig_C$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const long double _LXbig_C
     * }
     */
    public static MemorySegment _LXbig_C$segment() {
        return _LXbig_C$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const long double _LXbig_C
     * }
     */
    public static double _LXbig_C() {
        return _LXbig_C$constants.SEGMENT.get(_LXbig_C$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const long double _LXbig_C
     * }
     */
    public static void _LXbig_C(double varValue) {
        _LXbig_C$constants.SEGMENT.set(_LXbig_C$constants.LAYOUT, 0L, varValue);
    }

    private static class acos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("acos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double acos(double _X)
     * }
     */
    public static FunctionDescriptor acos$descriptor() {
        return acos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double acos(double _X)
     * }
     */
    public static MethodHandle acos$handle() {
        return acos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double acos(double _X)
     * }
     */
    public static MemorySegment acos$address() {
        return acos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double acos(double _X)
     * }
     */
    public static double acos(double _X) {
        var mh$ = acos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("acos", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("asin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double asin(double _X)
     * }
     */
    public static FunctionDescriptor asin$descriptor() {
        return asin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double asin(double _X)
     * }
     */
    public static MethodHandle asin$handle() {
        return asin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double asin(double _X)
     * }
     */
    public static MemorySegment asin$address() {
        return asin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double asin(double _X)
     * }
     */
    public static double asin(double _X) {
        var mh$ = asin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("asin", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atan {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("atan");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double atan(double _X)
     * }
     */
    public static FunctionDescriptor atan$descriptor() {
        return atan.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double atan(double _X)
     * }
     */
    public static MethodHandle atan$handle() {
        return atan.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double atan(double _X)
     * }
     */
    public static MemorySegment atan$address() {
        return atan.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double atan(double _X)
     * }
     */
    public static double atan(double _X) {
        var mh$ = atan.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atan", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atan2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("atan2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double atan2(double _Y, double _X)
     * }
     */
    public static FunctionDescriptor atan2$descriptor() {
        return atan2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double atan2(double _Y, double _X)
     * }
     */
    public static MethodHandle atan2$handle() {
        return atan2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double atan2(double _Y, double _X)
     * }
     */
    public static MemorySegment atan2$address() {
        return atan2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double atan2(double _Y, double _X)
     * }
     */
    public static double atan2(double _Y, double _X) {
        var mh$ = atan2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atan2", _Y, _X);
            }
            return (double)mh$.invokeExact(_Y, _X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("cos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double cos(double _X)
     * }
     */
    public static FunctionDescriptor cos$descriptor() {
        return cos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double cos(double _X)
     * }
     */
    public static MethodHandle cos$handle() {
        return cos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double cos(double _X)
     * }
     */
    public static MemorySegment cos$address() {
        return cos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double cos(double _X)
     * }
     */
    public static double cos(double _X) {
        var mh$ = cos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cos", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cosh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("cosh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double cosh(double _X)
     * }
     */
    public static FunctionDescriptor cosh$descriptor() {
        return cosh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double cosh(double _X)
     * }
     */
    public static MethodHandle cosh$handle() {
        return cosh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double cosh(double _X)
     * }
     */
    public static MemorySegment cosh$address() {
        return cosh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double cosh(double _X)
     * }
     */
    public static double cosh(double _X) {
        var mh$ = cosh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cosh", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class exp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("exp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double exp(double _X)
     * }
     */
    public static FunctionDescriptor exp$descriptor() {
        return exp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double exp(double _X)
     * }
     */
    public static MethodHandle exp$handle() {
        return exp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double exp(double _X)
     * }
     */
    public static MemorySegment exp$address() {
        return exp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double exp(double _X)
     * }
     */
    public static double exp(double _X) {
        var mh$ = exp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("exp", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fabs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fabs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double fabs(double _X)
     * }
     */
    public static FunctionDescriptor fabs$descriptor() {
        return fabs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double fabs(double _X)
     * }
     */
    public static MethodHandle fabs$handle() {
        return fabs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double fabs(double _X)
     * }
     */
    public static MemorySegment fabs$address() {
        return fabs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double fabs(double _X)
     * }
     */
    public static double fabs(double _X) {
        var mh$ = fabs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fabs", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fmod {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fmod");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double fmod(double _X, double _Y)
     * }
     */
    public static FunctionDescriptor fmod$descriptor() {
        return fmod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double fmod(double _X, double _Y)
     * }
     */
    public static MethodHandle fmod$handle() {
        return fmod.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double fmod(double _X, double _Y)
     * }
     */
    public static MemorySegment fmod$address() {
        return fmod.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double fmod(double _X, double _Y)
     * }
     */
    public static double fmod(double _X, double _Y) {
        var mh$ = fmod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fmod", _X, _Y);
            }
            return (double)mh$.invokeExact(_X, _Y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class log {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("log");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double log(double _X)
     * }
     */
    public static FunctionDescriptor log$descriptor() {
        return log.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double log(double _X)
     * }
     */
    public static MethodHandle log$handle() {
        return log.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double log(double _X)
     * }
     */
    public static MemorySegment log$address() {
        return log.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double log(double _X)
     * }
     */
    public static double log(double _X) {
        var mh$ = log.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("log", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class log10 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("log10");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double log10(double _X)
     * }
     */
    public static FunctionDescriptor log10$descriptor() {
        return log10.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double log10(double _X)
     * }
     */
    public static MethodHandle log10$handle() {
        return log10.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double log10(double _X)
     * }
     */
    public static MemorySegment log10$address() {
        return log10.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double log10(double _X)
     * }
     */
    public static double log10(double _X) {
        var mh$ = log10.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("log10", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double pow(double _X, double _Y)
     * }
     */
    public static FunctionDescriptor pow$descriptor() {
        return pow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double pow(double _X, double _Y)
     * }
     */
    public static MethodHandle pow$handle() {
        return pow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double pow(double _X, double _Y)
     * }
     */
    public static MemorySegment pow$address() {
        return pow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double pow(double _X, double _Y)
     * }
     */
    public static double pow(double _X, double _Y) {
        var mh$ = pow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pow", _X, _Y);
            }
            return (double)mh$.invokeExact(_X, _Y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("sin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double sin(double _X)
     * }
     */
    public static FunctionDescriptor sin$descriptor() {
        return sin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double sin(double _X)
     * }
     */
    public static MethodHandle sin$handle() {
        return sin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double sin(double _X)
     * }
     */
    public static MemorySegment sin$address() {
        return sin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double sin(double _X)
     * }
     */
    public static double sin(double _X) {
        var mh$ = sin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sin", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sinh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("sinh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double sinh(double _X)
     * }
     */
    public static FunctionDescriptor sinh$descriptor() {
        return sinh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double sinh(double _X)
     * }
     */
    public static MethodHandle sinh$handle() {
        return sinh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double sinh(double _X)
     * }
     */
    public static MemorySegment sinh$address() {
        return sinh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double sinh(double _X)
     * }
     */
    public static double sinh(double _X) {
        var mh$ = sinh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sinh", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sqrt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("sqrt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double sqrt(double _X)
     * }
     */
    public static FunctionDescriptor sqrt$descriptor() {
        return sqrt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double sqrt(double _X)
     * }
     */
    public static MethodHandle sqrt$handle() {
        return sqrt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double sqrt(double _X)
     * }
     */
    public static MemorySegment sqrt$address() {
        return sqrt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double sqrt(double _X)
     * }
     */
    public static double sqrt(double _X) {
        var mh$ = sqrt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sqrt", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tan {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("tan");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double tan(double _X)
     * }
     */
    public static FunctionDescriptor tan$descriptor() {
        return tan.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double tan(double _X)
     * }
     */
    public static MethodHandle tan$handle() {
        return tan.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double tan(double _X)
     * }
     */
    public static MemorySegment tan$address() {
        return tan.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double tan(double _X)
     * }
     */
    public static double tan(double _X) {
        var mh$ = tan.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tan", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tanh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("tanh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double tanh(double _X)
     * }
     */
    public static FunctionDescriptor tanh$descriptor() {
        return tanh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double tanh(double _X)
     * }
     */
    public static MethodHandle tanh$handle() {
        return tanh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double tanh(double _X)
     * }
     */
    public static MemorySegment tanh$address() {
        return tanh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double tanh(double _X)
     * }
     */
    public static double tanh(double _X) {
        var mh$ = tanh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tanh", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class acosh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("acosh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double acosh(double _X)
     * }
     */
    public static FunctionDescriptor acosh$descriptor() {
        return acosh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double acosh(double _X)
     * }
     */
    public static MethodHandle acosh$handle() {
        return acosh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double acosh(double _X)
     * }
     */
    public static MemorySegment acosh$address() {
        return acosh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double acosh(double _X)
     * }
     */
    public static double acosh(double _X) {
        var mh$ = acosh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("acosh", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asinh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("asinh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double asinh(double _X)
     * }
     */
    public static FunctionDescriptor asinh$descriptor() {
        return asinh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double asinh(double _X)
     * }
     */
    public static MethodHandle asinh$handle() {
        return asinh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double asinh(double _X)
     * }
     */
    public static MemorySegment asinh$address() {
        return asinh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double asinh(double _X)
     * }
     */
    public static double asinh(double _X) {
        var mh$ = asinh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("asinh", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atanh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("atanh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double atanh(double _X)
     * }
     */
    public static FunctionDescriptor atanh$descriptor() {
        return atanh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double atanh(double _X)
     * }
     */
    public static MethodHandle atanh$handle() {
        return atanh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double atanh(double _X)
     * }
     */
    public static MemorySegment atanh$address() {
        return atanh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double atanh(double _X)
     * }
     */
    public static double atanh(double _X) {
        var mh$ = atanh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atanh", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _cabs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            _complex.layout()
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_cabs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double _cabs(struct _complex _Complex_value)
     * }
     */
    public static FunctionDescriptor _cabs$descriptor() {
        return _cabs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double _cabs(struct _complex _Complex_value)
     * }
     */
    public static MethodHandle _cabs$handle() {
        return _cabs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double _cabs(struct _complex _Complex_value)
     * }
     */
    public static MemorySegment _cabs$address() {
        return _cabs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double _cabs(struct _complex _Complex_value)
     * }
     */
    public static double _cabs(MemorySegment _Complex_value) {
        var mh$ = _cabs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_cabs", _Complex_value);
            }
            return (double)mh$.invokeExact(_Complex_value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cbrt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("cbrt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double cbrt(double _X)
     * }
     */
    public static FunctionDescriptor cbrt$descriptor() {
        return cbrt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double cbrt(double _X)
     * }
     */
    public static MethodHandle cbrt$handle() {
        return cbrt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double cbrt(double _X)
     * }
     */
    public static MemorySegment cbrt$address() {
        return cbrt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double cbrt(double _X)
     * }
     */
    public static double cbrt(double _X) {
        var mh$ = cbrt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cbrt", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ceil {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("ceil");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double ceil(double _X)
     * }
     */
    public static FunctionDescriptor ceil$descriptor() {
        return ceil.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double ceil(double _X)
     * }
     */
    public static MethodHandle ceil$handle() {
        return ceil.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double ceil(double _X)
     * }
     */
    public static MemorySegment ceil$address() {
        return ceil.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double ceil(double _X)
     * }
     */
    public static double ceil(double _X) {
        var mh$ = ceil.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ceil", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _chgsign {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_chgsign");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double _chgsign(double _X)
     * }
     */
    public static FunctionDescriptor _chgsign$descriptor() {
        return _chgsign.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double _chgsign(double _X)
     * }
     */
    public static MethodHandle _chgsign$handle() {
        return _chgsign.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double _chgsign(double _X)
     * }
     */
    public static MemorySegment _chgsign$address() {
        return _chgsign.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double _chgsign(double _X)
     * }
     */
    public static double _chgsign(double _X) {
        var mh$ = _chgsign.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_chgsign", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class copysign {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("copysign");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double copysign(double _Number, double _Sign)
     * }
     */
    public static FunctionDescriptor copysign$descriptor() {
        return copysign.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double copysign(double _Number, double _Sign)
     * }
     */
    public static MethodHandle copysign$handle() {
        return copysign.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double copysign(double _Number, double _Sign)
     * }
     */
    public static MemorySegment copysign$address() {
        return copysign.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double copysign(double _Number, double _Sign)
     * }
     */
    public static double copysign(double _Number, double _Sign) {
        var mh$ = copysign.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("copysign", _Number, _Sign);
            }
            return (double)mh$.invokeExact(_Number, _Sign);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _copysign {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_copysign");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double _copysign(double _Number, double _Sign)
     * }
     */
    public static FunctionDescriptor _copysign$descriptor() {
        return _copysign.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double _copysign(double _Number, double _Sign)
     * }
     */
    public static MethodHandle _copysign$handle() {
        return _copysign.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double _copysign(double _Number, double _Sign)
     * }
     */
    public static MemorySegment _copysign$address() {
        return _copysign.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double _copysign(double _Number, double _Sign)
     * }
     */
    public static double _copysign(double _Number, double _Sign) {
        var mh$ = _copysign.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_copysign", _Number, _Sign);
            }
            return (double)mh$.invokeExact(_Number, _Sign);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class erf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("erf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double erf(double _X)
     * }
     */
    public static FunctionDescriptor erf$descriptor() {
        return erf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double erf(double _X)
     * }
     */
    public static MethodHandle erf$handle() {
        return erf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double erf(double _X)
     * }
     */
    public static MemorySegment erf$address() {
        return erf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double erf(double _X)
     * }
     */
    public static double erf(double _X) {
        var mh$ = erf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("erf", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class erfc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("erfc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double erfc(double _X)
     * }
     */
    public static FunctionDescriptor erfc$descriptor() {
        return erfc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double erfc(double _X)
     * }
     */
    public static MethodHandle erfc$handle() {
        return erfc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double erfc(double _X)
     * }
     */
    public static MemorySegment erfc$address() {
        return erfc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double erfc(double _X)
     * }
     */
    public static double erfc(double _X) {
        var mh$ = erfc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("erfc", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class exp2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("exp2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double exp2(double _X)
     * }
     */
    public static FunctionDescriptor exp2$descriptor() {
        return exp2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double exp2(double _X)
     * }
     */
    public static MethodHandle exp2$handle() {
        return exp2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double exp2(double _X)
     * }
     */
    public static MemorySegment exp2$address() {
        return exp2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double exp2(double _X)
     * }
     */
    public static double exp2(double _X) {
        var mh$ = exp2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("exp2", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class expm1 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("expm1");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double expm1(double _X)
     * }
     */
    public static FunctionDescriptor expm1$descriptor() {
        return expm1.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double expm1(double _X)
     * }
     */
    public static MethodHandle expm1$handle() {
        return expm1.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double expm1(double _X)
     * }
     */
    public static MemorySegment expm1$address() {
        return expm1.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double expm1(double _X)
     * }
     */
    public static double expm1(double _X) {
        var mh$ = expm1.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("expm1", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fdim {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fdim");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double fdim(double _X, double _Y)
     * }
     */
    public static FunctionDescriptor fdim$descriptor() {
        return fdim.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double fdim(double _X, double _Y)
     * }
     */
    public static MethodHandle fdim$handle() {
        return fdim.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double fdim(double _X, double _Y)
     * }
     */
    public static MemorySegment fdim$address() {
        return fdim.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double fdim(double _X, double _Y)
     * }
     */
    public static double fdim(double _X, double _Y) {
        var mh$ = fdim.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fdim", _X, _Y);
            }
            return (double)mh$.invokeExact(_X, _Y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class floor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("floor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double floor(double _X)
     * }
     */
    public static FunctionDescriptor floor$descriptor() {
        return floor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double floor(double _X)
     * }
     */
    public static MethodHandle floor$handle() {
        return floor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double floor(double _X)
     * }
     */
    public static MemorySegment floor$address() {
        return floor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double floor(double _X)
     * }
     */
    public static double floor(double _X) {
        var mh$ = floor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("floor", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fma {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fma");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double fma(double _X, double _Y, double _Z)
     * }
     */
    public static FunctionDescriptor fma$descriptor() {
        return fma.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double fma(double _X, double _Y, double _Z)
     * }
     */
    public static MethodHandle fma$handle() {
        return fma.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double fma(double _X, double _Y, double _Z)
     * }
     */
    public static MemorySegment fma$address() {
        return fma.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double fma(double _X, double _Y, double _Z)
     * }
     */
    public static double fma(double _X, double _Y, double _Z) {
        var mh$ = fma.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fma", _X, _Y, _Z);
            }
            return (double)mh$.invokeExact(_X, _Y, _Z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fmax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fmax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double fmax(double _X, double _Y)
     * }
     */
    public static FunctionDescriptor fmax$descriptor() {
        return fmax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double fmax(double _X, double _Y)
     * }
     */
    public static MethodHandle fmax$handle() {
        return fmax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double fmax(double _X, double _Y)
     * }
     */
    public static MemorySegment fmax$address() {
        return fmax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double fmax(double _X, double _Y)
     * }
     */
    public static double fmax(double _X, double _Y) {
        var mh$ = fmax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fmax", _X, _Y);
            }
            return (double)mh$.invokeExact(_X, _Y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fmin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fmin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double fmin(double _X, double _Y)
     * }
     */
    public static FunctionDescriptor fmin$descriptor() {
        return fmin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double fmin(double _X, double _Y)
     * }
     */
    public static MethodHandle fmin$handle() {
        return fmin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double fmin(double _X, double _Y)
     * }
     */
    public static MemorySegment fmin$address() {
        return fmin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double fmin(double _X, double _Y)
     * }
     */
    public static double fmin(double _X, double _Y) {
        var mh$ = fmin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fmin", _X, _Y);
            }
            return (double)mh$.invokeExact(_X, _Y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class frexp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("frexp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double frexp(double _X, int *_Y)
     * }
     */
    public static FunctionDescriptor frexp$descriptor() {
        return frexp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double frexp(double _X, int *_Y)
     * }
     */
    public static MethodHandle frexp$handle() {
        return frexp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double frexp(double _X, int *_Y)
     * }
     */
    public static MemorySegment frexp$address() {
        return frexp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double frexp(double _X, int *_Y)
     * }
     */
    public static double frexp(double _X, MemorySegment _Y) {
        var mh$ = frexp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("frexp", _X, _Y);
            }
            return (double)mh$.invokeExact(_X, _Y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class hypot {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("hypot");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double hypot(double _X, double _Y)
     * }
     */
    public static FunctionDescriptor hypot$descriptor() {
        return hypot.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double hypot(double _X, double _Y)
     * }
     */
    public static MethodHandle hypot$handle() {
        return hypot.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double hypot(double _X, double _Y)
     * }
     */
    public static MemorySegment hypot$address() {
        return hypot.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double hypot(double _X, double _Y)
     * }
     */
    public static double hypot(double _X, double _Y) {
        var mh$ = hypot.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("hypot", _X, _Y);
            }
            return (double)mh$.invokeExact(_X, _Y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _hypot {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_hypot");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double _hypot(double _X, double _Y)
     * }
     */
    public static FunctionDescriptor _hypot$descriptor() {
        return _hypot.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double _hypot(double _X, double _Y)
     * }
     */
    public static MethodHandle _hypot$handle() {
        return _hypot.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double _hypot(double _X, double _Y)
     * }
     */
    public static MemorySegment _hypot$address() {
        return _hypot.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double _hypot(double _X, double _Y)
     * }
     */
    public static double _hypot(double _X, double _Y) {
        var mh$ = _hypot.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_hypot", _X, _Y);
            }
            return (double)mh$.invokeExact(_X, _Y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ilogb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("ilogb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ilogb(double _X)
     * }
     */
    public static FunctionDescriptor ilogb$descriptor() {
        return ilogb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ilogb(double _X)
     * }
     */
    public static MethodHandle ilogb$handle() {
        return ilogb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ilogb(double _X)
     * }
     */
    public static MemorySegment ilogb$address() {
        return ilogb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ilogb(double _X)
     * }
     */
    public static int ilogb(double _X) {
        var mh$ = ilogb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ilogb", _X);
            }
            return (int)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ldexp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("ldexp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double ldexp(double _X, int _Y)
     * }
     */
    public static FunctionDescriptor ldexp$descriptor() {
        return ldexp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double ldexp(double _X, int _Y)
     * }
     */
    public static MethodHandle ldexp$handle() {
        return ldexp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double ldexp(double _X, int _Y)
     * }
     */
    public static MemorySegment ldexp$address() {
        return ldexp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double ldexp(double _X, int _Y)
     * }
     */
    public static double ldexp(double _X, int _Y) {
        var mh$ = ldexp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ldexp", _X, _Y);
            }
            return (double)mh$.invokeExact(_X, _Y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lgamma {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("lgamma");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double lgamma(double _X)
     * }
     */
    public static FunctionDescriptor lgamma$descriptor() {
        return lgamma.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double lgamma(double _X)
     * }
     */
    public static MethodHandle lgamma$handle() {
        return lgamma.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double lgamma(double _X)
     * }
     */
    public static MemorySegment lgamma$address() {
        return lgamma.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double lgamma(double _X)
     * }
     */
    public static double lgamma(double _X) {
        var mh$ = lgamma.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lgamma", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llrint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("llrint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long llrint(double _X)
     * }
     */
    public static FunctionDescriptor llrint$descriptor() {
        return llrint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long llrint(double _X)
     * }
     */
    public static MethodHandle llrint$handle() {
        return llrint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long llrint(double _X)
     * }
     */
    public static MemorySegment llrint$address() {
        return llrint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long llrint(double _X)
     * }
     */
    public static long llrint(double _X) {
        var mh$ = llrint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llrint", _X);
            }
            return (long)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llround {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("llround");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long llround(double _X)
     * }
     */
    public static FunctionDescriptor llround$descriptor() {
        return llround.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long llround(double _X)
     * }
     */
    public static MethodHandle llround$handle() {
        return llround.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long llround(double _X)
     * }
     */
    public static MemorySegment llround$address() {
        return llround.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long llround(double _X)
     * }
     */
    public static long llround(double _X) {
        var mh$ = llround.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llround", _X);
            }
            return (long)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class log1p {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("log1p");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double log1p(double _X)
     * }
     */
    public static FunctionDescriptor log1p$descriptor() {
        return log1p.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double log1p(double _X)
     * }
     */
    public static MethodHandle log1p$handle() {
        return log1p.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double log1p(double _X)
     * }
     */
    public static MemorySegment log1p$address() {
        return log1p.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double log1p(double _X)
     * }
     */
    public static double log1p(double _X) {
        var mh$ = log1p.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("log1p", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class log2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("log2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double log2(double _X)
     * }
     */
    public static FunctionDescriptor log2$descriptor() {
        return log2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double log2(double _X)
     * }
     */
    public static MethodHandle log2$handle() {
        return log2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double log2(double _X)
     * }
     */
    public static MemorySegment log2$address() {
        return log2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double log2(double _X)
     * }
     */
    public static double log2(double _X) {
        var mh$ = log2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("log2", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class logb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("logb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double logb(double _X)
     * }
     */
    public static FunctionDescriptor logb$descriptor() {
        return logb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double logb(double _X)
     * }
     */
    public static MethodHandle logb$handle() {
        return logb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double logb(double _X)
     * }
     */
    public static MemorySegment logb$address() {
        return logb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double logb(double _X)
     * }
     */
    public static double logb(double _X) {
        var mh$ = logb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("logb", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lrint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("lrint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long lrint(double _X)
     * }
     */
    public static FunctionDescriptor lrint$descriptor() {
        return lrint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long lrint(double _X)
     * }
     */
    public static MethodHandle lrint$handle() {
        return lrint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long lrint(double _X)
     * }
     */
    public static MemorySegment lrint$address() {
        return lrint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long lrint(double _X)
     * }
     */
    public static int lrint(double _X) {
        var mh$ = lrint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lrint", _X);
            }
            return (int)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lround {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("lround");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long lround(double _X)
     * }
     */
    public static FunctionDescriptor lround$descriptor() {
        return lround.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long lround(double _X)
     * }
     */
    public static MethodHandle lround$handle() {
        return lround.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long lround(double _X)
     * }
     */
    public static MemorySegment lround$address() {
        return lround.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long lround(double _X)
     * }
     */
    public static int lround(double _X) {
        var mh$ = lround.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lround", _X);
            }
            return (int)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _matherr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_matherr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _matherr(struct _exception *_Except)
     * }
     */
    public static FunctionDescriptor _matherr$descriptor() {
        return _matherr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _matherr(struct _exception *_Except)
     * }
     */
    public static MethodHandle _matherr$handle() {
        return _matherr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _matherr(struct _exception *_Except)
     * }
     */
    public static MemorySegment _matherr$address() {
        return _matherr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _matherr(struct _exception *_Except)
     * }
     */
    public static int _matherr(MemorySegment _Except) {
        var mh$ = _matherr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_matherr", _Except);
            }
            return (int)mh$.invokeExact(_Except);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class modf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("modf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double modf(double _X, double *_Y)
     * }
     */
    public static FunctionDescriptor modf$descriptor() {
        return modf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double modf(double _X, double *_Y)
     * }
     */
    public static MethodHandle modf$handle() {
        return modf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double modf(double _X, double *_Y)
     * }
     */
    public static MemorySegment modf$address() {
        return modf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double modf(double _X, double *_Y)
     * }
     */
    public static double modf(double _X, MemorySegment _Y) {
        var mh$ = modf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("modf", _X, _Y);
            }
            return (double)mh$.invokeExact(_X, _Y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nan {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("nan");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double nan(const char *_X)
     * }
     */
    public static FunctionDescriptor nan$descriptor() {
        return nan.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double nan(const char *_X)
     * }
     */
    public static MethodHandle nan$handle() {
        return nan.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double nan(const char *_X)
     * }
     */
    public static MemorySegment nan$address() {
        return nan.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double nan(const char *_X)
     * }
     */
    public static double nan(MemorySegment _X) {
        var mh$ = nan.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nan", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nearbyint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("nearbyint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double nearbyint(double _X)
     * }
     */
    public static FunctionDescriptor nearbyint$descriptor() {
        return nearbyint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double nearbyint(double _X)
     * }
     */
    public static MethodHandle nearbyint$handle() {
        return nearbyint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double nearbyint(double _X)
     * }
     */
    public static MemorySegment nearbyint$address() {
        return nearbyint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double nearbyint(double _X)
     * }
     */
    public static double nearbyint(double _X) {
        var mh$ = nearbyint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nearbyint", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nextafter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("nextafter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double nextafter(double _X, double _Y)
     * }
     */
    public static FunctionDescriptor nextafter$descriptor() {
        return nextafter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double nextafter(double _X, double _Y)
     * }
     */
    public static MethodHandle nextafter$handle() {
        return nextafter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double nextafter(double _X, double _Y)
     * }
     */
    public static MemorySegment nextafter$address() {
        return nextafter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double nextafter(double _X, double _Y)
     * }
     */
    public static double nextafter(double _X, double _Y) {
        var mh$ = nextafter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nextafter", _X, _Y);
            }
            return (double)mh$.invokeExact(_X, _Y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nexttoward {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE,
            Python_h.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("nexttoward");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double nexttoward(double _X, long double _Y)
     * }
     */
    public static FunctionDescriptor nexttoward$descriptor() {
        return nexttoward.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double nexttoward(double _X, long double _Y)
     * }
     */
    public static MethodHandle nexttoward$handle() {
        return nexttoward.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double nexttoward(double _X, long double _Y)
     * }
     */
    public static MemorySegment nexttoward$address() {
        return nexttoward.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double nexttoward(double _X, long double _Y)
     * }
     */
    public static double nexttoward(double _X, double _Y) {
        var mh$ = nexttoward.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nexttoward", _X, _Y);
            }
            return (double)mh$.invokeExact(_X, _Y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class remainder {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("remainder");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double remainder(double _X, double _Y)
     * }
     */
    public static FunctionDescriptor remainder$descriptor() {
        return remainder.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double remainder(double _X, double _Y)
     * }
     */
    public static MethodHandle remainder$handle() {
        return remainder.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double remainder(double _X, double _Y)
     * }
     */
    public static MemorySegment remainder$address() {
        return remainder.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double remainder(double _X, double _Y)
     * }
     */
    public static double remainder(double _X, double _Y) {
        var mh$ = remainder.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("remainder", _X, _Y);
            }
            return (double)mh$.invokeExact(_X, _Y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class remquo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("remquo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double remquo(double _X, double _Y, int *_Z)
     * }
     */
    public static FunctionDescriptor remquo$descriptor() {
        return remquo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double remquo(double _X, double _Y, int *_Z)
     * }
     */
    public static MethodHandle remquo$handle() {
        return remquo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double remquo(double _X, double _Y, int *_Z)
     * }
     */
    public static MemorySegment remquo$address() {
        return remquo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double remquo(double _X, double _Y, int *_Z)
     * }
     */
    public static double remquo(double _X, double _Y, MemorySegment _Z) {
        var mh$ = remquo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("remquo", _X, _Y, _Z);
            }
            return (double)mh$.invokeExact(_X, _Y, _Z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("rint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double rint(double _X)
     * }
     */
    public static FunctionDescriptor rint$descriptor() {
        return rint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double rint(double _X)
     * }
     */
    public static MethodHandle rint$handle() {
        return rint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double rint(double _X)
     * }
     */
    public static MemorySegment rint$address() {
        return rint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double rint(double _X)
     * }
     */
    public static double rint(double _X) {
        var mh$ = rint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rint", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class round {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("round");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double round(double _X)
     * }
     */
    public static FunctionDescriptor round$descriptor() {
        return round.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double round(double _X)
     * }
     */
    public static MethodHandle round$handle() {
        return round.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double round(double _X)
     * }
     */
    public static MemorySegment round$address() {
        return round.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double round(double _X)
     * }
     */
    public static double round(double _X) {
        var mh$ = round.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("round", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class scalbln {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("scalbln");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double scalbln(double _X, long _Y)
     * }
     */
    public static FunctionDescriptor scalbln$descriptor() {
        return scalbln.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double scalbln(double _X, long _Y)
     * }
     */
    public static MethodHandle scalbln$handle() {
        return scalbln.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double scalbln(double _X, long _Y)
     * }
     */
    public static MemorySegment scalbln$address() {
        return scalbln.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double scalbln(double _X, long _Y)
     * }
     */
    public static double scalbln(double _X, int _Y) {
        var mh$ = scalbln.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("scalbln", _X, _Y);
            }
            return (double)mh$.invokeExact(_X, _Y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class scalbn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("scalbn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double scalbn(double _X, int _Y)
     * }
     */
    public static FunctionDescriptor scalbn$descriptor() {
        return scalbn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double scalbn(double _X, int _Y)
     * }
     */
    public static MethodHandle scalbn$handle() {
        return scalbn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double scalbn(double _X, int _Y)
     * }
     */
    public static MemorySegment scalbn$address() {
        return scalbn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double scalbn(double _X, int _Y)
     * }
     */
    public static double scalbn(double _X, int _Y) {
        var mh$ = scalbn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("scalbn", _X, _Y);
            }
            return (double)mh$.invokeExact(_X, _Y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tgamma {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("tgamma");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double tgamma(double _X)
     * }
     */
    public static FunctionDescriptor tgamma$descriptor() {
        return tgamma.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double tgamma(double _X)
     * }
     */
    public static MethodHandle tgamma$handle() {
        return tgamma.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double tgamma(double _X)
     * }
     */
    public static MemorySegment tgamma$address() {
        return tgamma.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double tgamma(double _X)
     * }
     */
    public static double tgamma(double _X) {
        var mh$ = tgamma.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tgamma", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class trunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("trunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double trunc(double _X)
     * }
     */
    public static FunctionDescriptor trunc$descriptor() {
        return trunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double trunc(double _X)
     * }
     */
    public static MethodHandle trunc$handle() {
        return trunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double trunc(double _X)
     * }
     */
    public static MemorySegment trunc$address() {
        return trunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double trunc(double _X)
     * }
     */
    public static double trunc(double _X) {
        var mh$ = trunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("trunc", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _j0 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_j0");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double _j0(double _X)
     * }
     */
    public static FunctionDescriptor _j0$descriptor() {
        return _j0.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double _j0(double _X)
     * }
     */
    public static MethodHandle _j0$handle() {
        return _j0.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double _j0(double _X)
     * }
     */
    public static MemorySegment _j0$address() {
        return _j0.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double _j0(double _X)
     * }
     */
    public static double _j0(double _X) {
        var mh$ = _j0.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_j0", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _j1 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_j1");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double _j1(double _X)
     * }
     */
    public static FunctionDescriptor _j1$descriptor() {
        return _j1.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double _j1(double _X)
     * }
     */
    public static MethodHandle _j1$handle() {
        return _j1.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double _j1(double _X)
     * }
     */
    public static MemorySegment _j1$address() {
        return _j1.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double _j1(double _X)
     * }
     */
    public static double _j1(double _X) {
        var mh$ = _j1.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_j1", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _jn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_INT,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_jn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double _jn(int _X, double _Y)
     * }
     */
    public static FunctionDescriptor _jn$descriptor() {
        return _jn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double _jn(int _X, double _Y)
     * }
     */
    public static MethodHandle _jn$handle() {
        return _jn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double _jn(int _X, double _Y)
     * }
     */
    public static MemorySegment _jn$address() {
        return _jn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double _jn(int _X, double _Y)
     * }
     */
    public static double _jn(int _X, double _Y) {
        var mh$ = _jn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_jn", _X, _Y);
            }
            return (double)mh$.invokeExact(_X, _Y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _y0 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_y0");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double _y0(double _X)
     * }
     */
    public static FunctionDescriptor _y0$descriptor() {
        return _y0.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double _y0(double _X)
     * }
     */
    public static MethodHandle _y0$handle() {
        return _y0.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double _y0(double _X)
     * }
     */
    public static MemorySegment _y0$address() {
        return _y0.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double _y0(double _X)
     * }
     */
    public static double _y0(double _X) {
        var mh$ = _y0.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_y0", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _y1 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_y1");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double _y1(double _X)
     * }
     */
    public static FunctionDescriptor _y1$descriptor() {
        return _y1.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double _y1(double _X)
     * }
     */
    public static MethodHandle _y1$handle() {
        return _y1.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double _y1(double _X)
     * }
     */
    public static MemorySegment _y1$address() {
        return _y1.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double _y1(double _X)
     * }
     */
    public static double _y1(double _X) {
        var mh$ = _y1.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_y1", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _yn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_INT,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_yn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double _yn(int _X, double _Y)
     * }
     */
    public static FunctionDescriptor _yn$descriptor() {
        return _yn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double _yn(int _X, double _Y)
     * }
     */
    public static MethodHandle _yn$handle() {
        return _yn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double _yn(int _X, double _Y)
     * }
     */
    public static MemorySegment _yn$address() {
        return _yn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double _yn(int _X, double _Y)
     * }
     */
    public static double _yn(int _X, double _Y) {
        var mh$ = _yn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_yn", _X, _Y);
            }
            return (double)mh$.invokeExact(_X, _Y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class acoshf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("acoshf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float acoshf(float _X)
     * }
     */
    public static FunctionDescriptor acoshf$descriptor() {
        return acoshf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float acoshf(float _X)
     * }
     */
    public static MethodHandle acoshf$handle() {
        return acoshf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float acoshf(float _X)
     * }
     */
    public static MemorySegment acoshf$address() {
        return acoshf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float acoshf(float _X)
     * }
     */
    public static float acoshf(float _X) {
        var mh$ = acoshf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("acoshf", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asinhf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("asinhf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float asinhf(float _X)
     * }
     */
    public static FunctionDescriptor asinhf$descriptor() {
        return asinhf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float asinhf(float _X)
     * }
     */
    public static MethodHandle asinhf$handle() {
        return asinhf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float asinhf(float _X)
     * }
     */
    public static MemorySegment asinhf$address() {
        return asinhf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float asinhf(float _X)
     * }
     */
    public static float asinhf(float _X) {
        var mh$ = asinhf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("asinhf", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atanhf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("atanhf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float atanhf(float _X)
     * }
     */
    public static FunctionDescriptor atanhf$descriptor() {
        return atanhf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float atanhf(float _X)
     * }
     */
    public static MethodHandle atanhf$handle() {
        return atanhf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float atanhf(float _X)
     * }
     */
    public static MemorySegment atanhf$address() {
        return atanhf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float atanhf(float _X)
     * }
     */
    public static float atanhf(float _X) {
        var mh$ = atanhf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atanhf", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cbrtf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("cbrtf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float cbrtf(float _X)
     * }
     */
    public static FunctionDescriptor cbrtf$descriptor() {
        return cbrtf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float cbrtf(float _X)
     * }
     */
    public static MethodHandle cbrtf$handle() {
        return cbrtf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float cbrtf(float _X)
     * }
     */
    public static MemorySegment cbrtf$address() {
        return cbrtf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float cbrtf(float _X)
     * }
     */
    public static float cbrtf(float _X) {
        var mh$ = cbrtf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cbrtf", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _chgsignf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_chgsignf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float _chgsignf(float _X)
     * }
     */
    public static FunctionDescriptor _chgsignf$descriptor() {
        return _chgsignf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float _chgsignf(float _X)
     * }
     */
    public static MethodHandle _chgsignf$handle() {
        return _chgsignf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float _chgsignf(float _X)
     * }
     */
    public static MemorySegment _chgsignf$address() {
        return _chgsignf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float _chgsignf(float _X)
     * }
     */
    public static float _chgsignf(float _X) {
        var mh$ = _chgsignf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_chgsignf", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class copysignf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("copysignf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float copysignf(float _Number, float _Sign)
     * }
     */
    public static FunctionDescriptor copysignf$descriptor() {
        return copysignf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float copysignf(float _Number, float _Sign)
     * }
     */
    public static MethodHandle copysignf$handle() {
        return copysignf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float copysignf(float _Number, float _Sign)
     * }
     */
    public static MemorySegment copysignf$address() {
        return copysignf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float copysignf(float _Number, float _Sign)
     * }
     */
    public static float copysignf(float _Number, float _Sign) {
        var mh$ = copysignf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("copysignf", _Number, _Sign);
            }
            return (float)mh$.invokeExact(_Number, _Sign);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _copysignf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_copysignf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float _copysignf(float _Number, float _Sign)
     * }
     */
    public static FunctionDescriptor _copysignf$descriptor() {
        return _copysignf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float _copysignf(float _Number, float _Sign)
     * }
     */
    public static MethodHandle _copysignf$handle() {
        return _copysignf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float _copysignf(float _Number, float _Sign)
     * }
     */
    public static MemorySegment _copysignf$address() {
        return _copysignf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float _copysignf(float _Number, float _Sign)
     * }
     */
    public static float _copysignf(float _Number, float _Sign) {
        var mh$ = _copysignf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_copysignf", _Number, _Sign);
            }
            return (float)mh$.invokeExact(_Number, _Sign);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class erff {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("erff");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float erff(float _X)
     * }
     */
    public static FunctionDescriptor erff$descriptor() {
        return erff.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float erff(float _X)
     * }
     */
    public static MethodHandle erff$handle() {
        return erff.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float erff(float _X)
     * }
     */
    public static MemorySegment erff$address() {
        return erff.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float erff(float _X)
     * }
     */
    public static float erff(float _X) {
        var mh$ = erff.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("erff", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class erfcf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("erfcf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float erfcf(float _X)
     * }
     */
    public static FunctionDescriptor erfcf$descriptor() {
        return erfcf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float erfcf(float _X)
     * }
     */
    public static MethodHandle erfcf$handle() {
        return erfcf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float erfcf(float _X)
     * }
     */
    public static MemorySegment erfcf$address() {
        return erfcf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float erfcf(float _X)
     * }
     */
    public static float erfcf(float _X) {
        var mh$ = erfcf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("erfcf", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class expm1f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("expm1f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float expm1f(float _X)
     * }
     */
    public static FunctionDescriptor expm1f$descriptor() {
        return expm1f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float expm1f(float _X)
     * }
     */
    public static MethodHandle expm1f$handle() {
        return expm1f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float expm1f(float _X)
     * }
     */
    public static MemorySegment expm1f$address() {
        return expm1f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float expm1f(float _X)
     * }
     */
    public static float expm1f(float _X) {
        var mh$ = expm1f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("expm1f", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class exp2f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("exp2f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float exp2f(float _X)
     * }
     */
    public static FunctionDescriptor exp2f$descriptor() {
        return exp2f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float exp2f(float _X)
     * }
     */
    public static MethodHandle exp2f$handle() {
        return exp2f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float exp2f(float _X)
     * }
     */
    public static MemorySegment exp2f$address() {
        return exp2f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float exp2f(float _X)
     * }
     */
    public static float exp2f(float _X) {
        var mh$ = exp2f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("exp2f", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fdimf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fdimf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float fdimf(float _X, float _Y)
     * }
     */
    public static FunctionDescriptor fdimf$descriptor() {
        return fdimf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float fdimf(float _X, float _Y)
     * }
     */
    public static MethodHandle fdimf$handle() {
        return fdimf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float fdimf(float _X, float _Y)
     * }
     */
    public static MemorySegment fdimf$address() {
        return fdimf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float fdimf(float _X, float _Y)
     * }
     */
    public static float fdimf(float _X, float _Y) {
        var mh$ = fdimf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fdimf", _X, _Y);
            }
            return (float)mh$.invokeExact(_X, _Y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fmaf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT,
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fmaf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float fmaf(float _X, float _Y, float _Z)
     * }
     */
    public static FunctionDescriptor fmaf$descriptor() {
        return fmaf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float fmaf(float _X, float _Y, float _Z)
     * }
     */
    public static MethodHandle fmaf$handle() {
        return fmaf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float fmaf(float _X, float _Y, float _Z)
     * }
     */
    public static MemorySegment fmaf$address() {
        return fmaf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float fmaf(float _X, float _Y, float _Z)
     * }
     */
    public static float fmaf(float _X, float _Y, float _Z) {
        var mh$ = fmaf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fmaf", _X, _Y, _Z);
            }
            return (float)mh$.invokeExact(_X, _Y, _Z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fmaxf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fmaxf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float fmaxf(float _X, float _Y)
     * }
     */
    public static FunctionDescriptor fmaxf$descriptor() {
        return fmaxf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float fmaxf(float _X, float _Y)
     * }
     */
    public static MethodHandle fmaxf$handle() {
        return fmaxf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float fmaxf(float _X, float _Y)
     * }
     */
    public static MemorySegment fmaxf$address() {
        return fmaxf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float fmaxf(float _X, float _Y)
     * }
     */
    public static float fmaxf(float _X, float _Y) {
        var mh$ = fmaxf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fmaxf", _X, _Y);
            }
            return (float)mh$.invokeExact(_X, _Y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fminf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fminf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float fminf(float _X, float _Y)
     * }
     */
    public static FunctionDescriptor fminf$descriptor() {
        return fminf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float fminf(float _X, float _Y)
     * }
     */
    public static MethodHandle fminf$handle() {
        return fminf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float fminf(float _X, float _Y)
     * }
     */
    public static MemorySegment fminf$address() {
        return fminf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float fminf(float _X, float _Y)
     * }
     */
    public static float fminf(float _X, float _Y) {
        var mh$ = fminf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fminf", _X, _Y);
            }
            return (float)mh$.invokeExact(_X, _Y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _hypotf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_hypotf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float _hypotf(float _X, float _Y)
     * }
     */
    public static FunctionDescriptor _hypotf$descriptor() {
        return _hypotf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float _hypotf(float _X, float _Y)
     * }
     */
    public static MethodHandle _hypotf$handle() {
        return _hypotf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float _hypotf(float _X, float _Y)
     * }
     */
    public static MemorySegment _hypotf$address() {
        return _hypotf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float _hypotf(float _X, float _Y)
     * }
     */
    public static float _hypotf(float _X, float _Y) {
        var mh$ = _hypotf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_hypotf", _X, _Y);
            }
            return (float)mh$.invokeExact(_X, _Y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ilogbf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("ilogbf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ilogbf(float _X)
     * }
     */
    public static FunctionDescriptor ilogbf$descriptor() {
        return ilogbf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ilogbf(float _X)
     * }
     */
    public static MethodHandle ilogbf$handle() {
        return ilogbf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ilogbf(float _X)
     * }
     */
    public static MemorySegment ilogbf$address() {
        return ilogbf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ilogbf(float _X)
     * }
     */
    public static int ilogbf(float _X) {
        var mh$ = ilogbf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ilogbf", _X);
            }
            return (int)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lgammaf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("lgammaf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float lgammaf(float _X)
     * }
     */
    public static FunctionDescriptor lgammaf$descriptor() {
        return lgammaf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float lgammaf(float _X)
     * }
     */
    public static MethodHandle lgammaf$handle() {
        return lgammaf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float lgammaf(float _X)
     * }
     */
    public static MemorySegment lgammaf$address() {
        return lgammaf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float lgammaf(float _X)
     * }
     */
    public static float lgammaf(float _X) {
        var mh$ = lgammaf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lgammaf", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llrintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("llrintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long llrintf(float _X)
     * }
     */
    public static FunctionDescriptor llrintf$descriptor() {
        return llrintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long llrintf(float _X)
     * }
     */
    public static MethodHandle llrintf$handle() {
        return llrintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long llrintf(float _X)
     * }
     */
    public static MemorySegment llrintf$address() {
        return llrintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long llrintf(float _X)
     * }
     */
    public static long llrintf(float _X) {
        var mh$ = llrintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llrintf", _X);
            }
            return (long)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llroundf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("llroundf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long llroundf(float _X)
     * }
     */
    public static FunctionDescriptor llroundf$descriptor() {
        return llroundf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long llroundf(float _X)
     * }
     */
    public static MethodHandle llroundf$handle() {
        return llroundf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long llroundf(float _X)
     * }
     */
    public static MemorySegment llroundf$address() {
        return llroundf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long llroundf(float _X)
     * }
     */
    public static long llroundf(float _X) {
        var mh$ = llroundf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llroundf", _X);
            }
            return (long)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class log1pf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("log1pf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float log1pf(float _X)
     * }
     */
    public static FunctionDescriptor log1pf$descriptor() {
        return log1pf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float log1pf(float _X)
     * }
     */
    public static MethodHandle log1pf$handle() {
        return log1pf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float log1pf(float _X)
     * }
     */
    public static MemorySegment log1pf$address() {
        return log1pf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float log1pf(float _X)
     * }
     */
    public static float log1pf(float _X) {
        var mh$ = log1pf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("log1pf", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class log2f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("log2f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float log2f(float _X)
     * }
     */
    public static FunctionDescriptor log2f$descriptor() {
        return log2f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float log2f(float _X)
     * }
     */
    public static MethodHandle log2f$handle() {
        return log2f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float log2f(float _X)
     * }
     */
    public static MemorySegment log2f$address() {
        return log2f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float log2f(float _X)
     * }
     */
    public static float log2f(float _X) {
        var mh$ = log2f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("log2f", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class logbf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("logbf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float logbf(float _X)
     * }
     */
    public static FunctionDescriptor logbf$descriptor() {
        return logbf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float logbf(float _X)
     * }
     */
    public static MethodHandle logbf$handle() {
        return logbf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float logbf(float _X)
     * }
     */
    public static MemorySegment logbf$address() {
        return logbf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float logbf(float _X)
     * }
     */
    public static float logbf(float _X) {
        var mh$ = logbf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("logbf", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lrintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("lrintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long lrintf(float _X)
     * }
     */
    public static FunctionDescriptor lrintf$descriptor() {
        return lrintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long lrintf(float _X)
     * }
     */
    public static MethodHandle lrintf$handle() {
        return lrintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long lrintf(float _X)
     * }
     */
    public static MemorySegment lrintf$address() {
        return lrintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long lrintf(float _X)
     * }
     */
    public static int lrintf(float _X) {
        var mh$ = lrintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lrintf", _X);
            }
            return (int)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lroundf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("lroundf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long lroundf(float _X)
     * }
     */
    public static FunctionDescriptor lroundf$descriptor() {
        return lroundf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long lroundf(float _X)
     * }
     */
    public static MethodHandle lroundf$handle() {
        return lroundf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long lroundf(float _X)
     * }
     */
    public static MemorySegment lroundf$address() {
        return lroundf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long lroundf(float _X)
     * }
     */
    public static int lroundf(float _X) {
        var mh$ = lroundf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lroundf", _X);
            }
            return (int)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("nanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float nanf(const char *_X)
     * }
     */
    public static FunctionDescriptor nanf$descriptor() {
        return nanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float nanf(const char *_X)
     * }
     */
    public static MethodHandle nanf$handle() {
        return nanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float nanf(const char *_X)
     * }
     */
    public static MemorySegment nanf$address() {
        return nanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float nanf(const char *_X)
     * }
     */
    public static float nanf(MemorySegment _X) {
        var mh$ = nanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nanf", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nearbyintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("nearbyintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float nearbyintf(float _X)
     * }
     */
    public static FunctionDescriptor nearbyintf$descriptor() {
        return nearbyintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float nearbyintf(float _X)
     * }
     */
    public static MethodHandle nearbyintf$handle() {
        return nearbyintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float nearbyintf(float _X)
     * }
     */
    public static MemorySegment nearbyintf$address() {
        return nearbyintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float nearbyintf(float _X)
     * }
     */
    public static float nearbyintf(float _X) {
        var mh$ = nearbyintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nearbyintf", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nextafterf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("nextafterf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float nextafterf(float _X, float _Y)
     * }
     */
    public static FunctionDescriptor nextafterf$descriptor() {
        return nextafterf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float nextafterf(float _X, float _Y)
     * }
     */
    public static MethodHandle nextafterf$handle() {
        return nextafterf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float nextafterf(float _X, float _Y)
     * }
     */
    public static MemorySegment nextafterf$address() {
        return nextafterf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float nextafterf(float _X, float _Y)
     * }
     */
    public static float nextafterf(float _X, float _Y) {
        var mh$ = nextafterf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nextafterf", _X, _Y);
            }
            return (float)mh$.invokeExact(_X, _Y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nexttowardf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT,
            Python_h.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("nexttowardf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float nexttowardf(float _X, long double _Y)
     * }
     */
    public static FunctionDescriptor nexttowardf$descriptor() {
        return nexttowardf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float nexttowardf(float _X, long double _Y)
     * }
     */
    public static MethodHandle nexttowardf$handle() {
        return nexttowardf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float nexttowardf(float _X, long double _Y)
     * }
     */
    public static MemorySegment nexttowardf$address() {
        return nexttowardf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float nexttowardf(float _X, long double _Y)
     * }
     */
    public static float nexttowardf(float _X, double _Y) {
        var mh$ = nexttowardf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nexttowardf", _X, _Y);
            }
            return (float)mh$.invokeExact(_X, _Y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class remainderf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("remainderf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float remainderf(float _X, float _Y)
     * }
     */
    public static FunctionDescriptor remainderf$descriptor() {
        return remainderf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float remainderf(float _X, float _Y)
     * }
     */
    public static MethodHandle remainderf$handle() {
        return remainderf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float remainderf(float _X, float _Y)
     * }
     */
    public static MemorySegment remainderf$address() {
        return remainderf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float remainderf(float _X, float _Y)
     * }
     */
    public static float remainderf(float _X, float _Y) {
        var mh$ = remainderf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("remainderf", _X, _Y);
            }
            return (float)mh$.invokeExact(_X, _Y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class remquof {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT,
            Python_h.C_FLOAT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("remquof");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float remquof(float _X, float _Y, int *_Z)
     * }
     */
    public static FunctionDescriptor remquof$descriptor() {
        return remquof.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float remquof(float _X, float _Y, int *_Z)
     * }
     */
    public static MethodHandle remquof$handle() {
        return remquof.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float remquof(float _X, float _Y, int *_Z)
     * }
     */
    public static MemorySegment remquof$address() {
        return remquof.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float remquof(float _X, float _Y, int *_Z)
     * }
     */
    public static float remquof(float _X, float _Y, MemorySegment _Z) {
        var mh$ = remquof.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("remquof", _X, _Y, _Z);
            }
            return (float)mh$.invokeExact(_X, _Y, _Z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("rintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float rintf(float _X)
     * }
     */
    public static FunctionDescriptor rintf$descriptor() {
        return rintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float rintf(float _X)
     * }
     */
    public static MethodHandle rintf$handle() {
        return rintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float rintf(float _X)
     * }
     */
    public static MemorySegment rintf$address() {
        return rintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float rintf(float _X)
     * }
     */
    public static float rintf(float _X) {
        var mh$ = rintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rintf", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class roundf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("roundf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float roundf(float _X)
     * }
     */
    public static FunctionDescriptor roundf$descriptor() {
        return roundf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float roundf(float _X)
     * }
     */
    public static MethodHandle roundf$handle() {
        return roundf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float roundf(float _X)
     * }
     */
    public static MemorySegment roundf$address() {
        return roundf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float roundf(float _X)
     * }
     */
    public static float roundf(float _X) {
        var mh$ = roundf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("roundf", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class scalblnf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("scalblnf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float scalblnf(float _X, long _Y)
     * }
     */
    public static FunctionDescriptor scalblnf$descriptor() {
        return scalblnf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float scalblnf(float _X, long _Y)
     * }
     */
    public static MethodHandle scalblnf$handle() {
        return scalblnf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float scalblnf(float _X, long _Y)
     * }
     */
    public static MemorySegment scalblnf$address() {
        return scalblnf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float scalblnf(float _X, long _Y)
     * }
     */
    public static float scalblnf(float _X, int _Y) {
        var mh$ = scalblnf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("scalblnf", _X, _Y);
            }
            return (float)mh$.invokeExact(_X, _Y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class scalbnf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("scalbnf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float scalbnf(float _X, int _Y)
     * }
     */
    public static FunctionDescriptor scalbnf$descriptor() {
        return scalbnf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float scalbnf(float _X, int _Y)
     * }
     */
    public static MethodHandle scalbnf$handle() {
        return scalbnf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float scalbnf(float _X, int _Y)
     * }
     */
    public static MemorySegment scalbnf$address() {
        return scalbnf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float scalbnf(float _X, int _Y)
     * }
     */
    public static float scalbnf(float _X, int _Y) {
        var mh$ = scalbnf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("scalbnf", _X, _Y);
            }
            return (float)mh$.invokeExact(_X, _Y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tgammaf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("tgammaf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float tgammaf(float _X)
     * }
     */
    public static FunctionDescriptor tgammaf$descriptor() {
        return tgammaf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float tgammaf(float _X)
     * }
     */
    public static MethodHandle tgammaf$handle() {
        return tgammaf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float tgammaf(float _X)
     * }
     */
    public static MemorySegment tgammaf$address() {
        return tgammaf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float tgammaf(float _X)
     * }
     */
    public static float tgammaf(float _X) {
        var mh$ = tgammaf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tgammaf", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class truncf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("truncf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float truncf(float _X)
     * }
     */
    public static FunctionDescriptor truncf$descriptor() {
        return truncf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float truncf(float _X)
     * }
     */
    public static MethodHandle truncf$handle() {
        return truncf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float truncf(float _X)
     * }
     */
    public static MemorySegment truncf$address() {
        return truncf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float truncf(float _X)
     * }
     */
    public static float truncf(float _X) {
        var mh$ = truncf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("truncf", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _logbf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_logbf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float _logbf(float _X)
     * }
     */
    public static FunctionDescriptor _logbf$descriptor() {
        return _logbf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float _logbf(float _X)
     * }
     */
    public static MethodHandle _logbf$handle() {
        return _logbf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float _logbf(float _X)
     * }
     */
    public static MemorySegment _logbf$address() {
        return _logbf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float _logbf(float _X)
     * }
     */
    public static float _logbf(float _X) {
        var mh$ = _logbf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_logbf", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _nextafterf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_nextafterf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float _nextafterf(float _X, float _Y)
     * }
     */
    public static FunctionDescriptor _nextafterf$descriptor() {
        return _nextafterf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float _nextafterf(float _X, float _Y)
     * }
     */
    public static MethodHandle _nextafterf$handle() {
        return _nextafterf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float _nextafterf(float _X, float _Y)
     * }
     */
    public static MemorySegment _nextafterf$address() {
        return _nextafterf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float _nextafterf(float _X, float _Y)
     * }
     */
    public static float _nextafterf(float _X, float _Y) {
        var mh$ = _nextafterf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_nextafterf", _X, _Y);
            }
            return (float)mh$.invokeExact(_X, _Y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _finitef {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_finitef");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _finitef(float _X)
     * }
     */
    public static FunctionDescriptor _finitef$descriptor() {
        return _finitef.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _finitef(float _X)
     * }
     */
    public static MethodHandle _finitef$handle() {
        return _finitef.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _finitef(float _X)
     * }
     */
    public static MemorySegment _finitef$address() {
        return _finitef.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _finitef(float _X)
     * }
     */
    public static int _finitef(float _X) {
        var mh$ = _finitef.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_finitef", _X);
            }
            return (int)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _isnanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_isnanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _isnanf(float _X)
     * }
     */
    public static FunctionDescriptor _isnanf$descriptor() {
        return _isnanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _isnanf(float _X)
     * }
     */
    public static MethodHandle _isnanf$handle() {
        return _isnanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _isnanf(float _X)
     * }
     */
    public static MemorySegment _isnanf$address() {
        return _isnanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _isnanf(float _X)
     * }
     */
    public static int _isnanf(float _X) {
        var mh$ = _isnanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_isnanf", _X);
            }
            return (int)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fpclassf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_fpclassf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _fpclassf(float _X)
     * }
     */
    public static FunctionDescriptor _fpclassf$descriptor() {
        return _fpclassf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _fpclassf(float _X)
     * }
     */
    public static MethodHandle _fpclassf$handle() {
        return _fpclassf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _fpclassf(float _X)
     * }
     */
    public static MemorySegment _fpclassf$address() {
        return _fpclassf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _fpclassf(float _X)
     * }
     */
    public static int _fpclassf(float _X) {
        var mh$ = _fpclassf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fpclassf", _X);
            }
            return (int)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _set_FMA3_enable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_set_FMA3_enable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _set_FMA3_enable(int _Flag)
     * }
     */
    public static FunctionDescriptor _set_FMA3_enable$descriptor() {
        return _set_FMA3_enable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _set_FMA3_enable(int _Flag)
     * }
     */
    public static MethodHandle _set_FMA3_enable$handle() {
        return _set_FMA3_enable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _set_FMA3_enable(int _Flag)
     * }
     */
    public static MemorySegment _set_FMA3_enable$address() {
        return _set_FMA3_enable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _set_FMA3_enable(int _Flag)
     * }
     */
    public static int _set_FMA3_enable(int _Flag) {
        var mh$ = _set_FMA3_enable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_set_FMA3_enable", _Flag);
            }
            return (int)mh$.invokeExact(_Flag);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _get_FMA3_enable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_get_FMA3_enable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _get_FMA3_enable()
     * }
     */
    public static FunctionDescriptor _get_FMA3_enable$descriptor() {
        return _get_FMA3_enable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _get_FMA3_enable()
     * }
     */
    public static MethodHandle _get_FMA3_enable$handle() {
        return _get_FMA3_enable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _get_FMA3_enable()
     * }
     */
    public static MemorySegment _get_FMA3_enable$address() {
        return _get_FMA3_enable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _get_FMA3_enable()
     * }
     */
    public static int _get_FMA3_enable() {
        var mh$ = _get_FMA3_enable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_get_FMA3_enable");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class acosf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("acosf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float acosf(float _X)
     * }
     */
    public static FunctionDescriptor acosf$descriptor() {
        return acosf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float acosf(float _X)
     * }
     */
    public static MethodHandle acosf$handle() {
        return acosf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float acosf(float _X)
     * }
     */
    public static MemorySegment acosf$address() {
        return acosf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float acosf(float _X)
     * }
     */
    public static float acosf(float _X) {
        var mh$ = acosf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("acosf", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asinf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("asinf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float asinf(float _X)
     * }
     */
    public static FunctionDescriptor asinf$descriptor() {
        return asinf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float asinf(float _X)
     * }
     */
    public static MethodHandle asinf$handle() {
        return asinf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float asinf(float _X)
     * }
     */
    public static MemorySegment asinf$address() {
        return asinf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float asinf(float _X)
     * }
     */
    public static float asinf(float _X) {
        var mh$ = asinf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("asinf", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atan2f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("atan2f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float atan2f(float _Y, float _X)
     * }
     */
    public static FunctionDescriptor atan2f$descriptor() {
        return atan2f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float atan2f(float _Y, float _X)
     * }
     */
    public static MethodHandle atan2f$handle() {
        return atan2f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float atan2f(float _Y, float _X)
     * }
     */
    public static MemorySegment atan2f$address() {
        return atan2f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float atan2f(float _Y, float _X)
     * }
     */
    public static float atan2f(float _Y, float _X) {
        var mh$ = atan2f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atan2f", _Y, _X);
            }
            return (float)mh$.invokeExact(_Y, _X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("atanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float atanf(float _X)
     * }
     */
    public static FunctionDescriptor atanf$descriptor() {
        return atanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float atanf(float _X)
     * }
     */
    public static MethodHandle atanf$handle() {
        return atanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float atanf(float _X)
     * }
     */
    public static MemorySegment atanf$address() {
        return atanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float atanf(float _X)
     * }
     */
    public static float atanf(float _X) {
        var mh$ = atanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atanf", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ceilf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("ceilf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float ceilf(float _X)
     * }
     */
    public static FunctionDescriptor ceilf$descriptor() {
        return ceilf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float ceilf(float _X)
     * }
     */
    public static MethodHandle ceilf$handle() {
        return ceilf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float ceilf(float _X)
     * }
     */
    public static MemorySegment ceilf$address() {
        return ceilf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float ceilf(float _X)
     * }
     */
    public static float ceilf(float _X) {
        var mh$ = ceilf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ceilf", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cosf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("cosf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float cosf(float _X)
     * }
     */
    public static FunctionDescriptor cosf$descriptor() {
        return cosf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float cosf(float _X)
     * }
     */
    public static MethodHandle cosf$handle() {
        return cosf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float cosf(float _X)
     * }
     */
    public static MemorySegment cosf$address() {
        return cosf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float cosf(float _X)
     * }
     */
    public static float cosf(float _X) {
        var mh$ = cosf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cosf", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class coshf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("coshf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float coshf(float _X)
     * }
     */
    public static FunctionDescriptor coshf$descriptor() {
        return coshf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float coshf(float _X)
     * }
     */
    public static MethodHandle coshf$handle() {
        return coshf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float coshf(float _X)
     * }
     */
    public static MemorySegment coshf$address() {
        return coshf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float coshf(float _X)
     * }
     */
    public static float coshf(float _X) {
        var mh$ = coshf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("coshf", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class expf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("expf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float expf(float _X)
     * }
     */
    public static FunctionDescriptor expf$descriptor() {
        return expf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float expf(float _X)
     * }
     */
    public static MethodHandle expf$handle() {
        return expf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float expf(float _X)
     * }
     */
    public static MemorySegment expf$address() {
        return expf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float expf(float _X)
     * }
     */
    public static float expf(float _X) {
        var mh$ = expf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("expf", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class floorf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("floorf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float floorf(float _X)
     * }
     */
    public static FunctionDescriptor floorf$descriptor() {
        return floorf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float floorf(float _X)
     * }
     */
    public static MethodHandle floorf$handle() {
        return floorf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float floorf(float _X)
     * }
     */
    public static MemorySegment floorf$address() {
        return floorf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float floorf(float _X)
     * }
     */
    public static float floorf(float _X) {
        var mh$ = floorf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("floorf", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fmodf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fmodf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float fmodf(float _X, float _Y)
     * }
     */
    public static FunctionDescriptor fmodf$descriptor() {
        return fmodf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float fmodf(float _X, float _Y)
     * }
     */
    public static MethodHandle fmodf$handle() {
        return fmodf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float fmodf(float _X, float _Y)
     * }
     */
    public static MemorySegment fmodf$address() {
        return fmodf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float fmodf(float _X, float _Y)
     * }
     */
    public static float fmodf(float _X, float _Y) {
        var mh$ = fmodf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fmodf", _X, _Y);
            }
            return (float)mh$.invokeExact(_X, _Y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class log10f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("log10f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float log10f(float _X)
     * }
     */
    public static FunctionDescriptor log10f$descriptor() {
        return log10f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float log10f(float _X)
     * }
     */
    public static MethodHandle log10f$handle() {
        return log10f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float log10f(float _X)
     * }
     */
    public static MemorySegment log10f$address() {
        return log10f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float log10f(float _X)
     * }
     */
    public static float log10f(float _X) {
        var mh$ = log10f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("log10f", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class logf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("logf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float logf(float _X)
     * }
     */
    public static FunctionDescriptor logf$descriptor() {
        return logf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float logf(float _X)
     * }
     */
    public static MethodHandle logf$handle() {
        return logf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float logf(float _X)
     * }
     */
    public static MemorySegment logf$address() {
        return logf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float logf(float _X)
     * }
     */
    public static float logf(float _X) {
        var mh$ = logf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("logf", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class modff {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("modff");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float modff(float _X, float *_Y)
     * }
     */
    public static FunctionDescriptor modff$descriptor() {
        return modff.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float modff(float _X, float *_Y)
     * }
     */
    public static MethodHandle modff$handle() {
        return modff.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float modff(float _X, float *_Y)
     * }
     */
    public static MemorySegment modff$address() {
        return modff.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float modff(float _X, float *_Y)
     * }
     */
    public static float modff(float _X, MemorySegment _Y) {
        var mh$ = modff.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("modff", _X, _Y);
            }
            return (float)mh$.invokeExact(_X, _Y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class powf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("powf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float powf(float _X, float _Y)
     * }
     */
    public static FunctionDescriptor powf$descriptor() {
        return powf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float powf(float _X, float _Y)
     * }
     */
    public static MethodHandle powf$handle() {
        return powf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float powf(float _X, float _Y)
     * }
     */
    public static MemorySegment powf$address() {
        return powf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float powf(float _X, float _Y)
     * }
     */
    public static float powf(float _X, float _Y) {
        var mh$ = powf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("powf", _X, _Y);
            }
            return (float)mh$.invokeExact(_X, _Y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sinf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("sinf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float sinf(float _X)
     * }
     */
    public static FunctionDescriptor sinf$descriptor() {
        return sinf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float sinf(float _X)
     * }
     */
    public static MethodHandle sinf$handle() {
        return sinf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float sinf(float _X)
     * }
     */
    public static MemorySegment sinf$address() {
        return sinf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float sinf(float _X)
     * }
     */
    public static float sinf(float _X) {
        var mh$ = sinf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sinf", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sinhf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("sinhf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float sinhf(float _X)
     * }
     */
    public static FunctionDescriptor sinhf$descriptor() {
        return sinhf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float sinhf(float _X)
     * }
     */
    public static MethodHandle sinhf$handle() {
        return sinhf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float sinhf(float _X)
     * }
     */
    public static MemorySegment sinhf$address() {
        return sinhf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float sinhf(float _X)
     * }
     */
    public static float sinhf(float _X) {
        var mh$ = sinhf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sinhf", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sqrtf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("sqrtf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float sqrtf(float _X)
     * }
     */
    public static FunctionDescriptor sqrtf$descriptor() {
        return sqrtf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float sqrtf(float _X)
     * }
     */
    public static MethodHandle sqrtf$handle() {
        return sqrtf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float sqrtf(float _X)
     * }
     */
    public static MemorySegment sqrtf$address() {
        return sqrtf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float sqrtf(float _X)
     * }
     */
    public static float sqrtf(float _X) {
        var mh$ = sqrtf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sqrtf", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("tanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float tanf(float _X)
     * }
     */
    public static FunctionDescriptor tanf$descriptor() {
        return tanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float tanf(float _X)
     * }
     */
    public static MethodHandle tanf$handle() {
        return tanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float tanf(float _X)
     * }
     */
    public static MemorySegment tanf$address() {
        return tanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float tanf(float _X)
     * }
     */
    public static float tanf(float _X) {
        var mh$ = tanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tanf", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tanhf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("tanhf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float tanhf(float _X)
     * }
     */
    public static FunctionDescriptor tanhf$descriptor() {
        return tanhf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float tanhf(float _X)
     * }
     */
    public static MethodHandle tanhf$handle() {
        return tanhf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float tanhf(float _X)
     * }
     */
    public static MemorySegment tanhf$address() {
        return tanhf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float tanhf(float _X)
     * }
     */
    public static float tanhf(float _X) {
        var mh$ = tanhf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tanhf", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class acoshl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_DOUBLE,
            Python_h.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("acoshl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double acoshl(long double _X)
     * }
     */
    public static FunctionDescriptor acoshl$descriptor() {
        return acoshl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double acoshl(long double _X)
     * }
     */
    public static MethodHandle acoshl$handle() {
        return acoshl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double acoshl(long double _X)
     * }
     */
    public static MemorySegment acoshl$address() {
        return acoshl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double acoshl(long double _X)
     * }
     */
    public static double acoshl(double _X) {
        var mh$ = acoshl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("acoshl", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asinhl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_DOUBLE,
            Python_h.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("asinhl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double asinhl(long double _X)
     * }
     */
    public static FunctionDescriptor asinhl$descriptor() {
        return asinhl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double asinhl(long double _X)
     * }
     */
    public static MethodHandle asinhl$handle() {
        return asinhl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double asinhl(long double _X)
     * }
     */
    public static MemorySegment asinhl$address() {
        return asinhl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double asinhl(long double _X)
     * }
     */
    public static double asinhl(double _X) {
        var mh$ = asinhl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("asinhl", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atanhl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_DOUBLE,
            Python_h.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("atanhl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double atanhl(long double _X)
     * }
     */
    public static FunctionDescriptor atanhl$descriptor() {
        return atanhl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double atanhl(long double _X)
     * }
     */
    public static MethodHandle atanhl$handle() {
        return atanhl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double atanhl(long double _X)
     * }
     */
    public static MemorySegment atanhl$address() {
        return atanhl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double atanhl(long double _X)
     * }
     */
    public static double atanhl(double _X) {
        var mh$ = atanhl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atanhl", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cbrtl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_DOUBLE,
            Python_h.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("cbrtl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double cbrtl(long double _X)
     * }
     */
    public static FunctionDescriptor cbrtl$descriptor() {
        return cbrtl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double cbrtl(long double _X)
     * }
     */
    public static MethodHandle cbrtl$handle() {
        return cbrtl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double cbrtl(long double _X)
     * }
     */
    public static MemorySegment cbrtl$address() {
        return cbrtl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double cbrtl(long double _X)
     * }
     */
    public static double cbrtl(double _X) {
        var mh$ = cbrtl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cbrtl", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class copysignl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_DOUBLE,
            Python_h.C_LONG_DOUBLE,
            Python_h.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("copysignl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double copysignl(long double _Number, long double _Sign)
     * }
     */
    public static FunctionDescriptor copysignl$descriptor() {
        return copysignl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double copysignl(long double _Number, long double _Sign)
     * }
     */
    public static MethodHandle copysignl$handle() {
        return copysignl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double copysignl(long double _Number, long double _Sign)
     * }
     */
    public static MemorySegment copysignl$address() {
        return copysignl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double copysignl(long double _Number, long double _Sign)
     * }
     */
    public static double copysignl(double _Number, double _Sign) {
        var mh$ = copysignl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("copysignl", _Number, _Sign);
            }
            return (double)mh$.invokeExact(_Number, _Sign);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class erfl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_DOUBLE,
            Python_h.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("erfl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double erfl(long double _X)
     * }
     */
    public static FunctionDescriptor erfl$descriptor() {
        return erfl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double erfl(long double _X)
     * }
     */
    public static MethodHandle erfl$handle() {
        return erfl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double erfl(long double _X)
     * }
     */
    public static MemorySegment erfl$address() {
        return erfl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double erfl(long double _X)
     * }
     */
    public static double erfl(double _X) {
        var mh$ = erfl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("erfl", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class erfcl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_DOUBLE,
            Python_h.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("erfcl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double erfcl(long double _X)
     * }
     */
    public static FunctionDescriptor erfcl$descriptor() {
        return erfcl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double erfcl(long double _X)
     * }
     */
    public static MethodHandle erfcl$handle() {
        return erfcl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double erfcl(long double _X)
     * }
     */
    public static MemorySegment erfcl$address() {
        return erfcl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double erfcl(long double _X)
     * }
     */
    public static double erfcl(double _X) {
        var mh$ = erfcl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("erfcl", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class exp2l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_DOUBLE,
            Python_h.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("exp2l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double exp2l(long double _X)
     * }
     */
    public static FunctionDescriptor exp2l$descriptor() {
        return exp2l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double exp2l(long double _X)
     * }
     */
    public static MethodHandle exp2l$handle() {
        return exp2l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double exp2l(long double _X)
     * }
     */
    public static MemorySegment exp2l$address() {
        return exp2l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double exp2l(long double _X)
     * }
     */
    public static double exp2l(double _X) {
        var mh$ = exp2l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("exp2l", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class expm1l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_DOUBLE,
            Python_h.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("expm1l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double expm1l(long double _X)
     * }
     */
    public static FunctionDescriptor expm1l$descriptor() {
        return expm1l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double expm1l(long double _X)
     * }
     */
    public static MethodHandle expm1l$handle() {
        return expm1l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double expm1l(long double _X)
     * }
     */
    public static MemorySegment expm1l$address() {
        return expm1l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double expm1l(long double _X)
     * }
     */
    public static double expm1l(double _X) {
        var mh$ = expm1l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("expm1l", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fdiml {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_DOUBLE,
            Python_h.C_LONG_DOUBLE,
            Python_h.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fdiml");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double fdiml(long double _X, long double _Y)
     * }
     */
    public static FunctionDescriptor fdiml$descriptor() {
        return fdiml.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double fdiml(long double _X, long double _Y)
     * }
     */
    public static MethodHandle fdiml$handle() {
        return fdiml.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double fdiml(long double _X, long double _Y)
     * }
     */
    public static MemorySegment fdiml$address() {
        return fdiml.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double fdiml(long double _X, long double _Y)
     * }
     */
    public static double fdiml(double _X, double _Y) {
        var mh$ = fdiml.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fdiml", _X, _Y);
            }
            return (double)mh$.invokeExact(_X, _Y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fmal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_DOUBLE,
            Python_h.C_LONG_DOUBLE,
            Python_h.C_LONG_DOUBLE,
            Python_h.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fmal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double fmal(long double _X, long double _Y, long double _Z)
     * }
     */
    public static FunctionDescriptor fmal$descriptor() {
        return fmal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double fmal(long double _X, long double _Y, long double _Z)
     * }
     */
    public static MethodHandle fmal$handle() {
        return fmal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double fmal(long double _X, long double _Y, long double _Z)
     * }
     */
    public static MemorySegment fmal$address() {
        return fmal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double fmal(long double _X, long double _Y, long double _Z)
     * }
     */
    public static double fmal(double _X, double _Y, double _Z) {
        var mh$ = fmal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fmal", _X, _Y, _Z);
            }
            return (double)mh$.invokeExact(_X, _Y, _Z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fmaxl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_DOUBLE,
            Python_h.C_LONG_DOUBLE,
            Python_h.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fmaxl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double fmaxl(long double _X, long double _Y)
     * }
     */
    public static FunctionDescriptor fmaxl$descriptor() {
        return fmaxl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double fmaxl(long double _X, long double _Y)
     * }
     */
    public static MethodHandle fmaxl$handle() {
        return fmaxl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double fmaxl(long double _X, long double _Y)
     * }
     */
    public static MemorySegment fmaxl$address() {
        return fmaxl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double fmaxl(long double _X, long double _Y)
     * }
     */
    public static double fmaxl(double _X, double _Y) {
        var mh$ = fmaxl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fmaxl", _X, _Y);
            }
            return (double)mh$.invokeExact(_X, _Y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fminl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_DOUBLE,
            Python_h.C_LONG_DOUBLE,
            Python_h.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fminl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double fminl(long double _X, long double _Y)
     * }
     */
    public static FunctionDescriptor fminl$descriptor() {
        return fminl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double fminl(long double _X, long double _Y)
     * }
     */
    public static MethodHandle fminl$handle() {
        return fminl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double fminl(long double _X, long double _Y)
     * }
     */
    public static MemorySegment fminl$address() {
        return fminl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double fminl(long double _X, long double _Y)
     * }
     */
    public static double fminl(double _X, double _Y) {
        var mh$ = fminl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fminl", _X, _Y);
            }
            return (double)mh$.invokeExact(_X, _Y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ilogbl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("ilogbl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ilogbl(long double _X)
     * }
     */
    public static FunctionDescriptor ilogbl$descriptor() {
        return ilogbl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ilogbl(long double _X)
     * }
     */
    public static MethodHandle ilogbl$handle() {
        return ilogbl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ilogbl(long double _X)
     * }
     */
    public static MemorySegment ilogbl$address() {
        return ilogbl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ilogbl(long double _X)
     * }
     */
    public static int ilogbl(double _X) {
        var mh$ = ilogbl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ilogbl", _X);
            }
            return (int)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lgammal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_DOUBLE,
            Python_h.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("lgammal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double lgammal(long double _X)
     * }
     */
    public static FunctionDescriptor lgammal$descriptor() {
        return lgammal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double lgammal(long double _X)
     * }
     */
    public static MethodHandle lgammal$handle() {
        return lgammal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double lgammal(long double _X)
     * }
     */
    public static MemorySegment lgammal$address() {
        return lgammal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double lgammal(long double _X)
     * }
     */
    public static double lgammal(double _X) {
        var mh$ = lgammal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lgammal", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llrintl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("llrintl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long llrintl(long double _X)
     * }
     */
    public static FunctionDescriptor llrintl$descriptor() {
        return llrintl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long llrintl(long double _X)
     * }
     */
    public static MethodHandle llrintl$handle() {
        return llrintl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long llrintl(long double _X)
     * }
     */
    public static MemorySegment llrintl$address() {
        return llrintl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long llrintl(long double _X)
     * }
     */
    public static long llrintl(double _X) {
        var mh$ = llrintl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llrintl", _X);
            }
            return (long)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llroundl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("llroundl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long llroundl(long double _X)
     * }
     */
    public static FunctionDescriptor llroundl$descriptor() {
        return llroundl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long llroundl(long double _X)
     * }
     */
    public static MethodHandle llroundl$handle() {
        return llroundl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long llroundl(long double _X)
     * }
     */
    public static MemorySegment llroundl$address() {
        return llroundl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long llroundl(long double _X)
     * }
     */
    public static long llroundl(double _X) {
        var mh$ = llroundl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llroundl", _X);
            }
            return (long)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class log1pl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_DOUBLE,
            Python_h.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("log1pl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double log1pl(long double _X)
     * }
     */
    public static FunctionDescriptor log1pl$descriptor() {
        return log1pl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double log1pl(long double _X)
     * }
     */
    public static MethodHandle log1pl$handle() {
        return log1pl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double log1pl(long double _X)
     * }
     */
    public static MemorySegment log1pl$address() {
        return log1pl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double log1pl(long double _X)
     * }
     */
    public static double log1pl(double _X) {
        var mh$ = log1pl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("log1pl", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class log2l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_DOUBLE,
            Python_h.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("log2l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double log2l(long double _X)
     * }
     */
    public static FunctionDescriptor log2l$descriptor() {
        return log2l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double log2l(long double _X)
     * }
     */
    public static MethodHandle log2l$handle() {
        return log2l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double log2l(long double _X)
     * }
     */
    public static MemorySegment log2l$address() {
        return log2l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double log2l(long double _X)
     * }
     */
    public static double log2l(double _X) {
        var mh$ = log2l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("log2l", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class logbl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_DOUBLE,
            Python_h.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("logbl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double logbl(long double _X)
     * }
     */
    public static FunctionDescriptor logbl$descriptor() {
        return logbl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double logbl(long double _X)
     * }
     */
    public static MethodHandle logbl$handle() {
        return logbl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double logbl(long double _X)
     * }
     */
    public static MemorySegment logbl$address() {
        return logbl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double logbl(long double _X)
     * }
     */
    public static double logbl(double _X) {
        var mh$ = logbl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("logbl", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lrintl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("lrintl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long lrintl(long double _X)
     * }
     */
    public static FunctionDescriptor lrintl$descriptor() {
        return lrintl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long lrintl(long double _X)
     * }
     */
    public static MethodHandle lrintl$handle() {
        return lrintl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long lrintl(long double _X)
     * }
     */
    public static MemorySegment lrintl$address() {
        return lrintl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long lrintl(long double _X)
     * }
     */
    public static int lrintl(double _X) {
        var mh$ = lrintl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lrintl", _X);
            }
            return (int)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lroundl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("lroundl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long lroundl(long double _X)
     * }
     */
    public static FunctionDescriptor lroundl$descriptor() {
        return lroundl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long lroundl(long double _X)
     * }
     */
    public static MethodHandle lroundl$handle() {
        return lroundl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long lroundl(long double _X)
     * }
     */
    public static MemorySegment lroundl$address() {
        return lroundl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long lroundl(long double _X)
     * }
     */
    public static int lroundl(double _X) {
        var mh$ = lroundl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lroundl", _X);
            }
            return (int)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nanl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_DOUBLE,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("nanl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double nanl(const char *_X)
     * }
     */
    public static FunctionDescriptor nanl$descriptor() {
        return nanl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double nanl(const char *_X)
     * }
     */
    public static MethodHandle nanl$handle() {
        return nanl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double nanl(const char *_X)
     * }
     */
    public static MemorySegment nanl$address() {
        return nanl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double nanl(const char *_X)
     * }
     */
    public static double nanl(MemorySegment _X) {
        var mh$ = nanl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nanl", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nearbyintl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_DOUBLE,
            Python_h.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("nearbyintl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double nearbyintl(long double _X)
     * }
     */
    public static FunctionDescriptor nearbyintl$descriptor() {
        return nearbyintl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double nearbyintl(long double _X)
     * }
     */
    public static MethodHandle nearbyintl$handle() {
        return nearbyintl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double nearbyintl(long double _X)
     * }
     */
    public static MemorySegment nearbyintl$address() {
        return nearbyintl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double nearbyintl(long double _X)
     * }
     */
    public static double nearbyintl(double _X) {
        var mh$ = nearbyintl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nearbyintl", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nextafterl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_DOUBLE,
            Python_h.C_LONG_DOUBLE,
            Python_h.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("nextafterl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double nextafterl(long double _X, long double _Y)
     * }
     */
    public static FunctionDescriptor nextafterl$descriptor() {
        return nextafterl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double nextafterl(long double _X, long double _Y)
     * }
     */
    public static MethodHandle nextafterl$handle() {
        return nextafterl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double nextafterl(long double _X, long double _Y)
     * }
     */
    public static MemorySegment nextafterl$address() {
        return nextafterl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double nextafterl(long double _X, long double _Y)
     * }
     */
    public static double nextafterl(double _X, double _Y) {
        var mh$ = nextafterl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nextafterl", _X, _Y);
            }
            return (double)mh$.invokeExact(_X, _Y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nexttowardl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_DOUBLE,
            Python_h.C_LONG_DOUBLE,
            Python_h.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("nexttowardl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double nexttowardl(long double _X, long double _Y)
     * }
     */
    public static FunctionDescriptor nexttowardl$descriptor() {
        return nexttowardl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double nexttowardl(long double _X, long double _Y)
     * }
     */
    public static MethodHandle nexttowardl$handle() {
        return nexttowardl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double nexttowardl(long double _X, long double _Y)
     * }
     */
    public static MemorySegment nexttowardl$address() {
        return nexttowardl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double nexttowardl(long double _X, long double _Y)
     * }
     */
    public static double nexttowardl(double _X, double _Y) {
        var mh$ = nexttowardl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nexttowardl", _X, _Y);
            }
            return (double)mh$.invokeExact(_X, _Y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class remainderl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_DOUBLE,
            Python_h.C_LONG_DOUBLE,
            Python_h.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("remainderl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double remainderl(long double _X, long double _Y)
     * }
     */
    public static FunctionDescriptor remainderl$descriptor() {
        return remainderl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double remainderl(long double _X, long double _Y)
     * }
     */
    public static MethodHandle remainderl$handle() {
        return remainderl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double remainderl(long double _X, long double _Y)
     * }
     */
    public static MemorySegment remainderl$address() {
        return remainderl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double remainderl(long double _X, long double _Y)
     * }
     */
    public static double remainderl(double _X, double _Y) {
        var mh$ = remainderl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("remainderl", _X, _Y);
            }
            return (double)mh$.invokeExact(_X, _Y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class remquol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_DOUBLE,
            Python_h.C_LONG_DOUBLE,
            Python_h.C_LONG_DOUBLE,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("remquol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double remquol(long double _X, long double _Y, int *_Z)
     * }
     */
    public static FunctionDescriptor remquol$descriptor() {
        return remquol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double remquol(long double _X, long double _Y, int *_Z)
     * }
     */
    public static MethodHandle remquol$handle() {
        return remquol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double remquol(long double _X, long double _Y, int *_Z)
     * }
     */
    public static MemorySegment remquol$address() {
        return remquol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double remquol(long double _X, long double _Y, int *_Z)
     * }
     */
    public static double remquol(double _X, double _Y, MemorySegment _Z) {
        var mh$ = remquol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("remquol", _X, _Y, _Z);
            }
            return (double)mh$.invokeExact(_X, _Y, _Z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rintl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_DOUBLE,
            Python_h.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("rintl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double rintl(long double _X)
     * }
     */
    public static FunctionDescriptor rintl$descriptor() {
        return rintl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double rintl(long double _X)
     * }
     */
    public static MethodHandle rintl$handle() {
        return rintl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double rintl(long double _X)
     * }
     */
    public static MemorySegment rintl$address() {
        return rintl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double rintl(long double _X)
     * }
     */
    public static double rintl(double _X) {
        var mh$ = rintl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rintl", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class roundl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_DOUBLE,
            Python_h.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("roundl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double roundl(long double _X)
     * }
     */
    public static FunctionDescriptor roundl$descriptor() {
        return roundl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double roundl(long double _X)
     * }
     */
    public static MethodHandle roundl$handle() {
        return roundl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double roundl(long double _X)
     * }
     */
    public static MemorySegment roundl$address() {
        return roundl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double roundl(long double _X)
     * }
     */
    public static double roundl(double _X) {
        var mh$ = roundl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("roundl", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class scalblnl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_DOUBLE,
            Python_h.C_LONG_DOUBLE,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("scalblnl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double scalblnl(long double _X, long _Y)
     * }
     */
    public static FunctionDescriptor scalblnl$descriptor() {
        return scalblnl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double scalblnl(long double _X, long _Y)
     * }
     */
    public static MethodHandle scalblnl$handle() {
        return scalblnl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double scalblnl(long double _X, long _Y)
     * }
     */
    public static MemorySegment scalblnl$address() {
        return scalblnl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double scalblnl(long double _X, long _Y)
     * }
     */
    public static double scalblnl(double _X, int _Y) {
        var mh$ = scalblnl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("scalblnl", _X, _Y);
            }
            return (double)mh$.invokeExact(_X, _Y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class scalbnl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_DOUBLE,
            Python_h.C_LONG_DOUBLE,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("scalbnl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double scalbnl(long double _X, int _Y)
     * }
     */
    public static FunctionDescriptor scalbnl$descriptor() {
        return scalbnl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double scalbnl(long double _X, int _Y)
     * }
     */
    public static MethodHandle scalbnl$handle() {
        return scalbnl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double scalbnl(long double _X, int _Y)
     * }
     */
    public static MemorySegment scalbnl$address() {
        return scalbnl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double scalbnl(long double _X, int _Y)
     * }
     */
    public static double scalbnl(double _X, int _Y) {
        var mh$ = scalbnl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("scalbnl", _X, _Y);
            }
            return (double)mh$.invokeExact(_X, _Y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tgammal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_DOUBLE,
            Python_h.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("tgammal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double tgammal(long double _X)
     * }
     */
    public static FunctionDescriptor tgammal$descriptor() {
        return tgammal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double tgammal(long double _X)
     * }
     */
    public static MethodHandle tgammal$handle() {
        return tgammal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double tgammal(long double _X)
     * }
     */
    public static MemorySegment tgammal$address() {
        return tgammal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double tgammal(long double _X)
     * }
     */
    public static double tgammal(double _X) {
        var mh$ = tgammal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tgammal", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class truncl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_DOUBLE,
            Python_h.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("truncl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double truncl(long double _X)
     * }
     */
    public static FunctionDescriptor truncl$descriptor() {
        return truncl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double truncl(long double _X)
     * }
     */
    public static MethodHandle truncl$handle() {
        return truncl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double truncl(long double _X)
     * }
     */
    public static MemorySegment truncl$address() {
        return truncl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double truncl(long double _X)
     * }
     */
    public static double truncl(double _X) {
        var mh$ = truncl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("truncl", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class HUGE$constants {
        public static final OfDouble LAYOUT = Python_h.C_DOUBLE;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("HUGE").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern double HUGE
     * }
     */
    public static OfDouble HUGE$layout() {
        return HUGE$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern double HUGE
     * }
     */
    public static MemorySegment HUGE$segment() {
        return HUGE$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern double HUGE
     * }
     */
    public static double HUGE() {
        return HUGE$constants.SEGMENT.get(HUGE$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern double HUGE
     * }
     */
    public static void HUGE(double varValue) {
        HUGE$constants.SEGMENT.set(HUGE$constants.LAYOUT, 0L, varValue);
    }

    private static class j0 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("j0");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double j0(double _X)
     * }
     */
    public static FunctionDescriptor j0$descriptor() {
        return j0.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double j0(double _X)
     * }
     */
    public static MethodHandle j0$handle() {
        return j0.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double j0(double _X)
     * }
     */
    public static MemorySegment j0$address() {
        return j0.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double j0(double _X)
     * }
     */
    public static double j0(double _X) {
        var mh$ = j0.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("j0", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class j1 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("j1");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double j1(double _X)
     * }
     */
    public static FunctionDescriptor j1$descriptor() {
        return j1.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double j1(double _X)
     * }
     */
    public static MethodHandle j1$handle() {
        return j1.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double j1(double _X)
     * }
     */
    public static MemorySegment j1$address() {
        return j1.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double j1(double _X)
     * }
     */
    public static double j1(double _X) {
        var mh$ = j1.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("j1", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class jn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_INT,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("jn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double jn(int _X, double _Y)
     * }
     */
    public static FunctionDescriptor jn$descriptor() {
        return jn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double jn(int _X, double _Y)
     * }
     */
    public static MethodHandle jn$handle() {
        return jn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double jn(int _X, double _Y)
     * }
     */
    public static MemorySegment jn$address() {
        return jn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double jn(int _X, double _Y)
     * }
     */
    public static double jn(int _X, double _Y) {
        var mh$ = jn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("jn", _X, _Y);
            }
            return (double)mh$.invokeExact(_X, _Y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class y0 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("y0");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double y0(double _X)
     * }
     */
    public static FunctionDescriptor y0$descriptor() {
        return y0.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double y0(double _X)
     * }
     */
    public static MethodHandle y0$handle() {
        return y0.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double y0(double _X)
     * }
     */
    public static MemorySegment y0$address() {
        return y0.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double y0(double _X)
     * }
     */
    public static double y0(double _X) {
        var mh$ = y0.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("y0", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class y1 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("y1");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double y1(double _X)
     * }
     */
    public static FunctionDescriptor y1$descriptor() {
        return y1.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double y1(double _X)
     * }
     */
    public static MethodHandle y1$handle() {
        return y1.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double y1(double _X)
     * }
     */
    public static MemorySegment y1$address() {
        return y1.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double y1(double _X)
     * }
     */
    public static double y1(double _X) {
        var mh$ = y1.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("y1", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class yn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_INT,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("yn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double yn(int _X, double _Y)
     * }
     */
    public static FunctionDescriptor yn$descriptor() {
        return yn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double yn(int _X, double _Y)
     * }
     */
    public static MethodHandle yn$handle() {
        return yn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double yn(int _X, double _Y)
     * }
     */
    public static MemorySegment yn$address() {
        return yn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double yn(int _X, double _Y)
     * }
     */
    public static double yn(int _X, double _Y) {
        var mh$ = yn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("yn", _X, _Y);
            }
            return (double)mh$.invokeExact(_X, _Y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef long clock_t
     * }
     */
    public static final OfInt clock_t = Python_h.C_LONG;

    private static class __daylight {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("__daylight");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int *__daylight()
     * }
     */
    public static FunctionDescriptor __daylight$descriptor() {
        return __daylight.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int *__daylight()
     * }
     */
    public static MethodHandle __daylight$handle() {
        return __daylight.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int *__daylight()
     * }
     */
    public static MemorySegment __daylight$address() {
        return __daylight.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int *__daylight()
     * }
     */
    public static MemorySegment __daylight() {
        var mh$ = __daylight.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__daylight");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __dstbias {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("__dstbias");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long *__dstbias()
     * }
     */
    public static FunctionDescriptor __dstbias$descriptor() {
        return __dstbias.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long *__dstbias()
     * }
     */
    public static MethodHandle __dstbias$handle() {
        return __dstbias.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long *__dstbias()
     * }
     */
    public static MemorySegment __dstbias$address() {
        return __dstbias.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long *__dstbias()
     * }
     */
    public static MemorySegment __dstbias() {
        var mh$ = __dstbias.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__dstbias");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __timezone {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("__timezone");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long *__timezone()
     * }
     */
    public static FunctionDescriptor __timezone$descriptor() {
        return __timezone.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long *__timezone()
     * }
     */
    public static MethodHandle __timezone$handle() {
        return __timezone.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long *__timezone()
     * }
     */
    public static MemorySegment __timezone$address() {
        return __timezone.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long *__timezone()
     * }
     */
    public static MemorySegment __timezone() {
        var mh$ = __timezone.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__timezone");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __tzname {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("__tzname");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char **__tzname()
     * }
     */
    public static FunctionDescriptor __tzname$descriptor() {
        return __tzname.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char **__tzname()
     * }
     */
    public static MethodHandle __tzname$handle() {
        return __tzname.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char **__tzname()
     * }
     */
    public static MemorySegment __tzname$address() {
        return __tzname.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char **__tzname()
     * }
     */
    public static MemorySegment __tzname() {
        var mh$ = __tzname.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__tzname");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _get_daylight {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_get_daylight");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _get_daylight(int *_Daylight)
     * }
     */
    public static FunctionDescriptor _get_daylight$descriptor() {
        return _get_daylight.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _get_daylight(int *_Daylight)
     * }
     */
    public static MethodHandle _get_daylight$handle() {
        return _get_daylight.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _get_daylight(int *_Daylight)
     * }
     */
    public static MemorySegment _get_daylight$address() {
        return _get_daylight.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _get_daylight(int *_Daylight)
     * }
     */
    public static int _get_daylight(MemorySegment _Daylight) {
        var mh$ = _get_daylight.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_get_daylight", _Daylight);
            }
            return (int)mh$.invokeExact(_Daylight);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _get_dstbias {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_get_dstbias");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _get_dstbias(long *_DaylightSavingsBias)
     * }
     */
    public static FunctionDescriptor _get_dstbias$descriptor() {
        return _get_dstbias.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _get_dstbias(long *_DaylightSavingsBias)
     * }
     */
    public static MethodHandle _get_dstbias$handle() {
        return _get_dstbias.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _get_dstbias(long *_DaylightSavingsBias)
     * }
     */
    public static MemorySegment _get_dstbias$address() {
        return _get_dstbias.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _get_dstbias(long *_DaylightSavingsBias)
     * }
     */
    public static int _get_dstbias(MemorySegment _DaylightSavingsBias) {
        var mh$ = _get_dstbias.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_get_dstbias", _DaylightSavingsBias);
            }
            return (int)mh$.invokeExact(_DaylightSavingsBias);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _get_timezone {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_get_timezone");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _get_timezone(long *_TimeZone)
     * }
     */
    public static FunctionDescriptor _get_timezone$descriptor() {
        return _get_timezone.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _get_timezone(long *_TimeZone)
     * }
     */
    public static MethodHandle _get_timezone$handle() {
        return _get_timezone.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _get_timezone(long *_TimeZone)
     * }
     */
    public static MemorySegment _get_timezone$address() {
        return _get_timezone.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _get_timezone(long *_TimeZone)
     * }
     */
    public static int _get_timezone(MemorySegment _TimeZone) {
        var mh$ = _get_timezone.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_get_timezone", _TimeZone);
            }
            return (int)mh$.invokeExact(_TimeZone);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _get_tzname {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_get_tzname");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _get_tzname(size_t *_ReturnValue, char *_Buffer, size_t _SizeInBytes, int _Index)
     * }
     */
    public static FunctionDescriptor _get_tzname$descriptor() {
        return _get_tzname.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _get_tzname(size_t *_ReturnValue, char *_Buffer, size_t _SizeInBytes, int _Index)
     * }
     */
    public static MethodHandle _get_tzname$handle() {
        return _get_tzname.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _get_tzname(size_t *_ReturnValue, char *_Buffer, size_t _SizeInBytes, int _Index)
     * }
     */
    public static MemorySegment _get_tzname$address() {
        return _get_tzname.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _get_tzname(size_t *_ReturnValue, char *_Buffer, size_t _SizeInBytes, int _Index)
     * }
     */
    public static int _get_tzname(MemorySegment _ReturnValue, MemorySegment _Buffer, long _SizeInBytes, int _Index) {
        var mh$ = _get_tzname.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_get_tzname", _ReturnValue, _Buffer, _SizeInBytes, _Index);
            }
            return (int)mh$.invokeExact(_ReturnValue, _Buffer, _SizeInBytes, _Index);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asctime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("asctime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *asctime(const struct tm *_Tm)
     * }
     */
    public static FunctionDescriptor asctime$descriptor() {
        return asctime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *asctime(const struct tm *_Tm)
     * }
     */
    public static MethodHandle asctime$handle() {
        return asctime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *asctime(const struct tm *_Tm)
     * }
     */
    public static MemorySegment asctime$address() {
        return asctime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *asctime(const struct tm *_Tm)
     * }
     */
    public static MemorySegment asctime(MemorySegment _Tm) {
        var mh$ = asctime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("asctime", _Tm);
            }
            return (MemorySegment)mh$.invokeExact(_Tm);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asctime_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("asctime_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t asctime_s(char *_Buffer, size_t _SizeInBytes, const struct tm *_Tm)
     * }
     */
    public static FunctionDescriptor asctime_s$descriptor() {
        return asctime_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t asctime_s(char *_Buffer, size_t _SizeInBytes, const struct tm *_Tm)
     * }
     */
    public static MethodHandle asctime_s$handle() {
        return asctime_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t asctime_s(char *_Buffer, size_t _SizeInBytes, const struct tm *_Tm)
     * }
     */
    public static MemorySegment asctime_s$address() {
        return asctime_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t asctime_s(char *_Buffer, size_t _SizeInBytes, const struct tm *_Tm)
     * }
     */
    public static int asctime_s(MemorySegment _Buffer, long _SizeInBytes, MemorySegment _Tm) {
        var mh$ = asctime_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("asctime_s", _Buffer, _SizeInBytes, _Tm);
            }
            return (int)mh$.invokeExact(_Buffer, _SizeInBytes, _Tm);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("clock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * clock_t clock()
     * }
     */
    public static FunctionDescriptor clock$descriptor() {
        return clock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * clock_t clock()
     * }
     */
    public static MethodHandle clock$handle() {
        return clock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * clock_t clock()
     * }
     */
    public static MemorySegment clock$address() {
        return clock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * clock_t clock()
     * }
     */
    public static int clock() {
        var mh$ = clock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clock");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ctime32 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_ctime32");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *_ctime32(const __time32_t *_Time)
     * }
     */
    public static FunctionDescriptor _ctime32$descriptor() {
        return _ctime32.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *_ctime32(const __time32_t *_Time)
     * }
     */
    public static MethodHandle _ctime32$handle() {
        return _ctime32.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *_ctime32(const __time32_t *_Time)
     * }
     */
    public static MemorySegment _ctime32$address() {
        return _ctime32.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *_ctime32(const __time32_t *_Time)
     * }
     */
    public static MemorySegment _ctime32(MemorySegment _Time) {
        var mh$ = _ctime32.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ctime32", _Time);
            }
            return (MemorySegment)mh$.invokeExact(_Time);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ctime32_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_ctime32_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _ctime32_s(char *_Buffer, size_t _SizeInBytes, const __time32_t *_Time)
     * }
     */
    public static FunctionDescriptor _ctime32_s$descriptor() {
        return _ctime32_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _ctime32_s(char *_Buffer, size_t _SizeInBytes, const __time32_t *_Time)
     * }
     */
    public static MethodHandle _ctime32_s$handle() {
        return _ctime32_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _ctime32_s(char *_Buffer, size_t _SizeInBytes, const __time32_t *_Time)
     * }
     */
    public static MemorySegment _ctime32_s$address() {
        return _ctime32_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _ctime32_s(char *_Buffer, size_t _SizeInBytes, const __time32_t *_Time)
     * }
     */
    public static int _ctime32_s(MemorySegment _Buffer, long _SizeInBytes, MemorySegment _Time) {
        var mh$ = _ctime32_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ctime32_s", _Buffer, _SizeInBytes, _Time);
            }
            return (int)mh$.invokeExact(_Buffer, _SizeInBytes, _Time);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ctime64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_ctime64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *_ctime64(const __time64_t *_Time)
     * }
     */
    public static FunctionDescriptor _ctime64$descriptor() {
        return _ctime64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *_ctime64(const __time64_t *_Time)
     * }
     */
    public static MethodHandle _ctime64$handle() {
        return _ctime64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *_ctime64(const __time64_t *_Time)
     * }
     */
    public static MemorySegment _ctime64$address() {
        return _ctime64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *_ctime64(const __time64_t *_Time)
     * }
     */
    public static MemorySegment _ctime64(MemorySegment _Time) {
        var mh$ = _ctime64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ctime64", _Time);
            }
            return (MemorySegment)mh$.invokeExact(_Time);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ctime64_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_ctime64_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _ctime64_s(char *_Buffer, size_t _SizeInBytes, const __time64_t *_Time)
     * }
     */
    public static FunctionDescriptor _ctime64_s$descriptor() {
        return _ctime64_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _ctime64_s(char *_Buffer, size_t _SizeInBytes, const __time64_t *_Time)
     * }
     */
    public static MethodHandle _ctime64_s$handle() {
        return _ctime64_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _ctime64_s(char *_Buffer, size_t _SizeInBytes, const __time64_t *_Time)
     * }
     */
    public static MemorySegment _ctime64_s$address() {
        return _ctime64_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _ctime64_s(char *_Buffer, size_t _SizeInBytes, const __time64_t *_Time)
     * }
     */
    public static int _ctime64_s(MemorySegment _Buffer, long _SizeInBytes, MemorySegment _Time) {
        var mh$ = _ctime64_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ctime64_s", _Buffer, _SizeInBytes, _Time);
            }
            return (int)mh$.invokeExact(_Buffer, _SizeInBytes, _Time);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _difftime32 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_LONG,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_difftime32");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double _difftime32(__time32_t _Time1, __time32_t _Time2)
     * }
     */
    public static FunctionDescriptor _difftime32$descriptor() {
        return _difftime32.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double _difftime32(__time32_t _Time1, __time32_t _Time2)
     * }
     */
    public static MethodHandle _difftime32$handle() {
        return _difftime32.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double _difftime32(__time32_t _Time1, __time32_t _Time2)
     * }
     */
    public static MemorySegment _difftime32$address() {
        return _difftime32.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double _difftime32(__time32_t _Time1, __time32_t _Time2)
     * }
     */
    public static double _difftime32(int _Time1, int _Time2) {
        var mh$ = _difftime32.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_difftime32", _Time1, _Time2);
            }
            return (double)mh$.invokeExact(_Time1, _Time2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _difftime64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_LONG_LONG,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_difftime64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double _difftime64(__time64_t _Time1, __time64_t _Time2)
     * }
     */
    public static FunctionDescriptor _difftime64$descriptor() {
        return _difftime64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double _difftime64(__time64_t _Time1, __time64_t _Time2)
     * }
     */
    public static MethodHandle _difftime64$handle() {
        return _difftime64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double _difftime64(__time64_t _Time1, __time64_t _Time2)
     * }
     */
    public static MemorySegment _difftime64$address() {
        return _difftime64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double _difftime64(__time64_t _Time1, __time64_t _Time2)
     * }
     */
    public static double _difftime64(long _Time1, long _Time2) {
        var mh$ = _difftime64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_difftime64", _Time1, _Time2);
            }
            return (double)mh$.invokeExact(_Time1, _Time2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _gmtime32 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_gmtime32");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct tm *_gmtime32(const __time32_t *_Time)
     * }
     */
    public static FunctionDescriptor _gmtime32$descriptor() {
        return _gmtime32.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct tm *_gmtime32(const __time32_t *_Time)
     * }
     */
    public static MethodHandle _gmtime32$handle() {
        return _gmtime32.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct tm *_gmtime32(const __time32_t *_Time)
     * }
     */
    public static MemorySegment _gmtime32$address() {
        return _gmtime32.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct tm *_gmtime32(const __time32_t *_Time)
     * }
     */
    public static MemorySegment _gmtime32(MemorySegment _Time) {
        var mh$ = _gmtime32.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_gmtime32", _Time);
            }
            return (MemorySegment)mh$.invokeExact(_Time);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _gmtime32_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_gmtime32_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _gmtime32_s(struct tm *_Tm, const __time32_t *_Time)
     * }
     */
    public static FunctionDescriptor _gmtime32_s$descriptor() {
        return _gmtime32_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _gmtime32_s(struct tm *_Tm, const __time32_t *_Time)
     * }
     */
    public static MethodHandle _gmtime32_s$handle() {
        return _gmtime32_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _gmtime32_s(struct tm *_Tm, const __time32_t *_Time)
     * }
     */
    public static MemorySegment _gmtime32_s$address() {
        return _gmtime32_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _gmtime32_s(struct tm *_Tm, const __time32_t *_Time)
     * }
     */
    public static int _gmtime32_s(MemorySegment _Tm, MemorySegment _Time) {
        var mh$ = _gmtime32_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_gmtime32_s", _Tm, _Time);
            }
            return (int)mh$.invokeExact(_Tm, _Time);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _gmtime64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_gmtime64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct tm *_gmtime64(const __time64_t *_Time)
     * }
     */
    public static FunctionDescriptor _gmtime64$descriptor() {
        return _gmtime64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct tm *_gmtime64(const __time64_t *_Time)
     * }
     */
    public static MethodHandle _gmtime64$handle() {
        return _gmtime64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct tm *_gmtime64(const __time64_t *_Time)
     * }
     */
    public static MemorySegment _gmtime64$address() {
        return _gmtime64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct tm *_gmtime64(const __time64_t *_Time)
     * }
     */
    public static MemorySegment _gmtime64(MemorySegment _Time) {
        var mh$ = _gmtime64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_gmtime64", _Time);
            }
            return (MemorySegment)mh$.invokeExact(_Time);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _gmtime64_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_gmtime64_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _gmtime64_s(struct tm *_Tm, const __time64_t *_Time)
     * }
     */
    public static FunctionDescriptor _gmtime64_s$descriptor() {
        return _gmtime64_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _gmtime64_s(struct tm *_Tm, const __time64_t *_Time)
     * }
     */
    public static MethodHandle _gmtime64_s$handle() {
        return _gmtime64_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _gmtime64_s(struct tm *_Tm, const __time64_t *_Time)
     * }
     */
    public static MemorySegment _gmtime64_s$address() {
        return _gmtime64_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _gmtime64_s(struct tm *_Tm, const __time64_t *_Time)
     * }
     */
    public static int _gmtime64_s(MemorySegment _Tm, MemorySegment _Time) {
        var mh$ = _gmtime64_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_gmtime64_s", _Tm, _Time);
            }
            return (int)mh$.invokeExact(_Tm, _Time);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _localtime32 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_localtime32");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct tm *_localtime32(const __time32_t *_Time)
     * }
     */
    public static FunctionDescriptor _localtime32$descriptor() {
        return _localtime32.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct tm *_localtime32(const __time32_t *_Time)
     * }
     */
    public static MethodHandle _localtime32$handle() {
        return _localtime32.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct tm *_localtime32(const __time32_t *_Time)
     * }
     */
    public static MemorySegment _localtime32$address() {
        return _localtime32.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct tm *_localtime32(const __time32_t *_Time)
     * }
     */
    public static MemorySegment _localtime32(MemorySegment _Time) {
        var mh$ = _localtime32.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_localtime32", _Time);
            }
            return (MemorySegment)mh$.invokeExact(_Time);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _localtime32_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_localtime32_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _localtime32_s(struct tm *_Tm, const __time32_t *_Time)
     * }
     */
    public static FunctionDescriptor _localtime32_s$descriptor() {
        return _localtime32_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _localtime32_s(struct tm *_Tm, const __time32_t *_Time)
     * }
     */
    public static MethodHandle _localtime32_s$handle() {
        return _localtime32_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _localtime32_s(struct tm *_Tm, const __time32_t *_Time)
     * }
     */
    public static MemorySegment _localtime32_s$address() {
        return _localtime32_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _localtime32_s(struct tm *_Tm, const __time32_t *_Time)
     * }
     */
    public static int _localtime32_s(MemorySegment _Tm, MemorySegment _Time) {
        var mh$ = _localtime32_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_localtime32_s", _Tm, _Time);
            }
            return (int)mh$.invokeExact(_Tm, _Time);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _localtime64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_localtime64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct tm *_localtime64(const __time64_t *_Time)
     * }
     */
    public static FunctionDescriptor _localtime64$descriptor() {
        return _localtime64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct tm *_localtime64(const __time64_t *_Time)
     * }
     */
    public static MethodHandle _localtime64$handle() {
        return _localtime64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct tm *_localtime64(const __time64_t *_Time)
     * }
     */
    public static MemorySegment _localtime64$address() {
        return _localtime64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct tm *_localtime64(const __time64_t *_Time)
     * }
     */
    public static MemorySegment _localtime64(MemorySegment _Time) {
        var mh$ = _localtime64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_localtime64", _Time);
            }
            return (MemorySegment)mh$.invokeExact(_Time);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _localtime64_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_localtime64_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _localtime64_s(struct tm *_Tm, const __time64_t *_Time)
     * }
     */
    public static FunctionDescriptor _localtime64_s$descriptor() {
        return _localtime64_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _localtime64_s(struct tm *_Tm, const __time64_t *_Time)
     * }
     */
    public static MethodHandle _localtime64_s$handle() {
        return _localtime64_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _localtime64_s(struct tm *_Tm, const __time64_t *_Time)
     * }
     */
    public static MemorySegment _localtime64_s$address() {
        return _localtime64_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _localtime64_s(struct tm *_Tm, const __time64_t *_Time)
     * }
     */
    public static int _localtime64_s(MemorySegment _Tm, MemorySegment _Time) {
        var mh$ = _localtime64_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_localtime64_s", _Tm, _Time);
            }
            return (int)mh$.invokeExact(_Tm, _Time);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _mkgmtime32 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_mkgmtime32");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * __time32_t _mkgmtime32(struct tm *_Tm)
     * }
     */
    public static FunctionDescriptor _mkgmtime32$descriptor() {
        return _mkgmtime32.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * __time32_t _mkgmtime32(struct tm *_Tm)
     * }
     */
    public static MethodHandle _mkgmtime32$handle() {
        return _mkgmtime32.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * __time32_t _mkgmtime32(struct tm *_Tm)
     * }
     */
    public static MemorySegment _mkgmtime32$address() {
        return _mkgmtime32.ADDR;
    }

    /**
     * {@snippet lang=c :
     * __time32_t _mkgmtime32(struct tm *_Tm)
     * }
     */
    public static int _mkgmtime32(MemorySegment _Tm) {
        var mh$ = _mkgmtime32.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_mkgmtime32", _Tm);
            }
            return (int)mh$.invokeExact(_Tm);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _mkgmtime64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_mkgmtime64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * __time64_t _mkgmtime64(struct tm *_Tm)
     * }
     */
    public static FunctionDescriptor _mkgmtime64$descriptor() {
        return _mkgmtime64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * __time64_t _mkgmtime64(struct tm *_Tm)
     * }
     */
    public static MethodHandle _mkgmtime64$handle() {
        return _mkgmtime64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * __time64_t _mkgmtime64(struct tm *_Tm)
     * }
     */
    public static MemorySegment _mkgmtime64$address() {
        return _mkgmtime64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * __time64_t _mkgmtime64(struct tm *_Tm)
     * }
     */
    public static long _mkgmtime64(MemorySegment _Tm) {
        var mh$ = _mkgmtime64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_mkgmtime64", _Tm);
            }
            return (long)mh$.invokeExact(_Tm);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _mktime32 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_mktime32");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * __time32_t _mktime32(struct tm *_Tm)
     * }
     */
    public static FunctionDescriptor _mktime32$descriptor() {
        return _mktime32.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * __time32_t _mktime32(struct tm *_Tm)
     * }
     */
    public static MethodHandle _mktime32$handle() {
        return _mktime32.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * __time32_t _mktime32(struct tm *_Tm)
     * }
     */
    public static MemorySegment _mktime32$address() {
        return _mktime32.ADDR;
    }

    /**
     * {@snippet lang=c :
     * __time32_t _mktime32(struct tm *_Tm)
     * }
     */
    public static int _mktime32(MemorySegment _Tm) {
        var mh$ = _mktime32.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_mktime32", _Tm);
            }
            return (int)mh$.invokeExact(_Tm);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _mktime64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_mktime64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * __time64_t _mktime64(struct tm *_Tm)
     * }
     */
    public static FunctionDescriptor _mktime64$descriptor() {
        return _mktime64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * __time64_t _mktime64(struct tm *_Tm)
     * }
     */
    public static MethodHandle _mktime64$handle() {
        return _mktime64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * __time64_t _mktime64(struct tm *_Tm)
     * }
     */
    public static MemorySegment _mktime64$address() {
        return _mktime64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * __time64_t _mktime64(struct tm *_Tm)
     * }
     */
    public static long _mktime64(MemorySegment _Tm) {
        var mh$ = _mktime64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_mktime64", _Tm);
            }
            return (long)mh$.invokeExact(_Tm);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strftime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("strftime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t strftime(char *_Buffer, size_t _SizeInBytes, const char *_Format, const struct tm *_Tm)
     * }
     */
    public static FunctionDescriptor strftime$descriptor() {
        return strftime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t strftime(char *_Buffer, size_t _SizeInBytes, const char *_Format, const struct tm *_Tm)
     * }
     */
    public static MethodHandle strftime$handle() {
        return strftime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t strftime(char *_Buffer, size_t _SizeInBytes, const char *_Format, const struct tm *_Tm)
     * }
     */
    public static MemorySegment strftime$address() {
        return strftime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t strftime(char *_Buffer, size_t _SizeInBytes, const char *_Format, const struct tm *_Tm)
     * }
     */
    public static long strftime(MemorySegment _Buffer, long _SizeInBytes, MemorySegment _Format, MemorySegment _Tm) {
        var mh$ = strftime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strftime", _Buffer, _SizeInBytes, _Format, _Tm);
            }
            return (long)mh$.invokeExact(_Buffer, _SizeInBytes, _Format, _Tm);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strftime_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_strftime_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t _strftime_l(char *_Buffer, size_t _MaxSize, const char *_Format, const struct tm *_Tm, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _strftime_l$descriptor() {
        return _strftime_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t _strftime_l(char *_Buffer, size_t _MaxSize, const char *_Format, const struct tm *_Tm, _locale_t _Locale)
     * }
     */
    public static MethodHandle _strftime_l$handle() {
        return _strftime_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t _strftime_l(char *_Buffer, size_t _MaxSize, const char *_Format, const struct tm *_Tm, _locale_t _Locale)
     * }
     */
    public static MemorySegment _strftime_l$address() {
        return _strftime_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t _strftime_l(char *_Buffer, size_t _MaxSize, const char *_Format, const struct tm *_Tm, _locale_t _Locale)
     * }
     */
    public static long _strftime_l(MemorySegment _Buffer, long _MaxSize, MemorySegment _Format, MemorySegment _Tm, MemorySegment _Locale) {
        var mh$ = _strftime_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strftime_l", _Buffer, _MaxSize, _Format, _Tm, _Locale);
            }
            return (long)mh$.invokeExact(_Buffer, _MaxSize, _Format, _Tm, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strdate_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_strdate_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _strdate_s(char *_Buffer, size_t _SizeInBytes)
     * }
     */
    public static FunctionDescriptor _strdate_s$descriptor() {
        return _strdate_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _strdate_s(char *_Buffer, size_t _SizeInBytes)
     * }
     */
    public static MethodHandle _strdate_s$handle() {
        return _strdate_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _strdate_s(char *_Buffer, size_t _SizeInBytes)
     * }
     */
    public static MemorySegment _strdate_s$address() {
        return _strdate_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _strdate_s(char *_Buffer, size_t _SizeInBytes)
     * }
     */
    public static int _strdate_s(MemorySegment _Buffer, long _SizeInBytes) {
        var mh$ = _strdate_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strdate_s", _Buffer, _SizeInBytes);
            }
            return (int)mh$.invokeExact(_Buffer, _SizeInBytes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strdate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_strdate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *_strdate(char *_Buffer)
     * }
     */
    public static FunctionDescriptor _strdate$descriptor() {
        return _strdate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *_strdate(char *_Buffer)
     * }
     */
    public static MethodHandle _strdate$handle() {
        return _strdate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *_strdate(char *_Buffer)
     * }
     */
    public static MemorySegment _strdate$address() {
        return _strdate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *_strdate(char *_Buffer)
     * }
     */
    public static MemorySegment _strdate(MemorySegment _Buffer) {
        var mh$ = _strdate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strdate", _Buffer);
            }
            return (MemorySegment)mh$.invokeExact(_Buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strtime_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_strtime_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _strtime_s(char *_Buffer, size_t _SizeInBytes)
     * }
     */
    public static FunctionDescriptor _strtime_s$descriptor() {
        return _strtime_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _strtime_s(char *_Buffer, size_t _SizeInBytes)
     * }
     */
    public static MethodHandle _strtime_s$handle() {
        return _strtime_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _strtime_s(char *_Buffer, size_t _SizeInBytes)
     * }
     */
    public static MemorySegment _strtime_s$address() {
        return _strtime_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _strtime_s(char *_Buffer, size_t _SizeInBytes)
     * }
     */
    public static int _strtime_s(MemorySegment _Buffer, long _SizeInBytes) {
        var mh$ = _strtime_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strtime_s", _Buffer, _SizeInBytes);
            }
            return (int)mh$.invokeExact(_Buffer, _SizeInBytes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strtime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_strtime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *_strtime(char *_Buffer)
     * }
     */
    public static FunctionDescriptor _strtime$descriptor() {
        return _strtime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *_strtime(char *_Buffer)
     * }
     */
    public static MethodHandle _strtime$handle() {
        return _strtime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *_strtime(char *_Buffer)
     * }
     */
    public static MemorySegment _strtime$address() {
        return _strtime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *_strtime(char *_Buffer)
     * }
     */
    public static MemorySegment _strtime(MemorySegment _Buffer) {
        var mh$ = _strtime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strtime", _Buffer);
            }
            return (MemorySegment)mh$.invokeExact(_Buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _time32 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_time32");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * __time32_t _time32(__time32_t *_Time)
     * }
     */
    public static FunctionDescriptor _time32$descriptor() {
        return _time32.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * __time32_t _time32(__time32_t *_Time)
     * }
     */
    public static MethodHandle _time32$handle() {
        return _time32.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * __time32_t _time32(__time32_t *_Time)
     * }
     */
    public static MemorySegment _time32$address() {
        return _time32.ADDR;
    }

    /**
     * {@snippet lang=c :
     * __time32_t _time32(__time32_t *_Time)
     * }
     */
    public static int _time32(MemorySegment _Time) {
        var mh$ = _time32.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_time32", _Time);
            }
            return (int)mh$.invokeExact(_Time);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _time64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_time64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * __time64_t _time64(__time64_t *_Time)
     * }
     */
    public static FunctionDescriptor _time64$descriptor() {
        return _time64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * __time64_t _time64(__time64_t *_Time)
     * }
     */
    public static MethodHandle _time64$handle() {
        return _time64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * __time64_t _time64(__time64_t *_Time)
     * }
     */
    public static MemorySegment _time64$address() {
        return _time64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * __time64_t _time64(__time64_t *_Time)
     * }
     */
    public static long _time64(MemorySegment _Time) {
        var mh$ = _time64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_time64", _Time);
            }
            return (long)mh$.invokeExact(_Time);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _timespec32_get {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_timespec32_get");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _timespec32_get(struct _timespec32 *_Ts, int _Base)
     * }
     */
    public static FunctionDescriptor _timespec32_get$descriptor() {
        return _timespec32_get.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _timespec32_get(struct _timespec32 *_Ts, int _Base)
     * }
     */
    public static MethodHandle _timespec32_get$handle() {
        return _timespec32_get.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _timespec32_get(struct _timespec32 *_Ts, int _Base)
     * }
     */
    public static MemorySegment _timespec32_get$address() {
        return _timespec32_get.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _timespec32_get(struct _timespec32 *_Ts, int _Base)
     * }
     */
    public static int _timespec32_get(MemorySegment _Ts, int _Base) {
        var mh$ = _timespec32_get.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_timespec32_get", _Ts, _Base);
            }
            return (int)mh$.invokeExact(_Ts, _Base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _timespec64_get {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_timespec64_get");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _timespec64_get(struct _timespec64 *_Ts, int _Base)
     * }
     */
    public static FunctionDescriptor _timespec64_get$descriptor() {
        return _timespec64_get.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _timespec64_get(struct _timespec64 *_Ts, int _Base)
     * }
     */
    public static MethodHandle _timespec64_get$handle() {
        return _timespec64_get.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _timespec64_get(struct _timespec64 *_Ts, int _Base)
     * }
     */
    public static MemorySegment _timespec64_get$address() {
        return _timespec64_get.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _timespec64_get(struct _timespec64 *_Ts, int _Base)
     * }
     */
    public static int _timespec64_get(MemorySegment _Ts, int _Base) {
        var mh$ = _timespec64_get.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_timespec64_get", _Ts, _Base);
            }
            return (int)mh$.invokeExact(_Ts, _Base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _tzset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_tzset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _tzset()
     * }
     */
    public static FunctionDescriptor _tzset$descriptor() {
        return _tzset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _tzset()
     * }
     */
    public static MethodHandle _tzset$handle() {
        return _tzset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _tzset()
     * }
     */
    public static MemorySegment _tzset$address() {
        return _tzset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _tzset()
     * }
     */
    public static void _tzset() {
        var mh$ = _tzset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_tzset");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _getsystime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_getsystime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int _getsystime(struct tm *_Tm)
     * }
     */
    public static FunctionDescriptor _getsystime$descriptor() {
        return _getsystime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int _getsystime(struct tm *_Tm)
     * }
     */
    public static MethodHandle _getsystime$handle() {
        return _getsystime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int _getsystime(struct tm *_Tm)
     * }
     */
    public static MemorySegment _getsystime$address() {
        return _getsystime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int _getsystime(struct tm *_Tm)
     * }
     */
    public static int _getsystime(MemorySegment _Tm) {
        var mh$ = _getsystime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_getsystime", _Tm);
            }
            return (int)mh$.invokeExact(_Tm);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _setsystime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_setsystime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int _setsystime(struct tm *_Tm, unsigned int _Milliseconds)
     * }
     */
    public static FunctionDescriptor _setsystime$descriptor() {
        return _setsystime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int _setsystime(struct tm *_Tm, unsigned int _Milliseconds)
     * }
     */
    public static MethodHandle _setsystime$handle() {
        return _setsystime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int _setsystime(struct tm *_Tm, unsigned int _Milliseconds)
     * }
     */
    public static MemorySegment _setsystime$address() {
        return _setsystime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int _setsystime(struct tm *_Tm, unsigned int _Milliseconds)
     * }
     */
    public static int _setsystime(MemorySegment _Tm, int _Milliseconds) {
        var mh$ = _setsystime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_setsystime", _Tm, _Milliseconds);
            }
            return (int)mh$.invokeExact(_Tm, _Milliseconds);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tzset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("tzset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void tzset()
     * }
     */
    public static FunctionDescriptor tzset$descriptor() {
        return tzset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void tzset()
     * }
     */
    public static MethodHandle tzset$handle() {
        return tzset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void tzset()
     * }
     */
    public static MemorySegment tzset$address() {
        return tzset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void tzset()
     * }
     */
    public static void tzset() {
        var mh$ = tzset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tzset");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyMem_Malloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyMem_Malloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *PyMem_Malloc(size_t size)
     * }
     */
    public static FunctionDescriptor PyMem_Malloc$descriptor() {
        return PyMem_Malloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *PyMem_Malloc(size_t size)
     * }
     */
    public static MethodHandle PyMem_Malloc$handle() {
        return PyMem_Malloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *PyMem_Malloc(size_t size)
     * }
     */
    public static MemorySegment PyMem_Malloc$address() {
        return PyMem_Malloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *PyMem_Malloc(size_t size)
     * }
     */
    public static MemorySegment PyMem_Malloc(long size) {
        var mh$ = PyMem_Malloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyMem_Malloc", size);
            }
            return (MemorySegment)mh$.invokeExact(size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyMem_Calloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyMem_Calloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *PyMem_Calloc(size_t nelem, size_t elsize)
     * }
     */
    public static FunctionDescriptor PyMem_Calloc$descriptor() {
        return PyMem_Calloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *PyMem_Calloc(size_t nelem, size_t elsize)
     * }
     */
    public static MethodHandle PyMem_Calloc$handle() {
        return PyMem_Calloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *PyMem_Calloc(size_t nelem, size_t elsize)
     * }
     */
    public static MemorySegment PyMem_Calloc$address() {
        return PyMem_Calloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *PyMem_Calloc(size_t nelem, size_t elsize)
     * }
     */
    public static MemorySegment PyMem_Calloc(long nelem, long elsize) {
        var mh$ = PyMem_Calloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyMem_Calloc", nelem, elsize);
            }
            return (MemorySegment)mh$.invokeExact(nelem, elsize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyMem_Realloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyMem_Realloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *PyMem_Realloc(void *ptr, size_t new_size)
     * }
     */
    public static FunctionDescriptor PyMem_Realloc$descriptor() {
        return PyMem_Realloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *PyMem_Realloc(void *ptr, size_t new_size)
     * }
     */
    public static MethodHandle PyMem_Realloc$handle() {
        return PyMem_Realloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *PyMem_Realloc(void *ptr, size_t new_size)
     * }
     */
    public static MemorySegment PyMem_Realloc$address() {
        return PyMem_Realloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *PyMem_Realloc(void *ptr, size_t new_size)
     * }
     */
    public static MemorySegment PyMem_Realloc(MemorySegment ptr, long new_size) {
        var mh$ = PyMem_Realloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyMem_Realloc", ptr, new_size);
            }
            return (MemorySegment)mh$.invokeExact(ptr, new_size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyMem_Free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyMem_Free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyMem_Free(void *ptr)
     * }
     */
    public static FunctionDescriptor PyMem_Free$descriptor() {
        return PyMem_Free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyMem_Free(void *ptr)
     * }
     */
    public static MethodHandle PyMem_Free$handle() {
        return PyMem_Free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyMem_Free(void *ptr)
     * }
     */
    public static MemorySegment PyMem_Free$address() {
        return PyMem_Free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyMem_Free(void *ptr)
     * }
     */
    public static void PyMem_Free(MemorySegment ptr) {
        var mh$ = PyMem_Free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyMem_Free", ptr);
            }
            mh$.invokeExact(ptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyMem_RawMalloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyMem_RawMalloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *PyMem_RawMalloc(size_t size)
     * }
     */
    public static FunctionDescriptor PyMem_RawMalloc$descriptor() {
        return PyMem_RawMalloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *PyMem_RawMalloc(size_t size)
     * }
     */
    public static MethodHandle PyMem_RawMalloc$handle() {
        return PyMem_RawMalloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *PyMem_RawMalloc(size_t size)
     * }
     */
    public static MemorySegment PyMem_RawMalloc$address() {
        return PyMem_RawMalloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *PyMem_RawMalloc(size_t size)
     * }
     */
    public static MemorySegment PyMem_RawMalloc(long size) {
        var mh$ = PyMem_RawMalloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyMem_RawMalloc", size);
            }
            return (MemorySegment)mh$.invokeExact(size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyMem_RawCalloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyMem_RawCalloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *PyMem_RawCalloc(size_t nelem, size_t elsize)
     * }
     */
    public static FunctionDescriptor PyMem_RawCalloc$descriptor() {
        return PyMem_RawCalloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *PyMem_RawCalloc(size_t nelem, size_t elsize)
     * }
     */
    public static MethodHandle PyMem_RawCalloc$handle() {
        return PyMem_RawCalloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *PyMem_RawCalloc(size_t nelem, size_t elsize)
     * }
     */
    public static MemorySegment PyMem_RawCalloc$address() {
        return PyMem_RawCalloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *PyMem_RawCalloc(size_t nelem, size_t elsize)
     * }
     */
    public static MemorySegment PyMem_RawCalloc(long nelem, long elsize) {
        var mh$ = PyMem_RawCalloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyMem_RawCalloc", nelem, elsize);
            }
            return (MemorySegment)mh$.invokeExact(nelem, elsize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyMem_RawRealloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyMem_RawRealloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *PyMem_RawRealloc(void *ptr, size_t new_size)
     * }
     */
    public static FunctionDescriptor PyMem_RawRealloc$descriptor() {
        return PyMem_RawRealloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *PyMem_RawRealloc(void *ptr, size_t new_size)
     * }
     */
    public static MethodHandle PyMem_RawRealloc$handle() {
        return PyMem_RawRealloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *PyMem_RawRealloc(void *ptr, size_t new_size)
     * }
     */
    public static MemorySegment PyMem_RawRealloc$address() {
        return PyMem_RawRealloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *PyMem_RawRealloc(void *ptr, size_t new_size)
     * }
     */
    public static MemorySegment PyMem_RawRealloc(MemorySegment ptr, long new_size) {
        var mh$ = PyMem_RawRealloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyMem_RawRealloc", ptr, new_size);
            }
            return (MemorySegment)mh$.invokeExact(ptr, new_size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyMem_RawFree {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyMem_RawFree");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyMem_RawFree(void *ptr)
     * }
     */
    public static FunctionDescriptor PyMem_RawFree$descriptor() {
        return PyMem_RawFree.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyMem_RawFree(void *ptr)
     * }
     */
    public static MethodHandle PyMem_RawFree$handle() {
        return PyMem_RawFree.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyMem_RawFree(void *ptr)
     * }
     */
    public static MemorySegment PyMem_RawFree$address() {
        return PyMem_RawFree.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyMem_RawFree(void *ptr)
     * }
     */
    public static void PyMem_RawFree(MemorySegment ptr) {
        var mh$ = PyMem_RawFree.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyMem_RawFree", ptr);
            }
            mh$.invokeExact(ptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyMem_GetCurrentAllocatorName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyMem_GetCurrentAllocatorName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *_PyMem_GetCurrentAllocatorName()
     * }
     */
    public static FunctionDescriptor _PyMem_GetCurrentAllocatorName$descriptor() {
        return _PyMem_GetCurrentAllocatorName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *_PyMem_GetCurrentAllocatorName()
     * }
     */
    public static MethodHandle _PyMem_GetCurrentAllocatorName$handle() {
        return _PyMem_GetCurrentAllocatorName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *_PyMem_GetCurrentAllocatorName()
     * }
     */
    public static MemorySegment _PyMem_GetCurrentAllocatorName$address() {
        return _PyMem_GetCurrentAllocatorName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *_PyMem_GetCurrentAllocatorName()
     * }
     */
    public static MemorySegment _PyMem_GetCurrentAllocatorName() {
        var mh$ = _PyMem_GetCurrentAllocatorName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyMem_GetCurrentAllocatorName");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyMem_RawStrdup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyMem_RawStrdup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *_PyMem_RawStrdup(const char *str)
     * }
     */
    public static FunctionDescriptor _PyMem_RawStrdup$descriptor() {
        return _PyMem_RawStrdup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *_PyMem_RawStrdup(const char *str)
     * }
     */
    public static MethodHandle _PyMem_RawStrdup$handle() {
        return _PyMem_RawStrdup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *_PyMem_RawStrdup(const char *str)
     * }
     */
    public static MemorySegment _PyMem_RawStrdup$address() {
        return _PyMem_RawStrdup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *_PyMem_RawStrdup(const char *str)
     * }
     */
    public static MemorySegment _PyMem_RawStrdup(MemorySegment str) {
        var mh$ = _PyMem_RawStrdup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyMem_RawStrdup", str);
            }
            return (MemorySegment)mh$.invokeExact(str);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyMem_Strdup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyMem_Strdup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *_PyMem_Strdup(const char *str)
     * }
     */
    public static FunctionDescriptor _PyMem_Strdup$descriptor() {
        return _PyMem_Strdup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *_PyMem_Strdup(const char *str)
     * }
     */
    public static MethodHandle _PyMem_Strdup$handle() {
        return _PyMem_Strdup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *_PyMem_Strdup(const char *str)
     * }
     */
    public static MemorySegment _PyMem_Strdup$address() {
        return _PyMem_Strdup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *_PyMem_Strdup(const char *str)
     * }
     */
    public static MemorySegment _PyMem_Strdup(MemorySegment str) {
        var mh$ = _PyMem_Strdup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyMem_Strdup", str);
            }
            return (MemorySegment)mh$.invokeExact(str);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyMem_RawWcsdup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyMem_RawWcsdup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *_PyMem_RawWcsdup(const wchar_t *str)
     * }
     */
    public static FunctionDescriptor _PyMem_RawWcsdup$descriptor() {
        return _PyMem_RawWcsdup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *_PyMem_RawWcsdup(const wchar_t *str)
     * }
     */
    public static MethodHandle _PyMem_RawWcsdup$handle() {
        return _PyMem_RawWcsdup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *_PyMem_RawWcsdup(const wchar_t *str)
     * }
     */
    public static MemorySegment _PyMem_RawWcsdup$address() {
        return _PyMem_RawWcsdup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *_PyMem_RawWcsdup(const wchar_t *str)
     * }
     */
    public static MemorySegment _PyMem_RawWcsdup(MemorySegment str) {
        var mh$ = _PyMem_RawWcsdup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyMem_RawWcsdup", str);
            }
            return (MemorySegment)mh$.invokeExact(str);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int PYMEM_DOMAIN_RAW = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PYMEM_DOMAIN_RAW = 0
     * }
     */
    public static int PYMEM_DOMAIN_RAW() {
        return PYMEM_DOMAIN_RAW;
    }
    private static final int PYMEM_DOMAIN_MEM = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PYMEM_DOMAIN_MEM = 1
     * }
     */
    public static int PYMEM_DOMAIN_MEM() {
        return PYMEM_DOMAIN_MEM;
    }
    private static final int PYMEM_DOMAIN_OBJ = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PYMEM_DOMAIN_OBJ = 2
     * }
     */
    public static int PYMEM_DOMAIN_OBJ() {
        return PYMEM_DOMAIN_OBJ;
    }
    private static final int PYMEM_ALLOCATOR_NOT_SET = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PYMEM_ALLOCATOR_NOT_SET = 0
     * }
     */
    public static int PYMEM_ALLOCATOR_NOT_SET() {
        return PYMEM_ALLOCATOR_NOT_SET;
    }
    private static final int PYMEM_ALLOCATOR_DEFAULT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PYMEM_ALLOCATOR_DEFAULT = 1
     * }
     */
    public static int PYMEM_ALLOCATOR_DEFAULT() {
        return PYMEM_ALLOCATOR_DEFAULT;
    }
    private static final int PYMEM_ALLOCATOR_DEBUG = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PYMEM_ALLOCATOR_DEBUG = 2
     * }
     */
    public static int PYMEM_ALLOCATOR_DEBUG() {
        return PYMEM_ALLOCATOR_DEBUG;
    }
    private static final int PYMEM_ALLOCATOR_MALLOC = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PYMEM_ALLOCATOR_MALLOC = 3
     * }
     */
    public static int PYMEM_ALLOCATOR_MALLOC() {
        return PYMEM_ALLOCATOR_MALLOC;
    }
    private static final int PYMEM_ALLOCATOR_MALLOC_DEBUG = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PYMEM_ALLOCATOR_MALLOC_DEBUG = 4
     * }
     */
    public static int PYMEM_ALLOCATOR_MALLOC_DEBUG() {
        return PYMEM_ALLOCATOR_MALLOC_DEBUG;
    }
    private static final int PYMEM_ALLOCATOR_PYMALLOC = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PYMEM_ALLOCATOR_PYMALLOC = 5
     * }
     */
    public static int PYMEM_ALLOCATOR_PYMALLOC() {
        return PYMEM_ALLOCATOR_PYMALLOC;
    }
    private static final int PYMEM_ALLOCATOR_PYMALLOC_DEBUG = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PYMEM_ALLOCATOR_PYMALLOC_DEBUG = 6
     * }
     */
    public static int PYMEM_ALLOCATOR_PYMALLOC_DEBUG() {
        return PYMEM_ALLOCATOR_PYMALLOC_DEBUG;
    }

    private static class PyMem_GetAllocator {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyMem_GetAllocator");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyMem_GetAllocator(PyMemAllocatorDomain domain, PyMemAllocatorEx *allocator)
     * }
     */
    public static FunctionDescriptor PyMem_GetAllocator$descriptor() {
        return PyMem_GetAllocator.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyMem_GetAllocator(PyMemAllocatorDomain domain, PyMemAllocatorEx *allocator)
     * }
     */
    public static MethodHandle PyMem_GetAllocator$handle() {
        return PyMem_GetAllocator.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyMem_GetAllocator(PyMemAllocatorDomain domain, PyMemAllocatorEx *allocator)
     * }
     */
    public static MemorySegment PyMem_GetAllocator$address() {
        return PyMem_GetAllocator.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyMem_GetAllocator(PyMemAllocatorDomain domain, PyMemAllocatorEx *allocator)
     * }
     */
    public static void PyMem_GetAllocator(int domain, MemorySegment allocator) {
        var mh$ = PyMem_GetAllocator.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyMem_GetAllocator", domain, allocator);
            }
            mh$.invokeExact(domain, allocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyMem_SetAllocator {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyMem_SetAllocator");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyMem_SetAllocator(PyMemAllocatorDomain domain, PyMemAllocatorEx *allocator)
     * }
     */
    public static FunctionDescriptor PyMem_SetAllocator$descriptor() {
        return PyMem_SetAllocator.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyMem_SetAllocator(PyMemAllocatorDomain domain, PyMemAllocatorEx *allocator)
     * }
     */
    public static MethodHandle PyMem_SetAllocator$handle() {
        return PyMem_SetAllocator.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyMem_SetAllocator(PyMemAllocatorDomain domain, PyMemAllocatorEx *allocator)
     * }
     */
    public static MemorySegment PyMem_SetAllocator$address() {
        return PyMem_SetAllocator.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyMem_SetAllocator(PyMemAllocatorDomain domain, PyMemAllocatorEx *allocator)
     * }
     */
    public static void PyMem_SetAllocator(int domain, MemorySegment allocator) {
        var mh$ = PyMem_SetAllocator.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyMem_SetAllocator", domain, allocator);
            }
            mh$.invokeExact(domain, allocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyMem_SetupDebugHooks {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyMem_SetupDebugHooks");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyMem_SetupDebugHooks()
     * }
     */
    public static FunctionDescriptor PyMem_SetupDebugHooks$descriptor() {
        return PyMem_SetupDebugHooks.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyMem_SetupDebugHooks()
     * }
     */
    public static MethodHandle PyMem_SetupDebugHooks$handle() {
        return PyMem_SetupDebugHooks.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyMem_SetupDebugHooks()
     * }
     */
    public static MemorySegment PyMem_SetupDebugHooks$address() {
        return PyMem_SetupDebugHooks.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyMem_SetupDebugHooks()
     * }
     */
    public static void PyMem_SetupDebugHooks() {
        var mh$ = PyMem_SetupDebugHooks.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyMem_SetupDebugHooks");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_CheckBuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_CheckBuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyObject_CheckBuffer(PyObject *obj)
     * }
     */
    public static FunctionDescriptor PyObject_CheckBuffer$descriptor() {
        return PyObject_CheckBuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyObject_CheckBuffer(PyObject *obj)
     * }
     */
    public static MethodHandle PyObject_CheckBuffer$handle() {
        return PyObject_CheckBuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyObject_CheckBuffer(PyObject *obj)
     * }
     */
    public static MemorySegment PyObject_CheckBuffer$address() {
        return PyObject_CheckBuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyObject_CheckBuffer(PyObject *obj)
     * }
     */
    public static int PyObject_CheckBuffer(MemorySegment obj) {
        var mh$ = PyObject_CheckBuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_CheckBuffer", obj);
            }
            return (int)mh$.invokeExact(obj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_GetBuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_GetBuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyObject_GetBuffer(PyObject *obj, Py_buffer *view, int flags)
     * }
     */
    public static FunctionDescriptor PyObject_GetBuffer$descriptor() {
        return PyObject_GetBuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyObject_GetBuffer(PyObject *obj, Py_buffer *view, int flags)
     * }
     */
    public static MethodHandle PyObject_GetBuffer$handle() {
        return PyObject_GetBuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyObject_GetBuffer(PyObject *obj, Py_buffer *view, int flags)
     * }
     */
    public static MemorySegment PyObject_GetBuffer$address() {
        return PyObject_GetBuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyObject_GetBuffer(PyObject *obj, Py_buffer *view, int flags)
     * }
     */
    public static int PyObject_GetBuffer(MemorySegment obj, MemorySegment view, int flags) {
        var mh$ = PyObject_GetBuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_GetBuffer", obj, view, flags);
            }
            return (int)mh$.invokeExact(obj, view, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyBuffer_GetPointer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyBuffer_GetPointer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *PyBuffer_GetPointer(const Py_buffer *view, const Py_ssize_t *indices)
     * }
     */
    public static FunctionDescriptor PyBuffer_GetPointer$descriptor() {
        return PyBuffer_GetPointer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *PyBuffer_GetPointer(const Py_buffer *view, const Py_ssize_t *indices)
     * }
     */
    public static MethodHandle PyBuffer_GetPointer$handle() {
        return PyBuffer_GetPointer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *PyBuffer_GetPointer(const Py_buffer *view, const Py_ssize_t *indices)
     * }
     */
    public static MemorySegment PyBuffer_GetPointer$address() {
        return PyBuffer_GetPointer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *PyBuffer_GetPointer(const Py_buffer *view, const Py_ssize_t *indices)
     * }
     */
    public static MemorySegment PyBuffer_GetPointer(MemorySegment view, MemorySegment indices) {
        var mh$ = PyBuffer_GetPointer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyBuffer_GetPointer", view, indices);
            }
            return (MemorySegment)mh$.invokeExact(view, indices);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyBuffer_SizeFromFormat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyBuffer_SizeFromFormat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_ssize_t PyBuffer_SizeFromFormat(const char *format)
     * }
     */
    public static FunctionDescriptor PyBuffer_SizeFromFormat$descriptor() {
        return PyBuffer_SizeFromFormat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_ssize_t PyBuffer_SizeFromFormat(const char *format)
     * }
     */
    public static MethodHandle PyBuffer_SizeFromFormat$handle() {
        return PyBuffer_SizeFromFormat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_ssize_t PyBuffer_SizeFromFormat(const char *format)
     * }
     */
    public static MemorySegment PyBuffer_SizeFromFormat$address() {
        return PyBuffer_SizeFromFormat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_ssize_t PyBuffer_SizeFromFormat(const char *format)
     * }
     */
    public static long PyBuffer_SizeFromFormat(MemorySegment format) {
        var mh$ = PyBuffer_SizeFromFormat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyBuffer_SizeFromFormat", format);
            }
            return (long)mh$.invokeExact(format);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyBuffer_ToContiguous {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_CHAR
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyBuffer_ToContiguous");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyBuffer_ToContiguous(void *buf, const Py_buffer *view, Py_ssize_t len, char order)
     * }
     */
    public static FunctionDescriptor PyBuffer_ToContiguous$descriptor() {
        return PyBuffer_ToContiguous.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyBuffer_ToContiguous(void *buf, const Py_buffer *view, Py_ssize_t len, char order)
     * }
     */
    public static MethodHandle PyBuffer_ToContiguous$handle() {
        return PyBuffer_ToContiguous.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyBuffer_ToContiguous(void *buf, const Py_buffer *view, Py_ssize_t len, char order)
     * }
     */
    public static MemorySegment PyBuffer_ToContiguous$address() {
        return PyBuffer_ToContiguous.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyBuffer_ToContiguous(void *buf, const Py_buffer *view, Py_ssize_t len, char order)
     * }
     */
    public static int PyBuffer_ToContiguous(MemorySegment buf, MemorySegment view, long len, byte order) {
        var mh$ = PyBuffer_ToContiguous.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyBuffer_ToContiguous", buf, view, len, order);
            }
            return (int)mh$.invokeExact(buf, view, len, order);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyBuffer_FromContiguous {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_CHAR
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyBuffer_FromContiguous");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyBuffer_FromContiguous(const Py_buffer *view, const void *buf, Py_ssize_t len, char order)
     * }
     */
    public static FunctionDescriptor PyBuffer_FromContiguous$descriptor() {
        return PyBuffer_FromContiguous.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyBuffer_FromContiguous(const Py_buffer *view, const void *buf, Py_ssize_t len, char order)
     * }
     */
    public static MethodHandle PyBuffer_FromContiguous$handle() {
        return PyBuffer_FromContiguous.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyBuffer_FromContiguous(const Py_buffer *view, const void *buf, Py_ssize_t len, char order)
     * }
     */
    public static MemorySegment PyBuffer_FromContiguous$address() {
        return PyBuffer_FromContiguous.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyBuffer_FromContiguous(const Py_buffer *view, const void *buf, Py_ssize_t len, char order)
     * }
     */
    public static int PyBuffer_FromContiguous(MemorySegment view, MemorySegment buf, long len, byte order) {
        var mh$ = PyBuffer_FromContiguous.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyBuffer_FromContiguous", view, buf, len, order);
            }
            return (int)mh$.invokeExact(view, buf, len, order);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_CopyData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_CopyData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyObject_CopyData(PyObject *dest, PyObject *src)
     * }
     */
    public static FunctionDescriptor PyObject_CopyData$descriptor() {
        return PyObject_CopyData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyObject_CopyData(PyObject *dest, PyObject *src)
     * }
     */
    public static MethodHandle PyObject_CopyData$handle() {
        return PyObject_CopyData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyObject_CopyData(PyObject *dest, PyObject *src)
     * }
     */
    public static MemorySegment PyObject_CopyData$address() {
        return PyObject_CopyData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyObject_CopyData(PyObject *dest, PyObject *src)
     * }
     */
    public static int PyObject_CopyData(MemorySegment dest, MemorySegment src) {
        var mh$ = PyObject_CopyData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_CopyData", dest, src);
            }
            return (int)mh$.invokeExact(dest, src);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyBuffer_IsContiguous {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_CHAR
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyBuffer_IsContiguous");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyBuffer_IsContiguous(const Py_buffer *view, char fort)
     * }
     */
    public static FunctionDescriptor PyBuffer_IsContiguous$descriptor() {
        return PyBuffer_IsContiguous.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyBuffer_IsContiguous(const Py_buffer *view, char fort)
     * }
     */
    public static MethodHandle PyBuffer_IsContiguous$handle() {
        return PyBuffer_IsContiguous.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyBuffer_IsContiguous(const Py_buffer *view, char fort)
     * }
     */
    public static MemorySegment PyBuffer_IsContiguous$address() {
        return PyBuffer_IsContiguous.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyBuffer_IsContiguous(const Py_buffer *view, char fort)
     * }
     */
    public static int PyBuffer_IsContiguous(MemorySegment view, byte fort) {
        var mh$ = PyBuffer_IsContiguous.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyBuffer_IsContiguous", view, fort);
            }
            return (int)mh$.invokeExact(view, fort);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyBuffer_FillContiguousStrides {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_CHAR
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyBuffer_FillContiguousStrides");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyBuffer_FillContiguousStrides(int ndims, Py_ssize_t *shape, Py_ssize_t *strides, int itemsize, char fort)
     * }
     */
    public static FunctionDescriptor PyBuffer_FillContiguousStrides$descriptor() {
        return PyBuffer_FillContiguousStrides.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyBuffer_FillContiguousStrides(int ndims, Py_ssize_t *shape, Py_ssize_t *strides, int itemsize, char fort)
     * }
     */
    public static MethodHandle PyBuffer_FillContiguousStrides$handle() {
        return PyBuffer_FillContiguousStrides.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyBuffer_FillContiguousStrides(int ndims, Py_ssize_t *shape, Py_ssize_t *strides, int itemsize, char fort)
     * }
     */
    public static MemorySegment PyBuffer_FillContiguousStrides$address() {
        return PyBuffer_FillContiguousStrides.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyBuffer_FillContiguousStrides(int ndims, Py_ssize_t *shape, Py_ssize_t *strides, int itemsize, char fort)
     * }
     */
    public static void PyBuffer_FillContiguousStrides(int ndims, MemorySegment shape, MemorySegment strides, int itemsize, byte fort) {
        var mh$ = PyBuffer_FillContiguousStrides.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyBuffer_FillContiguousStrides", ndims, shape, strides, itemsize, fort);
            }
            mh$.invokeExact(ndims, shape, strides, itemsize, fort);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyBuffer_FillInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyBuffer_FillInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyBuffer_FillInfo(Py_buffer *view, PyObject *o, void *buf, Py_ssize_t len, int readonly, int flags)
     * }
     */
    public static FunctionDescriptor PyBuffer_FillInfo$descriptor() {
        return PyBuffer_FillInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyBuffer_FillInfo(Py_buffer *view, PyObject *o, void *buf, Py_ssize_t len, int readonly, int flags)
     * }
     */
    public static MethodHandle PyBuffer_FillInfo$handle() {
        return PyBuffer_FillInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyBuffer_FillInfo(Py_buffer *view, PyObject *o, void *buf, Py_ssize_t len, int readonly, int flags)
     * }
     */
    public static MemorySegment PyBuffer_FillInfo$address() {
        return PyBuffer_FillInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyBuffer_FillInfo(Py_buffer *view, PyObject *o, void *buf, Py_ssize_t len, int readonly, int flags)
     * }
     */
    public static int PyBuffer_FillInfo(MemorySegment view, MemorySegment o, MemorySegment buf, long len, int readonly, int flags) {
        var mh$ = PyBuffer_FillInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyBuffer_FillInfo", view, o, buf, len, readonly, flags);
            }
            return (int)mh$.invokeExact(view, o, buf, len, readonly, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyBuffer_Release {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyBuffer_Release");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyBuffer_Release(Py_buffer *view)
     * }
     */
    public static FunctionDescriptor PyBuffer_Release$descriptor() {
        return PyBuffer_Release.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyBuffer_Release(Py_buffer *view)
     * }
     */
    public static MethodHandle PyBuffer_Release$handle() {
        return PyBuffer_Release.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyBuffer_Release(Py_buffer *view)
     * }
     */
    public static MemorySegment PyBuffer_Release$address() {
        return PyBuffer_Release.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyBuffer_Release(Py_buffer *view)
     * }
     */
    public static void PyBuffer_Release(MemorySegment view) {
        var mh$ = PyBuffer_Release.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyBuffer_Release", view);
            }
            mh$.invokeExact(view);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_Is {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_Is");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int Py_Is(PyObject *x, PyObject *y)
     * }
     */
    public static FunctionDescriptor Py_Is$descriptor() {
        return Py_Is.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int Py_Is(PyObject *x, PyObject *y)
     * }
     */
    public static MethodHandle Py_Is$handle() {
        return Py_Is.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int Py_Is(PyObject *x, PyObject *y)
     * }
     */
    public static MemorySegment Py_Is$address() {
        return Py_Is.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int Py_Is(PyObject *x, PyObject *y)
     * }
     */
    public static int Py_Is(MemorySegment x, MemorySegment y) {
        var mh$ = Py_Is.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_Is", x, y);
            }
            return (int)mh$.invokeExact(x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyLong_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyLong_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyLong_Type
     * }
     */
    public static GroupLayout PyLong_Type$layout() {
        return PyLong_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyLong_Type
     * }
     */
    public static MemorySegment PyLong_Type() {
        return PyLong_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyLong_Type
     * }
     */
    public static void PyLong_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyLong_Type$constants.SEGMENT, 0L, PyLong_Type$constants.LAYOUT.byteSize());
    }

    private static class PyBool_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyBool_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyBool_Type
     * }
     */
    public static GroupLayout PyBool_Type$layout() {
        return PyBool_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyBool_Type
     * }
     */
    public static MemorySegment PyBool_Type() {
        return PyBool_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyBool_Type
     * }
     */
    public static void PyBool_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyBool_Type$constants.SEGMENT, 0L, PyBool_Type$constants.LAYOUT.byteSize());
    }

    private static class PyType_FromSpec {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyType_FromSpec");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyType_FromSpec(PyType_Spec *)
     * }
     */
    public static FunctionDescriptor PyType_FromSpec$descriptor() {
        return PyType_FromSpec.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyType_FromSpec(PyType_Spec *)
     * }
     */
    public static MethodHandle PyType_FromSpec$handle() {
        return PyType_FromSpec.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyType_FromSpec(PyType_Spec *)
     * }
     */
    public static MemorySegment PyType_FromSpec$address() {
        return PyType_FromSpec.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyType_FromSpec(PyType_Spec *)
     * }
     */
    public static MemorySegment PyType_FromSpec(MemorySegment x0) {
        var mh$ = PyType_FromSpec.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyType_FromSpec", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyType_FromSpecWithBases {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyType_FromSpecWithBases");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyType_FromSpecWithBases(PyType_Spec *, PyObject *)
     * }
     */
    public static FunctionDescriptor PyType_FromSpecWithBases$descriptor() {
        return PyType_FromSpecWithBases.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyType_FromSpecWithBases(PyType_Spec *, PyObject *)
     * }
     */
    public static MethodHandle PyType_FromSpecWithBases$handle() {
        return PyType_FromSpecWithBases.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyType_FromSpecWithBases(PyType_Spec *, PyObject *)
     * }
     */
    public static MemorySegment PyType_FromSpecWithBases$address() {
        return PyType_FromSpecWithBases.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyType_FromSpecWithBases(PyType_Spec *, PyObject *)
     * }
     */
    public static MemorySegment PyType_FromSpecWithBases(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyType_FromSpecWithBases.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyType_FromSpecWithBases", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyType_GetSlot {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyType_GetSlot");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *PyType_GetSlot(PyTypeObject *, int)
     * }
     */
    public static FunctionDescriptor PyType_GetSlot$descriptor() {
        return PyType_GetSlot.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *PyType_GetSlot(PyTypeObject *, int)
     * }
     */
    public static MethodHandle PyType_GetSlot$handle() {
        return PyType_GetSlot.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *PyType_GetSlot(PyTypeObject *, int)
     * }
     */
    public static MemorySegment PyType_GetSlot$address() {
        return PyType_GetSlot.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *PyType_GetSlot(PyTypeObject *, int)
     * }
     */
    public static MemorySegment PyType_GetSlot(MemorySegment x0, int x1) {
        var mh$ = PyType_GetSlot.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyType_GetSlot", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyType_FromModuleAndSpec {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyType_FromModuleAndSpec");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyType_FromModuleAndSpec(PyObject *, PyType_Spec *, PyObject *)
     * }
     */
    public static FunctionDescriptor PyType_FromModuleAndSpec$descriptor() {
        return PyType_FromModuleAndSpec.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyType_FromModuleAndSpec(PyObject *, PyType_Spec *, PyObject *)
     * }
     */
    public static MethodHandle PyType_FromModuleAndSpec$handle() {
        return PyType_FromModuleAndSpec.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyType_FromModuleAndSpec(PyObject *, PyType_Spec *, PyObject *)
     * }
     */
    public static MemorySegment PyType_FromModuleAndSpec$address() {
        return PyType_FromModuleAndSpec.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyType_FromModuleAndSpec(PyObject *, PyType_Spec *, PyObject *)
     * }
     */
    public static MemorySegment PyType_FromModuleAndSpec(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = PyType_FromModuleAndSpec.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyType_FromModuleAndSpec", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyType_GetModule {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyType_GetModule");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyType_GetModule(PyTypeObject *)
     * }
     */
    public static FunctionDescriptor PyType_GetModule$descriptor() {
        return PyType_GetModule.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyType_GetModule(PyTypeObject *)
     * }
     */
    public static MethodHandle PyType_GetModule$handle() {
        return PyType_GetModule.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyType_GetModule(PyTypeObject *)
     * }
     */
    public static MemorySegment PyType_GetModule$address() {
        return PyType_GetModule.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyType_GetModule(PyTypeObject *)
     * }
     */
    public static MemorySegment PyType_GetModule(MemorySegment x0) {
        var mh$ = PyType_GetModule.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyType_GetModule", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyType_GetModuleState {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyType_GetModuleState");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *PyType_GetModuleState(PyTypeObject *)
     * }
     */
    public static FunctionDescriptor PyType_GetModuleState$descriptor() {
        return PyType_GetModuleState.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *PyType_GetModuleState(PyTypeObject *)
     * }
     */
    public static MethodHandle PyType_GetModuleState$handle() {
        return PyType_GetModuleState.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *PyType_GetModuleState(PyTypeObject *)
     * }
     */
    public static MemorySegment PyType_GetModuleState$address() {
        return PyType_GetModuleState.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *PyType_GetModuleState(PyTypeObject *)
     * }
     */
    public static MemorySegment PyType_GetModuleState(MemorySegment x0) {
        var mh$ = PyType_GetModuleState.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyType_GetModuleState", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyType_GetName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyType_GetName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyType_GetName(PyTypeObject *)
     * }
     */
    public static FunctionDescriptor PyType_GetName$descriptor() {
        return PyType_GetName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyType_GetName(PyTypeObject *)
     * }
     */
    public static MethodHandle PyType_GetName$handle() {
        return PyType_GetName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyType_GetName(PyTypeObject *)
     * }
     */
    public static MemorySegment PyType_GetName$address() {
        return PyType_GetName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyType_GetName(PyTypeObject *)
     * }
     */
    public static MemorySegment PyType_GetName(MemorySegment x0) {
        var mh$ = PyType_GetName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyType_GetName", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyType_GetQualName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyType_GetQualName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyType_GetQualName(PyTypeObject *)
     * }
     */
    public static FunctionDescriptor PyType_GetQualName$descriptor() {
        return PyType_GetQualName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyType_GetQualName(PyTypeObject *)
     * }
     */
    public static MethodHandle PyType_GetQualName$handle() {
        return PyType_GetQualName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyType_GetQualName(PyTypeObject *)
     * }
     */
    public static MemorySegment PyType_GetQualName$address() {
        return PyType_GetQualName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyType_GetQualName(PyTypeObject *)
     * }
     */
    public static MemorySegment PyType_GetQualName(MemorySegment x0) {
        var mh$ = PyType_GetQualName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyType_GetQualName", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyType_FromMetaclass {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyType_FromMetaclass");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyType_FromMetaclass(PyTypeObject *, PyObject *, PyType_Spec *, PyObject *)
     * }
     */
    public static FunctionDescriptor PyType_FromMetaclass$descriptor() {
        return PyType_FromMetaclass.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyType_FromMetaclass(PyTypeObject *, PyObject *, PyType_Spec *, PyObject *)
     * }
     */
    public static MethodHandle PyType_FromMetaclass$handle() {
        return PyType_FromMetaclass.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyType_FromMetaclass(PyTypeObject *, PyObject *, PyType_Spec *, PyObject *)
     * }
     */
    public static MemorySegment PyType_FromMetaclass$address() {
        return PyType_FromMetaclass.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyType_FromMetaclass(PyTypeObject *, PyObject *, PyType_Spec *, PyObject *)
     * }
     */
    public static MemorySegment PyType_FromMetaclass(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = PyType_FromMetaclass.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyType_FromMetaclass", x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_GetTypeData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_GetTypeData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *PyObject_GetTypeData(PyObject *obj, PyTypeObject *cls)
     * }
     */
    public static FunctionDescriptor PyObject_GetTypeData$descriptor() {
        return PyObject_GetTypeData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *PyObject_GetTypeData(PyObject *obj, PyTypeObject *cls)
     * }
     */
    public static MethodHandle PyObject_GetTypeData$handle() {
        return PyObject_GetTypeData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *PyObject_GetTypeData(PyObject *obj, PyTypeObject *cls)
     * }
     */
    public static MemorySegment PyObject_GetTypeData$address() {
        return PyObject_GetTypeData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *PyObject_GetTypeData(PyObject *obj, PyTypeObject *cls)
     * }
     */
    public static MemorySegment PyObject_GetTypeData(MemorySegment obj, MemorySegment cls) {
        var mh$ = PyObject_GetTypeData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_GetTypeData", obj, cls);
            }
            return (MemorySegment)mh$.invokeExact(obj, cls);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyType_GetTypeDataSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyType_GetTypeDataSize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_ssize_t PyType_GetTypeDataSize(PyTypeObject *cls)
     * }
     */
    public static FunctionDescriptor PyType_GetTypeDataSize$descriptor() {
        return PyType_GetTypeDataSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_ssize_t PyType_GetTypeDataSize(PyTypeObject *cls)
     * }
     */
    public static MethodHandle PyType_GetTypeDataSize$handle() {
        return PyType_GetTypeDataSize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_ssize_t PyType_GetTypeDataSize(PyTypeObject *cls)
     * }
     */
    public static MemorySegment PyType_GetTypeDataSize$address() {
        return PyType_GetTypeDataSize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_ssize_t PyType_GetTypeDataSize(PyTypeObject *cls)
     * }
     */
    public static long PyType_GetTypeDataSize(MemorySegment cls) {
        var mh$ = PyType_GetTypeDataSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyType_GetTypeDataSize", cls);
            }
            return (long)mh$.invokeExact(cls);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyType_IsSubtype {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyType_IsSubtype");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyType_IsSubtype(PyTypeObject *, PyTypeObject *)
     * }
     */
    public static FunctionDescriptor PyType_IsSubtype$descriptor() {
        return PyType_IsSubtype.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyType_IsSubtype(PyTypeObject *, PyTypeObject *)
     * }
     */
    public static MethodHandle PyType_IsSubtype$handle() {
        return PyType_IsSubtype.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyType_IsSubtype(PyTypeObject *, PyTypeObject *)
     * }
     */
    public static MemorySegment PyType_IsSubtype$address() {
        return PyType_IsSubtype.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyType_IsSubtype(PyTypeObject *, PyTypeObject *)
     * }
     */
    public static int PyType_IsSubtype(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyType_IsSubtype.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyType_IsSubtype", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyType_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyType_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyType_Type
     * }
     */
    public static GroupLayout PyType_Type$layout() {
        return PyType_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyType_Type
     * }
     */
    public static MemorySegment PyType_Type() {
        return PyType_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyType_Type
     * }
     */
    public static void PyType_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyType_Type$constants.SEGMENT, 0L, PyType_Type$constants.LAYOUT.byteSize());
    }

    private static class PyBaseObject_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyBaseObject_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyBaseObject_Type
     * }
     */
    public static GroupLayout PyBaseObject_Type$layout() {
        return PyBaseObject_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyBaseObject_Type
     * }
     */
    public static MemorySegment PyBaseObject_Type() {
        return PyBaseObject_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyBaseObject_Type
     * }
     */
    public static void PyBaseObject_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyBaseObject_Type$constants.SEGMENT, 0L, PyBaseObject_Type$constants.LAYOUT.byteSize());
    }

    private static class PySuper_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PySuper_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PySuper_Type
     * }
     */
    public static GroupLayout PySuper_Type$layout() {
        return PySuper_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PySuper_Type
     * }
     */
    public static MemorySegment PySuper_Type() {
        return PySuper_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PySuper_Type
     * }
     */
    public static void PySuper_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PySuper_Type$constants.SEGMENT, 0L, PySuper_Type$constants.LAYOUT.byteSize());
    }

    private static class PyType_GetFlags {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyType_GetFlags");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long PyType_GetFlags(PyTypeObject *)
     * }
     */
    public static FunctionDescriptor PyType_GetFlags$descriptor() {
        return PyType_GetFlags.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long PyType_GetFlags(PyTypeObject *)
     * }
     */
    public static MethodHandle PyType_GetFlags$handle() {
        return PyType_GetFlags.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long PyType_GetFlags(PyTypeObject *)
     * }
     */
    public static MemorySegment PyType_GetFlags$address() {
        return PyType_GetFlags.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long PyType_GetFlags(PyTypeObject *)
     * }
     */
    public static int PyType_GetFlags(MemorySegment x0) {
        var mh$ = PyType_GetFlags.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyType_GetFlags", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyType_Ready {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyType_Ready");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyType_Ready(PyTypeObject *)
     * }
     */
    public static FunctionDescriptor PyType_Ready$descriptor() {
        return PyType_Ready.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyType_Ready(PyTypeObject *)
     * }
     */
    public static MethodHandle PyType_Ready$handle() {
        return PyType_Ready.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyType_Ready(PyTypeObject *)
     * }
     */
    public static MemorySegment PyType_Ready$address() {
        return PyType_Ready.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyType_Ready(PyTypeObject *)
     * }
     */
    public static int PyType_Ready(MemorySegment x0) {
        var mh$ = PyType_Ready.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyType_Ready", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyType_GenericAlloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyType_GenericAlloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyType_GenericAlloc(PyTypeObject *, Py_ssize_t)
     * }
     */
    public static FunctionDescriptor PyType_GenericAlloc$descriptor() {
        return PyType_GenericAlloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyType_GenericAlloc(PyTypeObject *, Py_ssize_t)
     * }
     */
    public static MethodHandle PyType_GenericAlloc$handle() {
        return PyType_GenericAlloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyType_GenericAlloc(PyTypeObject *, Py_ssize_t)
     * }
     */
    public static MemorySegment PyType_GenericAlloc$address() {
        return PyType_GenericAlloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyType_GenericAlloc(PyTypeObject *, Py_ssize_t)
     * }
     */
    public static MemorySegment PyType_GenericAlloc(MemorySegment x0, long x1) {
        var mh$ = PyType_GenericAlloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyType_GenericAlloc", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyType_GenericNew {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyType_GenericNew");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyType_GenericNew(PyTypeObject *, PyObject *, PyObject *)
     * }
     */
    public static FunctionDescriptor PyType_GenericNew$descriptor() {
        return PyType_GenericNew.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyType_GenericNew(PyTypeObject *, PyObject *, PyObject *)
     * }
     */
    public static MethodHandle PyType_GenericNew$handle() {
        return PyType_GenericNew.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyType_GenericNew(PyTypeObject *, PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyType_GenericNew$address() {
        return PyType_GenericNew.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyType_GenericNew(PyTypeObject *, PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyType_GenericNew(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = PyType_GenericNew.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyType_GenericNew", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyType_ClearCache {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyType_ClearCache");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int PyType_ClearCache()
     * }
     */
    public static FunctionDescriptor PyType_ClearCache$descriptor() {
        return PyType_ClearCache.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int PyType_ClearCache()
     * }
     */
    public static MethodHandle PyType_ClearCache$handle() {
        return PyType_ClearCache.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int PyType_ClearCache()
     * }
     */
    public static MemorySegment PyType_ClearCache$address() {
        return PyType_ClearCache.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int PyType_ClearCache()
     * }
     */
    public static int PyType_ClearCache() {
        var mh$ = PyType_ClearCache.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyType_ClearCache");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyType_Modified {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyType_Modified");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyType_Modified(PyTypeObject *)
     * }
     */
    public static FunctionDescriptor PyType_Modified$descriptor() {
        return PyType_Modified.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyType_Modified(PyTypeObject *)
     * }
     */
    public static MethodHandle PyType_Modified$handle() {
        return PyType_Modified.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyType_Modified(PyTypeObject *)
     * }
     */
    public static MemorySegment PyType_Modified$address() {
        return PyType_Modified.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyType_Modified(PyTypeObject *)
     * }
     */
    public static void PyType_Modified(MemorySegment x0) {
        var mh$ = PyType_Modified.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyType_Modified", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_Repr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_Repr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyObject_Repr(PyObject *)
     * }
     */
    public static FunctionDescriptor PyObject_Repr$descriptor() {
        return PyObject_Repr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyObject_Repr(PyObject *)
     * }
     */
    public static MethodHandle PyObject_Repr$handle() {
        return PyObject_Repr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyObject_Repr(PyObject *)
     * }
     */
    public static MemorySegment PyObject_Repr$address() {
        return PyObject_Repr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyObject_Repr(PyObject *)
     * }
     */
    public static MemorySegment PyObject_Repr(MemorySegment x0) {
        var mh$ = PyObject_Repr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_Repr", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_Str {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_Str");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyObject_Str(PyObject *)
     * }
     */
    public static FunctionDescriptor PyObject_Str$descriptor() {
        return PyObject_Str.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyObject_Str(PyObject *)
     * }
     */
    public static MethodHandle PyObject_Str$handle() {
        return PyObject_Str.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyObject_Str(PyObject *)
     * }
     */
    public static MemorySegment PyObject_Str$address() {
        return PyObject_Str.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyObject_Str(PyObject *)
     * }
     */
    public static MemorySegment PyObject_Str(MemorySegment x0) {
        var mh$ = PyObject_Str.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_Str", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_ASCII {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_ASCII");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyObject_ASCII(PyObject *)
     * }
     */
    public static FunctionDescriptor PyObject_ASCII$descriptor() {
        return PyObject_ASCII.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyObject_ASCII(PyObject *)
     * }
     */
    public static MethodHandle PyObject_ASCII$handle() {
        return PyObject_ASCII.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyObject_ASCII(PyObject *)
     * }
     */
    public static MemorySegment PyObject_ASCII$address() {
        return PyObject_ASCII.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyObject_ASCII(PyObject *)
     * }
     */
    public static MemorySegment PyObject_ASCII(MemorySegment x0) {
        var mh$ = PyObject_ASCII.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_ASCII", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_Bytes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_Bytes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyObject_Bytes(PyObject *)
     * }
     */
    public static FunctionDescriptor PyObject_Bytes$descriptor() {
        return PyObject_Bytes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyObject_Bytes(PyObject *)
     * }
     */
    public static MethodHandle PyObject_Bytes$handle() {
        return PyObject_Bytes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyObject_Bytes(PyObject *)
     * }
     */
    public static MemorySegment PyObject_Bytes$address() {
        return PyObject_Bytes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyObject_Bytes(PyObject *)
     * }
     */
    public static MemorySegment PyObject_Bytes(MemorySegment x0) {
        var mh$ = PyObject_Bytes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_Bytes", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_RichCompare {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_RichCompare");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyObject_RichCompare(PyObject *, PyObject *, int)
     * }
     */
    public static FunctionDescriptor PyObject_RichCompare$descriptor() {
        return PyObject_RichCompare.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyObject_RichCompare(PyObject *, PyObject *, int)
     * }
     */
    public static MethodHandle PyObject_RichCompare$handle() {
        return PyObject_RichCompare.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyObject_RichCompare(PyObject *, PyObject *, int)
     * }
     */
    public static MemorySegment PyObject_RichCompare$address() {
        return PyObject_RichCompare.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyObject_RichCompare(PyObject *, PyObject *, int)
     * }
     */
    public static MemorySegment PyObject_RichCompare(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = PyObject_RichCompare.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_RichCompare", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_RichCompareBool {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_RichCompareBool");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyObject_RichCompareBool(PyObject *, PyObject *, int)
     * }
     */
    public static FunctionDescriptor PyObject_RichCompareBool$descriptor() {
        return PyObject_RichCompareBool.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyObject_RichCompareBool(PyObject *, PyObject *, int)
     * }
     */
    public static MethodHandle PyObject_RichCompareBool$handle() {
        return PyObject_RichCompareBool.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyObject_RichCompareBool(PyObject *, PyObject *, int)
     * }
     */
    public static MemorySegment PyObject_RichCompareBool$address() {
        return PyObject_RichCompareBool.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyObject_RichCompareBool(PyObject *, PyObject *, int)
     * }
     */
    public static int PyObject_RichCompareBool(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = PyObject_RichCompareBool.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_RichCompareBool", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_GetAttrString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_GetAttrString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyObject_GetAttrString(PyObject *, const char *)
     * }
     */
    public static FunctionDescriptor PyObject_GetAttrString$descriptor() {
        return PyObject_GetAttrString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyObject_GetAttrString(PyObject *, const char *)
     * }
     */
    public static MethodHandle PyObject_GetAttrString$handle() {
        return PyObject_GetAttrString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyObject_GetAttrString(PyObject *, const char *)
     * }
     */
    public static MemorySegment PyObject_GetAttrString$address() {
        return PyObject_GetAttrString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyObject_GetAttrString(PyObject *, const char *)
     * }
     */
    public static MemorySegment PyObject_GetAttrString(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyObject_GetAttrString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_GetAttrString", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_SetAttrString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_SetAttrString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyObject_SetAttrString(PyObject *, const char *, PyObject *)
     * }
     */
    public static FunctionDescriptor PyObject_SetAttrString$descriptor() {
        return PyObject_SetAttrString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyObject_SetAttrString(PyObject *, const char *, PyObject *)
     * }
     */
    public static MethodHandle PyObject_SetAttrString$handle() {
        return PyObject_SetAttrString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyObject_SetAttrString(PyObject *, const char *, PyObject *)
     * }
     */
    public static MemorySegment PyObject_SetAttrString$address() {
        return PyObject_SetAttrString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyObject_SetAttrString(PyObject *, const char *, PyObject *)
     * }
     */
    public static int PyObject_SetAttrString(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = PyObject_SetAttrString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_SetAttrString", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_HasAttrString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_HasAttrString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyObject_HasAttrString(PyObject *, const char *)
     * }
     */
    public static FunctionDescriptor PyObject_HasAttrString$descriptor() {
        return PyObject_HasAttrString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyObject_HasAttrString(PyObject *, const char *)
     * }
     */
    public static MethodHandle PyObject_HasAttrString$handle() {
        return PyObject_HasAttrString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyObject_HasAttrString(PyObject *, const char *)
     * }
     */
    public static MemorySegment PyObject_HasAttrString$address() {
        return PyObject_HasAttrString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyObject_HasAttrString(PyObject *, const char *)
     * }
     */
    public static int PyObject_HasAttrString(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyObject_HasAttrString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_HasAttrString", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_GetAttr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_GetAttr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyObject_GetAttr(PyObject *, PyObject *)
     * }
     */
    public static FunctionDescriptor PyObject_GetAttr$descriptor() {
        return PyObject_GetAttr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyObject_GetAttr(PyObject *, PyObject *)
     * }
     */
    public static MethodHandle PyObject_GetAttr$handle() {
        return PyObject_GetAttr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyObject_GetAttr(PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyObject_GetAttr$address() {
        return PyObject_GetAttr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyObject_GetAttr(PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyObject_GetAttr(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyObject_GetAttr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_GetAttr", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_SetAttr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_SetAttr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyObject_SetAttr(PyObject *, PyObject *, PyObject *)
     * }
     */
    public static FunctionDescriptor PyObject_SetAttr$descriptor() {
        return PyObject_SetAttr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyObject_SetAttr(PyObject *, PyObject *, PyObject *)
     * }
     */
    public static MethodHandle PyObject_SetAttr$handle() {
        return PyObject_SetAttr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyObject_SetAttr(PyObject *, PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyObject_SetAttr$address() {
        return PyObject_SetAttr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyObject_SetAttr(PyObject *, PyObject *, PyObject *)
     * }
     */
    public static int PyObject_SetAttr(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = PyObject_SetAttr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_SetAttr", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_HasAttr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_HasAttr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyObject_HasAttr(PyObject *, PyObject *)
     * }
     */
    public static FunctionDescriptor PyObject_HasAttr$descriptor() {
        return PyObject_HasAttr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyObject_HasAttr(PyObject *, PyObject *)
     * }
     */
    public static MethodHandle PyObject_HasAttr$handle() {
        return PyObject_HasAttr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyObject_HasAttr(PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyObject_HasAttr$address() {
        return PyObject_HasAttr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyObject_HasAttr(PyObject *, PyObject *)
     * }
     */
    public static int PyObject_HasAttr(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyObject_HasAttr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_HasAttr", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_SelfIter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_SelfIter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyObject_SelfIter(PyObject *)
     * }
     */
    public static FunctionDescriptor PyObject_SelfIter$descriptor() {
        return PyObject_SelfIter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyObject_SelfIter(PyObject *)
     * }
     */
    public static MethodHandle PyObject_SelfIter$handle() {
        return PyObject_SelfIter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyObject_SelfIter(PyObject *)
     * }
     */
    public static MemorySegment PyObject_SelfIter$address() {
        return PyObject_SelfIter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyObject_SelfIter(PyObject *)
     * }
     */
    public static MemorySegment PyObject_SelfIter(MemorySegment x0) {
        var mh$ = PyObject_SelfIter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_SelfIter", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_GenericGetAttr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_GenericGetAttr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyObject_GenericGetAttr(PyObject *, PyObject *)
     * }
     */
    public static FunctionDescriptor PyObject_GenericGetAttr$descriptor() {
        return PyObject_GenericGetAttr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyObject_GenericGetAttr(PyObject *, PyObject *)
     * }
     */
    public static MethodHandle PyObject_GenericGetAttr$handle() {
        return PyObject_GenericGetAttr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyObject_GenericGetAttr(PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyObject_GenericGetAttr$address() {
        return PyObject_GenericGetAttr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyObject_GenericGetAttr(PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyObject_GenericGetAttr(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyObject_GenericGetAttr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_GenericGetAttr", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_GenericSetAttr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_GenericSetAttr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyObject_GenericSetAttr(PyObject *, PyObject *, PyObject *)
     * }
     */
    public static FunctionDescriptor PyObject_GenericSetAttr$descriptor() {
        return PyObject_GenericSetAttr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyObject_GenericSetAttr(PyObject *, PyObject *, PyObject *)
     * }
     */
    public static MethodHandle PyObject_GenericSetAttr$handle() {
        return PyObject_GenericSetAttr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyObject_GenericSetAttr(PyObject *, PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyObject_GenericSetAttr$address() {
        return PyObject_GenericSetAttr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyObject_GenericSetAttr(PyObject *, PyObject *, PyObject *)
     * }
     */
    public static int PyObject_GenericSetAttr(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = PyObject_GenericSetAttr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_GenericSetAttr", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_GenericSetDict {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_GenericSetDict");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyObject_GenericSetDict(PyObject *, PyObject *, void *)
     * }
     */
    public static FunctionDescriptor PyObject_GenericSetDict$descriptor() {
        return PyObject_GenericSetDict.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyObject_GenericSetDict(PyObject *, PyObject *, void *)
     * }
     */
    public static MethodHandle PyObject_GenericSetDict$handle() {
        return PyObject_GenericSetDict.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyObject_GenericSetDict(PyObject *, PyObject *, void *)
     * }
     */
    public static MemorySegment PyObject_GenericSetDict$address() {
        return PyObject_GenericSetDict.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyObject_GenericSetDict(PyObject *, PyObject *, void *)
     * }
     */
    public static int PyObject_GenericSetDict(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = PyObject_GenericSetDict.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_GenericSetDict", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_Hash {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_Hash");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_hash_t PyObject_Hash(PyObject *)
     * }
     */
    public static FunctionDescriptor PyObject_Hash$descriptor() {
        return PyObject_Hash.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_hash_t PyObject_Hash(PyObject *)
     * }
     */
    public static MethodHandle PyObject_Hash$handle() {
        return PyObject_Hash.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_hash_t PyObject_Hash(PyObject *)
     * }
     */
    public static MemorySegment PyObject_Hash$address() {
        return PyObject_Hash.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_hash_t PyObject_Hash(PyObject *)
     * }
     */
    public static long PyObject_Hash(MemorySegment x0) {
        var mh$ = PyObject_Hash.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_Hash", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_HashNotImplemented {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_HashNotImplemented");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_hash_t PyObject_HashNotImplemented(PyObject *)
     * }
     */
    public static FunctionDescriptor PyObject_HashNotImplemented$descriptor() {
        return PyObject_HashNotImplemented.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_hash_t PyObject_HashNotImplemented(PyObject *)
     * }
     */
    public static MethodHandle PyObject_HashNotImplemented$handle() {
        return PyObject_HashNotImplemented.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_hash_t PyObject_HashNotImplemented(PyObject *)
     * }
     */
    public static MemorySegment PyObject_HashNotImplemented$address() {
        return PyObject_HashNotImplemented.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_hash_t PyObject_HashNotImplemented(PyObject *)
     * }
     */
    public static long PyObject_HashNotImplemented(MemorySegment x0) {
        var mh$ = PyObject_HashNotImplemented.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_HashNotImplemented", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_IsTrue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_IsTrue");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyObject_IsTrue(PyObject *)
     * }
     */
    public static FunctionDescriptor PyObject_IsTrue$descriptor() {
        return PyObject_IsTrue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyObject_IsTrue(PyObject *)
     * }
     */
    public static MethodHandle PyObject_IsTrue$handle() {
        return PyObject_IsTrue.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyObject_IsTrue(PyObject *)
     * }
     */
    public static MemorySegment PyObject_IsTrue$address() {
        return PyObject_IsTrue.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyObject_IsTrue(PyObject *)
     * }
     */
    public static int PyObject_IsTrue(MemorySegment x0) {
        var mh$ = PyObject_IsTrue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_IsTrue", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_Not {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_Not");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyObject_Not(PyObject *)
     * }
     */
    public static FunctionDescriptor PyObject_Not$descriptor() {
        return PyObject_Not.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyObject_Not(PyObject *)
     * }
     */
    public static MethodHandle PyObject_Not$handle() {
        return PyObject_Not.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyObject_Not(PyObject *)
     * }
     */
    public static MemorySegment PyObject_Not$address() {
        return PyObject_Not.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyObject_Not(PyObject *)
     * }
     */
    public static int PyObject_Not(MemorySegment x0) {
        var mh$ = PyObject_Not.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_Not", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCallable_Check {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCallable_Check");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyCallable_Check(PyObject *)
     * }
     */
    public static FunctionDescriptor PyCallable_Check$descriptor() {
        return PyCallable_Check.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyCallable_Check(PyObject *)
     * }
     */
    public static MethodHandle PyCallable_Check$handle() {
        return PyCallable_Check.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyCallable_Check(PyObject *)
     * }
     */
    public static MemorySegment PyCallable_Check$address() {
        return PyCallable_Check.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyCallable_Check(PyObject *)
     * }
     */
    public static int PyCallable_Check(MemorySegment x0) {
        var mh$ = PyCallable_Check.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCallable_Check", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_ClearWeakRefs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_ClearWeakRefs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyObject_ClearWeakRefs(PyObject *)
     * }
     */
    public static FunctionDescriptor PyObject_ClearWeakRefs$descriptor() {
        return PyObject_ClearWeakRefs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyObject_ClearWeakRefs(PyObject *)
     * }
     */
    public static MethodHandle PyObject_ClearWeakRefs$handle() {
        return PyObject_ClearWeakRefs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyObject_ClearWeakRefs(PyObject *)
     * }
     */
    public static MemorySegment PyObject_ClearWeakRefs$address() {
        return PyObject_ClearWeakRefs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyObject_ClearWeakRefs(PyObject *)
     * }
     */
    public static void PyObject_ClearWeakRefs(MemorySegment x0) {
        var mh$ = PyObject_ClearWeakRefs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_ClearWeakRefs", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_Dir {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_Dir");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyObject_Dir(PyObject *)
     * }
     */
    public static FunctionDescriptor PyObject_Dir$descriptor() {
        return PyObject_Dir.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyObject_Dir(PyObject *)
     * }
     */
    public static MethodHandle PyObject_Dir$handle() {
        return PyObject_Dir.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyObject_Dir(PyObject *)
     * }
     */
    public static MemorySegment PyObject_Dir$address() {
        return PyObject_Dir.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyObject_Dir(PyObject *)
     * }
     */
    public static MemorySegment PyObject_Dir(MemorySegment x0) {
        var mh$ = PyObject_Dir.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_Dir", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyObject_GetState {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyObject_GetState");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *_PyObject_GetState(PyObject *)
     * }
     */
    public static FunctionDescriptor _PyObject_GetState$descriptor() {
        return _PyObject_GetState.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *_PyObject_GetState(PyObject *)
     * }
     */
    public static MethodHandle _PyObject_GetState$handle() {
        return _PyObject_GetState.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *_PyObject_GetState(PyObject *)
     * }
     */
    public static MemorySegment _PyObject_GetState$address() {
        return _PyObject_GetState.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *_PyObject_GetState(PyObject *)
     * }
     */
    public static MemorySegment _PyObject_GetState(MemorySegment x0) {
        var mh$ = _PyObject_GetState.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyObject_GetState", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_ReprEnter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_ReprEnter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int Py_ReprEnter(PyObject *)
     * }
     */
    public static FunctionDescriptor Py_ReprEnter$descriptor() {
        return Py_ReprEnter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int Py_ReprEnter(PyObject *)
     * }
     */
    public static MethodHandle Py_ReprEnter$handle() {
        return Py_ReprEnter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int Py_ReprEnter(PyObject *)
     * }
     */
    public static MemorySegment Py_ReprEnter$address() {
        return Py_ReprEnter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int Py_ReprEnter(PyObject *)
     * }
     */
    public static int Py_ReprEnter(MemorySegment x0) {
        var mh$ = Py_ReprEnter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_ReprEnter", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_ReprLeave {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_ReprLeave");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void Py_ReprLeave(PyObject *)
     * }
     */
    public static FunctionDescriptor Py_ReprLeave$descriptor() {
        return Py_ReprLeave.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void Py_ReprLeave(PyObject *)
     * }
     */
    public static MethodHandle Py_ReprLeave$handle() {
        return Py_ReprLeave.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void Py_ReprLeave(PyObject *)
     * }
     */
    public static MemorySegment Py_ReprLeave$address() {
        return Py_ReprLeave.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void Py_ReprLeave(PyObject *)
     * }
     */
    public static void Py_ReprLeave(MemorySegment x0) {
        var mh$ = Py_ReprLeave.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_ReprLeave", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _Py_Dealloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_Py_Dealloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _Py_Dealloc(PyObject *)
     * }
     */
    public static FunctionDescriptor _Py_Dealloc$descriptor() {
        return _Py_Dealloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _Py_Dealloc(PyObject *)
     * }
     */
    public static MethodHandle _Py_Dealloc$handle() {
        return _Py_Dealloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _Py_Dealloc(PyObject *)
     * }
     */
    public static MemorySegment _Py_Dealloc$address() {
        return _Py_Dealloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _Py_Dealloc(PyObject *)
     * }
     */
    public static void _Py_Dealloc(MemorySegment x0) {
        var mh$ = _Py_Dealloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_Py_Dealloc", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_IncRef {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_IncRef");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void Py_IncRef(PyObject *)
     * }
     */
    public static FunctionDescriptor Py_IncRef$descriptor() {
        return Py_IncRef.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void Py_IncRef(PyObject *)
     * }
     */
    public static MethodHandle Py_IncRef$handle() {
        return Py_IncRef.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void Py_IncRef(PyObject *)
     * }
     */
    public static MemorySegment Py_IncRef$address() {
        return Py_IncRef.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void Py_IncRef(PyObject *)
     * }
     */
    public static void Py_IncRef(MemorySegment x0) {
        var mh$ = Py_IncRef.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_IncRef", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_DecRef {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_DecRef");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void Py_DecRef(PyObject *)
     * }
     */
    public static FunctionDescriptor Py_DecRef$descriptor() {
        return Py_DecRef.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void Py_DecRef(PyObject *)
     * }
     */
    public static MethodHandle Py_DecRef$handle() {
        return Py_DecRef.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void Py_DecRef(PyObject *)
     * }
     */
    public static MemorySegment Py_DecRef$address() {
        return Py_DecRef.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void Py_DecRef(PyObject *)
     * }
     */
    public static void Py_DecRef(MemorySegment x0) {
        var mh$ = Py_DecRef.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_DecRef", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _Py_IncRef {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_Py_IncRef");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _Py_IncRef(PyObject *)
     * }
     */
    public static FunctionDescriptor _Py_IncRef$descriptor() {
        return _Py_IncRef.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _Py_IncRef(PyObject *)
     * }
     */
    public static MethodHandle _Py_IncRef$handle() {
        return _Py_IncRef.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _Py_IncRef(PyObject *)
     * }
     */
    public static MemorySegment _Py_IncRef$address() {
        return _Py_IncRef.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _Py_IncRef(PyObject *)
     * }
     */
    public static void _Py_IncRef(MemorySegment x0) {
        var mh$ = _Py_IncRef.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_Py_IncRef", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _Py_DecRef {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_Py_DecRef");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _Py_DecRef(PyObject *)
     * }
     */
    public static FunctionDescriptor _Py_DecRef$descriptor() {
        return _Py_DecRef.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _Py_DecRef(PyObject *)
     * }
     */
    public static MethodHandle _Py_DecRef$handle() {
        return _Py_DecRef.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _Py_DecRef(PyObject *)
     * }
     */
    public static MemorySegment _Py_DecRef$address() {
        return _Py_DecRef.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _Py_DecRef(PyObject *)
     * }
     */
    public static void _Py_DecRef(MemorySegment x0) {
        var mh$ = _Py_DecRef.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_Py_DecRef", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_NewRef {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_NewRef");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *Py_NewRef(PyObject *obj)
     * }
     */
    public static FunctionDescriptor Py_NewRef$descriptor() {
        return Py_NewRef.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *Py_NewRef(PyObject *obj)
     * }
     */
    public static MethodHandle Py_NewRef$handle() {
        return Py_NewRef.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *Py_NewRef(PyObject *obj)
     * }
     */
    public static MemorySegment Py_NewRef$address() {
        return Py_NewRef.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *Py_NewRef(PyObject *obj)
     * }
     */
    public static MemorySegment Py_NewRef(MemorySegment obj) {
        var mh$ = Py_NewRef.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_NewRef", obj);
            }
            return (MemorySegment)mh$.invokeExact(obj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_XNewRef {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_XNewRef");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *Py_XNewRef(PyObject *obj)
     * }
     */
    public static FunctionDescriptor Py_XNewRef$descriptor() {
        return Py_XNewRef.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *Py_XNewRef(PyObject *obj)
     * }
     */
    public static MethodHandle Py_XNewRef$handle() {
        return Py_XNewRef.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *Py_XNewRef(PyObject *obj)
     * }
     */
    public static MemorySegment Py_XNewRef$address() {
        return Py_XNewRef.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *Py_XNewRef(PyObject *obj)
     * }
     */
    public static MemorySegment Py_XNewRef(MemorySegment obj) {
        var mh$ = Py_XNewRef.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_XNewRef", obj);
            }
            return (MemorySegment)mh$.invokeExact(obj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _Py_NoneStruct$constants {
        public static final GroupLayout LAYOUT = _object.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("_Py_NoneStruct").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject _Py_NoneStruct
     * }
     */
    public static GroupLayout _Py_NoneStruct$layout() {
        return _Py_NoneStruct$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject _Py_NoneStruct
     * }
     */
    public static MemorySegment _Py_NoneStruct() {
        return _Py_NoneStruct$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject _Py_NoneStruct
     * }
     */
    public static void _Py_NoneStruct(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, _Py_NoneStruct$constants.SEGMENT, 0L, _Py_NoneStruct$constants.LAYOUT.byteSize());
    }

    private static class Py_IsNone {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_IsNone");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int Py_IsNone(PyObject *x)
     * }
     */
    public static FunctionDescriptor Py_IsNone$descriptor() {
        return Py_IsNone.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int Py_IsNone(PyObject *x)
     * }
     */
    public static MethodHandle Py_IsNone$handle() {
        return Py_IsNone.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int Py_IsNone(PyObject *x)
     * }
     */
    public static MemorySegment Py_IsNone$address() {
        return Py_IsNone.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int Py_IsNone(PyObject *x)
     * }
     */
    public static int Py_IsNone(MemorySegment x) {
        var mh$ = Py_IsNone.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_IsNone", x);
            }
            return (int)mh$.invokeExact(x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _Py_NotImplementedStruct$constants {
        public static final GroupLayout LAYOUT = _object.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("_Py_NotImplementedStruct").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject _Py_NotImplementedStruct
     * }
     */
    public static GroupLayout _Py_NotImplementedStruct$layout() {
        return _Py_NotImplementedStruct$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject _Py_NotImplementedStruct
     * }
     */
    public static MemorySegment _Py_NotImplementedStruct() {
        return _Py_NotImplementedStruct$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject _Py_NotImplementedStruct
     * }
     */
    public static void _Py_NotImplementedStruct(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, _Py_NotImplementedStruct$constants.SEGMENT, 0L, _Py_NotImplementedStruct$constants.LAYOUT.byteSize());
    }
    private static final int PYGEN_RETURN = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PYGEN_RETURN = 0
     * }
     */
    public static int PYGEN_RETURN() {
        return PYGEN_RETURN;
    }
    private static final int PYGEN_ERROR = (int)-1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PYGEN_ERROR = -1
     * }
     */
    public static int PYGEN_ERROR() {
        return PYGEN_ERROR;
    }
    private static final int PYGEN_NEXT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PYGEN_NEXT = 1
     * }
     */
    public static int PYGEN_NEXT() {
        return PYGEN_NEXT;
    }

    private static class _Py_NewReference {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_Py_NewReference");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _Py_NewReference(PyObject *op)
     * }
     */
    public static FunctionDescriptor _Py_NewReference$descriptor() {
        return _Py_NewReference.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _Py_NewReference(PyObject *op)
     * }
     */
    public static MethodHandle _Py_NewReference$handle() {
        return _Py_NewReference.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _Py_NewReference(PyObject *op)
     * }
     */
    public static MemorySegment _Py_NewReference$address() {
        return _Py_NewReference.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _Py_NewReference(PyObject *op)
     * }
     */
    public static void _Py_NewReference(MemorySegment op) {
        var mh$ = _Py_NewReference.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_Py_NewReference", op);
            }
            mh$.invokeExact(op);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _Py_NewReferenceNoTotal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_Py_NewReferenceNoTotal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _Py_NewReferenceNoTotal(PyObject *op)
     * }
     */
    public static FunctionDescriptor _Py_NewReferenceNoTotal$descriptor() {
        return _Py_NewReferenceNoTotal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _Py_NewReferenceNoTotal(PyObject *op)
     * }
     */
    public static MethodHandle _Py_NewReferenceNoTotal$handle() {
        return _Py_NewReferenceNoTotal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _Py_NewReferenceNoTotal(PyObject *op)
     * }
     */
    public static MemorySegment _Py_NewReferenceNoTotal$address() {
        return _Py_NewReferenceNoTotal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _Py_NewReferenceNoTotal(PyObject *op)
     * }
     */
    public static void _Py_NewReferenceNoTotal(MemorySegment op) {
        var mh$ = _Py_NewReferenceNoTotal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_Py_NewReferenceNoTotal", op);
            }
            mh$.invokeExact(op);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef Py_ssize_t printfunc
     * }
     */
    public static final OfLong printfunc = Python_h.C_LONG_LONG;

    private static class _PyType_Name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyType_Name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *_PyType_Name(PyTypeObject *)
     * }
     */
    public static FunctionDescriptor _PyType_Name$descriptor() {
        return _PyType_Name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *_PyType_Name(PyTypeObject *)
     * }
     */
    public static MethodHandle _PyType_Name$handle() {
        return _PyType_Name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *_PyType_Name(PyTypeObject *)
     * }
     */
    public static MemorySegment _PyType_Name$address() {
        return _PyType_Name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *_PyType_Name(PyTypeObject *)
     * }
     */
    public static MemorySegment _PyType_Name(MemorySegment x0) {
        var mh$ = _PyType_Name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyType_Name", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyType_Lookup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyType_Lookup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *_PyType_Lookup(PyTypeObject *, PyObject *)
     * }
     */
    public static FunctionDescriptor _PyType_Lookup$descriptor() {
        return _PyType_Lookup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *_PyType_Lookup(PyTypeObject *, PyObject *)
     * }
     */
    public static MethodHandle _PyType_Lookup$handle() {
        return _PyType_Lookup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *_PyType_Lookup(PyTypeObject *, PyObject *)
     * }
     */
    public static MemorySegment _PyType_Lookup$address() {
        return _PyType_Lookup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *_PyType_Lookup(PyTypeObject *, PyObject *)
     * }
     */
    public static MemorySegment _PyType_Lookup(MemorySegment x0, MemorySegment x1) {
        var mh$ = _PyType_Lookup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyType_Lookup", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyType_LookupId {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyType_LookupId");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *_PyType_LookupId(PyTypeObject *, _Py_Identifier *)
     * }
     */
    public static FunctionDescriptor _PyType_LookupId$descriptor() {
        return _PyType_LookupId.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *_PyType_LookupId(PyTypeObject *, _Py_Identifier *)
     * }
     */
    public static MethodHandle _PyType_LookupId$handle() {
        return _PyType_LookupId.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *_PyType_LookupId(PyTypeObject *, _Py_Identifier *)
     * }
     */
    public static MemorySegment _PyType_LookupId$address() {
        return _PyType_LookupId.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *_PyType_LookupId(PyTypeObject *, _Py_Identifier *)
     * }
     */
    public static MemorySegment _PyType_LookupId(MemorySegment x0, MemorySegment x1) {
        var mh$ = _PyType_LookupId.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyType_LookupId", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyObject_LookupSpecialId {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyObject_LookupSpecialId");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *_PyObject_LookupSpecialId(PyObject *, _Py_Identifier *)
     * }
     */
    public static FunctionDescriptor _PyObject_LookupSpecialId$descriptor() {
        return _PyObject_LookupSpecialId.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *_PyObject_LookupSpecialId(PyObject *, _Py_Identifier *)
     * }
     */
    public static MethodHandle _PyObject_LookupSpecialId$handle() {
        return _PyObject_LookupSpecialId.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *_PyObject_LookupSpecialId(PyObject *, _Py_Identifier *)
     * }
     */
    public static MemorySegment _PyObject_LookupSpecialId$address() {
        return _PyObject_LookupSpecialId.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *_PyObject_LookupSpecialId(PyObject *, _Py_Identifier *)
     * }
     */
    public static MemorySegment _PyObject_LookupSpecialId(MemorySegment x0, MemorySegment x1) {
        var mh$ = _PyObject_LookupSpecialId.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyObject_LookupSpecialId", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyType_CalculateMetaclass {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyType_CalculateMetaclass");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyTypeObject *_PyType_CalculateMetaclass(PyTypeObject *, PyObject *)
     * }
     */
    public static FunctionDescriptor _PyType_CalculateMetaclass$descriptor() {
        return _PyType_CalculateMetaclass.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyTypeObject *_PyType_CalculateMetaclass(PyTypeObject *, PyObject *)
     * }
     */
    public static MethodHandle _PyType_CalculateMetaclass$handle() {
        return _PyType_CalculateMetaclass.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyTypeObject *_PyType_CalculateMetaclass(PyTypeObject *, PyObject *)
     * }
     */
    public static MemorySegment _PyType_CalculateMetaclass$address() {
        return _PyType_CalculateMetaclass.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyTypeObject *_PyType_CalculateMetaclass(PyTypeObject *, PyObject *)
     * }
     */
    public static MemorySegment _PyType_CalculateMetaclass(MemorySegment x0, MemorySegment x1) {
        var mh$ = _PyType_CalculateMetaclass.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyType_CalculateMetaclass", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyType_GetDocFromInternalDoc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyType_GetDocFromInternalDoc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *_PyType_GetDocFromInternalDoc(const char *, const char *)
     * }
     */
    public static FunctionDescriptor _PyType_GetDocFromInternalDoc$descriptor() {
        return _PyType_GetDocFromInternalDoc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *_PyType_GetDocFromInternalDoc(const char *, const char *)
     * }
     */
    public static MethodHandle _PyType_GetDocFromInternalDoc$handle() {
        return _PyType_GetDocFromInternalDoc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *_PyType_GetDocFromInternalDoc(const char *, const char *)
     * }
     */
    public static MemorySegment _PyType_GetDocFromInternalDoc$address() {
        return _PyType_GetDocFromInternalDoc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *_PyType_GetDocFromInternalDoc(const char *, const char *)
     * }
     */
    public static MemorySegment _PyType_GetDocFromInternalDoc(MemorySegment x0, MemorySegment x1) {
        var mh$ = _PyType_GetDocFromInternalDoc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyType_GetDocFromInternalDoc", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyType_GetTextSignatureFromInternalDoc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyType_GetTextSignatureFromInternalDoc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *_PyType_GetTextSignatureFromInternalDoc(const char *, const char *)
     * }
     */
    public static FunctionDescriptor _PyType_GetTextSignatureFromInternalDoc$descriptor() {
        return _PyType_GetTextSignatureFromInternalDoc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *_PyType_GetTextSignatureFromInternalDoc(const char *, const char *)
     * }
     */
    public static MethodHandle _PyType_GetTextSignatureFromInternalDoc$handle() {
        return _PyType_GetTextSignatureFromInternalDoc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *_PyType_GetTextSignatureFromInternalDoc(const char *, const char *)
     * }
     */
    public static MemorySegment _PyType_GetTextSignatureFromInternalDoc$address() {
        return _PyType_GetTextSignatureFromInternalDoc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *_PyType_GetTextSignatureFromInternalDoc(const char *, const char *)
     * }
     */
    public static MemorySegment _PyType_GetTextSignatureFromInternalDoc(MemorySegment x0, MemorySegment x1) {
        var mh$ = _PyType_GetTextSignatureFromInternalDoc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyType_GetTextSignatureFromInternalDoc", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyType_GetModuleByDef {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyType_GetModuleByDef");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyType_GetModuleByDef(PyTypeObject *, PyModuleDef *)
     * }
     */
    public static FunctionDescriptor PyType_GetModuleByDef$descriptor() {
        return PyType_GetModuleByDef.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyType_GetModuleByDef(PyTypeObject *, PyModuleDef *)
     * }
     */
    public static MethodHandle PyType_GetModuleByDef$handle() {
        return PyType_GetModuleByDef.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyType_GetModuleByDef(PyTypeObject *, PyModuleDef *)
     * }
     */
    public static MemorySegment PyType_GetModuleByDef$address() {
        return PyType_GetModuleByDef.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyType_GetModuleByDef(PyTypeObject *, PyModuleDef *)
     * }
     */
    public static MemorySegment PyType_GetModuleByDef(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyType_GetModuleByDef.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyType_GetModuleByDef", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyType_GetDict {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyType_GetDict");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyType_GetDict(PyTypeObject *)
     * }
     */
    public static FunctionDescriptor PyType_GetDict$descriptor() {
        return PyType_GetDict.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyType_GetDict(PyTypeObject *)
     * }
     */
    public static MethodHandle PyType_GetDict$handle() {
        return PyType_GetDict.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyType_GetDict(PyTypeObject *)
     * }
     */
    public static MemorySegment PyType_GetDict$address() {
        return PyType_GetDict.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyType_GetDict(PyTypeObject *)
     * }
     */
    public static MemorySegment PyType_GetDict(MemorySegment x0) {
        var mh$ = PyType_GetDict.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyType_GetDict", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_Print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_Print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyObject_Print(PyObject *, FILE *, int)
     * }
     */
    public static FunctionDescriptor PyObject_Print$descriptor() {
        return PyObject_Print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyObject_Print(PyObject *, FILE *, int)
     * }
     */
    public static MethodHandle PyObject_Print$handle() {
        return PyObject_Print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyObject_Print(PyObject *, FILE *, int)
     * }
     */
    public static MemorySegment PyObject_Print$address() {
        return PyObject_Print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyObject_Print(PyObject *, FILE *, int)
     * }
     */
    public static int PyObject_Print(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = PyObject_Print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_Print", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _Py_BreakPoint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_Py_BreakPoint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _Py_BreakPoint()
     * }
     */
    public static FunctionDescriptor _Py_BreakPoint$descriptor() {
        return _Py_BreakPoint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _Py_BreakPoint()
     * }
     */
    public static MethodHandle _Py_BreakPoint$handle() {
        return _Py_BreakPoint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _Py_BreakPoint()
     * }
     */
    public static MemorySegment _Py_BreakPoint$address() {
        return _Py_BreakPoint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _Py_BreakPoint()
     * }
     */
    public static void _Py_BreakPoint() {
        var mh$ = _Py_BreakPoint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_Py_BreakPoint");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyObject_Dump {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyObject_Dump");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _PyObject_Dump(PyObject *)
     * }
     */
    public static FunctionDescriptor _PyObject_Dump$descriptor() {
        return _PyObject_Dump.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _PyObject_Dump(PyObject *)
     * }
     */
    public static MethodHandle _PyObject_Dump$handle() {
        return _PyObject_Dump.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _PyObject_Dump(PyObject *)
     * }
     */
    public static MemorySegment _PyObject_Dump$address() {
        return _PyObject_Dump.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _PyObject_Dump(PyObject *)
     * }
     */
    public static void _PyObject_Dump(MemorySegment x0) {
        var mh$ = _PyObject_Dump.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyObject_Dump", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyObject_IsFreed {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyObject_IsFreed");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyObject_IsFreed(PyObject *)
     * }
     */
    public static FunctionDescriptor _PyObject_IsFreed$descriptor() {
        return _PyObject_IsFreed.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyObject_IsFreed(PyObject *)
     * }
     */
    public static MethodHandle _PyObject_IsFreed$handle() {
        return _PyObject_IsFreed.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyObject_IsFreed(PyObject *)
     * }
     */
    public static MemorySegment _PyObject_IsFreed$address() {
        return _PyObject_IsFreed.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyObject_IsFreed(PyObject *)
     * }
     */
    public static int _PyObject_IsFreed(MemorySegment x0) {
        var mh$ = _PyObject_IsFreed.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyObject_IsFreed", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyObject_IsAbstract {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyObject_IsAbstract");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyObject_IsAbstract(PyObject *)
     * }
     */
    public static FunctionDescriptor _PyObject_IsAbstract$descriptor() {
        return _PyObject_IsAbstract.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyObject_IsAbstract(PyObject *)
     * }
     */
    public static MethodHandle _PyObject_IsAbstract$handle() {
        return _PyObject_IsAbstract.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyObject_IsAbstract(PyObject *)
     * }
     */
    public static MemorySegment _PyObject_IsAbstract$address() {
        return _PyObject_IsAbstract.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyObject_IsAbstract(PyObject *)
     * }
     */
    public static int _PyObject_IsAbstract(MemorySegment x0) {
        var mh$ = _PyObject_IsAbstract.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyObject_IsAbstract", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyObject_GetAttrId {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyObject_GetAttrId");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *_PyObject_GetAttrId(PyObject *, _Py_Identifier *)
     * }
     */
    public static FunctionDescriptor _PyObject_GetAttrId$descriptor() {
        return _PyObject_GetAttrId.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *_PyObject_GetAttrId(PyObject *, _Py_Identifier *)
     * }
     */
    public static MethodHandle _PyObject_GetAttrId$handle() {
        return _PyObject_GetAttrId.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *_PyObject_GetAttrId(PyObject *, _Py_Identifier *)
     * }
     */
    public static MemorySegment _PyObject_GetAttrId$address() {
        return _PyObject_GetAttrId.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *_PyObject_GetAttrId(PyObject *, _Py_Identifier *)
     * }
     */
    public static MemorySegment _PyObject_GetAttrId(MemorySegment x0, MemorySegment x1) {
        var mh$ = _PyObject_GetAttrId.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyObject_GetAttrId", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyObject_SetAttrId {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyObject_SetAttrId");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyObject_SetAttrId(PyObject *, _Py_Identifier *, PyObject *)
     * }
     */
    public static FunctionDescriptor _PyObject_SetAttrId$descriptor() {
        return _PyObject_SetAttrId.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyObject_SetAttrId(PyObject *, _Py_Identifier *, PyObject *)
     * }
     */
    public static MethodHandle _PyObject_SetAttrId$handle() {
        return _PyObject_SetAttrId.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyObject_SetAttrId(PyObject *, _Py_Identifier *, PyObject *)
     * }
     */
    public static MemorySegment _PyObject_SetAttrId$address() {
        return _PyObject_SetAttrId.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyObject_SetAttrId(PyObject *, _Py_Identifier *, PyObject *)
     * }
     */
    public static int _PyObject_SetAttrId(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = _PyObject_SetAttrId.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyObject_SetAttrId", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyObject_LookupAttr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyObject_LookupAttr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyObject_LookupAttr(PyObject *, PyObject *, PyObject **)
     * }
     */
    public static FunctionDescriptor _PyObject_LookupAttr$descriptor() {
        return _PyObject_LookupAttr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyObject_LookupAttr(PyObject *, PyObject *, PyObject **)
     * }
     */
    public static MethodHandle _PyObject_LookupAttr$handle() {
        return _PyObject_LookupAttr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyObject_LookupAttr(PyObject *, PyObject *, PyObject **)
     * }
     */
    public static MemorySegment _PyObject_LookupAttr$address() {
        return _PyObject_LookupAttr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyObject_LookupAttr(PyObject *, PyObject *, PyObject **)
     * }
     */
    public static int _PyObject_LookupAttr(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = _PyObject_LookupAttr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyObject_LookupAttr", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyObject_LookupAttrId {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyObject_LookupAttrId");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyObject_LookupAttrId(PyObject *, _Py_Identifier *, PyObject **)
     * }
     */
    public static FunctionDescriptor _PyObject_LookupAttrId$descriptor() {
        return _PyObject_LookupAttrId.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyObject_LookupAttrId(PyObject *, _Py_Identifier *, PyObject **)
     * }
     */
    public static MethodHandle _PyObject_LookupAttrId$handle() {
        return _PyObject_LookupAttrId.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyObject_LookupAttrId(PyObject *, _Py_Identifier *, PyObject **)
     * }
     */
    public static MemorySegment _PyObject_LookupAttrId$address() {
        return _PyObject_LookupAttrId.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyObject_LookupAttrId(PyObject *, _Py_Identifier *, PyObject **)
     * }
     */
    public static int _PyObject_LookupAttrId(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = _PyObject_LookupAttrId.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyObject_LookupAttrId", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyObject_GetMethod {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyObject_GetMethod");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyObject_GetMethod(PyObject *obj, PyObject *name, PyObject **method)
     * }
     */
    public static FunctionDescriptor _PyObject_GetMethod$descriptor() {
        return _PyObject_GetMethod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyObject_GetMethod(PyObject *obj, PyObject *name, PyObject **method)
     * }
     */
    public static MethodHandle _PyObject_GetMethod$handle() {
        return _PyObject_GetMethod.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyObject_GetMethod(PyObject *obj, PyObject *name, PyObject **method)
     * }
     */
    public static MemorySegment _PyObject_GetMethod$address() {
        return _PyObject_GetMethod.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyObject_GetMethod(PyObject *obj, PyObject *name, PyObject **method)
     * }
     */
    public static int _PyObject_GetMethod(MemorySegment obj, MemorySegment name, MemorySegment method) {
        var mh$ = _PyObject_GetMethod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyObject_GetMethod", obj, name, method);
            }
            return (int)mh$.invokeExact(obj, name, method);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyObject_GetDictPtr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyObject_GetDictPtr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject **_PyObject_GetDictPtr(PyObject *)
     * }
     */
    public static FunctionDescriptor _PyObject_GetDictPtr$descriptor() {
        return _PyObject_GetDictPtr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject **_PyObject_GetDictPtr(PyObject *)
     * }
     */
    public static MethodHandle _PyObject_GetDictPtr$handle() {
        return _PyObject_GetDictPtr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject **_PyObject_GetDictPtr(PyObject *)
     * }
     */
    public static MemorySegment _PyObject_GetDictPtr$address() {
        return _PyObject_GetDictPtr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject **_PyObject_GetDictPtr(PyObject *)
     * }
     */
    public static MemorySegment _PyObject_GetDictPtr(MemorySegment x0) {
        var mh$ = _PyObject_GetDictPtr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyObject_GetDictPtr", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyObject_NextNotImplemented {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyObject_NextNotImplemented");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *_PyObject_NextNotImplemented(PyObject *)
     * }
     */
    public static FunctionDescriptor _PyObject_NextNotImplemented$descriptor() {
        return _PyObject_NextNotImplemented.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *_PyObject_NextNotImplemented(PyObject *)
     * }
     */
    public static MethodHandle _PyObject_NextNotImplemented$handle() {
        return _PyObject_NextNotImplemented.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *_PyObject_NextNotImplemented(PyObject *)
     * }
     */
    public static MemorySegment _PyObject_NextNotImplemented$address() {
        return _PyObject_NextNotImplemented.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *_PyObject_NextNotImplemented(PyObject *)
     * }
     */
    public static MemorySegment _PyObject_NextNotImplemented(MemorySegment x0) {
        var mh$ = _PyObject_NextNotImplemented.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyObject_NextNotImplemented", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_CallFinalizer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_CallFinalizer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyObject_CallFinalizer(PyObject *)
     * }
     */
    public static FunctionDescriptor PyObject_CallFinalizer$descriptor() {
        return PyObject_CallFinalizer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyObject_CallFinalizer(PyObject *)
     * }
     */
    public static MethodHandle PyObject_CallFinalizer$handle() {
        return PyObject_CallFinalizer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyObject_CallFinalizer(PyObject *)
     * }
     */
    public static MemorySegment PyObject_CallFinalizer$address() {
        return PyObject_CallFinalizer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyObject_CallFinalizer(PyObject *)
     * }
     */
    public static void PyObject_CallFinalizer(MemorySegment x0) {
        var mh$ = PyObject_CallFinalizer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_CallFinalizer", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_CallFinalizerFromDealloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_CallFinalizerFromDealloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyObject_CallFinalizerFromDealloc(PyObject *)
     * }
     */
    public static FunctionDescriptor PyObject_CallFinalizerFromDealloc$descriptor() {
        return PyObject_CallFinalizerFromDealloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyObject_CallFinalizerFromDealloc(PyObject *)
     * }
     */
    public static MethodHandle PyObject_CallFinalizerFromDealloc$handle() {
        return PyObject_CallFinalizerFromDealloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyObject_CallFinalizerFromDealloc(PyObject *)
     * }
     */
    public static MemorySegment PyObject_CallFinalizerFromDealloc$address() {
        return PyObject_CallFinalizerFromDealloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyObject_CallFinalizerFromDealloc(PyObject *)
     * }
     */
    public static int PyObject_CallFinalizerFromDealloc(MemorySegment x0) {
        var mh$ = PyObject_CallFinalizerFromDealloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_CallFinalizerFromDealloc", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyObject_GenericGetAttrWithDict {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyObject_GenericGetAttrWithDict");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *_PyObject_GenericGetAttrWithDict(PyObject *, PyObject *, PyObject *, int)
     * }
     */
    public static FunctionDescriptor _PyObject_GenericGetAttrWithDict$descriptor() {
        return _PyObject_GenericGetAttrWithDict.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *_PyObject_GenericGetAttrWithDict(PyObject *, PyObject *, PyObject *, int)
     * }
     */
    public static MethodHandle _PyObject_GenericGetAttrWithDict$handle() {
        return _PyObject_GenericGetAttrWithDict.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *_PyObject_GenericGetAttrWithDict(PyObject *, PyObject *, PyObject *, int)
     * }
     */
    public static MemorySegment _PyObject_GenericGetAttrWithDict$address() {
        return _PyObject_GenericGetAttrWithDict.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *_PyObject_GenericGetAttrWithDict(PyObject *, PyObject *, PyObject *, int)
     * }
     */
    public static MemorySegment _PyObject_GenericGetAttrWithDict(MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3) {
        var mh$ = _PyObject_GenericGetAttrWithDict.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyObject_GenericGetAttrWithDict", x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyObject_GenericSetAttrWithDict {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyObject_GenericSetAttrWithDict");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyObject_GenericSetAttrWithDict(PyObject *, PyObject *, PyObject *, PyObject *)
     * }
     */
    public static FunctionDescriptor _PyObject_GenericSetAttrWithDict$descriptor() {
        return _PyObject_GenericSetAttrWithDict.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyObject_GenericSetAttrWithDict(PyObject *, PyObject *, PyObject *, PyObject *)
     * }
     */
    public static MethodHandle _PyObject_GenericSetAttrWithDict$handle() {
        return _PyObject_GenericSetAttrWithDict.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyObject_GenericSetAttrWithDict(PyObject *, PyObject *, PyObject *, PyObject *)
     * }
     */
    public static MemorySegment _PyObject_GenericSetAttrWithDict$address() {
        return _PyObject_GenericSetAttrWithDict.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyObject_GenericSetAttrWithDict(PyObject *, PyObject *, PyObject *, PyObject *)
     * }
     */
    public static int _PyObject_GenericSetAttrWithDict(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = _PyObject_GenericSetAttrWithDict.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyObject_GenericSetAttrWithDict", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyObject_FunctionStr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyObject_FunctionStr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *_PyObject_FunctionStr(PyObject *)
     * }
     */
    public static FunctionDescriptor _PyObject_FunctionStr$descriptor() {
        return _PyObject_FunctionStr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *_PyObject_FunctionStr(PyObject *)
     * }
     */
    public static MethodHandle _PyObject_FunctionStr$handle() {
        return _PyObject_FunctionStr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *_PyObject_FunctionStr(PyObject *)
     * }
     */
    public static MemorySegment _PyObject_FunctionStr$address() {
        return _PyObject_FunctionStr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *_PyObject_FunctionStr(PyObject *)
     * }
     */
    public static MemorySegment _PyObject_FunctionStr(MemorySegment x0) {
        var mh$ = _PyObject_FunctionStr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyObject_FunctionStr", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyNone_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("_PyNone_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject _PyNone_Type
     * }
     */
    public static GroupLayout _PyNone_Type$layout() {
        return _PyNone_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject _PyNone_Type
     * }
     */
    public static MemorySegment _PyNone_Type() {
        return _PyNone_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject _PyNone_Type
     * }
     */
    public static void _PyNone_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, _PyNone_Type$constants.SEGMENT, 0L, _PyNone_Type$constants.LAYOUT.byteSize());
    }

    private static class _PyNotImplemented_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("_PyNotImplemented_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject _PyNotImplemented_Type
     * }
     */
    public static GroupLayout _PyNotImplemented_Type$layout() {
        return _PyNotImplemented_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject _PyNotImplemented_Type
     * }
     */
    public static MemorySegment _PyNotImplemented_Type() {
        return _PyNotImplemented_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject _PyNotImplemented_Type
     * }
     */
    public static void _PyNotImplemented_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, _PyNotImplemented_Type$constants.SEGMENT, 0L, _PyNotImplemented_Type$constants.LAYOUT.byteSize());
    }

    private static class _Py_SwappedOp$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(0, Python_h.C_INT);
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("_Py_SwappedOp").reinterpret(LAYOUT.byteSize());
        public static final VarHandle HANDLE = LAYOUT.varHandle();

        public static final long[] DIMS = {  };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int _Py_SwappedOp[]
     * }
     */
    public static SequenceLayout _Py_SwappedOp$layout() {
        return _Py_SwappedOp$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern int _Py_SwappedOp[]
     * }
     */
    public static long[] _Py_SwappedOp$dimensions() {
        return _Py_SwappedOp$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int _Py_SwappedOp[]
     * }
     */
    public static MemorySegment _Py_SwappedOp() {
        return _Py_SwappedOp$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int _Py_SwappedOp[]
     * }
     */
    public static void _Py_SwappedOp(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, _Py_SwappedOp$constants.SEGMENT, 0L, _Py_SwappedOp$constants.LAYOUT.byteSize());
    }

    private static class _PyDebugAllocatorStats {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyDebugAllocatorStats");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _PyDebugAllocatorStats(FILE *out, const char *block_name, int num_blocks, size_t sizeof_block)
     * }
     */
    public static FunctionDescriptor _PyDebugAllocatorStats$descriptor() {
        return _PyDebugAllocatorStats.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _PyDebugAllocatorStats(FILE *out, const char *block_name, int num_blocks, size_t sizeof_block)
     * }
     */
    public static MethodHandle _PyDebugAllocatorStats$handle() {
        return _PyDebugAllocatorStats.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _PyDebugAllocatorStats(FILE *out, const char *block_name, int num_blocks, size_t sizeof_block)
     * }
     */
    public static MemorySegment _PyDebugAllocatorStats$address() {
        return _PyDebugAllocatorStats.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _PyDebugAllocatorStats(FILE *out, const char *block_name, int num_blocks, size_t sizeof_block)
     * }
     */
    public static void _PyDebugAllocatorStats(MemorySegment out, MemorySegment block_name, int num_blocks, long sizeof_block) {
        var mh$ = _PyDebugAllocatorStats.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyDebugAllocatorStats", out, block_name, num_blocks, sizeof_block);
            }
            mh$.invokeExact(out, block_name, num_blocks, sizeof_block);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyObject_DebugTypeStats {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyObject_DebugTypeStats");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _PyObject_DebugTypeStats(FILE *out)
     * }
     */
    public static FunctionDescriptor _PyObject_DebugTypeStats$descriptor() {
        return _PyObject_DebugTypeStats.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _PyObject_DebugTypeStats(FILE *out)
     * }
     */
    public static MethodHandle _PyObject_DebugTypeStats$handle() {
        return _PyObject_DebugTypeStats.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _PyObject_DebugTypeStats(FILE *out)
     * }
     */
    public static MemorySegment _PyObject_DebugTypeStats$address() {
        return _PyObject_DebugTypeStats.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _PyObject_DebugTypeStats(FILE *out)
     * }
     */
    public static void _PyObject_DebugTypeStats(MemorySegment out) {
        var mh$ = _PyObject_DebugTypeStats.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyObject_DebugTypeStats", out);
            }
            mh$.invokeExact(out);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyObject_AssertFailed {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyObject_AssertFailed");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _PyObject_AssertFailed(PyObject *obj, const char *expr, const char *msg, const char *file, int line, const char *function)
     * }
     */
    public static FunctionDescriptor _PyObject_AssertFailed$descriptor() {
        return _PyObject_AssertFailed.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _PyObject_AssertFailed(PyObject *obj, const char *expr, const char *msg, const char *file, int line, const char *function)
     * }
     */
    public static MethodHandle _PyObject_AssertFailed$handle() {
        return _PyObject_AssertFailed.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _PyObject_AssertFailed(PyObject *obj, const char *expr, const char *msg, const char *file, int line, const char *function)
     * }
     */
    public static MemorySegment _PyObject_AssertFailed$address() {
        return _PyObject_AssertFailed.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _PyObject_AssertFailed(PyObject *obj, const char *expr, const char *msg, const char *file, int line, const char *function)
     * }
     */
    public static void _PyObject_AssertFailed(MemorySegment obj, MemorySegment expr, MemorySegment msg, MemorySegment file, int line, MemorySegment function) {
        var mh$ = _PyObject_AssertFailed.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyObject_AssertFailed", obj, expr, msg, file, line, function);
            }
            mh$.invokeExact(obj, expr, msg, file, line, function);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyObject_CheckConsistency {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyObject_CheckConsistency");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyObject_CheckConsistency(PyObject *op, int check_content)
     * }
     */
    public static FunctionDescriptor _PyObject_CheckConsistency$descriptor() {
        return _PyObject_CheckConsistency.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyObject_CheckConsistency(PyObject *op, int check_content)
     * }
     */
    public static MethodHandle _PyObject_CheckConsistency$handle() {
        return _PyObject_CheckConsistency.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyObject_CheckConsistency(PyObject *op, int check_content)
     * }
     */
    public static MemorySegment _PyObject_CheckConsistency$address() {
        return _PyObject_CheckConsistency.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyObject_CheckConsistency(PyObject *op, int check_content)
     * }
     */
    public static int _PyObject_CheckConsistency(MemorySegment op, int check_content) {
        var mh$ = _PyObject_CheckConsistency.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyObject_CheckConsistency", op, check_content);
            }
            return (int)mh$.invokeExact(op, check_content);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyTrash_begin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyTrash_begin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyTrash_begin(PyThreadState *tstate, PyObject *op)
     * }
     */
    public static FunctionDescriptor _PyTrash_begin$descriptor() {
        return _PyTrash_begin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyTrash_begin(PyThreadState *tstate, PyObject *op)
     * }
     */
    public static MethodHandle _PyTrash_begin$handle() {
        return _PyTrash_begin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyTrash_begin(PyThreadState *tstate, PyObject *op)
     * }
     */
    public static MemorySegment _PyTrash_begin$address() {
        return _PyTrash_begin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyTrash_begin(PyThreadState *tstate, PyObject *op)
     * }
     */
    public static int _PyTrash_begin(MemorySegment tstate, MemorySegment op) {
        var mh$ = _PyTrash_begin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyTrash_begin", tstate, op);
            }
            return (int)mh$.invokeExact(tstate, op);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyTrash_end {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyTrash_end");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _PyTrash_end(PyThreadState *tstate)
     * }
     */
    public static FunctionDescriptor _PyTrash_end$descriptor() {
        return _PyTrash_end.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _PyTrash_end(PyThreadState *tstate)
     * }
     */
    public static MethodHandle _PyTrash_end$handle() {
        return _PyTrash_end.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _PyTrash_end(PyThreadState *tstate)
     * }
     */
    public static MemorySegment _PyTrash_end$address() {
        return _PyTrash_end.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _PyTrash_end(PyThreadState *tstate)
     * }
     */
    public static void _PyTrash_end(MemorySegment tstate) {
        var mh$ = _PyTrash_end.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyTrash_end", tstate);
            }
            mh$.invokeExact(tstate);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyTrash_cond {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyTrash_cond");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyTrash_cond(PyObject *op, destructor dealloc)
     * }
     */
    public static FunctionDescriptor _PyTrash_cond$descriptor() {
        return _PyTrash_cond.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyTrash_cond(PyObject *op, destructor dealloc)
     * }
     */
    public static MethodHandle _PyTrash_cond$handle() {
        return _PyTrash_cond.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyTrash_cond(PyObject *op, destructor dealloc)
     * }
     */
    public static MemorySegment _PyTrash_cond$address() {
        return _PyTrash_cond.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyTrash_cond(PyObject *op, destructor dealloc)
     * }
     */
    public static int _PyTrash_cond(MemorySegment op, MemorySegment dealloc) {
        var mh$ = _PyTrash_cond.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyTrash_cond", op, dealloc);
            }
            return (int)mh$.invokeExact(op, dealloc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef int UsingDeprecatedTrashcanMacro
     * }
     */
    public static final OfInt UsingDeprecatedTrashcanMacro = Python_h.C_INT;

    private static class PyObject_GetItemData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_GetItemData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *PyObject_GetItemData(PyObject *obj)
     * }
     */
    public static FunctionDescriptor PyObject_GetItemData$descriptor() {
        return PyObject_GetItemData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *PyObject_GetItemData(PyObject *obj)
     * }
     */
    public static MethodHandle PyObject_GetItemData$handle() {
        return PyObject_GetItemData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *PyObject_GetItemData(PyObject *obj)
     * }
     */
    public static MemorySegment PyObject_GetItemData$address() {
        return PyObject_GetItemData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *PyObject_GetItemData(PyObject *obj)
     * }
     */
    public static MemorySegment PyObject_GetItemData(MemorySegment obj) {
        var mh$ = PyObject_GetItemData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_GetItemData", obj);
            }
            return (MemorySegment)mh$.invokeExact(obj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyObject_VisitManagedDict {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyObject_VisitManagedDict");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyObject_VisitManagedDict(PyObject *obj, visitproc visit, void *arg)
     * }
     */
    public static FunctionDescriptor _PyObject_VisitManagedDict$descriptor() {
        return _PyObject_VisitManagedDict.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyObject_VisitManagedDict(PyObject *obj, visitproc visit, void *arg)
     * }
     */
    public static MethodHandle _PyObject_VisitManagedDict$handle() {
        return _PyObject_VisitManagedDict.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyObject_VisitManagedDict(PyObject *obj, visitproc visit, void *arg)
     * }
     */
    public static MemorySegment _PyObject_VisitManagedDict$address() {
        return _PyObject_VisitManagedDict.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyObject_VisitManagedDict(PyObject *obj, visitproc visit, void *arg)
     * }
     */
    public static int _PyObject_VisitManagedDict(MemorySegment obj, MemorySegment visit, MemorySegment arg) {
        var mh$ = _PyObject_VisitManagedDict.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyObject_VisitManagedDict", obj, visit, arg);
            }
            return (int)mh$.invokeExact(obj, visit, arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyObject_ClearManagedDict {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyObject_ClearManagedDict");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _PyObject_ClearManagedDict(PyObject *obj)
     * }
     */
    public static FunctionDescriptor _PyObject_ClearManagedDict$descriptor() {
        return _PyObject_ClearManagedDict.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _PyObject_ClearManagedDict(PyObject *obj)
     * }
     */
    public static MethodHandle _PyObject_ClearManagedDict$handle() {
        return _PyObject_ClearManagedDict.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _PyObject_ClearManagedDict(PyObject *obj)
     * }
     */
    public static MemorySegment _PyObject_ClearManagedDict$address() {
        return _PyObject_ClearManagedDict.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _PyObject_ClearManagedDict(PyObject *obj)
     * }
     */
    public static void _PyObject_ClearManagedDict(MemorySegment obj) {
        var mh$ = _PyObject_ClearManagedDict.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyObject_ClearManagedDict", obj);
            }
            mh$.invokeExact(obj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyType_AddWatcher {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyType_AddWatcher");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyType_AddWatcher(PyType_WatchCallback callback)
     * }
     */
    public static FunctionDescriptor PyType_AddWatcher$descriptor() {
        return PyType_AddWatcher.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyType_AddWatcher(PyType_WatchCallback callback)
     * }
     */
    public static MethodHandle PyType_AddWatcher$handle() {
        return PyType_AddWatcher.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyType_AddWatcher(PyType_WatchCallback callback)
     * }
     */
    public static MemorySegment PyType_AddWatcher$address() {
        return PyType_AddWatcher.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyType_AddWatcher(PyType_WatchCallback callback)
     * }
     */
    public static int PyType_AddWatcher(MemorySegment callback) {
        var mh$ = PyType_AddWatcher.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyType_AddWatcher", callback);
            }
            return (int)mh$.invokeExact(callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyType_ClearWatcher {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyType_ClearWatcher");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyType_ClearWatcher(int watcher_id)
     * }
     */
    public static FunctionDescriptor PyType_ClearWatcher$descriptor() {
        return PyType_ClearWatcher.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyType_ClearWatcher(int watcher_id)
     * }
     */
    public static MethodHandle PyType_ClearWatcher$handle() {
        return PyType_ClearWatcher.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyType_ClearWatcher(int watcher_id)
     * }
     */
    public static MemorySegment PyType_ClearWatcher$address() {
        return PyType_ClearWatcher.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyType_ClearWatcher(int watcher_id)
     * }
     */
    public static int PyType_ClearWatcher(int watcher_id) {
        var mh$ = PyType_ClearWatcher.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyType_ClearWatcher", watcher_id);
            }
            return (int)mh$.invokeExact(watcher_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyType_Watch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyType_Watch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyType_Watch(int watcher_id, PyObject *type)
     * }
     */
    public static FunctionDescriptor PyType_Watch$descriptor() {
        return PyType_Watch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyType_Watch(int watcher_id, PyObject *type)
     * }
     */
    public static MethodHandle PyType_Watch$handle() {
        return PyType_Watch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyType_Watch(int watcher_id, PyObject *type)
     * }
     */
    public static MemorySegment PyType_Watch$address() {
        return PyType_Watch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyType_Watch(int watcher_id, PyObject *type)
     * }
     */
    public static int PyType_Watch(int watcher_id, MemorySegment type) {
        var mh$ = PyType_Watch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyType_Watch", watcher_id, type);
            }
            return (int)mh$.invokeExact(watcher_id, type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyType_Unwatch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyType_Unwatch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyType_Unwatch(int watcher_id, PyObject *type)
     * }
     */
    public static FunctionDescriptor PyType_Unwatch$descriptor() {
        return PyType_Unwatch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyType_Unwatch(int watcher_id, PyObject *type)
     * }
     */
    public static MethodHandle PyType_Unwatch$handle() {
        return PyType_Unwatch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyType_Unwatch(int watcher_id, PyObject *type)
     * }
     */
    public static MemorySegment PyType_Unwatch$address() {
        return PyType_Unwatch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyType_Unwatch(int watcher_id, PyObject *type)
     * }
     */
    public static int PyType_Unwatch(int watcher_id, MemorySegment type) {
        var mh$ = PyType_Unwatch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyType_Unwatch", watcher_id, type);
            }
            return (int)mh$.invokeExact(watcher_id, type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnstable_Type_AssignVersionTag {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnstable_Type_AssignVersionTag");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyUnstable_Type_AssignVersionTag(PyTypeObject *type)
     * }
     */
    public static FunctionDescriptor PyUnstable_Type_AssignVersionTag$descriptor() {
        return PyUnstable_Type_AssignVersionTag.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyUnstable_Type_AssignVersionTag(PyTypeObject *type)
     * }
     */
    public static MethodHandle PyUnstable_Type_AssignVersionTag$handle() {
        return PyUnstable_Type_AssignVersionTag.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyUnstable_Type_AssignVersionTag(PyTypeObject *type)
     * }
     */
    public static MemorySegment PyUnstable_Type_AssignVersionTag$address() {
        return PyUnstable_Type_AssignVersionTag.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyUnstable_Type_AssignVersionTag(PyTypeObject *type)
     * }
     */
    public static int PyUnstable_Type_AssignVersionTag(MemorySegment type) {
        var mh$ = PyUnstable_Type_AssignVersionTag.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnstable_Type_AssignVersionTag", type);
            }
            return (int)mh$.invokeExact(type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_Malloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_Malloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *PyObject_Malloc(size_t size)
     * }
     */
    public static FunctionDescriptor PyObject_Malloc$descriptor() {
        return PyObject_Malloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *PyObject_Malloc(size_t size)
     * }
     */
    public static MethodHandle PyObject_Malloc$handle() {
        return PyObject_Malloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *PyObject_Malloc(size_t size)
     * }
     */
    public static MemorySegment PyObject_Malloc$address() {
        return PyObject_Malloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *PyObject_Malloc(size_t size)
     * }
     */
    public static MemorySegment PyObject_Malloc(long size) {
        var mh$ = PyObject_Malloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_Malloc", size);
            }
            return (MemorySegment)mh$.invokeExact(size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_Calloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_Calloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *PyObject_Calloc(size_t nelem, size_t elsize)
     * }
     */
    public static FunctionDescriptor PyObject_Calloc$descriptor() {
        return PyObject_Calloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *PyObject_Calloc(size_t nelem, size_t elsize)
     * }
     */
    public static MethodHandle PyObject_Calloc$handle() {
        return PyObject_Calloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *PyObject_Calloc(size_t nelem, size_t elsize)
     * }
     */
    public static MemorySegment PyObject_Calloc$address() {
        return PyObject_Calloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *PyObject_Calloc(size_t nelem, size_t elsize)
     * }
     */
    public static MemorySegment PyObject_Calloc(long nelem, long elsize) {
        var mh$ = PyObject_Calloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_Calloc", nelem, elsize);
            }
            return (MemorySegment)mh$.invokeExact(nelem, elsize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_Realloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_Realloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *PyObject_Realloc(void *ptr, size_t new_size)
     * }
     */
    public static FunctionDescriptor PyObject_Realloc$descriptor() {
        return PyObject_Realloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *PyObject_Realloc(void *ptr, size_t new_size)
     * }
     */
    public static MethodHandle PyObject_Realloc$handle() {
        return PyObject_Realloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *PyObject_Realloc(void *ptr, size_t new_size)
     * }
     */
    public static MemorySegment PyObject_Realloc$address() {
        return PyObject_Realloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *PyObject_Realloc(void *ptr, size_t new_size)
     * }
     */
    public static MemorySegment PyObject_Realloc(MemorySegment ptr, long new_size) {
        var mh$ = PyObject_Realloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_Realloc", ptr, new_size);
            }
            return (MemorySegment)mh$.invokeExact(ptr, new_size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_Free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_Free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyObject_Free(void *ptr)
     * }
     */
    public static FunctionDescriptor PyObject_Free$descriptor() {
        return PyObject_Free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyObject_Free(void *ptr)
     * }
     */
    public static MethodHandle PyObject_Free$handle() {
        return PyObject_Free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyObject_Free(void *ptr)
     * }
     */
    public static MemorySegment PyObject_Free$address() {
        return PyObject_Free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyObject_Free(void *ptr)
     * }
     */
    public static void PyObject_Free(MemorySegment ptr) {
        var mh$ = PyObject_Free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_Free", ptr);
            }
            mh$.invokeExact(ptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_Init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_Init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyObject_Init(PyObject *, PyTypeObject *)
     * }
     */
    public static FunctionDescriptor PyObject_Init$descriptor() {
        return PyObject_Init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyObject_Init(PyObject *, PyTypeObject *)
     * }
     */
    public static MethodHandle PyObject_Init$handle() {
        return PyObject_Init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyObject_Init(PyObject *, PyTypeObject *)
     * }
     */
    public static MemorySegment PyObject_Init$address() {
        return PyObject_Init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyObject_Init(PyObject *, PyTypeObject *)
     * }
     */
    public static MemorySegment PyObject_Init(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyObject_Init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_Init", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_InitVar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_InitVar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyVarObject *PyObject_InitVar(PyVarObject *, PyTypeObject *, Py_ssize_t)
     * }
     */
    public static FunctionDescriptor PyObject_InitVar$descriptor() {
        return PyObject_InitVar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyVarObject *PyObject_InitVar(PyVarObject *, PyTypeObject *, Py_ssize_t)
     * }
     */
    public static MethodHandle PyObject_InitVar$handle() {
        return PyObject_InitVar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyVarObject *PyObject_InitVar(PyVarObject *, PyTypeObject *, Py_ssize_t)
     * }
     */
    public static MemorySegment PyObject_InitVar$address() {
        return PyObject_InitVar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyVarObject *PyObject_InitVar(PyVarObject *, PyTypeObject *, Py_ssize_t)
     * }
     */
    public static MemorySegment PyObject_InitVar(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = PyObject_InitVar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_InitVar", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyObject_New {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyObject_New");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *_PyObject_New(PyTypeObject *)
     * }
     */
    public static FunctionDescriptor _PyObject_New$descriptor() {
        return _PyObject_New.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *_PyObject_New(PyTypeObject *)
     * }
     */
    public static MethodHandle _PyObject_New$handle() {
        return _PyObject_New.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *_PyObject_New(PyTypeObject *)
     * }
     */
    public static MemorySegment _PyObject_New$address() {
        return _PyObject_New.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *_PyObject_New(PyTypeObject *)
     * }
     */
    public static MemorySegment _PyObject_New(MemorySegment x0) {
        var mh$ = _PyObject_New.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyObject_New", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyObject_NewVar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyObject_NewVar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyVarObject *_PyObject_NewVar(PyTypeObject *, Py_ssize_t)
     * }
     */
    public static FunctionDescriptor _PyObject_NewVar$descriptor() {
        return _PyObject_NewVar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyVarObject *_PyObject_NewVar(PyTypeObject *, Py_ssize_t)
     * }
     */
    public static MethodHandle _PyObject_NewVar$handle() {
        return _PyObject_NewVar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyVarObject *_PyObject_NewVar(PyTypeObject *, Py_ssize_t)
     * }
     */
    public static MemorySegment _PyObject_NewVar$address() {
        return _PyObject_NewVar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyVarObject *_PyObject_NewVar(PyTypeObject *, Py_ssize_t)
     * }
     */
    public static MemorySegment _PyObject_NewVar(MemorySegment x0, long x1) {
        var mh$ = _PyObject_NewVar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyObject_NewVar", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyGC_Collect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyGC_Collect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_ssize_t PyGC_Collect()
     * }
     */
    public static FunctionDescriptor PyGC_Collect$descriptor() {
        return PyGC_Collect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_ssize_t PyGC_Collect()
     * }
     */
    public static MethodHandle PyGC_Collect$handle() {
        return PyGC_Collect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_ssize_t PyGC_Collect()
     * }
     */
    public static MemorySegment PyGC_Collect$address() {
        return PyGC_Collect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_ssize_t PyGC_Collect()
     * }
     */
    public static long PyGC_Collect() {
        var mh$ = PyGC_Collect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyGC_Collect");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyGC_Enable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyGC_Enable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyGC_Enable()
     * }
     */
    public static FunctionDescriptor PyGC_Enable$descriptor() {
        return PyGC_Enable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyGC_Enable()
     * }
     */
    public static MethodHandle PyGC_Enable$handle() {
        return PyGC_Enable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyGC_Enable()
     * }
     */
    public static MemorySegment PyGC_Enable$address() {
        return PyGC_Enable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyGC_Enable()
     * }
     */
    public static int PyGC_Enable() {
        var mh$ = PyGC_Enable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyGC_Enable");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyGC_Disable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyGC_Disable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyGC_Disable()
     * }
     */
    public static FunctionDescriptor PyGC_Disable$descriptor() {
        return PyGC_Disable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyGC_Disable()
     * }
     */
    public static MethodHandle PyGC_Disable$handle() {
        return PyGC_Disable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyGC_Disable()
     * }
     */
    public static MemorySegment PyGC_Disable$address() {
        return PyGC_Disable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyGC_Disable()
     * }
     */
    public static int PyGC_Disable() {
        var mh$ = PyGC_Disable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyGC_Disable");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyGC_IsEnabled {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyGC_IsEnabled");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyGC_IsEnabled()
     * }
     */
    public static FunctionDescriptor PyGC_IsEnabled$descriptor() {
        return PyGC_IsEnabled.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyGC_IsEnabled()
     * }
     */
    public static MethodHandle PyGC_IsEnabled$handle() {
        return PyGC_IsEnabled.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyGC_IsEnabled()
     * }
     */
    public static MemorySegment PyGC_IsEnabled$address() {
        return PyGC_IsEnabled.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyGC_IsEnabled()
     * }
     */
    public static int PyGC_IsEnabled() {
        var mh$ = PyGC_IsEnabled.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyGC_IsEnabled");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnstable_GC_VisitObjects {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnstable_GC_VisitObjects");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyUnstable_GC_VisitObjects(gcvisitobjects_t callback, void *arg)
     * }
     */
    public static FunctionDescriptor PyUnstable_GC_VisitObjects$descriptor() {
        return PyUnstable_GC_VisitObjects.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyUnstable_GC_VisitObjects(gcvisitobjects_t callback, void *arg)
     * }
     */
    public static MethodHandle PyUnstable_GC_VisitObjects$handle() {
        return PyUnstable_GC_VisitObjects.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyUnstable_GC_VisitObjects(gcvisitobjects_t callback, void *arg)
     * }
     */
    public static MemorySegment PyUnstable_GC_VisitObjects$address() {
        return PyUnstable_GC_VisitObjects.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyUnstable_GC_VisitObjects(gcvisitobjects_t callback, void *arg)
     * }
     */
    public static void PyUnstable_GC_VisitObjects(MemorySegment callback, MemorySegment arg) {
        var mh$ = PyUnstable_GC_VisitObjects.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnstable_GC_VisitObjects", callback, arg);
            }
            mh$.invokeExact(callback, arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyObject_GC_Resize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyObject_GC_Resize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyVarObject *_PyObject_GC_Resize(PyVarObject *, Py_ssize_t)
     * }
     */
    public static FunctionDescriptor _PyObject_GC_Resize$descriptor() {
        return _PyObject_GC_Resize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyVarObject *_PyObject_GC_Resize(PyVarObject *, Py_ssize_t)
     * }
     */
    public static MethodHandle _PyObject_GC_Resize$handle() {
        return _PyObject_GC_Resize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyVarObject *_PyObject_GC_Resize(PyVarObject *, Py_ssize_t)
     * }
     */
    public static MemorySegment _PyObject_GC_Resize$address() {
        return _PyObject_GC_Resize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyVarObject *_PyObject_GC_Resize(PyVarObject *, Py_ssize_t)
     * }
     */
    public static MemorySegment _PyObject_GC_Resize(MemorySegment x0, long x1) {
        var mh$ = _PyObject_GC_Resize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyObject_GC_Resize", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyObject_GC_New {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyObject_GC_New");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *_PyObject_GC_New(PyTypeObject *)
     * }
     */
    public static FunctionDescriptor _PyObject_GC_New$descriptor() {
        return _PyObject_GC_New.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *_PyObject_GC_New(PyTypeObject *)
     * }
     */
    public static MethodHandle _PyObject_GC_New$handle() {
        return _PyObject_GC_New.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *_PyObject_GC_New(PyTypeObject *)
     * }
     */
    public static MemorySegment _PyObject_GC_New$address() {
        return _PyObject_GC_New.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *_PyObject_GC_New(PyTypeObject *)
     * }
     */
    public static MemorySegment _PyObject_GC_New(MemorySegment x0) {
        var mh$ = _PyObject_GC_New.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyObject_GC_New", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyObject_GC_NewVar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyObject_GC_NewVar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyVarObject *_PyObject_GC_NewVar(PyTypeObject *, Py_ssize_t)
     * }
     */
    public static FunctionDescriptor _PyObject_GC_NewVar$descriptor() {
        return _PyObject_GC_NewVar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyVarObject *_PyObject_GC_NewVar(PyTypeObject *, Py_ssize_t)
     * }
     */
    public static MethodHandle _PyObject_GC_NewVar$handle() {
        return _PyObject_GC_NewVar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyVarObject *_PyObject_GC_NewVar(PyTypeObject *, Py_ssize_t)
     * }
     */
    public static MemorySegment _PyObject_GC_NewVar$address() {
        return _PyObject_GC_NewVar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyVarObject *_PyObject_GC_NewVar(PyTypeObject *, Py_ssize_t)
     * }
     */
    public static MemorySegment _PyObject_GC_NewVar(MemorySegment x0, long x1) {
        var mh$ = _PyObject_GC_NewVar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyObject_GC_NewVar", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_GC_Track {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_GC_Track");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyObject_GC_Track(void *)
     * }
     */
    public static FunctionDescriptor PyObject_GC_Track$descriptor() {
        return PyObject_GC_Track.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyObject_GC_Track(void *)
     * }
     */
    public static MethodHandle PyObject_GC_Track$handle() {
        return PyObject_GC_Track.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyObject_GC_Track(void *)
     * }
     */
    public static MemorySegment PyObject_GC_Track$address() {
        return PyObject_GC_Track.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyObject_GC_Track(void *)
     * }
     */
    public static void PyObject_GC_Track(MemorySegment x0) {
        var mh$ = PyObject_GC_Track.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_GC_Track", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_GC_UnTrack {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_GC_UnTrack");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyObject_GC_UnTrack(void *)
     * }
     */
    public static FunctionDescriptor PyObject_GC_UnTrack$descriptor() {
        return PyObject_GC_UnTrack.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyObject_GC_UnTrack(void *)
     * }
     */
    public static MethodHandle PyObject_GC_UnTrack$handle() {
        return PyObject_GC_UnTrack.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyObject_GC_UnTrack(void *)
     * }
     */
    public static MemorySegment PyObject_GC_UnTrack$address() {
        return PyObject_GC_UnTrack.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyObject_GC_UnTrack(void *)
     * }
     */
    public static void PyObject_GC_UnTrack(MemorySegment x0) {
        var mh$ = PyObject_GC_UnTrack.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_GC_UnTrack", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_GC_Del {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_GC_Del");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyObject_GC_Del(void *)
     * }
     */
    public static FunctionDescriptor PyObject_GC_Del$descriptor() {
        return PyObject_GC_Del.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyObject_GC_Del(void *)
     * }
     */
    public static MethodHandle PyObject_GC_Del$handle() {
        return PyObject_GC_Del.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyObject_GC_Del(void *)
     * }
     */
    public static MemorySegment PyObject_GC_Del$address() {
        return PyObject_GC_Del.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyObject_GC_Del(void *)
     * }
     */
    public static void PyObject_GC_Del(MemorySegment x0) {
        var mh$ = PyObject_GC_Del.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_GC_Del", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_GC_IsTracked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_GC_IsTracked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyObject_GC_IsTracked(PyObject *)
     * }
     */
    public static FunctionDescriptor PyObject_GC_IsTracked$descriptor() {
        return PyObject_GC_IsTracked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyObject_GC_IsTracked(PyObject *)
     * }
     */
    public static MethodHandle PyObject_GC_IsTracked$handle() {
        return PyObject_GC_IsTracked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyObject_GC_IsTracked(PyObject *)
     * }
     */
    public static MemorySegment PyObject_GC_IsTracked$address() {
        return PyObject_GC_IsTracked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyObject_GC_IsTracked(PyObject *)
     * }
     */
    public static int PyObject_GC_IsTracked(MemorySegment x0) {
        var mh$ = PyObject_GC_IsTracked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_GC_IsTracked", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_GC_IsFinalized {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_GC_IsFinalized");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyObject_GC_IsFinalized(PyObject *)
     * }
     */
    public static FunctionDescriptor PyObject_GC_IsFinalized$descriptor() {
        return PyObject_GC_IsFinalized.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyObject_GC_IsFinalized(PyObject *)
     * }
     */
    public static MethodHandle PyObject_GC_IsFinalized$handle() {
        return PyObject_GC_IsFinalized.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyObject_GC_IsFinalized(PyObject *)
     * }
     */
    public static MemorySegment PyObject_GC_IsFinalized$address() {
        return PyObject_GC_IsFinalized.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyObject_GC_IsFinalized(PyObject *)
     * }
     */
    public static int PyObject_GC_IsFinalized(MemorySegment x0) {
        var mh$ = PyObject_GC_IsFinalized.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_GC_IsFinalized", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_GetArenaAllocator {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_GetArenaAllocator");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyObject_GetArenaAllocator(PyObjectArenaAllocator *allocator)
     * }
     */
    public static FunctionDescriptor PyObject_GetArenaAllocator$descriptor() {
        return PyObject_GetArenaAllocator.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyObject_GetArenaAllocator(PyObjectArenaAllocator *allocator)
     * }
     */
    public static MethodHandle PyObject_GetArenaAllocator$handle() {
        return PyObject_GetArenaAllocator.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyObject_GetArenaAllocator(PyObjectArenaAllocator *allocator)
     * }
     */
    public static MemorySegment PyObject_GetArenaAllocator$address() {
        return PyObject_GetArenaAllocator.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyObject_GetArenaAllocator(PyObjectArenaAllocator *allocator)
     * }
     */
    public static void PyObject_GetArenaAllocator(MemorySegment allocator) {
        var mh$ = PyObject_GetArenaAllocator.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_GetArenaAllocator", allocator);
            }
            mh$.invokeExact(allocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_SetArenaAllocator {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_SetArenaAllocator");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyObject_SetArenaAllocator(PyObjectArenaAllocator *allocator)
     * }
     */
    public static FunctionDescriptor PyObject_SetArenaAllocator$descriptor() {
        return PyObject_SetArenaAllocator.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyObject_SetArenaAllocator(PyObjectArenaAllocator *allocator)
     * }
     */
    public static MethodHandle PyObject_SetArenaAllocator$handle() {
        return PyObject_SetArenaAllocator.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyObject_SetArenaAllocator(PyObjectArenaAllocator *allocator)
     * }
     */
    public static MemorySegment PyObject_SetArenaAllocator$address() {
        return PyObject_SetArenaAllocator.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyObject_SetArenaAllocator(PyObjectArenaAllocator *allocator)
     * }
     */
    public static void PyObject_SetArenaAllocator(MemorySegment allocator) {
        var mh$ = PyObject_SetArenaAllocator.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_SetArenaAllocator", allocator);
            }
            mh$.invokeExact(allocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_IS_GC {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_IS_GC");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyObject_IS_GC(PyObject *obj)
     * }
     */
    public static FunctionDescriptor PyObject_IS_GC$descriptor() {
        return PyObject_IS_GC.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyObject_IS_GC(PyObject *obj)
     * }
     */
    public static MethodHandle PyObject_IS_GC$handle() {
        return PyObject_IS_GC.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyObject_IS_GC(PyObject *obj)
     * }
     */
    public static MemorySegment PyObject_IS_GC$address() {
        return PyObject_IS_GC.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyObject_IS_GC(PyObject *obj)
     * }
     */
    public static int PyObject_IS_GC(MemorySegment obj) {
        var mh$ = PyObject_IS_GC.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_IS_GC", obj);
            }
            return (int)mh$.invokeExact(obj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyType_SUPPORTS_WEAKREFS {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyType_SUPPORTS_WEAKREFS");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyType_SUPPORTS_WEAKREFS(PyTypeObject *type)
     * }
     */
    public static FunctionDescriptor PyType_SUPPORTS_WEAKREFS$descriptor() {
        return PyType_SUPPORTS_WEAKREFS.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyType_SUPPORTS_WEAKREFS(PyTypeObject *type)
     * }
     */
    public static MethodHandle PyType_SUPPORTS_WEAKREFS$handle() {
        return PyType_SUPPORTS_WEAKREFS.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyType_SUPPORTS_WEAKREFS(PyTypeObject *type)
     * }
     */
    public static MemorySegment PyType_SUPPORTS_WEAKREFS$address() {
        return PyType_SUPPORTS_WEAKREFS.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyType_SUPPORTS_WEAKREFS(PyTypeObject *type)
     * }
     */
    public static int PyType_SUPPORTS_WEAKREFS(MemorySegment type) {
        var mh$ = PyType_SUPPORTS_WEAKREFS.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyType_SUPPORTS_WEAKREFS", type);
            }
            return (int)mh$.invokeExact(type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_GET_WEAKREFS_LISTPTR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_GET_WEAKREFS_LISTPTR");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject **PyObject_GET_WEAKREFS_LISTPTR(PyObject *op)
     * }
     */
    public static FunctionDescriptor PyObject_GET_WEAKREFS_LISTPTR$descriptor() {
        return PyObject_GET_WEAKREFS_LISTPTR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject **PyObject_GET_WEAKREFS_LISTPTR(PyObject *op)
     * }
     */
    public static MethodHandle PyObject_GET_WEAKREFS_LISTPTR$handle() {
        return PyObject_GET_WEAKREFS_LISTPTR.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject **PyObject_GET_WEAKREFS_LISTPTR(PyObject *op)
     * }
     */
    public static MemorySegment PyObject_GET_WEAKREFS_LISTPTR$address() {
        return PyObject_GET_WEAKREFS_LISTPTR.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject **PyObject_GET_WEAKREFS_LISTPTR(PyObject *op)
     * }
     */
    public static MemorySegment PyObject_GET_WEAKREFS_LISTPTR(MemorySegment op) {
        var mh$ = PyObject_GET_WEAKREFS_LISTPTR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_GET_WEAKREFS_LISTPTR", op);
            }
            return (MemorySegment)mh$.invokeExact(op);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnstable_Object_GC_NewWithExtraData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnstable_Object_GC_NewWithExtraData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnstable_Object_GC_NewWithExtraData(PyTypeObject *, size_t)
     * }
     */
    public static FunctionDescriptor PyUnstable_Object_GC_NewWithExtraData$descriptor() {
        return PyUnstable_Object_GC_NewWithExtraData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnstable_Object_GC_NewWithExtraData(PyTypeObject *, size_t)
     * }
     */
    public static MethodHandle PyUnstable_Object_GC_NewWithExtraData$handle() {
        return PyUnstable_Object_GC_NewWithExtraData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnstable_Object_GC_NewWithExtraData(PyTypeObject *, size_t)
     * }
     */
    public static MemorySegment PyUnstable_Object_GC_NewWithExtraData$address() {
        return PyUnstable_Object_GC_NewWithExtraData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnstable_Object_GC_NewWithExtraData(PyTypeObject *, size_t)
     * }
     */
    public static MemorySegment PyUnstable_Object_GC_NewWithExtraData(MemorySegment x0, long x1) {
        var mh$ = PyUnstable_Object_GC_NewWithExtraData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnstable_Object_GC_NewWithExtraData", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _Py_HashDouble {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_Py_HashDouble");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_hash_t _Py_HashDouble(PyObject *, double)
     * }
     */
    public static FunctionDescriptor _Py_HashDouble$descriptor() {
        return _Py_HashDouble.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_hash_t _Py_HashDouble(PyObject *, double)
     * }
     */
    public static MethodHandle _Py_HashDouble$handle() {
        return _Py_HashDouble.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_hash_t _Py_HashDouble(PyObject *, double)
     * }
     */
    public static MemorySegment _Py_HashDouble$address() {
        return _Py_HashDouble.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_hash_t _Py_HashDouble(PyObject *, double)
     * }
     */
    public static long _Py_HashDouble(MemorySegment x0, double x1) {
        var mh$ = _Py_HashDouble.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_Py_HashDouble", x0, x1);
            }
            return (long)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _Py_HashPointer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_Py_HashPointer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_hash_t _Py_HashPointer(const void *)
     * }
     */
    public static FunctionDescriptor _Py_HashPointer$descriptor() {
        return _Py_HashPointer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_hash_t _Py_HashPointer(const void *)
     * }
     */
    public static MethodHandle _Py_HashPointer$handle() {
        return _Py_HashPointer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_hash_t _Py_HashPointer(const void *)
     * }
     */
    public static MemorySegment _Py_HashPointer$address() {
        return _Py_HashPointer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_hash_t _Py_HashPointer(const void *)
     * }
     */
    public static long _Py_HashPointer(MemorySegment x0) {
        var mh$ = _Py_HashPointer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_Py_HashPointer", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _Py_HashPointerRaw {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_Py_HashPointerRaw");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_hash_t _Py_HashPointerRaw(const void *)
     * }
     */
    public static FunctionDescriptor _Py_HashPointerRaw$descriptor() {
        return _Py_HashPointerRaw.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_hash_t _Py_HashPointerRaw(const void *)
     * }
     */
    public static MethodHandle _Py_HashPointerRaw$handle() {
        return _Py_HashPointerRaw.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_hash_t _Py_HashPointerRaw(const void *)
     * }
     */
    public static MemorySegment _Py_HashPointerRaw$address() {
        return _Py_HashPointerRaw.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_hash_t _Py_HashPointerRaw(const void *)
     * }
     */
    public static long _Py_HashPointerRaw(MemorySegment x0) {
        var mh$ = _Py_HashPointerRaw.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_Py_HashPointerRaw", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _Py_HashBytes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_Py_HashBytes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_hash_t _Py_HashBytes(const void *, Py_ssize_t)
     * }
     */
    public static FunctionDescriptor _Py_HashBytes$descriptor() {
        return _Py_HashBytes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_hash_t _Py_HashBytes(const void *, Py_ssize_t)
     * }
     */
    public static MethodHandle _Py_HashBytes$handle() {
        return _Py_HashBytes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_hash_t _Py_HashBytes(const void *, Py_ssize_t)
     * }
     */
    public static MemorySegment _Py_HashBytes$address() {
        return _Py_HashBytes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_hash_t _Py_HashBytes(const void *, Py_ssize_t)
     * }
     */
    public static long _Py_HashBytes(MemorySegment x0, long x1) {
        var mh$ = _Py_HashBytes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_Py_HashBytes", x0, x1);
            }
            return (long)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _Py_HashSecret$constants {
        public static final GroupLayout LAYOUT = _Py_HashSecret_t.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("_Py_HashSecret").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern _Py_HashSecret_t _Py_HashSecret
     * }
     */
    public static GroupLayout _Py_HashSecret$layout() {
        return _Py_HashSecret$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern _Py_HashSecret_t _Py_HashSecret
     * }
     */
    public static MemorySegment _Py_HashSecret() {
        return _Py_HashSecret$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern _Py_HashSecret_t _Py_HashSecret
     * }
     */
    public static void _Py_HashSecret(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, _Py_HashSecret$constants.SEGMENT, 0L, _Py_HashSecret$constants.LAYOUT.byteSize());
    }

    private static class PyHash_GetFuncDef {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyHash_GetFuncDef");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyHash_FuncDef *PyHash_GetFuncDef()
     * }
     */
    public static FunctionDescriptor PyHash_GetFuncDef$descriptor() {
        return PyHash_GetFuncDef.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyHash_FuncDef *PyHash_GetFuncDef()
     * }
     */
    public static MethodHandle PyHash_GetFuncDef$handle() {
        return PyHash_GetFuncDef.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyHash_FuncDef *PyHash_GetFuncDef()
     * }
     */
    public static MemorySegment PyHash_GetFuncDef$address() {
        return PyHash_GetFuncDef.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyHash_FuncDef *PyHash_GetFuncDef()
     * }
     */
    public static MemorySegment PyHash_GetFuncDef() {
        var mh$ = PyHash_GetFuncDef.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyHash_GetFuncDef");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_DebugFlag$constants {
        public static final OfInt LAYOUT = Python_h.C_INT;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("Py_DebugFlag").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int Py_DebugFlag
     * }
     */
    public static OfInt Py_DebugFlag$layout() {
        return Py_DebugFlag$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int Py_DebugFlag
     * }
     */
    public static MemorySegment Py_DebugFlag$segment() {
        return Py_DebugFlag$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int Py_DebugFlag
     * }
     */
    public static int Py_DebugFlag() {
        return Py_DebugFlag$constants.SEGMENT.get(Py_DebugFlag$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int Py_DebugFlag
     * }
     */
    public static void Py_DebugFlag(int varValue) {
        Py_DebugFlag$constants.SEGMENT.set(Py_DebugFlag$constants.LAYOUT, 0L, varValue);
    }

    private static class Py_VerboseFlag$constants {
        public static final OfInt LAYOUT = Python_h.C_INT;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("Py_VerboseFlag").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int Py_VerboseFlag
     * }
     */
    public static OfInt Py_VerboseFlag$layout() {
        return Py_VerboseFlag$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int Py_VerboseFlag
     * }
     */
    public static MemorySegment Py_VerboseFlag$segment() {
        return Py_VerboseFlag$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int Py_VerboseFlag
     * }
     */
    public static int Py_VerboseFlag() {
        return Py_VerboseFlag$constants.SEGMENT.get(Py_VerboseFlag$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int Py_VerboseFlag
     * }
     */
    public static void Py_VerboseFlag(int varValue) {
        Py_VerboseFlag$constants.SEGMENT.set(Py_VerboseFlag$constants.LAYOUT, 0L, varValue);
    }

    private static class Py_QuietFlag$constants {
        public static final OfInt LAYOUT = Python_h.C_INT;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("Py_QuietFlag").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int Py_QuietFlag
     * }
     */
    public static OfInt Py_QuietFlag$layout() {
        return Py_QuietFlag$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int Py_QuietFlag
     * }
     */
    public static MemorySegment Py_QuietFlag$segment() {
        return Py_QuietFlag$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int Py_QuietFlag
     * }
     */
    public static int Py_QuietFlag() {
        return Py_QuietFlag$constants.SEGMENT.get(Py_QuietFlag$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int Py_QuietFlag
     * }
     */
    public static void Py_QuietFlag(int varValue) {
        Py_QuietFlag$constants.SEGMENT.set(Py_QuietFlag$constants.LAYOUT, 0L, varValue);
    }

    private static class Py_InteractiveFlag$constants {
        public static final OfInt LAYOUT = Python_h.C_INT;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("Py_InteractiveFlag").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int Py_InteractiveFlag
     * }
     */
    public static OfInt Py_InteractiveFlag$layout() {
        return Py_InteractiveFlag$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int Py_InteractiveFlag
     * }
     */
    public static MemorySegment Py_InteractiveFlag$segment() {
        return Py_InteractiveFlag$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int Py_InteractiveFlag
     * }
     */
    public static int Py_InteractiveFlag() {
        return Py_InteractiveFlag$constants.SEGMENT.get(Py_InteractiveFlag$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int Py_InteractiveFlag
     * }
     */
    public static void Py_InteractiveFlag(int varValue) {
        Py_InteractiveFlag$constants.SEGMENT.set(Py_InteractiveFlag$constants.LAYOUT, 0L, varValue);
    }

    private static class Py_InspectFlag$constants {
        public static final OfInt LAYOUT = Python_h.C_INT;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("Py_InspectFlag").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int Py_InspectFlag
     * }
     */
    public static OfInt Py_InspectFlag$layout() {
        return Py_InspectFlag$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int Py_InspectFlag
     * }
     */
    public static MemorySegment Py_InspectFlag$segment() {
        return Py_InspectFlag$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int Py_InspectFlag
     * }
     */
    public static int Py_InspectFlag() {
        return Py_InspectFlag$constants.SEGMENT.get(Py_InspectFlag$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int Py_InspectFlag
     * }
     */
    public static void Py_InspectFlag(int varValue) {
        Py_InspectFlag$constants.SEGMENT.set(Py_InspectFlag$constants.LAYOUT, 0L, varValue);
    }

    private static class Py_OptimizeFlag$constants {
        public static final OfInt LAYOUT = Python_h.C_INT;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("Py_OptimizeFlag").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int Py_OptimizeFlag
     * }
     */
    public static OfInt Py_OptimizeFlag$layout() {
        return Py_OptimizeFlag$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int Py_OptimizeFlag
     * }
     */
    public static MemorySegment Py_OptimizeFlag$segment() {
        return Py_OptimizeFlag$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int Py_OptimizeFlag
     * }
     */
    public static int Py_OptimizeFlag() {
        return Py_OptimizeFlag$constants.SEGMENT.get(Py_OptimizeFlag$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int Py_OptimizeFlag
     * }
     */
    public static void Py_OptimizeFlag(int varValue) {
        Py_OptimizeFlag$constants.SEGMENT.set(Py_OptimizeFlag$constants.LAYOUT, 0L, varValue);
    }

    private static class Py_NoSiteFlag$constants {
        public static final OfInt LAYOUT = Python_h.C_INT;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("Py_NoSiteFlag").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int Py_NoSiteFlag
     * }
     */
    public static OfInt Py_NoSiteFlag$layout() {
        return Py_NoSiteFlag$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int Py_NoSiteFlag
     * }
     */
    public static MemorySegment Py_NoSiteFlag$segment() {
        return Py_NoSiteFlag$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int Py_NoSiteFlag
     * }
     */
    public static int Py_NoSiteFlag() {
        return Py_NoSiteFlag$constants.SEGMENT.get(Py_NoSiteFlag$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int Py_NoSiteFlag
     * }
     */
    public static void Py_NoSiteFlag(int varValue) {
        Py_NoSiteFlag$constants.SEGMENT.set(Py_NoSiteFlag$constants.LAYOUT, 0L, varValue);
    }

    private static class Py_BytesWarningFlag$constants {
        public static final OfInt LAYOUT = Python_h.C_INT;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("Py_BytesWarningFlag").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int Py_BytesWarningFlag
     * }
     */
    public static OfInt Py_BytesWarningFlag$layout() {
        return Py_BytesWarningFlag$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int Py_BytesWarningFlag
     * }
     */
    public static MemorySegment Py_BytesWarningFlag$segment() {
        return Py_BytesWarningFlag$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int Py_BytesWarningFlag
     * }
     */
    public static int Py_BytesWarningFlag() {
        return Py_BytesWarningFlag$constants.SEGMENT.get(Py_BytesWarningFlag$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int Py_BytesWarningFlag
     * }
     */
    public static void Py_BytesWarningFlag(int varValue) {
        Py_BytesWarningFlag$constants.SEGMENT.set(Py_BytesWarningFlag$constants.LAYOUT, 0L, varValue);
    }

    private static class Py_FrozenFlag$constants {
        public static final OfInt LAYOUT = Python_h.C_INT;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("Py_FrozenFlag").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int Py_FrozenFlag
     * }
     */
    public static OfInt Py_FrozenFlag$layout() {
        return Py_FrozenFlag$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int Py_FrozenFlag
     * }
     */
    public static MemorySegment Py_FrozenFlag$segment() {
        return Py_FrozenFlag$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int Py_FrozenFlag
     * }
     */
    public static int Py_FrozenFlag() {
        return Py_FrozenFlag$constants.SEGMENT.get(Py_FrozenFlag$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int Py_FrozenFlag
     * }
     */
    public static void Py_FrozenFlag(int varValue) {
        Py_FrozenFlag$constants.SEGMENT.set(Py_FrozenFlag$constants.LAYOUT, 0L, varValue);
    }

    private static class Py_IgnoreEnvironmentFlag$constants {
        public static final OfInt LAYOUT = Python_h.C_INT;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("Py_IgnoreEnvironmentFlag").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int Py_IgnoreEnvironmentFlag
     * }
     */
    public static OfInt Py_IgnoreEnvironmentFlag$layout() {
        return Py_IgnoreEnvironmentFlag$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int Py_IgnoreEnvironmentFlag
     * }
     */
    public static MemorySegment Py_IgnoreEnvironmentFlag$segment() {
        return Py_IgnoreEnvironmentFlag$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int Py_IgnoreEnvironmentFlag
     * }
     */
    public static int Py_IgnoreEnvironmentFlag() {
        return Py_IgnoreEnvironmentFlag$constants.SEGMENT.get(Py_IgnoreEnvironmentFlag$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int Py_IgnoreEnvironmentFlag
     * }
     */
    public static void Py_IgnoreEnvironmentFlag(int varValue) {
        Py_IgnoreEnvironmentFlag$constants.SEGMENT.set(Py_IgnoreEnvironmentFlag$constants.LAYOUT, 0L, varValue);
    }

    private static class Py_DontWriteBytecodeFlag$constants {
        public static final OfInt LAYOUT = Python_h.C_INT;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("Py_DontWriteBytecodeFlag").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int Py_DontWriteBytecodeFlag
     * }
     */
    public static OfInt Py_DontWriteBytecodeFlag$layout() {
        return Py_DontWriteBytecodeFlag$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int Py_DontWriteBytecodeFlag
     * }
     */
    public static MemorySegment Py_DontWriteBytecodeFlag$segment() {
        return Py_DontWriteBytecodeFlag$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int Py_DontWriteBytecodeFlag
     * }
     */
    public static int Py_DontWriteBytecodeFlag() {
        return Py_DontWriteBytecodeFlag$constants.SEGMENT.get(Py_DontWriteBytecodeFlag$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int Py_DontWriteBytecodeFlag
     * }
     */
    public static void Py_DontWriteBytecodeFlag(int varValue) {
        Py_DontWriteBytecodeFlag$constants.SEGMENT.set(Py_DontWriteBytecodeFlag$constants.LAYOUT, 0L, varValue);
    }

    private static class Py_NoUserSiteDirectory$constants {
        public static final OfInt LAYOUT = Python_h.C_INT;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("Py_NoUserSiteDirectory").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int Py_NoUserSiteDirectory
     * }
     */
    public static OfInt Py_NoUserSiteDirectory$layout() {
        return Py_NoUserSiteDirectory$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int Py_NoUserSiteDirectory
     * }
     */
    public static MemorySegment Py_NoUserSiteDirectory$segment() {
        return Py_NoUserSiteDirectory$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int Py_NoUserSiteDirectory
     * }
     */
    public static int Py_NoUserSiteDirectory() {
        return Py_NoUserSiteDirectory$constants.SEGMENT.get(Py_NoUserSiteDirectory$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int Py_NoUserSiteDirectory
     * }
     */
    public static void Py_NoUserSiteDirectory(int varValue) {
        Py_NoUserSiteDirectory$constants.SEGMENT.set(Py_NoUserSiteDirectory$constants.LAYOUT, 0L, varValue);
    }

    private static class Py_UnbufferedStdioFlag$constants {
        public static final OfInt LAYOUT = Python_h.C_INT;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("Py_UnbufferedStdioFlag").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int Py_UnbufferedStdioFlag
     * }
     */
    public static OfInt Py_UnbufferedStdioFlag$layout() {
        return Py_UnbufferedStdioFlag$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int Py_UnbufferedStdioFlag
     * }
     */
    public static MemorySegment Py_UnbufferedStdioFlag$segment() {
        return Py_UnbufferedStdioFlag$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int Py_UnbufferedStdioFlag
     * }
     */
    public static int Py_UnbufferedStdioFlag() {
        return Py_UnbufferedStdioFlag$constants.SEGMENT.get(Py_UnbufferedStdioFlag$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int Py_UnbufferedStdioFlag
     * }
     */
    public static void Py_UnbufferedStdioFlag(int varValue) {
        Py_UnbufferedStdioFlag$constants.SEGMENT.set(Py_UnbufferedStdioFlag$constants.LAYOUT, 0L, varValue);
    }

    private static class Py_HashRandomizationFlag$constants {
        public static final OfInt LAYOUT = Python_h.C_INT;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("Py_HashRandomizationFlag").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int Py_HashRandomizationFlag
     * }
     */
    public static OfInt Py_HashRandomizationFlag$layout() {
        return Py_HashRandomizationFlag$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int Py_HashRandomizationFlag
     * }
     */
    public static MemorySegment Py_HashRandomizationFlag$segment() {
        return Py_HashRandomizationFlag$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int Py_HashRandomizationFlag
     * }
     */
    public static int Py_HashRandomizationFlag() {
        return Py_HashRandomizationFlag$constants.SEGMENT.get(Py_HashRandomizationFlag$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int Py_HashRandomizationFlag
     * }
     */
    public static void Py_HashRandomizationFlag(int varValue) {
        Py_HashRandomizationFlag$constants.SEGMENT.set(Py_HashRandomizationFlag$constants.LAYOUT, 0L, varValue);
    }

    private static class Py_IsolatedFlag$constants {
        public static final OfInt LAYOUT = Python_h.C_INT;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("Py_IsolatedFlag").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int Py_IsolatedFlag
     * }
     */
    public static OfInt Py_IsolatedFlag$layout() {
        return Py_IsolatedFlag$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int Py_IsolatedFlag
     * }
     */
    public static MemorySegment Py_IsolatedFlag$segment() {
        return Py_IsolatedFlag$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int Py_IsolatedFlag
     * }
     */
    public static int Py_IsolatedFlag() {
        return Py_IsolatedFlag$constants.SEGMENT.get(Py_IsolatedFlag$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int Py_IsolatedFlag
     * }
     */
    public static void Py_IsolatedFlag(int varValue) {
        Py_IsolatedFlag$constants.SEGMENT.set(Py_IsolatedFlag$constants.LAYOUT, 0L, varValue);
    }

    private static class Py_LegacyWindowsFSEncodingFlag$constants {
        public static final OfInt LAYOUT = Python_h.C_INT;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("Py_LegacyWindowsFSEncodingFlag").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int Py_LegacyWindowsFSEncodingFlag
     * }
     */
    public static OfInt Py_LegacyWindowsFSEncodingFlag$layout() {
        return Py_LegacyWindowsFSEncodingFlag$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int Py_LegacyWindowsFSEncodingFlag
     * }
     */
    public static MemorySegment Py_LegacyWindowsFSEncodingFlag$segment() {
        return Py_LegacyWindowsFSEncodingFlag$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int Py_LegacyWindowsFSEncodingFlag
     * }
     */
    public static int Py_LegacyWindowsFSEncodingFlag() {
        return Py_LegacyWindowsFSEncodingFlag$constants.SEGMENT.get(Py_LegacyWindowsFSEncodingFlag$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int Py_LegacyWindowsFSEncodingFlag
     * }
     */
    public static void Py_LegacyWindowsFSEncodingFlag(int varValue) {
        Py_LegacyWindowsFSEncodingFlag$constants.SEGMENT.set(Py_LegacyWindowsFSEncodingFlag$constants.LAYOUT, 0L, varValue);
    }

    private static class Py_LegacyWindowsStdioFlag$constants {
        public static final OfInt LAYOUT = Python_h.C_INT;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("Py_LegacyWindowsStdioFlag").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int Py_LegacyWindowsStdioFlag
     * }
     */
    public static OfInt Py_LegacyWindowsStdioFlag$layout() {
        return Py_LegacyWindowsStdioFlag$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int Py_LegacyWindowsStdioFlag
     * }
     */
    public static MemorySegment Py_LegacyWindowsStdioFlag$segment() {
        return Py_LegacyWindowsStdioFlag$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int Py_LegacyWindowsStdioFlag
     * }
     */
    public static int Py_LegacyWindowsStdioFlag() {
        return Py_LegacyWindowsStdioFlag$constants.SEGMENT.get(Py_LegacyWindowsStdioFlag$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int Py_LegacyWindowsStdioFlag
     * }
     */
    public static void Py_LegacyWindowsStdioFlag(int varValue) {
        Py_LegacyWindowsStdioFlag$constants.SEGMENT.set(Py_LegacyWindowsStdioFlag$constants.LAYOUT, 0L, varValue);
    }

    private static class Py_GETENV {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_GETENV");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *Py_GETENV(const char *name)
     * }
     */
    public static FunctionDescriptor Py_GETENV$descriptor() {
        return Py_GETENV.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *Py_GETENV(const char *name)
     * }
     */
    public static MethodHandle Py_GETENV$handle() {
        return Py_GETENV.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *Py_GETENV(const char *name)
     * }
     */
    public static MemorySegment Py_GETENV$address() {
        return Py_GETENV.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *Py_GETENV(const char *name)
     * }
     */
    public static MemorySegment Py_GETENV(MemorySegment name) {
        var mh$ = Py_GETENV.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_GETENV", name);
            }
            return (MemorySegment)mh$.invokeExact(name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyByteArray_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyByteArray_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyByteArray_Type
     * }
     */
    public static GroupLayout PyByteArray_Type$layout() {
        return PyByteArray_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyByteArray_Type
     * }
     */
    public static MemorySegment PyByteArray_Type() {
        return PyByteArray_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyByteArray_Type
     * }
     */
    public static void PyByteArray_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyByteArray_Type$constants.SEGMENT, 0L, PyByteArray_Type$constants.LAYOUT.byteSize());
    }

    private static class PyByteArrayIter_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyByteArrayIter_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyByteArrayIter_Type
     * }
     */
    public static GroupLayout PyByteArrayIter_Type$layout() {
        return PyByteArrayIter_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyByteArrayIter_Type
     * }
     */
    public static MemorySegment PyByteArrayIter_Type() {
        return PyByteArrayIter_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyByteArrayIter_Type
     * }
     */
    public static void PyByteArrayIter_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyByteArrayIter_Type$constants.SEGMENT, 0L, PyByteArrayIter_Type$constants.LAYOUT.byteSize());
    }

    private static class PyByteArray_FromObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyByteArray_FromObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyByteArray_FromObject(PyObject *)
     * }
     */
    public static FunctionDescriptor PyByteArray_FromObject$descriptor() {
        return PyByteArray_FromObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyByteArray_FromObject(PyObject *)
     * }
     */
    public static MethodHandle PyByteArray_FromObject$handle() {
        return PyByteArray_FromObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyByteArray_FromObject(PyObject *)
     * }
     */
    public static MemorySegment PyByteArray_FromObject$address() {
        return PyByteArray_FromObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyByteArray_FromObject(PyObject *)
     * }
     */
    public static MemorySegment PyByteArray_FromObject(MemorySegment x0) {
        var mh$ = PyByteArray_FromObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyByteArray_FromObject", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyByteArray_Concat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyByteArray_Concat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyByteArray_Concat(PyObject *, PyObject *)
     * }
     */
    public static FunctionDescriptor PyByteArray_Concat$descriptor() {
        return PyByteArray_Concat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyByteArray_Concat(PyObject *, PyObject *)
     * }
     */
    public static MethodHandle PyByteArray_Concat$handle() {
        return PyByteArray_Concat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyByteArray_Concat(PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyByteArray_Concat$address() {
        return PyByteArray_Concat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyByteArray_Concat(PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyByteArray_Concat(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyByteArray_Concat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyByteArray_Concat", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyByteArray_FromStringAndSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyByteArray_FromStringAndSize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyByteArray_FromStringAndSize(const char *, Py_ssize_t)
     * }
     */
    public static FunctionDescriptor PyByteArray_FromStringAndSize$descriptor() {
        return PyByteArray_FromStringAndSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyByteArray_FromStringAndSize(const char *, Py_ssize_t)
     * }
     */
    public static MethodHandle PyByteArray_FromStringAndSize$handle() {
        return PyByteArray_FromStringAndSize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyByteArray_FromStringAndSize(const char *, Py_ssize_t)
     * }
     */
    public static MemorySegment PyByteArray_FromStringAndSize$address() {
        return PyByteArray_FromStringAndSize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyByteArray_FromStringAndSize(const char *, Py_ssize_t)
     * }
     */
    public static MemorySegment PyByteArray_FromStringAndSize(MemorySegment x0, long x1) {
        var mh$ = PyByteArray_FromStringAndSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyByteArray_FromStringAndSize", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyByteArray_Size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyByteArray_Size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_ssize_t PyByteArray_Size(PyObject *)
     * }
     */
    public static FunctionDescriptor PyByteArray_Size$descriptor() {
        return PyByteArray_Size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_ssize_t PyByteArray_Size(PyObject *)
     * }
     */
    public static MethodHandle PyByteArray_Size$handle() {
        return PyByteArray_Size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_ssize_t PyByteArray_Size(PyObject *)
     * }
     */
    public static MemorySegment PyByteArray_Size$address() {
        return PyByteArray_Size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_ssize_t PyByteArray_Size(PyObject *)
     * }
     */
    public static long PyByteArray_Size(MemorySegment x0) {
        var mh$ = PyByteArray_Size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyByteArray_Size", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyByteArray_AsString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyByteArray_AsString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *PyByteArray_AsString(PyObject *)
     * }
     */
    public static FunctionDescriptor PyByteArray_AsString$descriptor() {
        return PyByteArray_AsString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *PyByteArray_AsString(PyObject *)
     * }
     */
    public static MethodHandle PyByteArray_AsString$handle() {
        return PyByteArray_AsString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *PyByteArray_AsString(PyObject *)
     * }
     */
    public static MemorySegment PyByteArray_AsString$address() {
        return PyByteArray_AsString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *PyByteArray_AsString(PyObject *)
     * }
     */
    public static MemorySegment PyByteArray_AsString(MemorySegment x0) {
        var mh$ = PyByteArray_AsString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyByteArray_AsString", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyByteArray_Resize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyByteArray_Resize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyByteArray_Resize(PyObject *, Py_ssize_t)
     * }
     */
    public static FunctionDescriptor PyByteArray_Resize$descriptor() {
        return PyByteArray_Resize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyByteArray_Resize(PyObject *, Py_ssize_t)
     * }
     */
    public static MethodHandle PyByteArray_Resize$handle() {
        return PyByteArray_Resize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyByteArray_Resize(PyObject *, Py_ssize_t)
     * }
     */
    public static MemorySegment PyByteArray_Resize$address() {
        return PyByteArray_Resize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyByteArray_Resize(PyObject *, Py_ssize_t)
     * }
     */
    public static int PyByteArray_Resize(MemorySegment x0, long x1) {
        var mh$ = PyByteArray_Resize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyByteArray_Resize", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyByteArray_empty_string$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(0, Python_h.C_CHAR);
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("_PyByteArray_empty_string").reinterpret(LAYOUT.byteSize());
        public static final VarHandle HANDLE = LAYOUT.varHandle();

        public static final long[] DIMS = {  };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern char _PyByteArray_empty_string[]
     * }
     */
    public static SequenceLayout _PyByteArray_empty_string$layout() {
        return _PyByteArray_empty_string$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern char _PyByteArray_empty_string[]
     * }
     */
    public static long[] _PyByteArray_empty_string$dimensions() {
        return _PyByteArray_empty_string$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern char _PyByteArray_empty_string[]
     * }
     */
    public static MemorySegment _PyByteArray_empty_string() {
        return _PyByteArray_empty_string$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern char _PyByteArray_empty_string[]
     * }
     */
    public static void _PyByteArray_empty_string(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, _PyByteArray_empty_string$constants.SEGMENT, 0L, _PyByteArray_empty_string$constants.LAYOUT.byteSize());
    }
    /**
     * {@snippet lang=c :
     * typedef __builtin_va_list __gnuc_va_list
     * }
     */
    public static final AddressLayout __gnuc_va_list = Python_h.C_POINTER;

    private static class PyBytes_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyBytes_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyBytes_Type
     * }
     */
    public static GroupLayout PyBytes_Type$layout() {
        return PyBytes_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyBytes_Type
     * }
     */
    public static MemorySegment PyBytes_Type() {
        return PyBytes_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyBytes_Type
     * }
     */
    public static void PyBytes_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyBytes_Type$constants.SEGMENT, 0L, PyBytes_Type$constants.LAYOUT.byteSize());
    }

    private static class PyBytesIter_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyBytesIter_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyBytesIter_Type
     * }
     */
    public static GroupLayout PyBytesIter_Type$layout() {
        return PyBytesIter_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyBytesIter_Type
     * }
     */
    public static MemorySegment PyBytesIter_Type() {
        return PyBytesIter_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyBytesIter_Type
     * }
     */
    public static void PyBytesIter_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyBytesIter_Type$constants.SEGMENT, 0L, PyBytesIter_Type$constants.LAYOUT.byteSize());
    }

    private static class PyBytes_FromStringAndSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyBytes_FromStringAndSize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyBytes_FromStringAndSize(const char *, Py_ssize_t)
     * }
     */
    public static FunctionDescriptor PyBytes_FromStringAndSize$descriptor() {
        return PyBytes_FromStringAndSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyBytes_FromStringAndSize(const char *, Py_ssize_t)
     * }
     */
    public static MethodHandle PyBytes_FromStringAndSize$handle() {
        return PyBytes_FromStringAndSize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyBytes_FromStringAndSize(const char *, Py_ssize_t)
     * }
     */
    public static MemorySegment PyBytes_FromStringAndSize$address() {
        return PyBytes_FromStringAndSize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyBytes_FromStringAndSize(const char *, Py_ssize_t)
     * }
     */
    public static MemorySegment PyBytes_FromStringAndSize(MemorySegment x0, long x1) {
        var mh$ = PyBytes_FromStringAndSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyBytes_FromStringAndSize", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyBytes_FromString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyBytes_FromString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyBytes_FromString(const char *)
     * }
     */
    public static FunctionDescriptor PyBytes_FromString$descriptor() {
        return PyBytes_FromString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyBytes_FromString(const char *)
     * }
     */
    public static MethodHandle PyBytes_FromString$handle() {
        return PyBytes_FromString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyBytes_FromString(const char *)
     * }
     */
    public static MemorySegment PyBytes_FromString$address() {
        return PyBytes_FromString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyBytes_FromString(const char *)
     * }
     */
    public static MemorySegment PyBytes_FromString(MemorySegment x0) {
        var mh$ = PyBytes_FromString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyBytes_FromString", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyBytes_FromObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyBytes_FromObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyBytes_FromObject(PyObject *)
     * }
     */
    public static FunctionDescriptor PyBytes_FromObject$descriptor() {
        return PyBytes_FromObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyBytes_FromObject(PyObject *)
     * }
     */
    public static MethodHandle PyBytes_FromObject$handle() {
        return PyBytes_FromObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyBytes_FromObject(PyObject *)
     * }
     */
    public static MemorySegment PyBytes_FromObject$address() {
        return PyBytes_FromObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyBytes_FromObject(PyObject *)
     * }
     */
    public static MemorySegment PyBytes_FromObject(MemorySegment x0) {
        var mh$ = PyBytes_FromObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyBytes_FromObject", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyBytes_FromFormatV {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyBytes_FromFormatV");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyBytes_FromFormatV(const char *, va_list)
     * }
     */
    public static FunctionDescriptor PyBytes_FromFormatV$descriptor() {
        return PyBytes_FromFormatV.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyBytes_FromFormatV(const char *, va_list)
     * }
     */
    public static MethodHandle PyBytes_FromFormatV$handle() {
        return PyBytes_FromFormatV.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyBytes_FromFormatV(const char *, va_list)
     * }
     */
    public static MemorySegment PyBytes_FromFormatV$address() {
        return PyBytes_FromFormatV.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyBytes_FromFormatV(const char *, va_list)
     * }
     */
    public static MemorySegment PyBytes_FromFormatV(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyBytes_FromFormatV.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyBytes_FromFormatV", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * PyObject *PyBytes_FromFormat(const char *, ...)
     * }
     */
    public static class PyBytes_FromFormat {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_POINTER,
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("PyBytes_FromFormat");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private PyBytes_FromFormat(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * PyObject *PyBytes_FromFormat(const char *, ...)
         * }
         */
        public static PyBytes_FromFormat makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new PyBytes_FromFormat(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public MemorySegment apply(MemorySegment x0, Object... x1) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("PyBytes_FromFormat", x0, x1);
                }
                return (MemorySegment)spreader.invokeExact(x0, x1);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class PyBytes_Size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyBytes_Size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_ssize_t PyBytes_Size(PyObject *)
     * }
     */
    public static FunctionDescriptor PyBytes_Size$descriptor() {
        return PyBytes_Size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_ssize_t PyBytes_Size(PyObject *)
     * }
     */
    public static MethodHandle PyBytes_Size$handle() {
        return PyBytes_Size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_ssize_t PyBytes_Size(PyObject *)
     * }
     */
    public static MemorySegment PyBytes_Size$address() {
        return PyBytes_Size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_ssize_t PyBytes_Size(PyObject *)
     * }
     */
    public static long PyBytes_Size(MemorySegment x0) {
        var mh$ = PyBytes_Size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyBytes_Size", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyBytes_AsString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyBytes_AsString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *PyBytes_AsString(PyObject *)
     * }
     */
    public static FunctionDescriptor PyBytes_AsString$descriptor() {
        return PyBytes_AsString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *PyBytes_AsString(PyObject *)
     * }
     */
    public static MethodHandle PyBytes_AsString$handle() {
        return PyBytes_AsString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *PyBytes_AsString(PyObject *)
     * }
     */
    public static MemorySegment PyBytes_AsString$address() {
        return PyBytes_AsString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *PyBytes_AsString(PyObject *)
     * }
     */
    public static MemorySegment PyBytes_AsString(MemorySegment x0) {
        var mh$ = PyBytes_AsString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyBytes_AsString", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyBytes_Repr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyBytes_Repr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyBytes_Repr(PyObject *, int)
     * }
     */
    public static FunctionDescriptor PyBytes_Repr$descriptor() {
        return PyBytes_Repr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyBytes_Repr(PyObject *, int)
     * }
     */
    public static MethodHandle PyBytes_Repr$handle() {
        return PyBytes_Repr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyBytes_Repr(PyObject *, int)
     * }
     */
    public static MemorySegment PyBytes_Repr$address() {
        return PyBytes_Repr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyBytes_Repr(PyObject *, int)
     * }
     */
    public static MemorySegment PyBytes_Repr(MemorySegment x0, int x1) {
        var mh$ = PyBytes_Repr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyBytes_Repr", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyBytes_Concat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyBytes_Concat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyBytes_Concat(PyObject **, PyObject *)
     * }
     */
    public static FunctionDescriptor PyBytes_Concat$descriptor() {
        return PyBytes_Concat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyBytes_Concat(PyObject **, PyObject *)
     * }
     */
    public static MethodHandle PyBytes_Concat$handle() {
        return PyBytes_Concat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyBytes_Concat(PyObject **, PyObject *)
     * }
     */
    public static MemorySegment PyBytes_Concat$address() {
        return PyBytes_Concat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyBytes_Concat(PyObject **, PyObject *)
     * }
     */
    public static void PyBytes_Concat(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyBytes_Concat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyBytes_Concat", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyBytes_ConcatAndDel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyBytes_ConcatAndDel");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyBytes_ConcatAndDel(PyObject **, PyObject *)
     * }
     */
    public static FunctionDescriptor PyBytes_ConcatAndDel$descriptor() {
        return PyBytes_ConcatAndDel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyBytes_ConcatAndDel(PyObject **, PyObject *)
     * }
     */
    public static MethodHandle PyBytes_ConcatAndDel$handle() {
        return PyBytes_ConcatAndDel.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyBytes_ConcatAndDel(PyObject **, PyObject *)
     * }
     */
    public static MemorySegment PyBytes_ConcatAndDel$address() {
        return PyBytes_ConcatAndDel.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyBytes_ConcatAndDel(PyObject **, PyObject *)
     * }
     */
    public static void PyBytes_ConcatAndDel(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyBytes_ConcatAndDel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyBytes_ConcatAndDel", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyBytes_DecodeEscape {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyBytes_DecodeEscape");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyBytes_DecodeEscape(const char *, Py_ssize_t, const char *, Py_ssize_t, const char *)
     * }
     */
    public static FunctionDescriptor PyBytes_DecodeEscape$descriptor() {
        return PyBytes_DecodeEscape.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyBytes_DecodeEscape(const char *, Py_ssize_t, const char *, Py_ssize_t, const char *)
     * }
     */
    public static MethodHandle PyBytes_DecodeEscape$handle() {
        return PyBytes_DecodeEscape.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyBytes_DecodeEscape(const char *, Py_ssize_t, const char *, Py_ssize_t, const char *)
     * }
     */
    public static MemorySegment PyBytes_DecodeEscape$address() {
        return PyBytes_DecodeEscape.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyBytes_DecodeEscape(const char *, Py_ssize_t, const char *, Py_ssize_t, const char *)
     * }
     */
    public static MemorySegment PyBytes_DecodeEscape(MemorySegment x0, long x1, MemorySegment x2, long x3, MemorySegment x4) {
        var mh$ = PyBytes_DecodeEscape.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyBytes_DecodeEscape", x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyBytes_AsStringAndSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyBytes_AsStringAndSize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyBytes_AsStringAndSize(PyObject *obj, char **s, Py_ssize_t *len)
     * }
     */
    public static FunctionDescriptor PyBytes_AsStringAndSize$descriptor() {
        return PyBytes_AsStringAndSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyBytes_AsStringAndSize(PyObject *obj, char **s, Py_ssize_t *len)
     * }
     */
    public static MethodHandle PyBytes_AsStringAndSize$handle() {
        return PyBytes_AsStringAndSize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyBytes_AsStringAndSize(PyObject *obj, char **s, Py_ssize_t *len)
     * }
     */
    public static MemorySegment PyBytes_AsStringAndSize$address() {
        return PyBytes_AsStringAndSize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyBytes_AsStringAndSize(PyObject *obj, char **s, Py_ssize_t *len)
     * }
     */
    public static int PyBytes_AsStringAndSize(MemorySegment obj, MemorySegment s, MemorySegment len) {
        var mh$ = PyBytes_AsStringAndSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyBytes_AsStringAndSize", obj, s, len);
            }
            return (int)mh$.invokeExact(obj, s, len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyBytes_Resize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyBytes_Resize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyBytes_Resize(PyObject **, Py_ssize_t)
     * }
     */
    public static FunctionDescriptor _PyBytes_Resize$descriptor() {
        return _PyBytes_Resize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyBytes_Resize(PyObject **, Py_ssize_t)
     * }
     */
    public static MethodHandle _PyBytes_Resize$handle() {
        return _PyBytes_Resize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyBytes_Resize(PyObject **, Py_ssize_t)
     * }
     */
    public static MemorySegment _PyBytes_Resize$address() {
        return _PyBytes_Resize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyBytes_Resize(PyObject **, Py_ssize_t)
     * }
     */
    public static int _PyBytes_Resize(MemorySegment x0, long x1) {
        var mh$ = _PyBytes_Resize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyBytes_Resize", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyBytes_FormatEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyBytes_FormatEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *_PyBytes_FormatEx(const char *format, Py_ssize_t format_len, PyObject *args, int use_bytearray)
     * }
     */
    public static FunctionDescriptor _PyBytes_FormatEx$descriptor() {
        return _PyBytes_FormatEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *_PyBytes_FormatEx(const char *format, Py_ssize_t format_len, PyObject *args, int use_bytearray)
     * }
     */
    public static MethodHandle _PyBytes_FormatEx$handle() {
        return _PyBytes_FormatEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *_PyBytes_FormatEx(const char *format, Py_ssize_t format_len, PyObject *args, int use_bytearray)
     * }
     */
    public static MemorySegment _PyBytes_FormatEx$address() {
        return _PyBytes_FormatEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *_PyBytes_FormatEx(const char *format, Py_ssize_t format_len, PyObject *args, int use_bytearray)
     * }
     */
    public static MemorySegment _PyBytes_FormatEx(MemorySegment format, long format_len, MemorySegment args, int use_bytearray) {
        var mh$ = _PyBytes_FormatEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyBytes_FormatEx", format, format_len, args, use_bytearray);
            }
            return (MemorySegment)mh$.invokeExact(format, format_len, args, use_bytearray);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyBytes_FromHex {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyBytes_FromHex");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *_PyBytes_FromHex(PyObject *string, int use_bytearray)
     * }
     */
    public static FunctionDescriptor _PyBytes_FromHex$descriptor() {
        return _PyBytes_FromHex.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *_PyBytes_FromHex(PyObject *string, int use_bytearray)
     * }
     */
    public static MethodHandle _PyBytes_FromHex$handle() {
        return _PyBytes_FromHex.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *_PyBytes_FromHex(PyObject *string, int use_bytearray)
     * }
     */
    public static MemorySegment _PyBytes_FromHex$address() {
        return _PyBytes_FromHex.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *_PyBytes_FromHex(PyObject *string, int use_bytearray)
     * }
     */
    public static MemorySegment _PyBytes_FromHex(MemorySegment string, int use_bytearray) {
        var mh$ = _PyBytes_FromHex.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyBytes_FromHex", string, use_bytearray);
            }
            return (MemorySegment)mh$.invokeExact(string, use_bytearray);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyBytes_DecodeEscape {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyBytes_DecodeEscape");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *_PyBytes_DecodeEscape(const char *, Py_ssize_t, const char *, const char **)
     * }
     */
    public static FunctionDescriptor _PyBytes_DecodeEscape$descriptor() {
        return _PyBytes_DecodeEscape.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *_PyBytes_DecodeEscape(const char *, Py_ssize_t, const char *, const char **)
     * }
     */
    public static MethodHandle _PyBytes_DecodeEscape$handle() {
        return _PyBytes_DecodeEscape.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *_PyBytes_DecodeEscape(const char *, Py_ssize_t, const char *, const char **)
     * }
     */
    public static MemorySegment _PyBytes_DecodeEscape$address() {
        return _PyBytes_DecodeEscape.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *_PyBytes_DecodeEscape(const char *, Py_ssize_t, const char *, const char **)
     * }
     */
    public static MemorySegment _PyBytes_DecodeEscape(MemorySegment x0, long x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = _PyBytes_DecodeEscape.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyBytes_DecodeEscape", x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyBytes_Join {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyBytes_Join");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *_PyBytes_Join(PyObject *sep, PyObject *x)
     * }
     */
    public static FunctionDescriptor _PyBytes_Join$descriptor() {
        return _PyBytes_Join.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *_PyBytes_Join(PyObject *sep, PyObject *x)
     * }
     */
    public static MethodHandle _PyBytes_Join$handle() {
        return _PyBytes_Join.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *_PyBytes_Join(PyObject *sep, PyObject *x)
     * }
     */
    public static MemorySegment _PyBytes_Join$address() {
        return _PyBytes_Join.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *_PyBytes_Join(PyObject *sep, PyObject *x)
     * }
     */
    public static MemorySegment _PyBytes_Join(MemorySegment sep, MemorySegment x) {
        var mh$ = _PyBytes_Join.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyBytes_Join", sep, x);
            }
            return (MemorySegment)mh$.invokeExact(sep, x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyBytesWriter_Init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyBytesWriter_Init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _PyBytesWriter_Init(_PyBytesWriter *writer)
     * }
     */
    public static FunctionDescriptor _PyBytesWriter_Init$descriptor() {
        return _PyBytesWriter_Init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _PyBytesWriter_Init(_PyBytesWriter *writer)
     * }
     */
    public static MethodHandle _PyBytesWriter_Init$handle() {
        return _PyBytesWriter_Init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _PyBytesWriter_Init(_PyBytesWriter *writer)
     * }
     */
    public static MemorySegment _PyBytesWriter_Init$address() {
        return _PyBytesWriter_Init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _PyBytesWriter_Init(_PyBytesWriter *writer)
     * }
     */
    public static void _PyBytesWriter_Init(MemorySegment writer) {
        var mh$ = _PyBytesWriter_Init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyBytesWriter_Init", writer);
            }
            mh$.invokeExact(writer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyBytesWriter_Finish {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyBytesWriter_Finish");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *_PyBytesWriter_Finish(_PyBytesWriter *writer, void *str)
     * }
     */
    public static FunctionDescriptor _PyBytesWriter_Finish$descriptor() {
        return _PyBytesWriter_Finish.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *_PyBytesWriter_Finish(_PyBytesWriter *writer, void *str)
     * }
     */
    public static MethodHandle _PyBytesWriter_Finish$handle() {
        return _PyBytesWriter_Finish.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *_PyBytesWriter_Finish(_PyBytesWriter *writer, void *str)
     * }
     */
    public static MemorySegment _PyBytesWriter_Finish$address() {
        return _PyBytesWriter_Finish.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *_PyBytesWriter_Finish(_PyBytesWriter *writer, void *str)
     * }
     */
    public static MemorySegment _PyBytesWriter_Finish(MemorySegment writer, MemorySegment str) {
        var mh$ = _PyBytesWriter_Finish.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyBytesWriter_Finish", writer, str);
            }
            return (MemorySegment)mh$.invokeExact(writer, str);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyBytesWriter_Dealloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyBytesWriter_Dealloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _PyBytesWriter_Dealloc(_PyBytesWriter *writer)
     * }
     */
    public static FunctionDescriptor _PyBytesWriter_Dealloc$descriptor() {
        return _PyBytesWriter_Dealloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _PyBytesWriter_Dealloc(_PyBytesWriter *writer)
     * }
     */
    public static MethodHandle _PyBytesWriter_Dealloc$handle() {
        return _PyBytesWriter_Dealloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _PyBytesWriter_Dealloc(_PyBytesWriter *writer)
     * }
     */
    public static MemorySegment _PyBytesWriter_Dealloc$address() {
        return _PyBytesWriter_Dealloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _PyBytesWriter_Dealloc(_PyBytesWriter *writer)
     * }
     */
    public static void _PyBytesWriter_Dealloc(MemorySegment writer) {
        var mh$ = _PyBytesWriter_Dealloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyBytesWriter_Dealloc", writer);
            }
            mh$.invokeExact(writer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyBytesWriter_Alloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyBytesWriter_Alloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *_PyBytesWriter_Alloc(_PyBytesWriter *writer, Py_ssize_t size)
     * }
     */
    public static FunctionDescriptor _PyBytesWriter_Alloc$descriptor() {
        return _PyBytesWriter_Alloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *_PyBytesWriter_Alloc(_PyBytesWriter *writer, Py_ssize_t size)
     * }
     */
    public static MethodHandle _PyBytesWriter_Alloc$handle() {
        return _PyBytesWriter_Alloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *_PyBytesWriter_Alloc(_PyBytesWriter *writer, Py_ssize_t size)
     * }
     */
    public static MemorySegment _PyBytesWriter_Alloc$address() {
        return _PyBytesWriter_Alloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *_PyBytesWriter_Alloc(_PyBytesWriter *writer, Py_ssize_t size)
     * }
     */
    public static MemorySegment _PyBytesWriter_Alloc(MemorySegment writer, long size) {
        var mh$ = _PyBytesWriter_Alloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyBytesWriter_Alloc", writer, size);
            }
            return (MemorySegment)mh$.invokeExact(writer, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyBytesWriter_Prepare {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyBytesWriter_Prepare");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *_PyBytesWriter_Prepare(_PyBytesWriter *writer, void *str, Py_ssize_t size)
     * }
     */
    public static FunctionDescriptor _PyBytesWriter_Prepare$descriptor() {
        return _PyBytesWriter_Prepare.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *_PyBytesWriter_Prepare(_PyBytesWriter *writer, void *str, Py_ssize_t size)
     * }
     */
    public static MethodHandle _PyBytesWriter_Prepare$handle() {
        return _PyBytesWriter_Prepare.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *_PyBytesWriter_Prepare(_PyBytesWriter *writer, void *str, Py_ssize_t size)
     * }
     */
    public static MemorySegment _PyBytesWriter_Prepare$address() {
        return _PyBytesWriter_Prepare.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *_PyBytesWriter_Prepare(_PyBytesWriter *writer, void *str, Py_ssize_t size)
     * }
     */
    public static MemorySegment _PyBytesWriter_Prepare(MemorySegment writer, MemorySegment str, long size) {
        var mh$ = _PyBytesWriter_Prepare.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyBytesWriter_Prepare", writer, str, size);
            }
            return (MemorySegment)mh$.invokeExact(writer, str, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyBytesWriter_Resize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyBytesWriter_Resize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *_PyBytesWriter_Resize(_PyBytesWriter *writer, void *str, Py_ssize_t size)
     * }
     */
    public static FunctionDescriptor _PyBytesWriter_Resize$descriptor() {
        return _PyBytesWriter_Resize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *_PyBytesWriter_Resize(_PyBytesWriter *writer, void *str, Py_ssize_t size)
     * }
     */
    public static MethodHandle _PyBytesWriter_Resize$handle() {
        return _PyBytesWriter_Resize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *_PyBytesWriter_Resize(_PyBytesWriter *writer, void *str, Py_ssize_t size)
     * }
     */
    public static MemorySegment _PyBytesWriter_Resize$address() {
        return _PyBytesWriter_Resize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *_PyBytesWriter_Resize(_PyBytesWriter *writer, void *str, Py_ssize_t size)
     * }
     */
    public static MemorySegment _PyBytesWriter_Resize(MemorySegment writer, MemorySegment str, long size) {
        var mh$ = _PyBytesWriter_Resize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyBytesWriter_Resize", writer, str, size);
            }
            return (MemorySegment)mh$.invokeExact(writer, str, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyBytesWriter_WriteBytes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyBytesWriter_WriteBytes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *_PyBytesWriter_WriteBytes(_PyBytesWriter *writer, void *str, const void *bytes, Py_ssize_t size)
     * }
     */
    public static FunctionDescriptor _PyBytesWriter_WriteBytes$descriptor() {
        return _PyBytesWriter_WriteBytes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *_PyBytesWriter_WriteBytes(_PyBytesWriter *writer, void *str, const void *bytes, Py_ssize_t size)
     * }
     */
    public static MethodHandle _PyBytesWriter_WriteBytes$handle() {
        return _PyBytesWriter_WriteBytes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *_PyBytesWriter_WriteBytes(_PyBytesWriter *writer, void *str, const void *bytes, Py_ssize_t size)
     * }
     */
    public static MemorySegment _PyBytesWriter_WriteBytes$address() {
        return _PyBytesWriter_WriteBytes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *_PyBytesWriter_WriteBytes(_PyBytesWriter *writer, void *str, const void *bytes, Py_ssize_t size)
     * }
     */
    public static MemorySegment _PyBytesWriter_WriteBytes(MemorySegment writer, MemorySegment str, MemorySegment bytes, long size) {
        var mh$ = _PyBytesWriter_WriteBytes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyBytesWriter_WriteBytes", writer, str, bytes, size);
            }
            return (MemorySegment)mh$.invokeExact(writer, str, bytes, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _isctype {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_isctype");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _isctype(int _C, int _Type)
     * }
     */
    public static FunctionDescriptor _isctype$descriptor() {
        return _isctype.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _isctype(int _C, int _Type)
     * }
     */
    public static MethodHandle _isctype$handle() {
        return _isctype.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _isctype(int _C, int _Type)
     * }
     */
    public static MemorySegment _isctype$address() {
        return _isctype.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _isctype(int _C, int _Type)
     * }
     */
    public static int _isctype(int _C, int _Type) {
        var mh$ = _isctype.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_isctype", _C, _Type);
            }
            return (int)mh$.invokeExact(_C, _Type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _isctype_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_isctype_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _isctype_l(int _C, int _Type, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _isctype_l$descriptor() {
        return _isctype_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _isctype_l(int _C, int _Type, _locale_t _Locale)
     * }
     */
    public static MethodHandle _isctype_l$handle() {
        return _isctype_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _isctype_l(int _C, int _Type, _locale_t _Locale)
     * }
     */
    public static MemorySegment _isctype_l$address() {
        return _isctype_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _isctype_l(int _C, int _Type, _locale_t _Locale)
     * }
     */
    public static int _isctype_l(int _C, int _Type, MemorySegment _Locale) {
        var mh$ = _isctype_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_isctype_l", _C, _Type, _Locale);
            }
            return (int)mh$.invokeExact(_C, _Type, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class isalpha {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("isalpha");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int isalpha(int _C)
     * }
     */
    public static FunctionDescriptor isalpha$descriptor() {
        return isalpha.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int isalpha(int _C)
     * }
     */
    public static MethodHandle isalpha$handle() {
        return isalpha.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int isalpha(int _C)
     * }
     */
    public static MemorySegment isalpha$address() {
        return isalpha.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int isalpha(int _C)
     * }
     */
    public static int isalpha(int _C) {
        var mh$ = isalpha.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("isalpha", _C);
            }
            return (int)mh$.invokeExact(_C);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _isalpha_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_isalpha_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _isalpha_l(int _C, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _isalpha_l$descriptor() {
        return _isalpha_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _isalpha_l(int _C, _locale_t _Locale)
     * }
     */
    public static MethodHandle _isalpha_l$handle() {
        return _isalpha_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _isalpha_l(int _C, _locale_t _Locale)
     * }
     */
    public static MemorySegment _isalpha_l$address() {
        return _isalpha_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _isalpha_l(int _C, _locale_t _Locale)
     * }
     */
    public static int _isalpha_l(int _C, MemorySegment _Locale) {
        var mh$ = _isalpha_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_isalpha_l", _C, _Locale);
            }
            return (int)mh$.invokeExact(_C, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class isupper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("isupper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int isupper(int _C)
     * }
     */
    public static FunctionDescriptor isupper$descriptor() {
        return isupper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int isupper(int _C)
     * }
     */
    public static MethodHandle isupper$handle() {
        return isupper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int isupper(int _C)
     * }
     */
    public static MemorySegment isupper$address() {
        return isupper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int isupper(int _C)
     * }
     */
    public static int isupper(int _C) {
        var mh$ = isupper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("isupper", _C);
            }
            return (int)mh$.invokeExact(_C);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _isupper_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_isupper_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _isupper_l(int _C, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _isupper_l$descriptor() {
        return _isupper_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _isupper_l(int _C, _locale_t _Locale)
     * }
     */
    public static MethodHandle _isupper_l$handle() {
        return _isupper_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _isupper_l(int _C, _locale_t _Locale)
     * }
     */
    public static MemorySegment _isupper_l$address() {
        return _isupper_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _isupper_l(int _C, _locale_t _Locale)
     * }
     */
    public static int _isupper_l(int _C, MemorySegment _Locale) {
        var mh$ = _isupper_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_isupper_l", _C, _Locale);
            }
            return (int)mh$.invokeExact(_C, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class islower {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("islower");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int islower(int _C)
     * }
     */
    public static FunctionDescriptor islower$descriptor() {
        return islower.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int islower(int _C)
     * }
     */
    public static MethodHandle islower$handle() {
        return islower.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int islower(int _C)
     * }
     */
    public static MemorySegment islower$address() {
        return islower.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int islower(int _C)
     * }
     */
    public static int islower(int _C) {
        var mh$ = islower.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("islower", _C);
            }
            return (int)mh$.invokeExact(_C);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _islower_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_islower_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _islower_l(int _C, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _islower_l$descriptor() {
        return _islower_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _islower_l(int _C, _locale_t _Locale)
     * }
     */
    public static MethodHandle _islower_l$handle() {
        return _islower_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _islower_l(int _C, _locale_t _Locale)
     * }
     */
    public static MemorySegment _islower_l$address() {
        return _islower_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _islower_l(int _C, _locale_t _Locale)
     * }
     */
    public static int _islower_l(int _C, MemorySegment _Locale) {
        var mh$ = _islower_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_islower_l", _C, _Locale);
            }
            return (int)mh$.invokeExact(_C, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class isdigit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("isdigit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int isdigit(int _C)
     * }
     */
    public static FunctionDescriptor isdigit$descriptor() {
        return isdigit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int isdigit(int _C)
     * }
     */
    public static MethodHandle isdigit$handle() {
        return isdigit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int isdigit(int _C)
     * }
     */
    public static MemorySegment isdigit$address() {
        return isdigit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int isdigit(int _C)
     * }
     */
    public static int isdigit(int _C) {
        var mh$ = isdigit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("isdigit", _C);
            }
            return (int)mh$.invokeExact(_C);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _isdigit_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_isdigit_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _isdigit_l(int _C, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _isdigit_l$descriptor() {
        return _isdigit_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _isdigit_l(int _C, _locale_t _Locale)
     * }
     */
    public static MethodHandle _isdigit_l$handle() {
        return _isdigit_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _isdigit_l(int _C, _locale_t _Locale)
     * }
     */
    public static MemorySegment _isdigit_l$address() {
        return _isdigit_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _isdigit_l(int _C, _locale_t _Locale)
     * }
     */
    public static int _isdigit_l(int _C, MemorySegment _Locale) {
        var mh$ = _isdigit_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_isdigit_l", _C, _Locale);
            }
            return (int)mh$.invokeExact(_C, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class isxdigit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("isxdigit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int isxdigit(int _C)
     * }
     */
    public static FunctionDescriptor isxdigit$descriptor() {
        return isxdigit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int isxdigit(int _C)
     * }
     */
    public static MethodHandle isxdigit$handle() {
        return isxdigit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int isxdigit(int _C)
     * }
     */
    public static MemorySegment isxdigit$address() {
        return isxdigit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int isxdigit(int _C)
     * }
     */
    public static int isxdigit(int _C) {
        var mh$ = isxdigit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("isxdigit", _C);
            }
            return (int)mh$.invokeExact(_C);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _isxdigit_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_isxdigit_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _isxdigit_l(int _C, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _isxdigit_l$descriptor() {
        return _isxdigit_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _isxdigit_l(int _C, _locale_t _Locale)
     * }
     */
    public static MethodHandle _isxdigit_l$handle() {
        return _isxdigit_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _isxdigit_l(int _C, _locale_t _Locale)
     * }
     */
    public static MemorySegment _isxdigit_l$address() {
        return _isxdigit_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _isxdigit_l(int _C, _locale_t _Locale)
     * }
     */
    public static int _isxdigit_l(int _C, MemorySegment _Locale) {
        var mh$ = _isxdigit_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_isxdigit_l", _C, _Locale);
            }
            return (int)mh$.invokeExact(_C, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class isspace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("isspace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int isspace(int _C)
     * }
     */
    public static FunctionDescriptor isspace$descriptor() {
        return isspace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int isspace(int _C)
     * }
     */
    public static MethodHandle isspace$handle() {
        return isspace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int isspace(int _C)
     * }
     */
    public static MemorySegment isspace$address() {
        return isspace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int isspace(int _C)
     * }
     */
    public static int isspace(int _C) {
        var mh$ = isspace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("isspace", _C);
            }
            return (int)mh$.invokeExact(_C);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _isspace_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_isspace_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _isspace_l(int _C, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _isspace_l$descriptor() {
        return _isspace_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _isspace_l(int _C, _locale_t _Locale)
     * }
     */
    public static MethodHandle _isspace_l$handle() {
        return _isspace_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _isspace_l(int _C, _locale_t _Locale)
     * }
     */
    public static MemorySegment _isspace_l$address() {
        return _isspace_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _isspace_l(int _C, _locale_t _Locale)
     * }
     */
    public static int _isspace_l(int _C, MemorySegment _Locale) {
        var mh$ = _isspace_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_isspace_l", _C, _Locale);
            }
            return (int)mh$.invokeExact(_C, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ispunct {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("ispunct");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ispunct(int _C)
     * }
     */
    public static FunctionDescriptor ispunct$descriptor() {
        return ispunct.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ispunct(int _C)
     * }
     */
    public static MethodHandle ispunct$handle() {
        return ispunct.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ispunct(int _C)
     * }
     */
    public static MemorySegment ispunct$address() {
        return ispunct.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ispunct(int _C)
     * }
     */
    public static int ispunct(int _C) {
        var mh$ = ispunct.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ispunct", _C);
            }
            return (int)mh$.invokeExact(_C);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ispunct_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_ispunct_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _ispunct_l(int _C, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _ispunct_l$descriptor() {
        return _ispunct_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _ispunct_l(int _C, _locale_t _Locale)
     * }
     */
    public static MethodHandle _ispunct_l$handle() {
        return _ispunct_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _ispunct_l(int _C, _locale_t _Locale)
     * }
     */
    public static MemorySegment _ispunct_l$address() {
        return _ispunct_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _ispunct_l(int _C, _locale_t _Locale)
     * }
     */
    public static int _ispunct_l(int _C, MemorySegment _Locale) {
        var mh$ = _ispunct_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ispunct_l", _C, _Locale);
            }
            return (int)mh$.invokeExact(_C, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class isblank {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("isblank");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int isblank(int _C)
     * }
     */
    public static FunctionDescriptor isblank$descriptor() {
        return isblank.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int isblank(int _C)
     * }
     */
    public static MethodHandle isblank$handle() {
        return isblank.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int isblank(int _C)
     * }
     */
    public static MemorySegment isblank$address() {
        return isblank.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int isblank(int _C)
     * }
     */
    public static int isblank(int _C) {
        var mh$ = isblank.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("isblank", _C);
            }
            return (int)mh$.invokeExact(_C);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _isblank_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_isblank_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _isblank_l(int _C, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _isblank_l$descriptor() {
        return _isblank_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _isblank_l(int _C, _locale_t _Locale)
     * }
     */
    public static MethodHandle _isblank_l$handle() {
        return _isblank_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _isblank_l(int _C, _locale_t _Locale)
     * }
     */
    public static MemorySegment _isblank_l$address() {
        return _isblank_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _isblank_l(int _C, _locale_t _Locale)
     * }
     */
    public static int _isblank_l(int _C, MemorySegment _Locale) {
        var mh$ = _isblank_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_isblank_l", _C, _Locale);
            }
            return (int)mh$.invokeExact(_C, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class isalnum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("isalnum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int isalnum(int _C)
     * }
     */
    public static FunctionDescriptor isalnum$descriptor() {
        return isalnum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int isalnum(int _C)
     * }
     */
    public static MethodHandle isalnum$handle() {
        return isalnum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int isalnum(int _C)
     * }
     */
    public static MemorySegment isalnum$address() {
        return isalnum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int isalnum(int _C)
     * }
     */
    public static int isalnum(int _C) {
        var mh$ = isalnum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("isalnum", _C);
            }
            return (int)mh$.invokeExact(_C);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _isalnum_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_isalnum_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _isalnum_l(int _C, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _isalnum_l$descriptor() {
        return _isalnum_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _isalnum_l(int _C, _locale_t _Locale)
     * }
     */
    public static MethodHandle _isalnum_l$handle() {
        return _isalnum_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _isalnum_l(int _C, _locale_t _Locale)
     * }
     */
    public static MemorySegment _isalnum_l$address() {
        return _isalnum_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _isalnum_l(int _C, _locale_t _Locale)
     * }
     */
    public static int _isalnum_l(int _C, MemorySegment _Locale) {
        var mh$ = _isalnum_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_isalnum_l", _C, _Locale);
            }
            return (int)mh$.invokeExact(_C, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class isprint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("isprint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int isprint(int _C)
     * }
     */
    public static FunctionDescriptor isprint$descriptor() {
        return isprint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int isprint(int _C)
     * }
     */
    public static MethodHandle isprint$handle() {
        return isprint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int isprint(int _C)
     * }
     */
    public static MemorySegment isprint$address() {
        return isprint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int isprint(int _C)
     * }
     */
    public static int isprint(int _C) {
        var mh$ = isprint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("isprint", _C);
            }
            return (int)mh$.invokeExact(_C);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _isprint_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_isprint_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _isprint_l(int _C, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _isprint_l$descriptor() {
        return _isprint_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _isprint_l(int _C, _locale_t _Locale)
     * }
     */
    public static MethodHandle _isprint_l$handle() {
        return _isprint_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _isprint_l(int _C, _locale_t _Locale)
     * }
     */
    public static MemorySegment _isprint_l$address() {
        return _isprint_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _isprint_l(int _C, _locale_t _Locale)
     * }
     */
    public static int _isprint_l(int _C, MemorySegment _Locale) {
        var mh$ = _isprint_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_isprint_l", _C, _Locale);
            }
            return (int)mh$.invokeExact(_C, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class isgraph {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("isgraph");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int isgraph(int _C)
     * }
     */
    public static FunctionDescriptor isgraph$descriptor() {
        return isgraph.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int isgraph(int _C)
     * }
     */
    public static MethodHandle isgraph$handle() {
        return isgraph.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int isgraph(int _C)
     * }
     */
    public static MemorySegment isgraph$address() {
        return isgraph.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int isgraph(int _C)
     * }
     */
    public static int isgraph(int _C) {
        var mh$ = isgraph.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("isgraph", _C);
            }
            return (int)mh$.invokeExact(_C);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _isgraph_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_isgraph_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _isgraph_l(int _C, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _isgraph_l$descriptor() {
        return _isgraph_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _isgraph_l(int _C, _locale_t _Locale)
     * }
     */
    public static MethodHandle _isgraph_l$handle() {
        return _isgraph_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _isgraph_l(int _C, _locale_t _Locale)
     * }
     */
    public static MemorySegment _isgraph_l$address() {
        return _isgraph_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _isgraph_l(int _C, _locale_t _Locale)
     * }
     */
    public static int _isgraph_l(int _C, MemorySegment _Locale) {
        var mh$ = _isgraph_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_isgraph_l", _C, _Locale);
            }
            return (int)mh$.invokeExact(_C, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class iscntrl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("iscntrl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int iscntrl(int _C)
     * }
     */
    public static FunctionDescriptor iscntrl$descriptor() {
        return iscntrl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int iscntrl(int _C)
     * }
     */
    public static MethodHandle iscntrl$handle() {
        return iscntrl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int iscntrl(int _C)
     * }
     */
    public static MemorySegment iscntrl$address() {
        return iscntrl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int iscntrl(int _C)
     * }
     */
    public static int iscntrl(int _C) {
        var mh$ = iscntrl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("iscntrl", _C);
            }
            return (int)mh$.invokeExact(_C);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _iscntrl_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_iscntrl_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _iscntrl_l(int _C, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _iscntrl_l$descriptor() {
        return _iscntrl_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _iscntrl_l(int _C, _locale_t _Locale)
     * }
     */
    public static MethodHandle _iscntrl_l$handle() {
        return _iscntrl_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _iscntrl_l(int _C, _locale_t _Locale)
     * }
     */
    public static MemorySegment _iscntrl_l$address() {
        return _iscntrl_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _iscntrl_l(int _C, _locale_t _Locale)
     * }
     */
    public static int _iscntrl_l(int _C, MemorySegment _Locale) {
        var mh$ = _iscntrl_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_iscntrl_l", _C, _Locale);
            }
            return (int)mh$.invokeExact(_C, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class toupper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("toupper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int toupper(int _C)
     * }
     */
    public static FunctionDescriptor toupper$descriptor() {
        return toupper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int toupper(int _C)
     * }
     */
    public static MethodHandle toupper$handle() {
        return toupper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int toupper(int _C)
     * }
     */
    public static MemorySegment toupper$address() {
        return toupper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int toupper(int _C)
     * }
     */
    public static int toupper(int _C) {
        var mh$ = toupper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("toupper", _C);
            }
            return (int)mh$.invokeExact(_C);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tolower {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("tolower");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int tolower(int _C)
     * }
     */
    public static FunctionDescriptor tolower$descriptor() {
        return tolower.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int tolower(int _C)
     * }
     */
    public static MethodHandle tolower$handle() {
        return tolower.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int tolower(int _C)
     * }
     */
    public static MemorySegment tolower$address() {
        return tolower.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int tolower(int _C)
     * }
     */
    public static int tolower(int _C) {
        var mh$ = tolower.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tolower", _C);
            }
            return (int)mh$.invokeExact(_C);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _tolower {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_tolower");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _tolower(int _C)
     * }
     */
    public static FunctionDescriptor _tolower$descriptor() {
        return _tolower.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _tolower(int _C)
     * }
     */
    public static MethodHandle _tolower$handle() {
        return _tolower.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _tolower(int _C)
     * }
     */
    public static MemorySegment _tolower$address() {
        return _tolower.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _tolower(int _C)
     * }
     */
    public static int _tolower(int _C) {
        var mh$ = _tolower.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_tolower", _C);
            }
            return (int)mh$.invokeExact(_C);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _tolower_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_tolower_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _tolower_l(int _C, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _tolower_l$descriptor() {
        return _tolower_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _tolower_l(int _C, _locale_t _Locale)
     * }
     */
    public static MethodHandle _tolower_l$handle() {
        return _tolower_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _tolower_l(int _C, _locale_t _Locale)
     * }
     */
    public static MemorySegment _tolower_l$address() {
        return _tolower_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _tolower_l(int _C, _locale_t _Locale)
     * }
     */
    public static int _tolower_l(int _C, MemorySegment _Locale) {
        var mh$ = _tolower_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_tolower_l", _C, _Locale);
            }
            return (int)mh$.invokeExact(_C, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _toupper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_toupper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _toupper(int _C)
     * }
     */
    public static FunctionDescriptor _toupper$descriptor() {
        return _toupper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _toupper(int _C)
     * }
     */
    public static MethodHandle _toupper$handle() {
        return _toupper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _toupper(int _C)
     * }
     */
    public static MemorySegment _toupper$address() {
        return _toupper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _toupper(int _C)
     * }
     */
    public static int _toupper(int _C) {
        var mh$ = _toupper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_toupper", _C);
            }
            return (int)mh$.invokeExact(_C);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _toupper_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_toupper_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _toupper_l(int _C, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _toupper_l$descriptor() {
        return _toupper_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _toupper_l(int _C, _locale_t _Locale)
     * }
     */
    public static MethodHandle _toupper_l$handle() {
        return _toupper_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _toupper_l(int _C, _locale_t _Locale)
     * }
     */
    public static MemorySegment _toupper_l$address() {
        return _toupper_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _toupper_l(int _C, _locale_t _Locale)
     * }
     */
    public static int _toupper_l(int _C, MemorySegment _Locale) {
        var mh$ = _toupper_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_toupper_l", _C, _Locale);
            }
            return (int)mh$.invokeExact(_C, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __isascii {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("__isascii");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __isascii(int _C)
     * }
     */
    public static FunctionDescriptor __isascii$descriptor() {
        return __isascii.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __isascii(int _C)
     * }
     */
    public static MethodHandle __isascii$handle() {
        return __isascii.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __isascii(int _C)
     * }
     */
    public static MemorySegment __isascii$address() {
        return __isascii.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __isascii(int _C)
     * }
     */
    public static int __isascii(int _C) {
        var mh$ = __isascii.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__isascii", _C);
            }
            return (int)mh$.invokeExact(_C);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __toascii {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("__toascii");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __toascii(int _C)
     * }
     */
    public static FunctionDescriptor __toascii$descriptor() {
        return __toascii.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __toascii(int _C)
     * }
     */
    public static MethodHandle __toascii$handle() {
        return __toascii.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __toascii(int _C)
     * }
     */
    public static MemorySegment __toascii$address() {
        return __toascii.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __toascii(int _C)
     * }
     */
    public static int __toascii(int _C) {
        var mh$ = __toascii.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__toascii", _C);
            }
            return (int)mh$.invokeExact(_C);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __iscsymf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("__iscsymf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __iscsymf(int _C)
     * }
     */
    public static FunctionDescriptor __iscsymf$descriptor() {
        return __iscsymf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __iscsymf(int _C)
     * }
     */
    public static MethodHandle __iscsymf$handle() {
        return __iscsymf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __iscsymf(int _C)
     * }
     */
    public static MemorySegment __iscsymf$address() {
        return __iscsymf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __iscsymf(int _C)
     * }
     */
    public static int __iscsymf(int _C) {
        var mh$ = __iscsymf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__iscsymf", _C);
            }
            return (int)mh$.invokeExact(_C);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __iscsym {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("__iscsym");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __iscsym(int _C)
     * }
     */
    public static FunctionDescriptor __iscsym$descriptor() {
        return __iscsym.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __iscsym(int _C)
     * }
     */
    public static MethodHandle __iscsym$handle() {
        return __iscsym.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __iscsym(int _C)
     * }
     */
    public static MemorySegment __iscsym$address() {
        return __iscsym.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __iscsym(int _C)
     * }
     */
    public static int __iscsym(int _C) {
        var mh$ = __iscsym.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__iscsym", _C);
            }
            return (int)mh$.invokeExact(_C);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef uint32_t Py_UCS4
     * }
     */
    public static final OfInt Py_UCS4 = Python_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef uint16_t Py_UCS2
     * }
     */
    public static final OfShort Py_UCS2 = Python_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef uint8_t Py_UCS1
     * }
     */
    public static final OfByte Py_UCS1 = Python_h.C_CHAR;

    private static class PyUnicode_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyUnicode_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyUnicode_Type
     * }
     */
    public static GroupLayout PyUnicode_Type$layout() {
        return PyUnicode_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyUnicode_Type
     * }
     */
    public static MemorySegment PyUnicode_Type() {
        return PyUnicode_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyUnicode_Type
     * }
     */
    public static void PyUnicode_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyUnicode_Type$constants.SEGMENT, 0L, PyUnicode_Type$constants.LAYOUT.byteSize());
    }

    private static class PyUnicodeIter_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyUnicodeIter_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyUnicodeIter_Type
     * }
     */
    public static GroupLayout PyUnicodeIter_Type$layout() {
        return PyUnicodeIter_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyUnicodeIter_Type
     * }
     */
    public static MemorySegment PyUnicodeIter_Type() {
        return PyUnicodeIter_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyUnicodeIter_Type
     * }
     */
    public static void PyUnicodeIter_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyUnicodeIter_Type$constants.SEGMENT, 0L, PyUnicodeIter_Type$constants.LAYOUT.byteSize());
    }

    private static class PyUnicode_FromStringAndSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_FromStringAndSize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_FromStringAndSize(const char *u, Py_ssize_t size)
     * }
     */
    public static FunctionDescriptor PyUnicode_FromStringAndSize$descriptor() {
        return PyUnicode_FromStringAndSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_FromStringAndSize(const char *u, Py_ssize_t size)
     * }
     */
    public static MethodHandle PyUnicode_FromStringAndSize$handle() {
        return PyUnicode_FromStringAndSize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_FromStringAndSize(const char *u, Py_ssize_t size)
     * }
     */
    public static MemorySegment PyUnicode_FromStringAndSize$address() {
        return PyUnicode_FromStringAndSize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_FromStringAndSize(const char *u, Py_ssize_t size)
     * }
     */
    public static MemorySegment PyUnicode_FromStringAndSize(MemorySegment u, long size) {
        var mh$ = PyUnicode_FromStringAndSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_FromStringAndSize", u, size);
            }
            return (MemorySegment)mh$.invokeExact(u, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_FromString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_FromString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_FromString(const char *u)
     * }
     */
    public static FunctionDescriptor PyUnicode_FromString$descriptor() {
        return PyUnicode_FromString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_FromString(const char *u)
     * }
     */
    public static MethodHandle PyUnicode_FromString$handle() {
        return PyUnicode_FromString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_FromString(const char *u)
     * }
     */
    public static MemorySegment PyUnicode_FromString$address() {
        return PyUnicode_FromString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_FromString(const char *u)
     * }
     */
    public static MemorySegment PyUnicode_FromString(MemorySegment u) {
        var mh$ = PyUnicode_FromString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_FromString", u);
            }
            return (MemorySegment)mh$.invokeExact(u);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_Substring {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_Substring");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_Substring(PyObject *str, Py_ssize_t start, Py_ssize_t end)
     * }
     */
    public static FunctionDescriptor PyUnicode_Substring$descriptor() {
        return PyUnicode_Substring.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_Substring(PyObject *str, Py_ssize_t start, Py_ssize_t end)
     * }
     */
    public static MethodHandle PyUnicode_Substring$handle() {
        return PyUnicode_Substring.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_Substring(PyObject *str, Py_ssize_t start, Py_ssize_t end)
     * }
     */
    public static MemorySegment PyUnicode_Substring$address() {
        return PyUnicode_Substring.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_Substring(PyObject *str, Py_ssize_t start, Py_ssize_t end)
     * }
     */
    public static MemorySegment PyUnicode_Substring(MemorySegment str, long start, long end) {
        var mh$ = PyUnicode_Substring.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_Substring", str, start, end);
            }
            return (MemorySegment)mh$.invokeExact(str, start, end);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_AsUCS4 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_AsUCS4");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_UCS4 *PyUnicode_AsUCS4(PyObject *unicode, Py_UCS4 *buffer, Py_ssize_t buflen, int copy_null)
     * }
     */
    public static FunctionDescriptor PyUnicode_AsUCS4$descriptor() {
        return PyUnicode_AsUCS4.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_UCS4 *PyUnicode_AsUCS4(PyObject *unicode, Py_UCS4 *buffer, Py_ssize_t buflen, int copy_null)
     * }
     */
    public static MethodHandle PyUnicode_AsUCS4$handle() {
        return PyUnicode_AsUCS4.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_UCS4 *PyUnicode_AsUCS4(PyObject *unicode, Py_UCS4 *buffer, Py_ssize_t buflen, int copy_null)
     * }
     */
    public static MemorySegment PyUnicode_AsUCS4$address() {
        return PyUnicode_AsUCS4.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_UCS4 *PyUnicode_AsUCS4(PyObject *unicode, Py_UCS4 *buffer, Py_ssize_t buflen, int copy_null)
     * }
     */
    public static MemorySegment PyUnicode_AsUCS4(MemorySegment unicode, MemorySegment buffer, long buflen, int copy_null) {
        var mh$ = PyUnicode_AsUCS4.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_AsUCS4", unicode, buffer, buflen, copy_null);
            }
            return (MemorySegment)mh$.invokeExact(unicode, buffer, buflen, copy_null);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_AsUCS4Copy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_AsUCS4Copy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_UCS4 *PyUnicode_AsUCS4Copy(PyObject *unicode)
     * }
     */
    public static FunctionDescriptor PyUnicode_AsUCS4Copy$descriptor() {
        return PyUnicode_AsUCS4Copy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_UCS4 *PyUnicode_AsUCS4Copy(PyObject *unicode)
     * }
     */
    public static MethodHandle PyUnicode_AsUCS4Copy$handle() {
        return PyUnicode_AsUCS4Copy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_UCS4 *PyUnicode_AsUCS4Copy(PyObject *unicode)
     * }
     */
    public static MemorySegment PyUnicode_AsUCS4Copy$address() {
        return PyUnicode_AsUCS4Copy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_UCS4 *PyUnicode_AsUCS4Copy(PyObject *unicode)
     * }
     */
    public static MemorySegment PyUnicode_AsUCS4Copy(MemorySegment unicode) {
        var mh$ = PyUnicode_AsUCS4Copy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_AsUCS4Copy", unicode);
            }
            return (MemorySegment)mh$.invokeExact(unicode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_GetLength {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_GetLength");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_ssize_t PyUnicode_GetLength(PyObject *unicode)
     * }
     */
    public static FunctionDescriptor PyUnicode_GetLength$descriptor() {
        return PyUnicode_GetLength.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_ssize_t PyUnicode_GetLength(PyObject *unicode)
     * }
     */
    public static MethodHandle PyUnicode_GetLength$handle() {
        return PyUnicode_GetLength.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_ssize_t PyUnicode_GetLength(PyObject *unicode)
     * }
     */
    public static MemorySegment PyUnicode_GetLength$address() {
        return PyUnicode_GetLength.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_ssize_t PyUnicode_GetLength(PyObject *unicode)
     * }
     */
    public static long PyUnicode_GetLength(MemorySegment unicode) {
        var mh$ = PyUnicode_GetLength.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_GetLength", unicode);
            }
            return (long)mh$.invokeExact(unicode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_ReadChar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_ReadChar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_UCS4 PyUnicode_ReadChar(PyObject *unicode, Py_ssize_t index)
     * }
     */
    public static FunctionDescriptor PyUnicode_ReadChar$descriptor() {
        return PyUnicode_ReadChar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_UCS4 PyUnicode_ReadChar(PyObject *unicode, Py_ssize_t index)
     * }
     */
    public static MethodHandle PyUnicode_ReadChar$handle() {
        return PyUnicode_ReadChar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_UCS4 PyUnicode_ReadChar(PyObject *unicode, Py_ssize_t index)
     * }
     */
    public static MemorySegment PyUnicode_ReadChar$address() {
        return PyUnicode_ReadChar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_UCS4 PyUnicode_ReadChar(PyObject *unicode, Py_ssize_t index)
     * }
     */
    public static int PyUnicode_ReadChar(MemorySegment unicode, long index) {
        var mh$ = PyUnicode_ReadChar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_ReadChar", unicode, index);
            }
            return (int)mh$.invokeExact(unicode, index);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_WriteChar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_WriteChar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyUnicode_WriteChar(PyObject *unicode, Py_ssize_t index, Py_UCS4 character)
     * }
     */
    public static FunctionDescriptor PyUnicode_WriteChar$descriptor() {
        return PyUnicode_WriteChar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyUnicode_WriteChar(PyObject *unicode, Py_ssize_t index, Py_UCS4 character)
     * }
     */
    public static MethodHandle PyUnicode_WriteChar$handle() {
        return PyUnicode_WriteChar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyUnicode_WriteChar(PyObject *unicode, Py_ssize_t index, Py_UCS4 character)
     * }
     */
    public static MemorySegment PyUnicode_WriteChar$address() {
        return PyUnicode_WriteChar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyUnicode_WriteChar(PyObject *unicode, Py_ssize_t index, Py_UCS4 character)
     * }
     */
    public static int PyUnicode_WriteChar(MemorySegment unicode, long index, int character) {
        var mh$ = PyUnicode_WriteChar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_WriteChar", unicode, index, character);
            }
            return (int)mh$.invokeExact(unicode, index, character);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_Resize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_Resize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyUnicode_Resize(PyObject **unicode, Py_ssize_t length)
     * }
     */
    public static FunctionDescriptor PyUnicode_Resize$descriptor() {
        return PyUnicode_Resize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyUnicode_Resize(PyObject **unicode, Py_ssize_t length)
     * }
     */
    public static MethodHandle PyUnicode_Resize$handle() {
        return PyUnicode_Resize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyUnicode_Resize(PyObject **unicode, Py_ssize_t length)
     * }
     */
    public static MemorySegment PyUnicode_Resize$address() {
        return PyUnicode_Resize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyUnicode_Resize(PyObject **unicode, Py_ssize_t length)
     * }
     */
    public static int PyUnicode_Resize(MemorySegment unicode, long length) {
        var mh$ = PyUnicode_Resize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_Resize", unicode, length);
            }
            return (int)mh$.invokeExact(unicode, length);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_FromEncodedObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_FromEncodedObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_FromEncodedObject(PyObject *obj, const char *encoding, const char *errors)
     * }
     */
    public static FunctionDescriptor PyUnicode_FromEncodedObject$descriptor() {
        return PyUnicode_FromEncodedObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_FromEncodedObject(PyObject *obj, const char *encoding, const char *errors)
     * }
     */
    public static MethodHandle PyUnicode_FromEncodedObject$handle() {
        return PyUnicode_FromEncodedObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_FromEncodedObject(PyObject *obj, const char *encoding, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_FromEncodedObject$address() {
        return PyUnicode_FromEncodedObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_FromEncodedObject(PyObject *obj, const char *encoding, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_FromEncodedObject(MemorySegment obj, MemorySegment encoding, MemorySegment errors) {
        var mh$ = PyUnicode_FromEncodedObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_FromEncodedObject", obj, encoding, errors);
            }
            return (MemorySegment)mh$.invokeExact(obj, encoding, errors);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_FromObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_FromObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_FromObject(PyObject *obj)
     * }
     */
    public static FunctionDescriptor PyUnicode_FromObject$descriptor() {
        return PyUnicode_FromObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_FromObject(PyObject *obj)
     * }
     */
    public static MethodHandle PyUnicode_FromObject$handle() {
        return PyUnicode_FromObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_FromObject(PyObject *obj)
     * }
     */
    public static MemorySegment PyUnicode_FromObject$address() {
        return PyUnicode_FromObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_FromObject(PyObject *obj)
     * }
     */
    public static MemorySegment PyUnicode_FromObject(MemorySegment obj) {
        var mh$ = PyUnicode_FromObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_FromObject", obj);
            }
            return (MemorySegment)mh$.invokeExact(obj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_FromFormatV {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_FromFormatV");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_FromFormatV(const char *format, va_list vargs)
     * }
     */
    public static FunctionDescriptor PyUnicode_FromFormatV$descriptor() {
        return PyUnicode_FromFormatV.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_FromFormatV(const char *format, va_list vargs)
     * }
     */
    public static MethodHandle PyUnicode_FromFormatV$handle() {
        return PyUnicode_FromFormatV.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_FromFormatV(const char *format, va_list vargs)
     * }
     */
    public static MemorySegment PyUnicode_FromFormatV$address() {
        return PyUnicode_FromFormatV.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_FromFormatV(const char *format, va_list vargs)
     * }
     */
    public static MemorySegment PyUnicode_FromFormatV(MemorySegment format, MemorySegment vargs) {
        var mh$ = PyUnicode_FromFormatV.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_FromFormatV", format, vargs);
            }
            return (MemorySegment)mh$.invokeExact(format, vargs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_FromFormat(const char *format, ...)
     * }
     */
    public static class PyUnicode_FromFormat {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_POINTER,
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_FromFormat");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private PyUnicode_FromFormat(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * PyObject *PyUnicode_FromFormat(const char *format, ...)
         * }
         */
        public static PyUnicode_FromFormat makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new PyUnicode_FromFormat(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public MemorySegment apply(MemorySegment format, Object... x1) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("PyUnicode_FromFormat", format, x1);
                }
                return (MemorySegment)spreader.invokeExact(format, x1);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class PyUnicode_InternInPlace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_InternInPlace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyUnicode_InternInPlace(PyObject **)
     * }
     */
    public static FunctionDescriptor PyUnicode_InternInPlace$descriptor() {
        return PyUnicode_InternInPlace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyUnicode_InternInPlace(PyObject **)
     * }
     */
    public static MethodHandle PyUnicode_InternInPlace$handle() {
        return PyUnicode_InternInPlace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyUnicode_InternInPlace(PyObject **)
     * }
     */
    public static MemorySegment PyUnicode_InternInPlace$address() {
        return PyUnicode_InternInPlace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyUnicode_InternInPlace(PyObject **)
     * }
     */
    public static void PyUnicode_InternInPlace(MemorySegment x0) {
        var mh$ = PyUnicode_InternInPlace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_InternInPlace", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_InternFromString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_InternFromString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_InternFromString(const char *u)
     * }
     */
    public static FunctionDescriptor PyUnicode_InternFromString$descriptor() {
        return PyUnicode_InternFromString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_InternFromString(const char *u)
     * }
     */
    public static MethodHandle PyUnicode_InternFromString$handle() {
        return PyUnicode_InternFromString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_InternFromString(const char *u)
     * }
     */
    public static MemorySegment PyUnicode_InternFromString$address() {
        return PyUnicode_InternFromString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_InternFromString(const char *u)
     * }
     */
    public static MemorySegment PyUnicode_InternFromString(MemorySegment u) {
        var mh$ = PyUnicode_InternFromString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_InternFromString", u);
            }
            return (MemorySegment)mh$.invokeExact(u);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_FromWideChar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_FromWideChar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_FromWideChar(const wchar_t *w, Py_ssize_t size)
     * }
     */
    public static FunctionDescriptor PyUnicode_FromWideChar$descriptor() {
        return PyUnicode_FromWideChar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_FromWideChar(const wchar_t *w, Py_ssize_t size)
     * }
     */
    public static MethodHandle PyUnicode_FromWideChar$handle() {
        return PyUnicode_FromWideChar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_FromWideChar(const wchar_t *w, Py_ssize_t size)
     * }
     */
    public static MemorySegment PyUnicode_FromWideChar$address() {
        return PyUnicode_FromWideChar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_FromWideChar(const wchar_t *w, Py_ssize_t size)
     * }
     */
    public static MemorySegment PyUnicode_FromWideChar(MemorySegment w, long size) {
        var mh$ = PyUnicode_FromWideChar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_FromWideChar", w, size);
            }
            return (MemorySegment)mh$.invokeExact(w, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_AsWideChar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_AsWideChar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_ssize_t PyUnicode_AsWideChar(PyObject *unicode, wchar_t *w, Py_ssize_t size)
     * }
     */
    public static FunctionDescriptor PyUnicode_AsWideChar$descriptor() {
        return PyUnicode_AsWideChar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_ssize_t PyUnicode_AsWideChar(PyObject *unicode, wchar_t *w, Py_ssize_t size)
     * }
     */
    public static MethodHandle PyUnicode_AsWideChar$handle() {
        return PyUnicode_AsWideChar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_ssize_t PyUnicode_AsWideChar(PyObject *unicode, wchar_t *w, Py_ssize_t size)
     * }
     */
    public static MemorySegment PyUnicode_AsWideChar$address() {
        return PyUnicode_AsWideChar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_ssize_t PyUnicode_AsWideChar(PyObject *unicode, wchar_t *w, Py_ssize_t size)
     * }
     */
    public static long PyUnicode_AsWideChar(MemorySegment unicode, MemorySegment w, long size) {
        var mh$ = PyUnicode_AsWideChar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_AsWideChar", unicode, w, size);
            }
            return (long)mh$.invokeExact(unicode, w, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_AsWideCharString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_AsWideCharString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *PyUnicode_AsWideCharString(PyObject *unicode, Py_ssize_t *size)
     * }
     */
    public static FunctionDescriptor PyUnicode_AsWideCharString$descriptor() {
        return PyUnicode_AsWideCharString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *PyUnicode_AsWideCharString(PyObject *unicode, Py_ssize_t *size)
     * }
     */
    public static MethodHandle PyUnicode_AsWideCharString$handle() {
        return PyUnicode_AsWideCharString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *PyUnicode_AsWideCharString(PyObject *unicode, Py_ssize_t *size)
     * }
     */
    public static MemorySegment PyUnicode_AsWideCharString$address() {
        return PyUnicode_AsWideCharString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *PyUnicode_AsWideCharString(PyObject *unicode, Py_ssize_t *size)
     * }
     */
    public static MemorySegment PyUnicode_AsWideCharString(MemorySegment unicode, MemorySegment size) {
        var mh$ = PyUnicode_AsWideCharString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_AsWideCharString", unicode, size);
            }
            return (MemorySegment)mh$.invokeExact(unicode, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_FromOrdinal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_FromOrdinal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_FromOrdinal(int ordinal)
     * }
     */
    public static FunctionDescriptor PyUnicode_FromOrdinal$descriptor() {
        return PyUnicode_FromOrdinal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_FromOrdinal(int ordinal)
     * }
     */
    public static MethodHandle PyUnicode_FromOrdinal$handle() {
        return PyUnicode_FromOrdinal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_FromOrdinal(int ordinal)
     * }
     */
    public static MemorySegment PyUnicode_FromOrdinal$address() {
        return PyUnicode_FromOrdinal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_FromOrdinal(int ordinal)
     * }
     */
    public static MemorySegment PyUnicode_FromOrdinal(int ordinal) {
        var mh$ = PyUnicode_FromOrdinal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_FromOrdinal", ordinal);
            }
            return (MemorySegment)mh$.invokeExact(ordinal);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_GetDefaultEncoding {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_GetDefaultEncoding");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *PyUnicode_GetDefaultEncoding()
     * }
     */
    public static FunctionDescriptor PyUnicode_GetDefaultEncoding$descriptor() {
        return PyUnicode_GetDefaultEncoding.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *PyUnicode_GetDefaultEncoding()
     * }
     */
    public static MethodHandle PyUnicode_GetDefaultEncoding$handle() {
        return PyUnicode_GetDefaultEncoding.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *PyUnicode_GetDefaultEncoding()
     * }
     */
    public static MemorySegment PyUnicode_GetDefaultEncoding$address() {
        return PyUnicode_GetDefaultEncoding.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *PyUnicode_GetDefaultEncoding()
     * }
     */
    public static MemorySegment PyUnicode_GetDefaultEncoding() {
        var mh$ = PyUnicode_GetDefaultEncoding.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_GetDefaultEncoding");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_Decode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_Decode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_Decode(const char *s, Py_ssize_t size, const char *encoding, const char *errors)
     * }
     */
    public static FunctionDescriptor PyUnicode_Decode$descriptor() {
        return PyUnicode_Decode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_Decode(const char *s, Py_ssize_t size, const char *encoding, const char *errors)
     * }
     */
    public static MethodHandle PyUnicode_Decode$handle() {
        return PyUnicode_Decode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_Decode(const char *s, Py_ssize_t size, const char *encoding, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_Decode$address() {
        return PyUnicode_Decode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_Decode(const char *s, Py_ssize_t size, const char *encoding, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_Decode(MemorySegment s, long size, MemorySegment encoding, MemorySegment errors) {
        var mh$ = PyUnicode_Decode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_Decode", s, size, encoding, errors);
            }
            return (MemorySegment)mh$.invokeExact(s, size, encoding, errors);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_AsDecodedObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_AsDecodedObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsDecodedObject(PyObject *unicode, const char *encoding, const char *errors)
     * }
     */
    public static FunctionDescriptor PyUnicode_AsDecodedObject$descriptor() {
        return PyUnicode_AsDecodedObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsDecodedObject(PyObject *unicode, const char *encoding, const char *errors)
     * }
     */
    public static MethodHandle PyUnicode_AsDecodedObject$handle() {
        return PyUnicode_AsDecodedObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsDecodedObject(PyObject *unicode, const char *encoding, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_AsDecodedObject$address() {
        return PyUnicode_AsDecodedObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsDecodedObject(PyObject *unicode, const char *encoding, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_AsDecodedObject(MemorySegment unicode, MemorySegment encoding, MemorySegment errors) {
        var mh$ = PyUnicode_AsDecodedObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_AsDecodedObject", unicode, encoding, errors);
            }
            return (MemorySegment)mh$.invokeExact(unicode, encoding, errors);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_AsDecodedUnicode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_AsDecodedUnicode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsDecodedUnicode(PyObject *unicode, const char *encoding, const char *errors)
     * }
     */
    public static FunctionDescriptor PyUnicode_AsDecodedUnicode$descriptor() {
        return PyUnicode_AsDecodedUnicode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsDecodedUnicode(PyObject *unicode, const char *encoding, const char *errors)
     * }
     */
    public static MethodHandle PyUnicode_AsDecodedUnicode$handle() {
        return PyUnicode_AsDecodedUnicode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsDecodedUnicode(PyObject *unicode, const char *encoding, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_AsDecodedUnicode$address() {
        return PyUnicode_AsDecodedUnicode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsDecodedUnicode(PyObject *unicode, const char *encoding, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_AsDecodedUnicode(MemorySegment unicode, MemorySegment encoding, MemorySegment errors) {
        var mh$ = PyUnicode_AsDecodedUnicode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_AsDecodedUnicode", unicode, encoding, errors);
            }
            return (MemorySegment)mh$.invokeExact(unicode, encoding, errors);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_AsEncodedObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_AsEncodedObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsEncodedObject(PyObject *unicode, const char *encoding, const char *errors)
     * }
     */
    public static FunctionDescriptor PyUnicode_AsEncodedObject$descriptor() {
        return PyUnicode_AsEncodedObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsEncodedObject(PyObject *unicode, const char *encoding, const char *errors)
     * }
     */
    public static MethodHandle PyUnicode_AsEncodedObject$handle() {
        return PyUnicode_AsEncodedObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsEncodedObject(PyObject *unicode, const char *encoding, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_AsEncodedObject$address() {
        return PyUnicode_AsEncodedObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsEncodedObject(PyObject *unicode, const char *encoding, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_AsEncodedObject(MemorySegment unicode, MemorySegment encoding, MemorySegment errors) {
        var mh$ = PyUnicode_AsEncodedObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_AsEncodedObject", unicode, encoding, errors);
            }
            return (MemorySegment)mh$.invokeExact(unicode, encoding, errors);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_AsEncodedString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_AsEncodedString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsEncodedString(PyObject *unicode, const char *encoding, const char *errors)
     * }
     */
    public static FunctionDescriptor PyUnicode_AsEncodedString$descriptor() {
        return PyUnicode_AsEncodedString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsEncodedString(PyObject *unicode, const char *encoding, const char *errors)
     * }
     */
    public static MethodHandle PyUnicode_AsEncodedString$handle() {
        return PyUnicode_AsEncodedString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsEncodedString(PyObject *unicode, const char *encoding, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_AsEncodedString$address() {
        return PyUnicode_AsEncodedString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsEncodedString(PyObject *unicode, const char *encoding, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_AsEncodedString(MemorySegment unicode, MemorySegment encoding, MemorySegment errors) {
        var mh$ = PyUnicode_AsEncodedString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_AsEncodedString", unicode, encoding, errors);
            }
            return (MemorySegment)mh$.invokeExact(unicode, encoding, errors);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_AsEncodedUnicode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_AsEncodedUnicode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsEncodedUnicode(PyObject *unicode, const char *encoding, const char *errors)
     * }
     */
    public static FunctionDescriptor PyUnicode_AsEncodedUnicode$descriptor() {
        return PyUnicode_AsEncodedUnicode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsEncodedUnicode(PyObject *unicode, const char *encoding, const char *errors)
     * }
     */
    public static MethodHandle PyUnicode_AsEncodedUnicode$handle() {
        return PyUnicode_AsEncodedUnicode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsEncodedUnicode(PyObject *unicode, const char *encoding, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_AsEncodedUnicode$address() {
        return PyUnicode_AsEncodedUnicode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsEncodedUnicode(PyObject *unicode, const char *encoding, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_AsEncodedUnicode(MemorySegment unicode, MemorySegment encoding, MemorySegment errors) {
        var mh$ = PyUnicode_AsEncodedUnicode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_AsEncodedUnicode", unicode, encoding, errors);
            }
            return (MemorySegment)mh$.invokeExact(unicode, encoding, errors);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_BuildEncodingMap {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_BuildEncodingMap");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_BuildEncodingMap(PyObject *string)
     * }
     */
    public static FunctionDescriptor PyUnicode_BuildEncodingMap$descriptor() {
        return PyUnicode_BuildEncodingMap.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_BuildEncodingMap(PyObject *string)
     * }
     */
    public static MethodHandle PyUnicode_BuildEncodingMap$handle() {
        return PyUnicode_BuildEncodingMap.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_BuildEncodingMap(PyObject *string)
     * }
     */
    public static MemorySegment PyUnicode_BuildEncodingMap$address() {
        return PyUnicode_BuildEncodingMap.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_BuildEncodingMap(PyObject *string)
     * }
     */
    public static MemorySegment PyUnicode_BuildEncodingMap(MemorySegment string) {
        var mh$ = PyUnicode_BuildEncodingMap.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_BuildEncodingMap", string);
            }
            return (MemorySegment)mh$.invokeExact(string);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_DecodeUTF7 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_DecodeUTF7");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUTF7(const char *string, Py_ssize_t length, const char *errors)
     * }
     */
    public static FunctionDescriptor PyUnicode_DecodeUTF7$descriptor() {
        return PyUnicode_DecodeUTF7.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUTF7(const char *string, Py_ssize_t length, const char *errors)
     * }
     */
    public static MethodHandle PyUnicode_DecodeUTF7$handle() {
        return PyUnicode_DecodeUTF7.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUTF7(const char *string, Py_ssize_t length, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_DecodeUTF7$address() {
        return PyUnicode_DecodeUTF7.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUTF7(const char *string, Py_ssize_t length, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_DecodeUTF7(MemorySegment string, long length, MemorySegment errors) {
        var mh$ = PyUnicode_DecodeUTF7.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_DecodeUTF7", string, length, errors);
            }
            return (MemorySegment)mh$.invokeExact(string, length, errors);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_DecodeUTF7Stateful {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_DecodeUTF7Stateful");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUTF7Stateful(const char *string, Py_ssize_t length, const char *errors, Py_ssize_t *consumed)
     * }
     */
    public static FunctionDescriptor PyUnicode_DecodeUTF7Stateful$descriptor() {
        return PyUnicode_DecodeUTF7Stateful.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUTF7Stateful(const char *string, Py_ssize_t length, const char *errors, Py_ssize_t *consumed)
     * }
     */
    public static MethodHandle PyUnicode_DecodeUTF7Stateful$handle() {
        return PyUnicode_DecodeUTF7Stateful.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUTF7Stateful(const char *string, Py_ssize_t length, const char *errors, Py_ssize_t *consumed)
     * }
     */
    public static MemorySegment PyUnicode_DecodeUTF7Stateful$address() {
        return PyUnicode_DecodeUTF7Stateful.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUTF7Stateful(const char *string, Py_ssize_t length, const char *errors, Py_ssize_t *consumed)
     * }
     */
    public static MemorySegment PyUnicode_DecodeUTF7Stateful(MemorySegment string, long length, MemorySegment errors, MemorySegment consumed) {
        var mh$ = PyUnicode_DecodeUTF7Stateful.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_DecodeUTF7Stateful", string, length, errors, consumed);
            }
            return (MemorySegment)mh$.invokeExact(string, length, errors, consumed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_DecodeUTF8 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_DecodeUTF8");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUTF8(const char *string, Py_ssize_t length, const char *errors)
     * }
     */
    public static FunctionDescriptor PyUnicode_DecodeUTF8$descriptor() {
        return PyUnicode_DecodeUTF8.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUTF8(const char *string, Py_ssize_t length, const char *errors)
     * }
     */
    public static MethodHandle PyUnicode_DecodeUTF8$handle() {
        return PyUnicode_DecodeUTF8.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUTF8(const char *string, Py_ssize_t length, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_DecodeUTF8$address() {
        return PyUnicode_DecodeUTF8.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUTF8(const char *string, Py_ssize_t length, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_DecodeUTF8(MemorySegment string, long length, MemorySegment errors) {
        var mh$ = PyUnicode_DecodeUTF8.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_DecodeUTF8", string, length, errors);
            }
            return (MemorySegment)mh$.invokeExact(string, length, errors);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_DecodeUTF8Stateful {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_DecodeUTF8Stateful");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUTF8Stateful(const char *string, Py_ssize_t length, const char *errors, Py_ssize_t *consumed)
     * }
     */
    public static FunctionDescriptor PyUnicode_DecodeUTF8Stateful$descriptor() {
        return PyUnicode_DecodeUTF8Stateful.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUTF8Stateful(const char *string, Py_ssize_t length, const char *errors, Py_ssize_t *consumed)
     * }
     */
    public static MethodHandle PyUnicode_DecodeUTF8Stateful$handle() {
        return PyUnicode_DecodeUTF8Stateful.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUTF8Stateful(const char *string, Py_ssize_t length, const char *errors, Py_ssize_t *consumed)
     * }
     */
    public static MemorySegment PyUnicode_DecodeUTF8Stateful$address() {
        return PyUnicode_DecodeUTF8Stateful.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUTF8Stateful(const char *string, Py_ssize_t length, const char *errors, Py_ssize_t *consumed)
     * }
     */
    public static MemorySegment PyUnicode_DecodeUTF8Stateful(MemorySegment string, long length, MemorySegment errors, MemorySegment consumed) {
        var mh$ = PyUnicode_DecodeUTF8Stateful.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_DecodeUTF8Stateful", string, length, errors, consumed);
            }
            return (MemorySegment)mh$.invokeExact(string, length, errors, consumed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_AsUTF8String {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_AsUTF8String");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsUTF8String(PyObject *unicode)
     * }
     */
    public static FunctionDescriptor PyUnicode_AsUTF8String$descriptor() {
        return PyUnicode_AsUTF8String.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsUTF8String(PyObject *unicode)
     * }
     */
    public static MethodHandle PyUnicode_AsUTF8String$handle() {
        return PyUnicode_AsUTF8String.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsUTF8String(PyObject *unicode)
     * }
     */
    public static MemorySegment PyUnicode_AsUTF8String$address() {
        return PyUnicode_AsUTF8String.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsUTF8String(PyObject *unicode)
     * }
     */
    public static MemorySegment PyUnicode_AsUTF8String(MemorySegment unicode) {
        var mh$ = PyUnicode_AsUTF8String.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_AsUTF8String", unicode);
            }
            return (MemorySegment)mh$.invokeExact(unicode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_AsUTF8AndSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_AsUTF8AndSize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *PyUnicode_AsUTF8AndSize(PyObject *unicode, Py_ssize_t *size)
     * }
     */
    public static FunctionDescriptor PyUnicode_AsUTF8AndSize$descriptor() {
        return PyUnicode_AsUTF8AndSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *PyUnicode_AsUTF8AndSize(PyObject *unicode, Py_ssize_t *size)
     * }
     */
    public static MethodHandle PyUnicode_AsUTF8AndSize$handle() {
        return PyUnicode_AsUTF8AndSize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *PyUnicode_AsUTF8AndSize(PyObject *unicode, Py_ssize_t *size)
     * }
     */
    public static MemorySegment PyUnicode_AsUTF8AndSize$address() {
        return PyUnicode_AsUTF8AndSize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *PyUnicode_AsUTF8AndSize(PyObject *unicode, Py_ssize_t *size)
     * }
     */
    public static MemorySegment PyUnicode_AsUTF8AndSize(MemorySegment unicode, MemorySegment size) {
        var mh$ = PyUnicode_AsUTF8AndSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_AsUTF8AndSize", unicode, size);
            }
            return (MemorySegment)mh$.invokeExact(unicode, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_DecodeUTF32 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_DecodeUTF32");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUTF32(const char *string, Py_ssize_t length, const char *errors, int *byteorder)
     * }
     */
    public static FunctionDescriptor PyUnicode_DecodeUTF32$descriptor() {
        return PyUnicode_DecodeUTF32.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUTF32(const char *string, Py_ssize_t length, const char *errors, int *byteorder)
     * }
     */
    public static MethodHandle PyUnicode_DecodeUTF32$handle() {
        return PyUnicode_DecodeUTF32.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUTF32(const char *string, Py_ssize_t length, const char *errors, int *byteorder)
     * }
     */
    public static MemorySegment PyUnicode_DecodeUTF32$address() {
        return PyUnicode_DecodeUTF32.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUTF32(const char *string, Py_ssize_t length, const char *errors, int *byteorder)
     * }
     */
    public static MemorySegment PyUnicode_DecodeUTF32(MemorySegment string, long length, MemorySegment errors, MemorySegment byteorder) {
        var mh$ = PyUnicode_DecodeUTF32.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_DecodeUTF32", string, length, errors, byteorder);
            }
            return (MemorySegment)mh$.invokeExact(string, length, errors, byteorder);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_DecodeUTF32Stateful {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_DecodeUTF32Stateful");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUTF32Stateful(const char *string, Py_ssize_t length, const char *errors, int *byteorder, Py_ssize_t *consumed)
     * }
     */
    public static FunctionDescriptor PyUnicode_DecodeUTF32Stateful$descriptor() {
        return PyUnicode_DecodeUTF32Stateful.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUTF32Stateful(const char *string, Py_ssize_t length, const char *errors, int *byteorder, Py_ssize_t *consumed)
     * }
     */
    public static MethodHandle PyUnicode_DecodeUTF32Stateful$handle() {
        return PyUnicode_DecodeUTF32Stateful.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUTF32Stateful(const char *string, Py_ssize_t length, const char *errors, int *byteorder, Py_ssize_t *consumed)
     * }
     */
    public static MemorySegment PyUnicode_DecodeUTF32Stateful$address() {
        return PyUnicode_DecodeUTF32Stateful.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUTF32Stateful(const char *string, Py_ssize_t length, const char *errors, int *byteorder, Py_ssize_t *consumed)
     * }
     */
    public static MemorySegment PyUnicode_DecodeUTF32Stateful(MemorySegment string, long length, MemorySegment errors, MemorySegment byteorder, MemorySegment consumed) {
        var mh$ = PyUnicode_DecodeUTF32Stateful.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_DecodeUTF32Stateful", string, length, errors, byteorder, consumed);
            }
            return (MemorySegment)mh$.invokeExact(string, length, errors, byteorder, consumed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_AsUTF32String {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_AsUTF32String");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsUTF32String(PyObject *unicode)
     * }
     */
    public static FunctionDescriptor PyUnicode_AsUTF32String$descriptor() {
        return PyUnicode_AsUTF32String.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsUTF32String(PyObject *unicode)
     * }
     */
    public static MethodHandle PyUnicode_AsUTF32String$handle() {
        return PyUnicode_AsUTF32String.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsUTF32String(PyObject *unicode)
     * }
     */
    public static MemorySegment PyUnicode_AsUTF32String$address() {
        return PyUnicode_AsUTF32String.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsUTF32String(PyObject *unicode)
     * }
     */
    public static MemorySegment PyUnicode_AsUTF32String(MemorySegment unicode) {
        var mh$ = PyUnicode_AsUTF32String.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_AsUTF32String", unicode);
            }
            return (MemorySegment)mh$.invokeExact(unicode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_DecodeUTF16 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_DecodeUTF16");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUTF16(const char *string, Py_ssize_t length, const char *errors, int *byteorder)
     * }
     */
    public static FunctionDescriptor PyUnicode_DecodeUTF16$descriptor() {
        return PyUnicode_DecodeUTF16.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUTF16(const char *string, Py_ssize_t length, const char *errors, int *byteorder)
     * }
     */
    public static MethodHandle PyUnicode_DecodeUTF16$handle() {
        return PyUnicode_DecodeUTF16.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUTF16(const char *string, Py_ssize_t length, const char *errors, int *byteorder)
     * }
     */
    public static MemorySegment PyUnicode_DecodeUTF16$address() {
        return PyUnicode_DecodeUTF16.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUTF16(const char *string, Py_ssize_t length, const char *errors, int *byteorder)
     * }
     */
    public static MemorySegment PyUnicode_DecodeUTF16(MemorySegment string, long length, MemorySegment errors, MemorySegment byteorder) {
        var mh$ = PyUnicode_DecodeUTF16.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_DecodeUTF16", string, length, errors, byteorder);
            }
            return (MemorySegment)mh$.invokeExact(string, length, errors, byteorder);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_DecodeUTF16Stateful {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_DecodeUTF16Stateful");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUTF16Stateful(const char *string, Py_ssize_t length, const char *errors, int *byteorder, Py_ssize_t *consumed)
     * }
     */
    public static FunctionDescriptor PyUnicode_DecodeUTF16Stateful$descriptor() {
        return PyUnicode_DecodeUTF16Stateful.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUTF16Stateful(const char *string, Py_ssize_t length, const char *errors, int *byteorder, Py_ssize_t *consumed)
     * }
     */
    public static MethodHandle PyUnicode_DecodeUTF16Stateful$handle() {
        return PyUnicode_DecodeUTF16Stateful.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUTF16Stateful(const char *string, Py_ssize_t length, const char *errors, int *byteorder, Py_ssize_t *consumed)
     * }
     */
    public static MemorySegment PyUnicode_DecodeUTF16Stateful$address() {
        return PyUnicode_DecodeUTF16Stateful.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUTF16Stateful(const char *string, Py_ssize_t length, const char *errors, int *byteorder, Py_ssize_t *consumed)
     * }
     */
    public static MemorySegment PyUnicode_DecodeUTF16Stateful(MemorySegment string, long length, MemorySegment errors, MemorySegment byteorder, MemorySegment consumed) {
        var mh$ = PyUnicode_DecodeUTF16Stateful.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_DecodeUTF16Stateful", string, length, errors, byteorder, consumed);
            }
            return (MemorySegment)mh$.invokeExact(string, length, errors, byteorder, consumed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_AsUTF16String {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_AsUTF16String");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsUTF16String(PyObject *unicode)
     * }
     */
    public static FunctionDescriptor PyUnicode_AsUTF16String$descriptor() {
        return PyUnicode_AsUTF16String.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsUTF16String(PyObject *unicode)
     * }
     */
    public static MethodHandle PyUnicode_AsUTF16String$handle() {
        return PyUnicode_AsUTF16String.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsUTF16String(PyObject *unicode)
     * }
     */
    public static MemorySegment PyUnicode_AsUTF16String$address() {
        return PyUnicode_AsUTF16String.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsUTF16String(PyObject *unicode)
     * }
     */
    public static MemorySegment PyUnicode_AsUTF16String(MemorySegment unicode) {
        var mh$ = PyUnicode_AsUTF16String.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_AsUTF16String", unicode);
            }
            return (MemorySegment)mh$.invokeExact(unicode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_DecodeUnicodeEscape {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_DecodeUnicodeEscape");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUnicodeEscape(const char *string, Py_ssize_t length, const char *errors)
     * }
     */
    public static FunctionDescriptor PyUnicode_DecodeUnicodeEscape$descriptor() {
        return PyUnicode_DecodeUnicodeEscape.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUnicodeEscape(const char *string, Py_ssize_t length, const char *errors)
     * }
     */
    public static MethodHandle PyUnicode_DecodeUnicodeEscape$handle() {
        return PyUnicode_DecodeUnicodeEscape.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUnicodeEscape(const char *string, Py_ssize_t length, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_DecodeUnicodeEscape$address() {
        return PyUnicode_DecodeUnicodeEscape.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUnicodeEscape(const char *string, Py_ssize_t length, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_DecodeUnicodeEscape(MemorySegment string, long length, MemorySegment errors) {
        var mh$ = PyUnicode_DecodeUnicodeEscape.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_DecodeUnicodeEscape", string, length, errors);
            }
            return (MemorySegment)mh$.invokeExact(string, length, errors);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_AsUnicodeEscapeString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_AsUnicodeEscapeString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsUnicodeEscapeString(PyObject *unicode)
     * }
     */
    public static FunctionDescriptor PyUnicode_AsUnicodeEscapeString$descriptor() {
        return PyUnicode_AsUnicodeEscapeString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsUnicodeEscapeString(PyObject *unicode)
     * }
     */
    public static MethodHandle PyUnicode_AsUnicodeEscapeString$handle() {
        return PyUnicode_AsUnicodeEscapeString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsUnicodeEscapeString(PyObject *unicode)
     * }
     */
    public static MemorySegment PyUnicode_AsUnicodeEscapeString$address() {
        return PyUnicode_AsUnicodeEscapeString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsUnicodeEscapeString(PyObject *unicode)
     * }
     */
    public static MemorySegment PyUnicode_AsUnicodeEscapeString(MemorySegment unicode) {
        var mh$ = PyUnicode_AsUnicodeEscapeString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_AsUnicodeEscapeString", unicode);
            }
            return (MemorySegment)mh$.invokeExact(unicode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_DecodeRawUnicodeEscape {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_DecodeRawUnicodeEscape");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeRawUnicodeEscape(const char *string, Py_ssize_t length, const char *errors)
     * }
     */
    public static FunctionDescriptor PyUnicode_DecodeRawUnicodeEscape$descriptor() {
        return PyUnicode_DecodeRawUnicodeEscape.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeRawUnicodeEscape(const char *string, Py_ssize_t length, const char *errors)
     * }
     */
    public static MethodHandle PyUnicode_DecodeRawUnicodeEscape$handle() {
        return PyUnicode_DecodeRawUnicodeEscape.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeRawUnicodeEscape(const char *string, Py_ssize_t length, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_DecodeRawUnicodeEscape$address() {
        return PyUnicode_DecodeRawUnicodeEscape.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeRawUnicodeEscape(const char *string, Py_ssize_t length, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_DecodeRawUnicodeEscape(MemorySegment string, long length, MemorySegment errors) {
        var mh$ = PyUnicode_DecodeRawUnicodeEscape.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_DecodeRawUnicodeEscape", string, length, errors);
            }
            return (MemorySegment)mh$.invokeExact(string, length, errors);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_AsRawUnicodeEscapeString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_AsRawUnicodeEscapeString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsRawUnicodeEscapeString(PyObject *unicode)
     * }
     */
    public static FunctionDescriptor PyUnicode_AsRawUnicodeEscapeString$descriptor() {
        return PyUnicode_AsRawUnicodeEscapeString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsRawUnicodeEscapeString(PyObject *unicode)
     * }
     */
    public static MethodHandle PyUnicode_AsRawUnicodeEscapeString$handle() {
        return PyUnicode_AsRawUnicodeEscapeString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsRawUnicodeEscapeString(PyObject *unicode)
     * }
     */
    public static MemorySegment PyUnicode_AsRawUnicodeEscapeString$address() {
        return PyUnicode_AsRawUnicodeEscapeString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsRawUnicodeEscapeString(PyObject *unicode)
     * }
     */
    public static MemorySegment PyUnicode_AsRawUnicodeEscapeString(MemorySegment unicode) {
        var mh$ = PyUnicode_AsRawUnicodeEscapeString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_AsRawUnicodeEscapeString", unicode);
            }
            return (MemorySegment)mh$.invokeExact(unicode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_DecodeLatin1 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_DecodeLatin1");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeLatin1(const char *string, Py_ssize_t length, const char *errors)
     * }
     */
    public static FunctionDescriptor PyUnicode_DecodeLatin1$descriptor() {
        return PyUnicode_DecodeLatin1.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeLatin1(const char *string, Py_ssize_t length, const char *errors)
     * }
     */
    public static MethodHandle PyUnicode_DecodeLatin1$handle() {
        return PyUnicode_DecodeLatin1.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeLatin1(const char *string, Py_ssize_t length, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_DecodeLatin1$address() {
        return PyUnicode_DecodeLatin1.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeLatin1(const char *string, Py_ssize_t length, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_DecodeLatin1(MemorySegment string, long length, MemorySegment errors) {
        var mh$ = PyUnicode_DecodeLatin1.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_DecodeLatin1", string, length, errors);
            }
            return (MemorySegment)mh$.invokeExact(string, length, errors);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_AsLatin1String {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_AsLatin1String");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsLatin1String(PyObject *unicode)
     * }
     */
    public static FunctionDescriptor PyUnicode_AsLatin1String$descriptor() {
        return PyUnicode_AsLatin1String.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsLatin1String(PyObject *unicode)
     * }
     */
    public static MethodHandle PyUnicode_AsLatin1String$handle() {
        return PyUnicode_AsLatin1String.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsLatin1String(PyObject *unicode)
     * }
     */
    public static MemorySegment PyUnicode_AsLatin1String$address() {
        return PyUnicode_AsLatin1String.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsLatin1String(PyObject *unicode)
     * }
     */
    public static MemorySegment PyUnicode_AsLatin1String(MemorySegment unicode) {
        var mh$ = PyUnicode_AsLatin1String.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_AsLatin1String", unicode);
            }
            return (MemorySegment)mh$.invokeExact(unicode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_DecodeASCII {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_DecodeASCII");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeASCII(const char *string, Py_ssize_t length, const char *errors)
     * }
     */
    public static FunctionDescriptor PyUnicode_DecodeASCII$descriptor() {
        return PyUnicode_DecodeASCII.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeASCII(const char *string, Py_ssize_t length, const char *errors)
     * }
     */
    public static MethodHandle PyUnicode_DecodeASCII$handle() {
        return PyUnicode_DecodeASCII.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeASCII(const char *string, Py_ssize_t length, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_DecodeASCII$address() {
        return PyUnicode_DecodeASCII.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeASCII(const char *string, Py_ssize_t length, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_DecodeASCII(MemorySegment string, long length, MemorySegment errors) {
        var mh$ = PyUnicode_DecodeASCII.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_DecodeASCII", string, length, errors);
            }
            return (MemorySegment)mh$.invokeExact(string, length, errors);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_AsASCIIString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_AsASCIIString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsASCIIString(PyObject *unicode)
     * }
     */
    public static FunctionDescriptor PyUnicode_AsASCIIString$descriptor() {
        return PyUnicode_AsASCIIString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsASCIIString(PyObject *unicode)
     * }
     */
    public static MethodHandle PyUnicode_AsASCIIString$handle() {
        return PyUnicode_AsASCIIString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsASCIIString(PyObject *unicode)
     * }
     */
    public static MemorySegment PyUnicode_AsASCIIString$address() {
        return PyUnicode_AsASCIIString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsASCIIString(PyObject *unicode)
     * }
     */
    public static MemorySegment PyUnicode_AsASCIIString(MemorySegment unicode) {
        var mh$ = PyUnicode_AsASCIIString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_AsASCIIString", unicode);
            }
            return (MemorySegment)mh$.invokeExact(unicode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_DecodeCharmap {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_DecodeCharmap");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeCharmap(const char *string, Py_ssize_t length, PyObject *mapping, const char *errors)
     * }
     */
    public static FunctionDescriptor PyUnicode_DecodeCharmap$descriptor() {
        return PyUnicode_DecodeCharmap.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeCharmap(const char *string, Py_ssize_t length, PyObject *mapping, const char *errors)
     * }
     */
    public static MethodHandle PyUnicode_DecodeCharmap$handle() {
        return PyUnicode_DecodeCharmap.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeCharmap(const char *string, Py_ssize_t length, PyObject *mapping, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_DecodeCharmap$address() {
        return PyUnicode_DecodeCharmap.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeCharmap(const char *string, Py_ssize_t length, PyObject *mapping, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_DecodeCharmap(MemorySegment string, long length, MemorySegment mapping, MemorySegment errors) {
        var mh$ = PyUnicode_DecodeCharmap.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_DecodeCharmap", string, length, mapping, errors);
            }
            return (MemorySegment)mh$.invokeExact(string, length, mapping, errors);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_AsCharmapString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_AsCharmapString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsCharmapString(PyObject *unicode, PyObject *mapping)
     * }
     */
    public static FunctionDescriptor PyUnicode_AsCharmapString$descriptor() {
        return PyUnicode_AsCharmapString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsCharmapString(PyObject *unicode, PyObject *mapping)
     * }
     */
    public static MethodHandle PyUnicode_AsCharmapString$handle() {
        return PyUnicode_AsCharmapString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsCharmapString(PyObject *unicode, PyObject *mapping)
     * }
     */
    public static MemorySegment PyUnicode_AsCharmapString$address() {
        return PyUnicode_AsCharmapString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsCharmapString(PyObject *unicode, PyObject *mapping)
     * }
     */
    public static MemorySegment PyUnicode_AsCharmapString(MemorySegment unicode, MemorySegment mapping) {
        var mh$ = PyUnicode_AsCharmapString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_AsCharmapString", unicode, mapping);
            }
            return (MemorySegment)mh$.invokeExact(unicode, mapping);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_DecodeMBCS {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_DecodeMBCS");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeMBCS(const char *string, Py_ssize_t length, const char *errors)
     * }
     */
    public static FunctionDescriptor PyUnicode_DecodeMBCS$descriptor() {
        return PyUnicode_DecodeMBCS.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeMBCS(const char *string, Py_ssize_t length, const char *errors)
     * }
     */
    public static MethodHandle PyUnicode_DecodeMBCS$handle() {
        return PyUnicode_DecodeMBCS.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeMBCS(const char *string, Py_ssize_t length, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_DecodeMBCS$address() {
        return PyUnicode_DecodeMBCS.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeMBCS(const char *string, Py_ssize_t length, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_DecodeMBCS(MemorySegment string, long length, MemorySegment errors) {
        var mh$ = PyUnicode_DecodeMBCS.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_DecodeMBCS", string, length, errors);
            }
            return (MemorySegment)mh$.invokeExact(string, length, errors);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_DecodeMBCSStateful {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_DecodeMBCSStateful");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeMBCSStateful(const char *string, Py_ssize_t length, const char *errors, Py_ssize_t *consumed)
     * }
     */
    public static FunctionDescriptor PyUnicode_DecodeMBCSStateful$descriptor() {
        return PyUnicode_DecodeMBCSStateful.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeMBCSStateful(const char *string, Py_ssize_t length, const char *errors, Py_ssize_t *consumed)
     * }
     */
    public static MethodHandle PyUnicode_DecodeMBCSStateful$handle() {
        return PyUnicode_DecodeMBCSStateful.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeMBCSStateful(const char *string, Py_ssize_t length, const char *errors, Py_ssize_t *consumed)
     * }
     */
    public static MemorySegment PyUnicode_DecodeMBCSStateful$address() {
        return PyUnicode_DecodeMBCSStateful.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeMBCSStateful(const char *string, Py_ssize_t length, const char *errors, Py_ssize_t *consumed)
     * }
     */
    public static MemorySegment PyUnicode_DecodeMBCSStateful(MemorySegment string, long length, MemorySegment errors, MemorySegment consumed) {
        var mh$ = PyUnicode_DecodeMBCSStateful.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_DecodeMBCSStateful", string, length, errors, consumed);
            }
            return (MemorySegment)mh$.invokeExact(string, length, errors, consumed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_DecodeCodePageStateful {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_DecodeCodePageStateful");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeCodePageStateful(int code_page, const char *string, Py_ssize_t length, const char *errors, Py_ssize_t *consumed)
     * }
     */
    public static FunctionDescriptor PyUnicode_DecodeCodePageStateful$descriptor() {
        return PyUnicode_DecodeCodePageStateful.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeCodePageStateful(int code_page, const char *string, Py_ssize_t length, const char *errors, Py_ssize_t *consumed)
     * }
     */
    public static MethodHandle PyUnicode_DecodeCodePageStateful$handle() {
        return PyUnicode_DecodeCodePageStateful.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeCodePageStateful(int code_page, const char *string, Py_ssize_t length, const char *errors, Py_ssize_t *consumed)
     * }
     */
    public static MemorySegment PyUnicode_DecodeCodePageStateful$address() {
        return PyUnicode_DecodeCodePageStateful.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeCodePageStateful(int code_page, const char *string, Py_ssize_t length, const char *errors, Py_ssize_t *consumed)
     * }
     */
    public static MemorySegment PyUnicode_DecodeCodePageStateful(int code_page, MemorySegment string, long length, MemorySegment errors, MemorySegment consumed) {
        var mh$ = PyUnicode_DecodeCodePageStateful.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_DecodeCodePageStateful", code_page, string, length, errors, consumed);
            }
            return (MemorySegment)mh$.invokeExact(code_page, string, length, errors, consumed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_AsMBCSString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_AsMBCSString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsMBCSString(PyObject *unicode)
     * }
     */
    public static FunctionDescriptor PyUnicode_AsMBCSString$descriptor() {
        return PyUnicode_AsMBCSString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsMBCSString(PyObject *unicode)
     * }
     */
    public static MethodHandle PyUnicode_AsMBCSString$handle() {
        return PyUnicode_AsMBCSString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsMBCSString(PyObject *unicode)
     * }
     */
    public static MemorySegment PyUnicode_AsMBCSString$address() {
        return PyUnicode_AsMBCSString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsMBCSString(PyObject *unicode)
     * }
     */
    public static MemorySegment PyUnicode_AsMBCSString(MemorySegment unicode) {
        var mh$ = PyUnicode_AsMBCSString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_AsMBCSString", unicode);
            }
            return (MemorySegment)mh$.invokeExact(unicode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_EncodeCodePage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_EncodeCodePage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_EncodeCodePage(int code_page, PyObject *unicode, const char *errors)
     * }
     */
    public static FunctionDescriptor PyUnicode_EncodeCodePage$descriptor() {
        return PyUnicode_EncodeCodePage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_EncodeCodePage(int code_page, PyObject *unicode, const char *errors)
     * }
     */
    public static MethodHandle PyUnicode_EncodeCodePage$handle() {
        return PyUnicode_EncodeCodePage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_EncodeCodePage(int code_page, PyObject *unicode, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_EncodeCodePage$address() {
        return PyUnicode_EncodeCodePage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_EncodeCodePage(int code_page, PyObject *unicode, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_EncodeCodePage(int code_page, MemorySegment unicode, MemorySegment errors) {
        var mh$ = PyUnicode_EncodeCodePage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_EncodeCodePage", code_page, unicode, errors);
            }
            return (MemorySegment)mh$.invokeExact(code_page, unicode, errors);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_DecodeLocaleAndSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_DecodeLocaleAndSize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeLocaleAndSize(const char *str, Py_ssize_t len, const char *errors)
     * }
     */
    public static FunctionDescriptor PyUnicode_DecodeLocaleAndSize$descriptor() {
        return PyUnicode_DecodeLocaleAndSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeLocaleAndSize(const char *str, Py_ssize_t len, const char *errors)
     * }
     */
    public static MethodHandle PyUnicode_DecodeLocaleAndSize$handle() {
        return PyUnicode_DecodeLocaleAndSize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeLocaleAndSize(const char *str, Py_ssize_t len, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_DecodeLocaleAndSize$address() {
        return PyUnicode_DecodeLocaleAndSize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeLocaleAndSize(const char *str, Py_ssize_t len, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_DecodeLocaleAndSize(MemorySegment str, long len, MemorySegment errors) {
        var mh$ = PyUnicode_DecodeLocaleAndSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_DecodeLocaleAndSize", str, len, errors);
            }
            return (MemorySegment)mh$.invokeExact(str, len, errors);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_DecodeLocale {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_DecodeLocale");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeLocale(const char *str, const char *errors)
     * }
     */
    public static FunctionDescriptor PyUnicode_DecodeLocale$descriptor() {
        return PyUnicode_DecodeLocale.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeLocale(const char *str, const char *errors)
     * }
     */
    public static MethodHandle PyUnicode_DecodeLocale$handle() {
        return PyUnicode_DecodeLocale.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeLocale(const char *str, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_DecodeLocale$address() {
        return PyUnicode_DecodeLocale.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeLocale(const char *str, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_DecodeLocale(MemorySegment str, MemorySegment errors) {
        var mh$ = PyUnicode_DecodeLocale.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_DecodeLocale", str, errors);
            }
            return (MemorySegment)mh$.invokeExact(str, errors);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_EncodeLocale {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_EncodeLocale");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_EncodeLocale(PyObject *unicode, const char *errors)
     * }
     */
    public static FunctionDescriptor PyUnicode_EncodeLocale$descriptor() {
        return PyUnicode_EncodeLocale.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_EncodeLocale(PyObject *unicode, const char *errors)
     * }
     */
    public static MethodHandle PyUnicode_EncodeLocale$handle() {
        return PyUnicode_EncodeLocale.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_EncodeLocale(PyObject *unicode, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_EncodeLocale$address() {
        return PyUnicode_EncodeLocale.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_EncodeLocale(PyObject *unicode, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_EncodeLocale(MemorySegment unicode, MemorySegment errors) {
        var mh$ = PyUnicode_EncodeLocale.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_EncodeLocale", unicode, errors);
            }
            return (MemorySegment)mh$.invokeExact(unicode, errors);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_FSConverter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_FSConverter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyUnicode_FSConverter(PyObject *, void *)
     * }
     */
    public static FunctionDescriptor PyUnicode_FSConverter$descriptor() {
        return PyUnicode_FSConverter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyUnicode_FSConverter(PyObject *, void *)
     * }
     */
    public static MethodHandle PyUnicode_FSConverter$handle() {
        return PyUnicode_FSConverter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyUnicode_FSConverter(PyObject *, void *)
     * }
     */
    public static MemorySegment PyUnicode_FSConverter$address() {
        return PyUnicode_FSConverter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyUnicode_FSConverter(PyObject *, void *)
     * }
     */
    public static int PyUnicode_FSConverter(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyUnicode_FSConverter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_FSConverter", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_FSDecoder {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_FSDecoder");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyUnicode_FSDecoder(PyObject *, void *)
     * }
     */
    public static FunctionDescriptor PyUnicode_FSDecoder$descriptor() {
        return PyUnicode_FSDecoder.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyUnicode_FSDecoder(PyObject *, void *)
     * }
     */
    public static MethodHandle PyUnicode_FSDecoder$handle() {
        return PyUnicode_FSDecoder.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyUnicode_FSDecoder(PyObject *, void *)
     * }
     */
    public static MemorySegment PyUnicode_FSDecoder$address() {
        return PyUnicode_FSDecoder.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyUnicode_FSDecoder(PyObject *, void *)
     * }
     */
    public static int PyUnicode_FSDecoder(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyUnicode_FSDecoder.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_FSDecoder", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_DecodeFSDefault {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_DecodeFSDefault");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeFSDefault(const char *s)
     * }
     */
    public static FunctionDescriptor PyUnicode_DecodeFSDefault$descriptor() {
        return PyUnicode_DecodeFSDefault.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeFSDefault(const char *s)
     * }
     */
    public static MethodHandle PyUnicode_DecodeFSDefault$handle() {
        return PyUnicode_DecodeFSDefault.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeFSDefault(const char *s)
     * }
     */
    public static MemorySegment PyUnicode_DecodeFSDefault$address() {
        return PyUnicode_DecodeFSDefault.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeFSDefault(const char *s)
     * }
     */
    public static MemorySegment PyUnicode_DecodeFSDefault(MemorySegment s) {
        var mh$ = PyUnicode_DecodeFSDefault.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_DecodeFSDefault", s);
            }
            return (MemorySegment)mh$.invokeExact(s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_DecodeFSDefaultAndSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_DecodeFSDefaultAndSize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeFSDefaultAndSize(const char *s, Py_ssize_t size)
     * }
     */
    public static FunctionDescriptor PyUnicode_DecodeFSDefaultAndSize$descriptor() {
        return PyUnicode_DecodeFSDefaultAndSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeFSDefaultAndSize(const char *s, Py_ssize_t size)
     * }
     */
    public static MethodHandle PyUnicode_DecodeFSDefaultAndSize$handle() {
        return PyUnicode_DecodeFSDefaultAndSize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeFSDefaultAndSize(const char *s, Py_ssize_t size)
     * }
     */
    public static MemorySegment PyUnicode_DecodeFSDefaultAndSize$address() {
        return PyUnicode_DecodeFSDefaultAndSize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeFSDefaultAndSize(const char *s, Py_ssize_t size)
     * }
     */
    public static MemorySegment PyUnicode_DecodeFSDefaultAndSize(MemorySegment s, long size) {
        var mh$ = PyUnicode_DecodeFSDefaultAndSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_DecodeFSDefaultAndSize", s, size);
            }
            return (MemorySegment)mh$.invokeExact(s, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_EncodeFSDefault {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_EncodeFSDefault");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_EncodeFSDefault(PyObject *unicode)
     * }
     */
    public static FunctionDescriptor PyUnicode_EncodeFSDefault$descriptor() {
        return PyUnicode_EncodeFSDefault.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_EncodeFSDefault(PyObject *unicode)
     * }
     */
    public static MethodHandle PyUnicode_EncodeFSDefault$handle() {
        return PyUnicode_EncodeFSDefault.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_EncodeFSDefault(PyObject *unicode)
     * }
     */
    public static MemorySegment PyUnicode_EncodeFSDefault$address() {
        return PyUnicode_EncodeFSDefault.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_EncodeFSDefault(PyObject *unicode)
     * }
     */
    public static MemorySegment PyUnicode_EncodeFSDefault(MemorySegment unicode) {
        var mh$ = PyUnicode_EncodeFSDefault.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_EncodeFSDefault", unicode);
            }
            return (MemorySegment)mh$.invokeExact(unicode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_Concat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_Concat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_Concat(PyObject *left, PyObject *right)
     * }
     */
    public static FunctionDescriptor PyUnicode_Concat$descriptor() {
        return PyUnicode_Concat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_Concat(PyObject *left, PyObject *right)
     * }
     */
    public static MethodHandle PyUnicode_Concat$handle() {
        return PyUnicode_Concat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_Concat(PyObject *left, PyObject *right)
     * }
     */
    public static MemorySegment PyUnicode_Concat$address() {
        return PyUnicode_Concat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_Concat(PyObject *left, PyObject *right)
     * }
     */
    public static MemorySegment PyUnicode_Concat(MemorySegment left, MemorySegment right) {
        var mh$ = PyUnicode_Concat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_Concat", left, right);
            }
            return (MemorySegment)mh$.invokeExact(left, right);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_Append {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_Append");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyUnicode_Append(PyObject **pleft, PyObject *right)
     * }
     */
    public static FunctionDescriptor PyUnicode_Append$descriptor() {
        return PyUnicode_Append.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyUnicode_Append(PyObject **pleft, PyObject *right)
     * }
     */
    public static MethodHandle PyUnicode_Append$handle() {
        return PyUnicode_Append.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyUnicode_Append(PyObject **pleft, PyObject *right)
     * }
     */
    public static MemorySegment PyUnicode_Append$address() {
        return PyUnicode_Append.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyUnicode_Append(PyObject **pleft, PyObject *right)
     * }
     */
    public static void PyUnicode_Append(MemorySegment pleft, MemorySegment right) {
        var mh$ = PyUnicode_Append.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_Append", pleft, right);
            }
            mh$.invokeExact(pleft, right);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_AppendAndDel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_AppendAndDel");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyUnicode_AppendAndDel(PyObject **pleft, PyObject *right)
     * }
     */
    public static FunctionDescriptor PyUnicode_AppendAndDel$descriptor() {
        return PyUnicode_AppendAndDel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyUnicode_AppendAndDel(PyObject **pleft, PyObject *right)
     * }
     */
    public static MethodHandle PyUnicode_AppendAndDel$handle() {
        return PyUnicode_AppendAndDel.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyUnicode_AppendAndDel(PyObject **pleft, PyObject *right)
     * }
     */
    public static MemorySegment PyUnicode_AppendAndDel$address() {
        return PyUnicode_AppendAndDel.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyUnicode_AppendAndDel(PyObject **pleft, PyObject *right)
     * }
     */
    public static void PyUnicode_AppendAndDel(MemorySegment pleft, MemorySegment right) {
        var mh$ = PyUnicode_AppendAndDel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_AppendAndDel", pleft, right);
            }
            mh$.invokeExact(pleft, right);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_Split {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_Split");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_Split(PyObject *s, PyObject *sep, Py_ssize_t maxsplit)
     * }
     */
    public static FunctionDescriptor PyUnicode_Split$descriptor() {
        return PyUnicode_Split.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_Split(PyObject *s, PyObject *sep, Py_ssize_t maxsplit)
     * }
     */
    public static MethodHandle PyUnicode_Split$handle() {
        return PyUnicode_Split.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_Split(PyObject *s, PyObject *sep, Py_ssize_t maxsplit)
     * }
     */
    public static MemorySegment PyUnicode_Split$address() {
        return PyUnicode_Split.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_Split(PyObject *s, PyObject *sep, Py_ssize_t maxsplit)
     * }
     */
    public static MemorySegment PyUnicode_Split(MemorySegment s, MemorySegment sep, long maxsplit) {
        var mh$ = PyUnicode_Split.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_Split", s, sep, maxsplit);
            }
            return (MemorySegment)mh$.invokeExact(s, sep, maxsplit);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_Splitlines {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_Splitlines");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_Splitlines(PyObject *s, int keepends)
     * }
     */
    public static FunctionDescriptor PyUnicode_Splitlines$descriptor() {
        return PyUnicode_Splitlines.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_Splitlines(PyObject *s, int keepends)
     * }
     */
    public static MethodHandle PyUnicode_Splitlines$handle() {
        return PyUnicode_Splitlines.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_Splitlines(PyObject *s, int keepends)
     * }
     */
    public static MemorySegment PyUnicode_Splitlines$address() {
        return PyUnicode_Splitlines.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_Splitlines(PyObject *s, int keepends)
     * }
     */
    public static MemorySegment PyUnicode_Splitlines(MemorySegment s, int keepends) {
        var mh$ = PyUnicode_Splitlines.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_Splitlines", s, keepends);
            }
            return (MemorySegment)mh$.invokeExact(s, keepends);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_Partition {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_Partition");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_Partition(PyObject *s, PyObject *sep)
     * }
     */
    public static FunctionDescriptor PyUnicode_Partition$descriptor() {
        return PyUnicode_Partition.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_Partition(PyObject *s, PyObject *sep)
     * }
     */
    public static MethodHandle PyUnicode_Partition$handle() {
        return PyUnicode_Partition.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_Partition(PyObject *s, PyObject *sep)
     * }
     */
    public static MemorySegment PyUnicode_Partition$address() {
        return PyUnicode_Partition.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_Partition(PyObject *s, PyObject *sep)
     * }
     */
    public static MemorySegment PyUnicode_Partition(MemorySegment s, MemorySegment sep) {
        var mh$ = PyUnicode_Partition.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_Partition", s, sep);
            }
            return (MemorySegment)mh$.invokeExact(s, sep);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_RPartition {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_RPartition");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_RPartition(PyObject *s, PyObject *sep)
     * }
     */
    public static FunctionDescriptor PyUnicode_RPartition$descriptor() {
        return PyUnicode_RPartition.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_RPartition(PyObject *s, PyObject *sep)
     * }
     */
    public static MethodHandle PyUnicode_RPartition$handle() {
        return PyUnicode_RPartition.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_RPartition(PyObject *s, PyObject *sep)
     * }
     */
    public static MemorySegment PyUnicode_RPartition$address() {
        return PyUnicode_RPartition.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_RPartition(PyObject *s, PyObject *sep)
     * }
     */
    public static MemorySegment PyUnicode_RPartition(MemorySegment s, MemorySegment sep) {
        var mh$ = PyUnicode_RPartition.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_RPartition", s, sep);
            }
            return (MemorySegment)mh$.invokeExact(s, sep);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_RSplit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_RSplit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_RSplit(PyObject *s, PyObject *sep, Py_ssize_t maxsplit)
     * }
     */
    public static FunctionDescriptor PyUnicode_RSplit$descriptor() {
        return PyUnicode_RSplit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_RSplit(PyObject *s, PyObject *sep, Py_ssize_t maxsplit)
     * }
     */
    public static MethodHandle PyUnicode_RSplit$handle() {
        return PyUnicode_RSplit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_RSplit(PyObject *s, PyObject *sep, Py_ssize_t maxsplit)
     * }
     */
    public static MemorySegment PyUnicode_RSplit$address() {
        return PyUnicode_RSplit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_RSplit(PyObject *s, PyObject *sep, Py_ssize_t maxsplit)
     * }
     */
    public static MemorySegment PyUnicode_RSplit(MemorySegment s, MemorySegment sep, long maxsplit) {
        var mh$ = PyUnicode_RSplit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_RSplit", s, sep, maxsplit);
            }
            return (MemorySegment)mh$.invokeExact(s, sep, maxsplit);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_Translate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_Translate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_Translate(PyObject *str, PyObject *table, const char *errors)
     * }
     */
    public static FunctionDescriptor PyUnicode_Translate$descriptor() {
        return PyUnicode_Translate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_Translate(PyObject *str, PyObject *table, const char *errors)
     * }
     */
    public static MethodHandle PyUnicode_Translate$handle() {
        return PyUnicode_Translate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_Translate(PyObject *str, PyObject *table, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_Translate$address() {
        return PyUnicode_Translate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_Translate(PyObject *str, PyObject *table, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_Translate(MemorySegment str, MemorySegment table, MemorySegment errors) {
        var mh$ = PyUnicode_Translate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_Translate", str, table, errors);
            }
            return (MemorySegment)mh$.invokeExact(str, table, errors);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_Join {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_Join");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_Join(PyObject *separator, PyObject *seq)
     * }
     */
    public static FunctionDescriptor PyUnicode_Join$descriptor() {
        return PyUnicode_Join.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_Join(PyObject *separator, PyObject *seq)
     * }
     */
    public static MethodHandle PyUnicode_Join$handle() {
        return PyUnicode_Join.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_Join(PyObject *separator, PyObject *seq)
     * }
     */
    public static MemorySegment PyUnicode_Join$address() {
        return PyUnicode_Join.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_Join(PyObject *separator, PyObject *seq)
     * }
     */
    public static MemorySegment PyUnicode_Join(MemorySegment separator, MemorySegment seq) {
        var mh$ = PyUnicode_Join.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_Join", separator, seq);
            }
            return (MemorySegment)mh$.invokeExact(separator, seq);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_Tailmatch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_LONG_LONG,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_Tailmatch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_ssize_t PyUnicode_Tailmatch(PyObject *str, PyObject *substr, Py_ssize_t start, Py_ssize_t end, int direction)
     * }
     */
    public static FunctionDescriptor PyUnicode_Tailmatch$descriptor() {
        return PyUnicode_Tailmatch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_ssize_t PyUnicode_Tailmatch(PyObject *str, PyObject *substr, Py_ssize_t start, Py_ssize_t end, int direction)
     * }
     */
    public static MethodHandle PyUnicode_Tailmatch$handle() {
        return PyUnicode_Tailmatch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_ssize_t PyUnicode_Tailmatch(PyObject *str, PyObject *substr, Py_ssize_t start, Py_ssize_t end, int direction)
     * }
     */
    public static MemorySegment PyUnicode_Tailmatch$address() {
        return PyUnicode_Tailmatch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_ssize_t PyUnicode_Tailmatch(PyObject *str, PyObject *substr, Py_ssize_t start, Py_ssize_t end, int direction)
     * }
     */
    public static long PyUnicode_Tailmatch(MemorySegment str, MemorySegment substr, long start, long end, int direction) {
        var mh$ = PyUnicode_Tailmatch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_Tailmatch", str, substr, start, end, direction);
            }
            return (long)mh$.invokeExact(str, substr, start, end, direction);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_Find {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_LONG_LONG,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_Find");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_ssize_t PyUnicode_Find(PyObject *str, PyObject *substr, Py_ssize_t start, Py_ssize_t end, int direction)
     * }
     */
    public static FunctionDescriptor PyUnicode_Find$descriptor() {
        return PyUnicode_Find.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_ssize_t PyUnicode_Find(PyObject *str, PyObject *substr, Py_ssize_t start, Py_ssize_t end, int direction)
     * }
     */
    public static MethodHandle PyUnicode_Find$handle() {
        return PyUnicode_Find.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_ssize_t PyUnicode_Find(PyObject *str, PyObject *substr, Py_ssize_t start, Py_ssize_t end, int direction)
     * }
     */
    public static MemorySegment PyUnicode_Find$address() {
        return PyUnicode_Find.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_ssize_t PyUnicode_Find(PyObject *str, PyObject *substr, Py_ssize_t start, Py_ssize_t end, int direction)
     * }
     */
    public static long PyUnicode_Find(MemorySegment str, MemorySegment substr, long start, long end, int direction) {
        var mh$ = PyUnicode_Find.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_Find", str, substr, start, end, direction);
            }
            return (long)mh$.invokeExact(str, substr, start, end, direction);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_FindChar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_LONG_LONG,
            Python_h.C_LONG_LONG,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_FindChar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_ssize_t PyUnicode_FindChar(PyObject *str, Py_UCS4 ch, Py_ssize_t start, Py_ssize_t end, int direction)
     * }
     */
    public static FunctionDescriptor PyUnicode_FindChar$descriptor() {
        return PyUnicode_FindChar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_ssize_t PyUnicode_FindChar(PyObject *str, Py_UCS4 ch, Py_ssize_t start, Py_ssize_t end, int direction)
     * }
     */
    public static MethodHandle PyUnicode_FindChar$handle() {
        return PyUnicode_FindChar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_ssize_t PyUnicode_FindChar(PyObject *str, Py_UCS4 ch, Py_ssize_t start, Py_ssize_t end, int direction)
     * }
     */
    public static MemorySegment PyUnicode_FindChar$address() {
        return PyUnicode_FindChar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_ssize_t PyUnicode_FindChar(PyObject *str, Py_UCS4 ch, Py_ssize_t start, Py_ssize_t end, int direction)
     * }
     */
    public static long PyUnicode_FindChar(MemorySegment str, int ch, long start, long end, int direction) {
        var mh$ = PyUnicode_FindChar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_FindChar", str, ch, start, end, direction);
            }
            return (long)mh$.invokeExact(str, ch, start, end, direction);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_Count {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_Count");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_ssize_t PyUnicode_Count(PyObject *str, PyObject *substr, Py_ssize_t start, Py_ssize_t end)
     * }
     */
    public static FunctionDescriptor PyUnicode_Count$descriptor() {
        return PyUnicode_Count.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_ssize_t PyUnicode_Count(PyObject *str, PyObject *substr, Py_ssize_t start, Py_ssize_t end)
     * }
     */
    public static MethodHandle PyUnicode_Count$handle() {
        return PyUnicode_Count.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_ssize_t PyUnicode_Count(PyObject *str, PyObject *substr, Py_ssize_t start, Py_ssize_t end)
     * }
     */
    public static MemorySegment PyUnicode_Count$address() {
        return PyUnicode_Count.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_ssize_t PyUnicode_Count(PyObject *str, PyObject *substr, Py_ssize_t start, Py_ssize_t end)
     * }
     */
    public static long PyUnicode_Count(MemorySegment str, MemorySegment substr, long start, long end) {
        var mh$ = PyUnicode_Count.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_Count", str, substr, start, end);
            }
            return (long)mh$.invokeExact(str, substr, start, end);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_Replace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_Replace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_Replace(PyObject *str, PyObject *substr, PyObject *replstr, Py_ssize_t maxcount)
     * }
     */
    public static FunctionDescriptor PyUnicode_Replace$descriptor() {
        return PyUnicode_Replace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_Replace(PyObject *str, PyObject *substr, PyObject *replstr, Py_ssize_t maxcount)
     * }
     */
    public static MethodHandle PyUnicode_Replace$handle() {
        return PyUnicode_Replace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_Replace(PyObject *str, PyObject *substr, PyObject *replstr, Py_ssize_t maxcount)
     * }
     */
    public static MemorySegment PyUnicode_Replace$address() {
        return PyUnicode_Replace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_Replace(PyObject *str, PyObject *substr, PyObject *replstr, Py_ssize_t maxcount)
     * }
     */
    public static MemorySegment PyUnicode_Replace(MemorySegment str, MemorySegment substr, MemorySegment replstr, long maxcount) {
        var mh$ = PyUnicode_Replace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_Replace", str, substr, replstr, maxcount);
            }
            return (MemorySegment)mh$.invokeExact(str, substr, replstr, maxcount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_Compare {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_Compare");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyUnicode_Compare(PyObject *left, PyObject *right)
     * }
     */
    public static FunctionDescriptor PyUnicode_Compare$descriptor() {
        return PyUnicode_Compare.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyUnicode_Compare(PyObject *left, PyObject *right)
     * }
     */
    public static MethodHandle PyUnicode_Compare$handle() {
        return PyUnicode_Compare.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyUnicode_Compare(PyObject *left, PyObject *right)
     * }
     */
    public static MemorySegment PyUnicode_Compare$address() {
        return PyUnicode_Compare.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyUnicode_Compare(PyObject *left, PyObject *right)
     * }
     */
    public static int PyUnicode_Compare(MemorySegment left, MemorySegment right) {
        var mh$ = PyUnicode_Compare.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_Compare", left, right);
            }
            return (int)mh$.invokeExact(left, right);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_CompareWithASCIIString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_CompareWithASCIIString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyUnicode_CompareWithASCIIString(PyObject *left, const char *right)
     * }
     */
    public static FunctionDescriptor PyUnicode_CompareWithASCIIString$descriptor() {
        return PyUnicode_CompareWithASCIIString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyUnicode_CompareWithASCIIString(PyObject *left, const char *right)
     * }
     */
    public static MethodHandle PyUnicode_CompareWithASCIIString$handle() {
        return PyUnicode_CompareWithASCIIString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyUnicode_CompareWithASCIIString(PyObject *left, const char *right)
     * }
     */
    public static MemorySegment PyUnicode_CompareWithASCIIString$address() {
        return PyUnicode_CompareWithASCIIString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyUnicode_CompareWithASCIIString(PyObject *left, const char *right)
     * }
     */
    public static int PyUnicode_CompareWithASCIIString(MemorySegment left, MemorySegment right) {
        var mh$ = PyUnicode_CompareWithASCIIString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_CompareWithASCIIString", left, right);
            }
            return (int)mh$.invokeExact(left, right);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_RichCompare {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_RichCompare");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_RichCompare(PyObject *left, PyObject *right, int op)
     * }
     */
    public static FunctionDescriptor PyUnicode_RichCompare$descriptor() {
        return PyUnicode_RichCompare.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_RichCompare(PyObject *left, PyObject *right, int op)
     * }
     */
    public static MethodHandle PyUnicode_RichCompare$handle() {
        return PyUnicode_RichCompare.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_RichCompare(PyObject *left, PyObject *right, int op)
     * }
     */
    public static MemorySegment PyUnicode_RichCompare$address() {
        return PyUnicode_RichCompare.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_RichCompare(PyObject *left, PyObject *right, int op)
     * }
     */
    public static MemorySegment PyUnicode_RichCompare(MemorySegment left, MemorySegment right, int op) {
        var mh$ = PyUnicode_RichCompare.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_RichCompare", left, right, op);
            }
            return (MemorySegment)mh$.invokeExact(left, right, op);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_Format {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_Format");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_Format(PyObject *format, PyObject *args)
     * }
     */
    public static FunctionDescriptor PyUnicode_Format$descriptor() {
        return PyUnicode_Format.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_Format(PyObject *format, PyObject *args)
     * }
     */
    public static MethodHandle PyUnicode_Format$handle() {
        return PyUnicode_Format.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_Format(PyObject *format, PyObject *args)
     * }
     */
    public static MemorySegment PyUnicode_Format$address() {
        return PyUnicode_Format.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_Format(PyObject *format, PyObject *args)
     * }
     */
    public static MemorySegment PyUnicode_Format(MemorySegment format, MemorySegment args) {
        var mh$ = PyUnicode_Format.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_Format", format, args);
            }
            return (MemorySegment)mh$.invokeExact(format, args);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_Contains {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_Contains");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyUnicode_Contains(PyObject *container, PyObject *element)
     * }
     */
    public static FunctionDescriptor PyUnicode_Contains$descriptor() {
        return PyUnicode_Contains.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyUnicode_Contains(PyObject *container, PyObject *element)
     * }
     */
    public static MethodHandle PyUnicode_Contains$handle() {
        return PyUnicode_Contains.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyUnicode_Contains(PyObject *container, PyObject *element)
     * }
     */
    public static MemorySegment PyUnicode_Contains$address() {
        return PyUnicode_Contains.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyUnicode_Contains(PyObject *container, PyObject *element)
     * }
     */
    public static int PyUnicode_Contains(MemorySegment container, MemorySegment element) {
        var mh$ = PyUnicode_Contains.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_Contains", container, element);
            }
            return (int)mh$.invokeExact(container, element);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_IsIdentifier {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_IsIdentifier");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyUnicode_IsIdentifier(PyObject *s)
     * }
     */
    public static FunctionDescriptor PyUnicode_IsIdentifier$descriptor() {
        return PyUnicode_IsIdentifier.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyUnicode_IsIdentifier(PyObject *s)
     * }
     */
    public static MethodHandle PyUnicode_IsIdentifier$handle() {
        return PyUnicode_IsIdentifier.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyUnicode_IsIdentifier(PyObject *s)
     * }
     */
    public static MemorySegment PyUnicode_IsIdentifier$address() {
        return PyUnicode_IsIdentifier.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyUnicode_IsIdentifier(PyObject *s)
     * }
     */
    public static int PyUnicode_IsIdentifier(MemorySegment s) {
        var mh$ = PyUnicode_IsIdentifier.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_IsIdentifier", s);
            }
            return (int)mh$.invokeExact(s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef wchar_t Py_UNICODE
     * }
     */
    public static final OfShort Py_UNICODE = Python_h.C_SHORT;

    private static class _PyUnicode_CheckConsistency {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyUnicode_CheckConsistency");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyUnicode_CheckConsistency(PyObject *op, int check_content)
     * }
     */
    public static FunctionDescriptor _PyUnicode_CheckConsistency$descriptor() {
        return _PyUnicode_CheckConsistency.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyUnicode_CheckConsistency(PyObject *op, int check_content)
     * }
     */
    public static MethodHandle _PyUnicode_CheckConsistency$handle() {
        return _PyUnicode_CheckConsistency.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyUnicode_CheckConsistency(PyObject *op, int check_content)
     * }
     */
    public static MemorySegment _PyUnicode_CheckConsistency$address() {
        return _PyUnicode_CheckConsistency.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyUnicode_CheckConsistency(PyObject *op, int check_content)
     * }
     */
    public static int _PyUnicode_CheckConsistency(MemorySegment op, int check_content) {
        var mh$ = _PyUnicode_CheckConsistency.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyUnicode_CheckConsistency", op, check_content);
            }
            return (int)mh$.invokeExact(op, check_content);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
}

