// Generated by jextract

package org.python;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

public class Python_h extends Python_h_1 {

    Python_h() {
        // Should not be called directly
    }

    private static class PyEval_AcquireThread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyEval_AcquireThread");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyEval_AcquireThread(PyThreadState *tstate)
     * }
     */
    public static FunctionDescriptor PyEval_AcquireThread$descriptor() {
        return PyEval_AcquireThread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyEval_AcquireThread(PyThreadState *tstate)
     * }
     */
    public static MethodHandle PyEval_AcquireThread$handle() {
        return PyEval_AcquireThread.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyEval_AcquireThread(PyThreadState *tstate)
     * }
     */
    public static MemorySegment PyEval_AcquireThread$address() {
        return PyEval_AcquireThread.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyEval_AcquireThread(PyThreadState *tstate)
     * }
     */
    public static void PyEval_AcquireThread(MemorySegment tstate) {
        var mh$ = PyEval_AcquireThread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyEval_AcquireThread", tstate);
            }
            mh$.invokeExact(tstate);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyEval_ReleaseThread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyEval_ReleaseThread");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyEval_ReleaseThread(PyThreadState *tstate)
     * }
     */
    public static FunctionDescriptor PyEval_ReleaseThread$descriptor() {
        return PyEval_ReleaseThread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyEval_ReleaseThread(PyThreadState *tstate)
     * }
     */
    public static MethodHandle PyEval_ReleaseThread$handle() {
        return PyEval_ReleaseThread.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyEval_ReleaseThread(PyThreadState *tstate)
     * }
     */
    public static MemorySegment PyEval_ReleaseThread$address() {
        return PyEval_ReleaseThread.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyEval_ReleaseThread(PyThreadState *tstate)
     * }
     */
    public static void PyEval_ReleaseThread(MemorySegment tstate) {
        var mh$ = PyEval_ReleaseThread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyEval_ReleaseThread", tstate);
            }
            mh$.invokeExact(tstate);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyEval_SetProfile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyEval_SetProfile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyEval_SetProfile(Py_tracefunc, PyObject *)
     * }
     */
    public static FunctionDescriptor PyEval_SetProfile$descriptor() {
        return PyEval_SetProfile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyEval_SetProfile(Py_tracefunc, PyObject *)
     * }
     */
    public static MethodHandle PyEval_SetProfile$handle() {
        return PyEval_SetProfile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyEval_SetProfile(Py_tracefunc, PyObject *)
     * }
     */
    public static MemorySegment PyEval_SetProfile$address() {
        return PyEval_SetProfile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyEval_SetProfile(Py_tracefunc, PyObject *)
     * }
     */
    public static void PyEval_SetProfile(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyEval_SetProfile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyEval_SetProfile", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyEval_SetProfileAllThreads {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyEval_SetProfileAllThreads");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyEval_SetProfileAllThreads(Py_tracefunc, PyObject *)
     * }
     */
    public static FunctionDescriptor PyEval_SetProfileAllThreads$descriptor() {
        return PyEval_SetProfileAllThreads.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyEval_SetProfileAllThreads(Py_tracefunc, PyObject *)
     * }
     */
    public static MethodHandle PyEval_SetProfileAllThreads$handle() {
        return PyEval_SetProfileAllThreads.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyEval_SetProfileAllThreads(Py_tracefunc, PyObject *)
     * }
     */
    public static MemorySegment PyEval_SetProfileAllThreads$address() {
        return PyEval_SetProfileAllThreads.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyEval_SetProfileAllThreads(Py_tracefunc, PyObject *)
     * }
     */
    public static void PyEval_SetProfileAllThreads(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyEval_SetProfileAllThreads.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyEval_SetProfileAllThreads", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyEval_SetProfile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyEval_SetProfile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int _PyEval_SetProfile(PyThreadState *tstate, Py_tracefunc func, PyObject *arg)
     * }
     */
    public static FunctionDescriptor _PyEval_SetProfile$descriptor() {
        return _PyEval_SetProfile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int _PyEval_SetProfile(PyThreadState *tstate, Py_tracefunc func, PyObject *arg)
     * }
     */
    public static MethodHandle _PyEval_SetProfile$handle() {
        return _PyEval_SetProfile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int _PyEval_SetProfile(PyThreadState *tstate, Py_tracefunc func, PyObject *arg)
     * }
     */
    public static MemorySegment _PyEval_SetProfile$address() {
        return _PyEval_SetProfile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int _PyEval_SetProfile(PyThreadState *tstate, Py_tracefunc func, PyObject *arg)
     * }
     */
    public static int _PyEval_SetProfile(MemorySegment tstate, MemorySegment func, MemorySegment arg) {
        var mh$ = _PyEval_SetProfile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyEval_SetProfile", tstate, func, arg);
            }
            return (int)mh$.invokeExact(tstate, func, arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyEval_SetTrace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyEval_SetTrace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyEval_SetTrace(Py_tracefunc, PyObject *)
     * }
     */
    public static FunctionDescriptor PyEval_SetTrace$descriptor() {
        return PyEval_SetTrace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyEval_SetTrace(Py_tracefunc, PyObject *)
     * }
     */
    public static MethodHandle PyEval_SetTrace$handle() {
        return PyEval_SetTrace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyEval_SetTrace(Py_tracefunc, PyObject *)
     * }
     */
    public static MemorySegment PyEval_SetTrace$address() {
        return PyEval_SetTrace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyEval_SetTrace(Py_tracefunc, PyObject *)
     * }
     */
    public static void PyEval_SetTrace(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyEval_SetTrace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyEval_SetTrace", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyEval_SetTraceAllThreads {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyEval_SetTraceAllThreads");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyEval_SetTraceAllThreads(Py_tracefunc, PyObject *)
     * }
     */
    public static FunctionDescriptor PyEval_SetTraceAllThreads$descriptor() {
        return PyEval_SetTraceAllThreads.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyEval_SetTraceAllThreads(Py_tracefunc, PyObject *)
     * }
     */
    public static MethodHandle PyEval_SetTraceAllThreads$handle() {
        return PyEval_SetTraceAllThreads.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyEval_SetTraceAllThreads(Py_tracefunc, PyObject *)
     * }
     */
    public static MemorySegment PyEval_SetTraceAllThreads$address() {
        return PyEval_SetTraceAllThreads.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyEval_SetTraceAllThreads(Py_tracefunc, PyObject *)
     * }
     */
    public static void PyEval_SetTraceAllThreads(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyEval_SetTraceAllThreads.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyEval_SetTraceAllThreads", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyEval_SetTrace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyEval_SetTrace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyEval_SetTrace(PyThreadState *tstate, Py_tracefunc func, PyObject *arg)
     * }
     */
    public static FunctionDescriptor _PyEval_SetTrace$descriptor() {
        return _PyEval_SetTrace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyEval_SetTrace(PyThreadState *tstate, Py_tracefunc func, PyObject *arg)
     * }
     */
    public static MethodHandle _PyEval_SetTrace$handle() {
        return _PyEval_SetTrace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyEval_SetTrace(PyThreadState *tstate, Py_tracefunc func, PyObject *arg)
     * }
     */
    public static MemorySegment _PyEval_SetTrace$address() {
        return _PyEval_SetTrace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyEval_SetTrace(PyThreadState *tstate, Py_tracefunc func, PyObject *arg)
     * }
     */
    public static int _PyEval_SetTrace(MemorySegment tstate, MemorySegment func, MemorySegment arg) {
        var mh$ = _PyEval_SetTrace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyEval_SetTrace", tstate, func, arg);
            }
            return (int)mh$.invokeExact(tstate, func, arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyEval_GetBuiltin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyEval_GetBuiltin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *_PyEval_GetBuiltin(PyObject *)
     * }
     */
    public static FunctionDescriptor _PyEval_GetBuiltin$descriptor() {
        return _PyEval_GetBuiltin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *_PyEval_GetBuiltin(PyObject *)
     * }
     */
    public static MethodHandle _PyEval_GetBuiltin$handle() {
        return _PyEval_GetBuiltin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *_PyEval_GetBuiltin(PyObject *)
     * }
     */
    public static MemorySegment _PyEval_GetBuiltin$address() {
        return _PyEval_GetBuiltin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *_PyEval_GetBuiltin(PyObject *)
     * }
     */
    public static MemorySegment _PyEval_GetBuiltin(MemorySegment x0) {
        var mh$ = _PyEval_GetBuiltin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyEval_GetBuiltin", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyEval_GetBuiltinId {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyEval_GetBuiltinId");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *_PyEval_GetBuiltinId(_Py_Identifier *)
     * }
     */
    public static FunctionDescriptor _PyEval_GetBuiltinId$descriptor() {
        return _PyEval_GetBuiltinId.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *_PyEval_GetBuiltinId(_Py_Identifier *)
     * }
     */
    public static MethodHandle _PyEval_GetBuiltinId$handle() {
        return _PyEval_GetBuiltinId.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *_PyEval_GetBuiltinId(_Py_Identifier *)
     * }
     */
    public static MemorySegment _PyEval_GetBuiltinId$address() {
        return _PyEval_GetBuiltinId.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *_PyEval_GetBuiltinId(_Py_Identifier *)
     * }
     */
    public static MemorySegment _PyEval_GetBuiltinId(MemorySegment x0) {
        var mh$ = _PyEval_GetBuiltinId.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyEval_GetBuiltinId", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyEval_MergeCompilerFlags {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyEval_MergeCompilerFlags");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyEval_MergeCompilerFlags(PyCompilerFlags *cf)
     * }
     */
    public static FunctionDescriptor PyEval_MergeCompilerFlags$descriptor() {
        return PyEval_MergeCompilerFlags.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyEval_MergeCompilerFlags(PyCompilerFlags *cf)
     * }
     */
    public static MethodHandle PyEval_MergeCompilerFlags$handle() {
        return PyEval_MergeCompilerFlags.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyEval_MergeCompilerFlags(PyCompilerFlags *cf)
     * }
     */
    public static MemorySegment PyEval_MergeCompilerFlags$address() {
        return PyEval_MergeCompilerFlags.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyEval_MergeCompilerFlags(PyCompilerFlags *cf)
     * }
     */
    public static int PyEval_MergeCompilerFlags(MemorySegment cf) {
        var mh$ = PyEval_MergeCompilerFlags.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyEval_MergeCompilerFlags", cf);
            }
            return (int)mh$.invokeExact(cf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyEval_EvalFrameDefault {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyEval_EvalFrameDefault");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *_PyEval_EvalFrameDefault(PyThreadState *tstate, struct _PyInterpreterFrame *f, int exc)
     * }
     */
    public static FunctionDescriptor _PyEval_EvalFrameDefault$descriptor() {
        return _PyEval_EvalFrameDefault.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *_PyEval_EvalFrameDefault(PyThreadState *tstate, struct _PyInterpreterFrame *f, int exc)
     * }
     */
    public static MethodHandle _PyEval_EvalFrameDefault$handle() {
        return _PyEval_EvalFrameDefault.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *_PyEval_EvalFrameDefault(PyThreadState *tstate, struct _PyInterpreterFrame *f, int exc)
     * }
     */
    public static MemorySegment _PyEval_EvalFrameDefault$address() {
        return _PyEval_EvalFrameDefault.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *_PyEval_EvalFrameDefault(PyThreadState *tstate, struct _PyInterpreterFrame *f, int exc)
     * }
     */
    public static MemorySegment _PyEval_EvalFrameDefault(MemorySegment tstate, MemorySegment f, int exc) {
        var mh$ = _PyEval_EvalFrameDefault.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyEval_EvalFrameDefault", tstate, f, exc);
            }
            return (MemorySegment)mh$.invokeExact(tstate, f, exc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyEval_SetSwitchInterval {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyEval_SetSwitchInterval");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _PyEval_SetSwitchInterval(unsigned long microseconds)
     * }
     */
    public static FunctionDescriptor _PyEval_SetSwitchInterval$descriptor() {
        return _PyEval_SetSwitchInterval.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _PyEval_SetSwitchInterval(unsigned long microseconds)
     * }
     */
    public static MethodHandle _PyEval_SetSwitchInterval$handle() {
        return _PyEval_SetSwitchInterval.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _PyEval_SetSwitchInterval(unsigned long microseconds)
     * }
     */
    public static MemorySegment _PyEval_SetSwitchInterval$address() {
        return _PyEval_SetSwitchInterval.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _PyEval_SetSwitchInterval(unsigned long microseconds)
     * }
     */
    public static void _PyEval_SetSwitchInterval(int microseconds) {
        var mh$ = _PyEval_SetSwitchInterval.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyEval_SetSwitchInterval", microseconds);
            }
            mh$.invokeExact(microseconds);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyEval_GetSwitchInterval {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyEval_GetSwitchInterval");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long _PyEval_GetSwitchInterval()
     * }
     */
    public static FunctionDescriptor _PyEval_GetSwitchInterval$descriptor() {
        return _PyEval_GetSwitchInterval.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long _PyEval_GetSwitchInterval()
     * }
     */
    public static MethodHandle _PyEval_GetSwitchInterval$handle() {
        return _PyEval_GetSwitchInterval.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long _PyEval_GetSwitchInterval()
     * }
     */
    public static MemorySegment _PyEval_GetSwitchInterval$address() {
        return _PyEval_GetSwitchInterval.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long _PyEval_GetSwitchInterval()
     * }
     */
    public static int _PyEval_GetSwitchInterval() {
        var mh$ = _PyEval_GetSwitchInterval.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyEval_GetSwitchInterval");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyEval_MakePendingCalls {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyEval_MakePendingCalls");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyEval_MakePendingCalls(PyThreadState *)
     * }
     */
    public static FunctionDescriptor _PyEval_MakePendingCalls$descriptor() {
        return _PyEval_MakePendingCalls.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyEval_MakePendingCalls(PyThreadState *)
     * }
     */
    public static MethodHandle _PyEval_MakePendingCalls$handle() {
        return _PyEval_MakePendingCalls.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyEval_MakePendingCalls(PyThreadState *)
     * }
     */
    public static MemorySegment _PyEval_MakePendingCalls$address() {
        return _PyEval_MakePendingCalls.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyEval_MakePendingCalls(PyThreadState *)
     * }
     */
    public static int _PyEval_MakePendingCalls(MemorySegment x0) {
        var mh$ = _PyEval_MakePendingCalls.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyEval_MakePendingCalls", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnstable_Eval_RequestCodeExtraIndex {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnstable_Eval_RequestCodeExtraIndex");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_ssize_t PyUnstable_Eval_RequestCodeExtraIndex(freefunc)
     * }
     */
    public static FunctionDescriptor PyUnstable_Eval_RequestCodeExtraIndex$descriptor() {
        return PyUnstable_Eval_RequestCodeExtraIndex.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_ssize_t PyUnstable_Eval_RequestCodeExtraIndex(freefunc)
     * }
     */
    public static MethodHandle PyUnstable_Eval_RequestCodeExtraIndex$handle() {
        return PyUnstable_Eval_RequestCodeExtraIndex.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_ssize_t PyUnstable_Eval_RequestCodeExtraIndex(freefunc)
     * }
     */
    public static MemorySegment PyUnstable_Eval_RequestCodeExtraIndex$address() {
        return PyUnstable_Eval_RequestCodeExtraIndex.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_ssize_t PyUnstable_Eval_RequestCodeExtraIndex(freefunc)
     * }
     */
    public static long PyUnstable_Eval_RequestCodeExtraIndex(MemorySegment x0) {
        var mh$ = PyUnstable_Eval_RequestCodeExtraIndex.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnstable_Eval_RequestCodeExtraIndex", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyEval_SliceIndex {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyEval_SliceIndex");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyEval_SliceIndex(PyObject *, Py_ssize_t *)
     * }
     */
    public static FunctionDescriptor _PyEval_SliceIndex$descriptor() {
        return _PyEval_SliceIndex.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyEval_SliceIndex(PyObject *, Py_ssize_t *)
     * }
     */
    public static MethodHandle _PyEval_SliceIndex$handle() {
        return _PyEval_SliceIndex.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyEval_SliceIndex(PyObject *, Py_ssize_t *)
     * }
     */
    public static MemorySegment _PyEval_SliceIndex$address() {
        return _PyEval_SliceIndex.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyEval_SliceIndex(PyObject *, Py_ssize_t *)
     * }
     */
    public static int _PyEval_SliceIndex(MemorySegment x0, MemorySegment x1) {
        var mh$ = _PyEval_SliceIndex.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyEval_SliceIndex", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyEval_SliceIndexNotNone {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyEval_SliceIndexNotNone");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyEval_SliceIndexNotNone(PyObject *, Py_ssize_t *)
     * }
     */
    public static FunctionDescriptor _PyEval_SliceIndexNotNone$descriptor() {
        return _PyEval_SliceIndexNotNone.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyEval_SliceIndexNotNone(PyObject *, Py_ssize_t *)
     * }
     */
    public static MethodHandle _PyEval_SliceIndexNotNone$handle() {
        return _PyEval_SliceIndexNotNone.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyEval_SliceIndexNotNone(PyObject *, Py_ssize_t *)
     * }
     */
    public static MemorySegment _PyEval_SliceIndexNotNone$address() {
        return _PyEval_SliceIndexNotNone.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyEval_SliceIndexNotNone(PyObject *, Py_ssize_t *)
     * }
     */
    public static int _PyEval_SliceIndexNotNone(MemorySegment x0, MemorySegment x1) {
        var mh$ = _PyEval_SliceIndexNotNone.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyEval_SliceIndexNotNone", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PySys_GetObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PySys_GetObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PySys_GetObject(const char *)
     * }
     */
    public static FunctionDescriptor PySys_GetObject$descriptor() {
        return PySys_GetObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PySys_GetObject(const char *)
     * }
     */
    public static MethodHandle PySys_GetObject$handle() {
        return PySys_GetObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PySys_GetObject(const char *)
     * }
     */
    public static MemorySegment PySys_GetObject$address() {
        return PySys_GetObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PySys_GetObject(const char *)
     * }
     */
    public static MemorySegment PySys_GetObject(MemorySegment x0) {
        var mh$ = PySys_GetObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PySys_GetObject", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PySys_SetObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PySys_SetObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PySys_SetObject(const char *, PyObject *)
     * }
     */
    public static FunctionDescriptor PySys_SetObject$descriptor() {
        return PySys_SetObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PySys_SetObject(const char *, PyObject *)
     * }
     */
    public static MethodHandle PySys_SetObject$handle() {
        return PySys_SetObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PySys_SetObject(const char *, PyObject *)
     * }
     */
    public static MemorySegment PySys_SetObject$address() {
        return PySys_SetObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PySys_SetObject(const char *, PyObject *)
     * }
     */
    public static int PySys_SetObject(MemorySegment x0, MemorySegment x1) {
        var mh$ = PySys_SetObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PySys_SetObject", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PySys_SetArgv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PySys_SetArgv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PySys_SetArgv(int, wchar_t **)
     * }
     */
    public static FunctionDescriptor PySys_SetArgv$descriptor() {
        return PySys_SetArgv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PySys_SetArgv(int, wchar_t **)
     * }
     */
    public static MethodHandle PySys_SetArgv$handle() {
        return PySys_SetArgv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PySys_SetArgv(int, wchar_t **)
     * }
     */
    public static MemorySegment PySys_SetArgv$address() {
        return PySys_SetArgv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PySys_SetArgv(int, wchar_t **)
     * }
     */
    public static void PySys_SetArgv(int x0, MemorySegment x1) {
        var mh$ = PySys_SetArgv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PySys_SetArgv", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PySys_SetArgvEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PySys_SetArgvEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PySys_SetArgvEx(int, wchar_t **, int)
     * }
     */
    public static FunctionDescriptor PySys_SetArgvEx$descriptor() {
        return PySys_SetArgvEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PySys_SetArgvEx(int, wchar_t **, int)
     * }
     */
    public static MethodHandle PySys_SetArgvEx$handle() {
        return PySys_SetArgvEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PySys_SetArgvEx(int, wchar_t **, int)
     * }
     */
    public static MemorySegment PySys_SetArgvEx$address() {
        return PySys_SetArgvEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PySys_SetArgvEx(int, wchar_t **, int)
     * }
     */
    public static void PySys_SetArgvEx(int x0, MemorySegment x1, int x2) {
        var mh$ = PySys_SetArgvEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PySys_SetArgvEx", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PySys_SetPath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PySys_SetPath");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PySys_SetPath(const wchar_t *)
     * }
     */
    public static FunctionDescriptor PySys_SetPath$descriptor() {
        return PySys_SetPath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PySys_SetPath(const wchar_t *)
     * }
     */
    public static MethodHandle PySys_SetPath$handle() {
        return PySys_SetPath.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PySys_SetPath(const wchar_t *)
     * }
     */
    public static MemorySegment PySys_SetPath$address() {
        return PySys_SetPath.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PySys_SetPath(const wchar_t *)
     * }
     */
    public static void PySys_SetPath(MemorySegment x0) {
        var mh$ = PySys_SetPath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PySys_SetPath", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * void PySys_WriteStdout(const char *format, ...)
     * }
     */
    public static class PySys_WriteStdout {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.ofVoid(
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("PySys_WriteStdout");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private PySys_WriteStdout(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * void PySys_WriteStdout(const char *format, ...)
         * }
         */
        public static PySys_WriteStdout makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new PySys_WriteStdout(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public void apply(MemorySegment format, Object... x1) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("PySys_WriteStdout", format, x1);
                }
                spreader.invokeExact(format, x1);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * void PySys_WriteStderr(const char *format, ...)
     * }
     */
    public static class PySys_WriteStderr {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.ofVoid(
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("PySys_WriteStderr");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private PySys_WriteStderr(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * void PySys_WriteStderr(const char *format, ...)
         * }
         */
        public static PySys_WriteStderr makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new PySys_WriteStderr(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public void apply(MemorySegment format, Object... x1) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("PySys_WriteStderr", format, x1);
                }
                spreader.invokeExact(format, x1);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * void PySys_FormatStdout(const char *format, ...)
     * }
     */
    public static class PySys_FormatStdout {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.ofVoid(
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("PySys_FormatStdout");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private PySys_FormatStdout(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * void PySys_FormatStdout(const char *format, ...)
         * }
         */
        public static PySys_FormatStdout makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new PySys_FormatStdout(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public void apply(MemorySegment format, Object... x1) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("PySys_FormatStdout", format, x1);
                }
                spreader.invokeExact(format, x1);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * void PySys_FormatStderr(const char *format, ...)
     * }
     */
    public static class PySys_FormatStderr {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.ofVoid(
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("PySys_FormatStderr");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private PySys_FormatStderr(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * void PySys_FormatStderr(const char *format, ...)
         * }
         */
        public static PySys_FormatStderr makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new PySys_FormatStderr(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public void apply(MemorySegment format, Object... x1) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("PySys_FormatStderr", format, x1);
                }
                spreader.invokeExact(format, x1);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class PySys_ResetWarnOptions {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PySys_ResetWarnOptions");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PySys_ResetWarnOptions()
     * }
     */
    public static FunctionDescriptor PySys_ResetWarnOptions$descriptor() {
        return PySys_ResetWarnOptions.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PySys_ResetWarnOptions()
     * }
     */
    public static MethodHandle PySys_ResetWarnOptions$handle() {
        return PySys_ResetWarnOptions.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PySys_ResetWarnOptions()
     * }
     */
    public static MemorySegment PySys_ResetWarnOptions$address() {
        return PySys_ResetWarnOptions.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PySys_ResetWarnOptions()
     * }
     */
    public static void PySys_ResetWarnOptions() {
        var mh$ = PySys_ResetWarnOptions.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PySys_ResetWarnOptions");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PySys_AddWarnOption {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PySys_AddWarnOption");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PySys_AddWarnOption(const wchar_t *)
     * }
     */
    public static FunctionDescriptor PySys_AddWarnOption$descriptor() {
        return PySys_AddWarnOption.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PySys_AddWarnOption(const wchar_t *)
     * }
     */
    public static MethodHandle PySys_AddWarnOption$handle() {
        return PySys_AddWarnOption.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PySys_AddWarnOption(const wchar_t *)
     * }
     */
    public static MemorySegment PySys_AddWarnOption$address() {
        return PySys_AddWarnOption.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PySys_AddWarnOption(const wchar_t *)
     * }
     */
    public static void PySys_AddWarnOption(MemorySegment x0) {
        var mh$ = PySys_AddWarnOption.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PySys_AddWarnOption", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PySys_AddWarnOptionUnicode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PySys_AddWarnOptionUnicode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PySys_AddWarnOptionUnicode(PyObject *)
     * }
     */
    public static FunctionDescriptor PySys_AddWarnOptionUnicode$descriptor() {
        return PySys_AddWarnOptionUnicode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PySys_AddWarnOptionUnicode(PyObject *)
     * }
     */
    public static MethodHandle PySys_AddWarnOptionUnicode$handle() {
        return PySys_AddWarnOptionUnicode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PySys_AddWarnOptionUnicode(PyObject *)
     * }
     */
    public static MemorySegment PySys_AddWarnOptionUnicode$address() {
        return PySys_AddWarnOptionUnicode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PySys_AddWarnOptionUnicode(PyObject *)
     * }
     */
    public static void PySys_AddWarnOptionUnicode(MemorySegment x0) {
        var mh$ = PySys_AddWarnOptionUnicode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PySys_AddWarnOptionUnicode", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PySys_HasWarnOptions {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PySys_HasWarnOptions");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PySys_HasWarnOptions()
     * }
     */
    public static FunctionDescriptor PySys_HasWarnOptions$descriptor() {
        return PySys_HasWarnOptions.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PySys_HasWarnOptions()
     * }
     */
    public static MethodHandle PySys_HasWarnOptions$handle() {
        return PySys_HasWarnOptions.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PySys_HasWarnOptions()
     * }
     */
    public static MemorySegment PySys_HasWarnOptions$address() {
        return PySys_HasWarnOptions.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PySys_HasWarnOptions()
     * }
     */
    public static int PySys_HasWarnOptions() {
        var mh$ = PySys_HasWarnOptions.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PySys_HasWarnOptions");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PySys_AddXOption {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PySys_AddXOption");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PySys_AddXOption(const wchar_t *)
     * }
     */
    public static FunctionDescriptor PySys_AddXOption$descriptor() {
        return PySys_AddXOption.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PySys_AddXOption(const wchar_t *)
     * }
     */
    public static MethodHandle PySys_AddXOption$handle() {
        return PySys_AddXOption.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PySys_AddXOption(const wchar_t *)
     * }
     */
    public static MemorySegment PySys_AddXOption$address() {
        return PySys_AddXOption.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PySys_AddXOption(const wchar_t *)
     * }
     */
    public static void PySys_AddXOption(MemorySegment x0) {
        var mh$ = PySys_AddXOption.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PySys_AddXOption", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PySys_GetXOptions {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PySys_GetXOptions");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PySys_GetXOptions()
     * }
     */
    public static FunctionDescriptor PySys_GetXOptions$descriptor() {
        return PySys_GetXOptions.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PySys_GetXOptions()
     * }
     */
    public static MethodHandle PySys_GetXOptions$handle() {
        return PySys_GetXOptions.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PySys_GetXOptions()
     * }
     */
    public static MemorySegment PySys_GetXOptions$address() {
        return PySys_GetXOptions.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PySys_GetXOptions()
     * }
     */
    public static MemorySegment PySys_GetXOptions() {
        var mh$ = PySys_GetXOptions.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PySys_GetXOptions");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnstable_PerfMapState_Init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnstable_PerfMapState_Init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyUnstable_PerfMapState_Init()
     * }
     */
    public static FunctionDescriptor PyUnstable_PerfMapState_Init$descriptor() {
        return PyUnstable_PerfMapState_Init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyUnstable_PerfMapState_Init()
     * }
     */
    public static MethodHandle PyUnstable_PerfMapState_Init$handle() {
        return PyUnstable_PerfMapState_Init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyUnstable_PerfMapState_Init()
     * }
     */
    public static MemorySegment PyUnstable_PerfMapState_Init$address() {
        return PyUnstable_PerfMapState_Init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyUnstable_PerfMapState_Init()
     * }
     */
    public static int PyUnstable_PerfMapState_Init() {
        var mh$ = PyUnstable_PerfMapState_Init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnstable_PerfMapState_Init");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnstable_WritePerfMapEntry {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnstable_WritePerfMapEntry");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyUnstable_WritePerfMapEntry(const void *code_addr, unsigned int code_size, const char *entry_name)
     * }
     */
    public static FunctionDescriptor PyUnstable_WritePerfMapEntry$descriptor() {
        return PyUnstable_WritePerfMapEntry.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyUnstable_WritePerfMapEntry(const void *code_addr, unsigned int code_size, const char *entry_name)
     * }
     */
    public static MethodHandle PyUnstable_WritePerfMapEntry$handle() {
        return PyUnstable_WritePerfMapEntry.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyUnstable_WritePerfMapEntry(const void *code_addr, unsigned int code_size, const char *entry_name)
     * }
     */
    public static MemorySegment PyUnstable_WritePerfMapEntry$address() {
        return PyUnstable_WritePerfMapEntry.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyUnstable_WritePerfMapEntry(const void *code_addr, unsigned int code_size, const char *entry_name)
     * }
     */
    public static int PyUnstable_WritePerfMapEntry(MemorySegment code_addr, int code_size, MemorySegment entry_name) {
        var mh$ = PyUnstable_WritePerfMapEntry.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnstable_WritePerfMapEntry", code_addr, code_size, entry_name);
            }
            return (int)mh$.invokeExact(code_addr, code_size, entry_name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnstable_PerfMapState_Fini {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnstable_PerfMapState_Fini");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyUnstable_PerfMapState_Fini()
     * }
     */
    public static FunctionDescriptor PyUnstable_PerfMapState_Fini$descriptor() {
        return PyUnstable_PerfMapState_Fini.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyUnstable_PerfMapState_Fini()
     * }
     */
    public static MethodHandle PyUnstable_PerfMapState_Fini$handle() {
        return PyUnstable_PerfMapState_Fini.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyUnstable_PerfMapState_Fini()
     * }
     */
    public static MemorySegment PyUnstable_PerfMapState_Fini$address() {
        return PyUnstable_PerfMapState_Fini.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyUnstable_PerfMapState_Fini()
     * }
     */
    public static void PyUnstable_PerfMapState_Fini() {
        var mh$ = PyUnstable_PerfMapState_Fini.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnstable_PerfMapState_Fini");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PySys_GetAttr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PySys_GetAttr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *_PySys_GetAttr(PyThreadState *tstate, PyObject *name)
     * }
     */
    public static FunctionDescriptor _PySys_GetAttr$descriptor() {
        return _PySys_GetAttr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *_PySys_GetAttr(PyThreadState *tstate, PyObject *name)
     * }
     */
    public static MethodHandle _PySys_GetAttr$handle() {
        return _PySys_GetAttr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *_PySys_GetAttr(PyThreadState *tstate, PyObject *name)
     * }
     */
    public static MemorySegment _PySys_GetAttr$address() {
        return _PySys_GetAttr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *_PySys_GetAttr(PyThreadState *tstate, PyObject *name)
     * }
     */
    public static MemorySegment _PySys_GetAttr(MemorySegment tstate, MemorySegment name) {
        var mh$ = _PySys_GetAttr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PySys_GetAttr", tstate, name);
            }
            return (MemorySegment)mh$.invokeExact(tstate, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PySys_GetSizeOf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PySys_GetSizeOf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t _PySys_GetSizeOf(PyObject *)
     * }
     */
    public static FunctionDescriptor _PySys_GetSizeOf$descriptor() {
        return _PySys_GetSizeOf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t _PySys_GetSizeOf(PyObject *)
     * }
     */
    public static MethodHandle _PySys_GetSizeOf$handle() {
        return _PySys_GetSizeOf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t _PySys_GetSizeOf(PyObject *)
     * }
     */
    public static MemorySegment _PySys_GetSizeOf$address() {
        return _PySys_GetSizeOf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t _PySys_GetSizeOf(PyObject *)
     * }
     */
    public static long _PySys_GetSizeOf(MemorySegment x0) {
        var mh$ = _PySys_GetSizeOf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PySys_GetSizeOf", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int PySys_Audit(const char *event, const char *argFormat, ...)
     * }
     */
    public static class PySys_Audit {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_INT,
                Python_h.C_POINTER,
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("PySys_Audit");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private PySys_Audit(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int PySys_Audit(const char *event, const char *argFormat, ...)
         * }
         */
        public static PySys_Audit makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new PySys_Audit(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment event, MemorySegment argFormat, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("PySys_Audit", event, argFormat, x2);
                }
                return (int)spreader.invokeExact(event, argFormat, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class PySys_AddAuditHook {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PySys_AddAuditHook");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PySys_AddAuditHook(Py_AuditHookFunction, void *)
     * }
     */
    public static FunctionDescriptor PySys_AddAuditHook$descriptor() {
        return PySys_AddAuditHook.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PySys_AddAuditHook(Py_AuditHookFunction, void *)
     * }
     */
    public static MethodHandle PySys_AddAuditHook$handle() {
        return PySys_AddAuditHook.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PySys_AddAuditHook(Py_AuditHookFunction, void *)
     * }
     */
    public static MemorySegment PySys_AddAuditHook$address() {
        return PySys_AddAuditHook.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PySys_AddAuditHook(Py_AuditHookFunction, void *)
     * }
     */
    public static int PySys_AddAuditHook(MemorySegment x0, MemorySegment x1) {
        var mh$ = PySys_AddAuditHook.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PySys_AddAuditHook", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyOS_FSPath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyOS_FSPath");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyOS_FSPath(PyObject *path)
     * }
     */
    public static FunctionDescriptor PyOS_FSPath$descriptor() {
        return PyOS_FSPath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyOS_FSPath(PyObject *path)
     * }
     */
    public static MethodHandle PyOS_FSPath$handle() {
        return PyOS_FSPath.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyOS_FSPath(PyObject *path)
     * }
     */
    public static MemorySegment PyOS_FSPath$address() {
        return PyOS_FSPath.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyOS_FSPath(PyObject *path)
     * }
     */
    public static MemorySegment PyOS_FSPath(MemorySegment path) {
        var mh$ = PyOS_FSPath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyOS_FSPath", path);
            }
            return (MemorySegment)mh$.invokeExact(path);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyOS_InterruptOccurred {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyOS_InterruptOccurred");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyOS_InterruptOccurred()
     * }
     */
    public static FunctionDescriptor PyOS_InterruptOccurred$descriptor() {
        return PyOS_InterruptOccurred.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyOS_InterruptOccurred()
     * }
     */
    public static MethodHandle PyOS_InterruptOccurred$handle() {
        return PyOS_InterruptOccurred.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyOS_InterruptOccurred()
     * }
     */
    public static MemorySegment PyOS_InterruptOccurred$address() {
        return PyOS_InterruptOccurred.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyOS_InterruptOccurred()
     * }
     */
    public static int PyOS_InterruptOccurred() {
        var mh$ = PyOS_InterruptOccurred.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyOS_InterruptOccurred");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyOS_AfterFork {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyOS_AfterFork");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyOS_AfterFork()
     * }
     */
    public static FunctionDescriptor PyOS_AfterFork$descriptor() {
        return PyOS_AfterFork.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyOS_AfterFork()
     * }
     */
    public static MethodHandle PyOS_AfterFork$handle() {
        return PyOS_AfterFork.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyOS_AfterFork()
     * }
     */
    public static MemorySegment PyOS_AfterFork$address() {
        return PyOS_AfterFork.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyOS_AfterFork()
     * }
     */
    public static void PyOS_AfterFork() {
        var mh$ = PyOS_AfterFork.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyOS_AfterFork");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyOS_IsMainThread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyOS_IsMainThread");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyOS_IsMainThread()
     * }
     */
    public static FunctionDescriptor _PyOS_IsMainThread$descriptor() {
        return _PyOS_IsMainThread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyOS_IsMainThread()
     * }
     */
    public static MethodHandle _PyOS_IsMainThread$handle() {
        return _PyOS_IsMainThread.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyOS_IsMainThread()
     * }
     */
    public static MemorySegment _PyOS_IsMainThread$address() {
        return _PyOS_IsMainThread.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyOS_IsMainThread()
     * }
     */
    public static int _PyOS_IsMainThread() {
        var mh$ = _PyOS_IsMainThread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyOS_IsMainThread");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyOS_SigintEvent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyOS_SigintEvent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *_PyOS_SigintEvent()
     * }
     */
    public static FunctionDescriptor _PyOS_SigintEvent$descriptor() {
        return _PyOS_SigintEvent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *_PyOS_SigintEvent()
     * }
     */
    public static MethodHandle _PyOS_SigintEvent$handle() {
        return _PyOS_SigintEvent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *_PyOS_SigintEvent()
     * }
     */
    public static MemorySegment _PyOS_SigintEvent$address() {
        return _PyOS_SigintEvent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *_PyOS_SigintEvent()
     * }
     */
    public static MemorySegment _PyOS_SigintEvent() {
        var mh$ = _PyOS_SigintEvent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyOS_SigintEvent");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyImport_GetMagicNumber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyImport_GetMagicNumber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long PyImport_GetMagicNumber()
     * }
     */
    public static FunctionDescriptor PyImport_GetMagicNumber$descriptor() {
        return PyImport_GetMagicNumber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long PyImport_GetMagicNumber()
     * }
     */
    public static MethodHandle PyImport_GetMagicNumber$handle() {
        return PyImport_GetMagicNumber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long PyImport_GetMagicNumber()
     * }
     */
    public static MemorySegment PyImport_GetMagicNumber$address() {
        return PyImport_GetMagicNumber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long PyImport_GetMagicNumber()
     * }
     */
    public static int PyImport_GetMagicNumber() {
        var mh$ = PyImport_GetMagicNumber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyImport_GetMagicNumber");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyImport_GetMagicTag {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyImport_GetMagicTag");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *PyImport_GetMagicTag()
     * }
     */
    public static FunctionDescriptor PyImport_GetMagicTag$descriptor() {
        return PyImport_GetMagicTag.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *PyImport_GetMagicTag()
     * }
     */
    public static MethodHandle PyImport_GetMagicTag$handle() {
        return PyImport_GetMagicTag.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *PyImport_GetMagicTag()
     * }
     */
    public static MemorySegment PyImport_GetMagicTag$address() {
        return PyImport_GetMagicTag.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *PyImport_GetMagicTag()
     * }
     */
    public static MemorySegment PyImport_GetMagicTag() {
        var mh$ = PyImport_GetMagicTag.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyImport_GetMagicTag");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyImport_ExecCodeModule {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyImport_ExecCodeModule");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyImport_ExecCodeModule(const char *name, PyObject *co)
     * }
     */
    public static FunctionDescriptor PyImport_ExecCodeModule$descriptor() {
        return PyImport_ExecCodeModule.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyImport_ExecCodeModule(const char *name, PyObject *co)
     * }
     */
    public static MethodHandle PyImport_ExecCodeModule$handle() {
        return PyImport_ExecCodeModule.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyImport_ExecCodeModule(const char *name, PyObject *co)
     * }
     */
    public static MemorySegment PyImport_ExecCodeModule$address() {
        return PyImport_ExecCodeModule.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyImport_ExecCodeModule(const char *name, PyObject *co)
     * }
     */
    public static MemorySegment PyImport_ExecCodeModule(MemorySegment name, MemorySegment co) {
        var mh$ = PyImport_ExecCodeModule.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyImport_ExecCodeModule", name, co);
            }
            return (MemorySegment)mh$.invokeExact(name, co);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyImport_ExecCodeModuleEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyImport_ExecCodeModuleEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyImport_ExecCodeModuleEx(const char *name, PyObject *co, const char *pathname)
     * }
     */
    public static FunctionDescriptor PyImport_ExecCodeModuleEx$descriptor() {
        return PyImport_ExecCodeModuleEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyImport_ExecCodeModuleEx(const char *name, PyObject *co, const char *pathname)
     * }
     */
    public static MethodHandle PyImport_ExecCodeModuleEx$handle() {
        return PyImport_ExecCodeModuleEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyImport_ExecCodeModuleEx(const char *name, PyObject *co, const char *pathname)
     * }
     */
    public static MemorySegment PyImport_ExecCodeModuleEx$address() {
        return PyImport_ExecCodeModuleEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyImport_ExecCodeModuleEx(const char *name, PyObject *co, const char *pathname)
     * }
     */
    public static MemorySegment PyImport_ExecCodeModuleEx(MemorySegment name, MemorySegment co, MemorySegment pathname) {
        var mh$ = PyImport_ExecCodeModuleEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyImport_ExecCodeModuleEx", name, co, pathname);
            }
            return (MemorySegment)mh$.invokeExact(name, co, pathname);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyImport_ExecCodeModuleWithPathnames {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyImport_ExecCodeModuleWithPathnames");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyImport_ExecCodeModuleWithPathnames(const char *name, PyObject *co, const char *pathname, const char *cpathname)
     * }
     */
    public static FunctionDescriptor PyImport_ExecCodeModuleWithPathnames$descriptor() {
        return PyImport_ExecCodeModuleWithPathnames.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyImport_ExecCodeModuleWithPathnames(const char *name, PyObject *co, const char *pathname, const char *cpathname)
     * }
     */
    public static MethodHandle PyImport_ExecCodeModuleWithPathnames$handle() {
        return PyImport_ExecCodeModuleWithPathnames.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyImport_ExecCodeModuleWithPathnames(const char *name, PyObject *co, const char *pathname, const char *cpathname)
     * }
     */
    public static MemorySegment PyImport_ExecCodeModuleWithPathnames$address() {
        return PyImport_ExecCodeModuleWithPathnames.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyImport_ExecCodeModuleWithPathnames(const char *name, PyObject *co, const char *pathname, const char *cpathname)
     * }
     */
    public static MemorySegment PyImport_ExecCodeModuleWithPathnames(MemorySegment name, MemorySegment co, MemorySegment pathname, MemorySegment cpathname) {
        var mh$ = PyImport_ExecCodeModuleWithPathnames.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyImport_ExecCodeModuleWithPathnames", name, co, pathname, cpathname);
            }
            return (MemorySegment)mh$.invokeExact(name, co, pathname, cpathname);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyImport_ExecCodeModuleObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyImport_ExecCodeModuleObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyImport_ExecCodeModuleObject(PyObject *name, PyObject *co, PyObject *pathname, PyObject *cpathname)
     * }
     */
    public static FunctionDescriptor PyImport_ExecCodeModuleObject$descriptor() {
        return PyImport_ExecCodeModuleObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyImport_ExecCodeModuleObject(PyObject *name, PyObject *co, PyObject *pathname, PyObject *cpathname)
     * }
     */
    public static MethodHandle PyImport_ExecCodeModuleObject$handle() {
        return PyImport_ExecCodeModuleObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyImport_ExecCodeModuleObject(PyObject *name, PyObject *co, PyObject *pathname, PyObject *cpathname)
     * }
     */
    public static MemorySegment PyImport_ExecCodeModuleObject$address() {
        return PyImport_ExecCodeModuleObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyImport_ExecCodeModuleObject(PyObject *name, PyObject *co, PyObject *pathname, PyObject *cpathname)
     * }
     */
    public static MemorySegment PyImport_ExecCodeModuleObject(MemorySegment name, MemorySegment co, MemorySegment pathname, MemorySegment cpathname) {
        var mh$ = PyImport_ExecCodeModuleObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyImport_ExecCodeModuleObject", name, co, pathname, cpathname);
            }
            return (MemorySegment)mh$.invokeExact(name, co, pathname, cpathname);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyImport_GetModuleDict {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyImport_GetModuleDict");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyImport_GetModuleDict()
     * }
     */
    public static FunctionDescriptor PyImport_GetModuleDict$descriptor() {
        return PyImport_GetModuleDict.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyImport_GetModuleDict()
     * }
     */
    public static MethodHandle PyImport_GetModuleDict$handle() {
        return PyImport_GetModuleDict.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyImport_GetModuleDict()
     * }
     */
    public static MemorySegment PyImport_GetModuleDict$address() {
        return PyImport_GetModuleDict.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyImport_GetModuleDict()
     * }
     */
    public static MemorySegment PyImport_GetModuleDict() {
        var mh$ = PyImport_GetModuleDict.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyImport_GetModuleDict");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyImport_GetModule {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyImport_GetModule");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyImport_GetModule(PyObject *name)
     * }
     */
    public static FunctionDescriptor PyImport_GetModule$descriptor() {
        return PyImport_GetModule.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyImport_GetModule(PyObject *name)
     * }
     */
    public static MethodHandle PyImport_GetModule$handle() {
        return PyImport_GetModule.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyImport_GetModule(PyObject *name)
     * }
     */
    public static MemorySegment PyImport_GetModule$address() {
        return PyImport_GetModule.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyImport_GetModule(PyObject *name)
     * }
     */
    public static MemorySegment PyImport_GetModule(MemorySegment name) {
        var mh$ = PyImport_GetModule.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyImport_GetModule", name);
            }
            return (MemorySegment)mh$.invokeExact(name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyImport_AddModuleObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyImport_AddModuleObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyImport_AddModuleObject(PyObject *name)
     * }
     */
    public static FunctionDescriptor PyImport_AddModuleObject$descriptor() {
        return PyImport_AddModuleObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyImport_AddModuleObject(PyObject *name)
     * }
     */
    public static MethodHandle PyImport_AddModuleObject$handle() {
        return PyImport_AddModuleObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyImport_AddModuleObject(PyObject *name)
     * }
     */
    public static MemorySegment PyImport_AddModuleObject$address() {
        return PyImport_AddModuleObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyImport_AddModuleObject(PyObject *name)
     * }
     */
    public static MemorySegment PyImport_AddModuleObject(MemorySegment name) {
        var mh$ = PyImport_AddModuleObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyImport_AddModuleObject", name);
            }
            return (MemorySegment)mh$.invokeExact(name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyImport_AddModule {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyImport_AddModule");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyImport_AddModule(const char *name)
     * }
     */
    public static FunctionDescriptor PyImport_AddModule$descriptor() {
        return PyImport_AddModule.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyImport_AddModule(const char *name)
     * }
     */
    public static MethodHandle PyImport_AddModule$handle() {
        return PyImport_AddModule.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyImport_AddModule(const char *name)
     * }
     */
    public static MemorySegment PyImport_AddModule$address() {
        return PyImport_AddModule.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyImport_AddModule(const char *name)
     * }
     */
    public static MemorySegment PyImport_AddModule(MemorySegment name) {
        var mh$ = PyImport_AddModule.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyImport_AddModule", name);
            }
            return (MemorySegment)mh$.invokeExact(name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyImport_ImportModule {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyImport_ImportModule");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyImport_ImportModule(const char *name)
     * }
     */
    public static FunctionDescriptor PyImport_ImportModule$descriptor() {
        return PyImport_ImportModule.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyImport_ImportModule(const char *name)
     * }
     */
    public static MethodHandle PyImport_ImportModule$handle() {
        return PyImport_ImportModule.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyImport_ImportModule(const char *name)
     * }
     */
    public static MemorySegment PyImport_ImportModule$address() {
        return PyImport_ImportModule.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyImport_ImportModule(const char *name)
     * }
     */
    public static MemorySegment PyImport_ImportModule(MemorySegment name) {
        var mh$ = PyImport_ImportModule.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyImport_ImportModule", name);
            }
            return (MemorySegment)mh$.invokeExact(name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyImport_ImportModuleNoBlock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyImport_ImportModuleNoBlock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyImport_ImportModuleNoBlock(const char *name)
     * }
     */
    public static FunctionDescriptor PyImport_ImportModuleNoBlock$descriptor() {
        return PyImport_ImportModuleNoBlock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyImport_ImportModuleNoBlock(const char *name)
     * }
     */
    public static MethodHandle PyImport_ImportModuleNoBlock$handle() {
        return PyImport_ImportModuleNoBlock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyImport_ImportModuleNoBlock(const char *name)
     * }
     */
    public static MemorySegment PyImport_ImportModuleNoBlock$address() {
        return PyImport_ImportModuleNoBlock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyImport_ImportModuleNoBlock(const char *name)
     * }
     */
    public static MemorySegment PyImport_ImportModuleNoBlock(MemorySegment name) {
        var mh$ = PyImport_ImportModuleNoBlock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyImport_ImportModuleNoBlock", name);
            }
            return (MemorySegment)mh$.invokeExact(name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyImport_ImportModuleLevel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyImport_ImportModuleLevel");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyImport_ImportModuleLevel(const char *name, PyObject *globals, PyObject *locals, PyObject *fromlist, int level)
     * }
     */
    public static FunctionDescriptor PyImport_ImportModuleLevel$descriptor() {
        return PyImport_ImportModuleLevel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyImport_ImportModuleLevel(const char *name, PyObject *globals, PyObject *locals, PyObject *fromlist, int level)
     * }
     */
    public static MethodHandle PyImport_ImportModuleLevel$handle() {
        return PyImport_ImportModuleLevel.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyImport_ImportModuleLevel(const char *name, PyObject *globals, PyObject *locals, PyObject *fromlist, int level)
     * }
     */
    public static MemorySegment PyImport_ImportModuleLevel$address() {
        return PyImport_ImportModuleLevel.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyImport_ImportModuleLevel(const char *name, PyObject *globals, PyObject *locals, PyObject *fromlist, int level)
     * }
     */
    public static MemorySegment PyImport_ImportModuleLevel(MemorySegment name, MemorySegment globals, MemorySegment locals, MemorySegment fromlist, int level) {
        var mh$ = PyImport_ImportModuleLevel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyImport_ImportModuleLevel", name, globals, locals, fromlist, level);
            }
            return (MemorySegment)mh$.invokeExact(name, globals, locals, fromlist, level);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyImport_ImportModuleLevelObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyImport_ImportModuleLevelObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyImport_ImportModuleLevelObject(PyObject *name, PyObject *globals, PyObject *locals, PyObject *fromlist, int level)
     * }
     */
    public static FunctionDescriptor PyImport_ImportModuleLevelObject$descriptor() {
        return PyImport_ImportModuleLevelObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyImport_ImportModuleLevelObject(PyObject *name, PyObject *globals, PyObject *locals, PyObject *fromlist, int level)
     * }
     */
    public static MethodHandle PyImport_ImportModuleLevelObject$handle() {
        return PyImport_ImportModuleLevelObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyImport_ImportModuleLevelObject(PyObject *name, PyObject *globals, PyObject *locals, PyObject *fromlist, int level)
     * }
     */
    public static MemorySegment PyImport_ImportModuleLevelObject$address() {
        return PyImport_ImportModuleLevelObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyImport_ImportModuleLevelObject(PyObject *name, PyObject *globals, PyObject *locals, PyObject *fromlist, int level)
     * }
     */
    public static MemorySegment PyImport_ImportModuleLevelObject(MemorySegment name, MemorySegment globals, MemorySegment locals, MemorySegment fromlist, int level) {
        var mh$ = PyImport_ImportModuleLevelObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyImport_ImportModuleLevelObject", name, globals, locals, fromlist, level);
            }
            return (MemorySegment)mh$.invokeExact(name, globals, locals, fromlist, level);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyImport_GetImporter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyImport_GetImporter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyImport_GetImporter(PyObject *path)
     * }
     */
    public static FunctionDescriptor PyImport_GetImporter$descriptor() {
        return PyImport_GetImporter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyImport_GetImporter(PyObject *path)
     * }
     */
    public static MethodHandle PyImport_GetImporter$handle() {
        return PyImport_GetImporter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyImport_GetImporter(PyObject *path)
     * }
     */
    public static MemorySegment PyImport_GetImporter$address() {
        return PyImport_GetImporter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyImport_GetImporter(PyObject *path)
     * }
     */
    public static MemorySegment PyImport_GetImporter(MemorySegment path) {
        var mh$ = PyImport_GetImporter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyImport_GetImporter", path);
            }
            return (MemorySegment)mh$.invokeExact(path);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyImport_Import {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyImport_Import");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyImport_Import(PyObject *name)
     * }
     */
    public static FunctionDescriptor PyImport_Import$descriptor() {
        return PyImport_Import.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyImport_Import(PyObject *name)
     * }
     */
    public static MethodHandle PyImport_Import$handle() {
        return PyImport_Import.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyImport_Import(PyObject *name)
     * }
     */
    public static MemorySegment PyImport_Import$address() {
        return PyImport_Import.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyImport_Import(PyObject *name)
     * }
     */
    public static MemorySegment PyImport_Import(MemorySegment name) {
        var mh$ = PyImport_Import.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyImport_Import", name);
            }
            return (MemorySegment)mh$.invokeExact(name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyImport_ReloadModule {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyImport_ReloadModule");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyImport_ReloadModule(PyObject *m)
     * }
     */
    public static FunctionDescriptor PyImport_ReloadModule$descriptor() {
        return PyImport_ReloadModule.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyImport_ReloadModule(PyObject *m)
     * }
     */
    public static MethodHandle PyImport_ReloadModule$handle() {
        return PyImport_ReloadModule.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyImport_ReloadModule(PyObject *m)
     * }
     */
    public static MemorySegment PyImport_ReloadModule$address() {
        return PyImport_ReloadModule.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyImport_ReloadModule(PyObject *m)
     * }
     */
    public static MemorySegment PyImport_ReloadModule(MemorySegment m) {
        var mh$ = PyImport_ReloadModule.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyImport_ReloadModule", m);
            }
            return (MemorySegment)mh$.invokeExact(m);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyImport_ImportFrozenModuleObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyImport_ImportFrozenModuleObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyImport_ImportFrozenModuleObject(PyObject *name)
     * }
     */
    public static FunctionDescriptor PyImport_ImportFrozenModuleObject$descriptor() {
        return PyImport_ImportFrozenModuleObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyImport_ImportFrozenModuleObject(PyObject *name)
     * }
     */
    public static MethodHandle PyImport_ImportFrozenModuleObject$handle() {
        return PyImport_ImportFrozenModuleObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyImport_ImportFrozenModuleObject(PyObject *name)
     * }
     */
    public static MemorySegment PyImport_ImportFrozenModuleObject$address() {
        return PyImport_ImportFrozenModuleObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyImport_ImportFrozenModuleObject(PyObject *name)
     * }
     */
    public static int PyImport_ImportFrozenModuleObject(MemorySegment name) {
        var mh$ = PyImport_ImportFrozenModuleObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyImport_ImportFrozenModuleObject", name);
            }
            return (int)mh$.invokeExact(name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyImport_ImportFrozenModule {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyImport_ImportFrozenModule");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyImport_ImportFrozenModule(const char *name)
     * }
     */
    public static FunctionDescriptor PyImport_ImportFrozenModule$descriptor() {
        return PyImport_ImportFrozenModule.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyImport_ImportFrozenModule(const char *name)
     * }
     */
    public static MethodHandle PyImport_ImportFrozenModule$handle() {
        return PyImport_ImportFrozenModule.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyImport_ImportFrozenModule(const char *name)
     * }
     */
    public static MemorySegment PyImport_ImportFrozenModule$address() {
        return PyImport_ImportFrozenModule.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyImport_ImportFrozenModule(const char *name)
     * }
     */
    public static int PyImport_ImportFrozenModule(MemorySegment name) {
        var mh$ = PyImport_ImportFrozenModule.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyImport_ImportFrozenModule", name);
            }
            return (int)mh$.invokeExact(name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyImport_AppendInittab {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyImport_AppendInittab");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyImport_AppendInittab(const char *name, PyObject *(*initfunc)(void))
     * }
     */
    public static FunctionDescriptor PyImport_AppendInittab$descriptor() {
        return PyImport_AppendInittab.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyImport_AppendInittab(const char *name, PyObject *(*initfunc)(void))
     * }
     */
    public static MethodHandle PyImport_AppendInittab$handle() {
        return PyImport_AppendInittab.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyImport_AppendInittab(const char *name, PyObject *(*initfunc)(void))
     * }
     */
    public static MemorySegment PyImport_AppendInittab$address() {
        return PyImport_AppendInittab.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyImport_AppendInittab(const char *name, PyObject *(*initfunc)(void))
     * }
     */
    public static int PyImport_AppendInittab(MemorySegment name, MemorySegment initfunc) {
        var mh$ = PyImport_AppendInittab.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyImport_AppendInittab", name, initfunc);
            }
            return (int)mh$.invokeExact(name, initfunc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyInit__imp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyInit__imp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyInit__imp()
     * }
     */
    public static FunctionDescriptor PyInit__imp$descriptor() {
        return PyInit__imp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyInit__imp()
     * }
     */
    public static MethodHandle PyInit__imp$handle() {
        return PyInit__imp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyInit__imp()
     * }
     */
    public static MemorySegment PyInit__imp$address() {
        return PyInit__imp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyInit__imp()
     * }
     */
    public static MemorySegment PyInit__imp() {
        var mh$ = PyInit__imp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyInit__imp");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyImport_IsInitialized {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyImport_IsInitialized");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyImport_IsInitialized(PyInterpreterState *)
     * }
     */
    public static FunctionDescriptor _PyImport_IsInitialized$descriptor() {
        return _PyImport_IsInitialized.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyImport_IsInitialized(PyInterpreterState *)
     * }
     */
    public static MethodHandle _PyImport_IsInitialized$handle() {
        return _PyImport_IsInitialized.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyImport_IsInitialized(PyInterpreterState *)
     * }
     */
    public static MemorySegment _PyImport_IsInitialized$address() {
        return _PyImport_IsInitialized.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyImport_IsInitialized(PyInterpreterState *)
     * }
     */
    public static int _PyImport_IsInitialized(MemorySegment x0) {
        var mh$ = _PyImport_IsInitialized.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyImport_IsInitialized", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyImport_GetModuleId {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyImport_GetModuleId");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *_PyImport_GetModuleId(_Py_Identifier *name)
     * }
     */
    public static FunctionDescriptor _PyImport_GetModuleId$descriptor() {
        return _PyImport_GetModuleId.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *_PyImport_GetModuleId(_Py_Identifier *name)
     * }
     */
    public static MethodHandle _PyImport_GetModuleId$handle() {
        return _PyImport_GetModuleId.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *_PyImport_GetModuleId(_Py_Identifier *name)
     * }
     */
    public static MemorySegment _PyImport_GetModuleId$address() {
        return _PyImport_GetModuleId.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *_PyImport_GetModuleId(_Py_Identifier *name)
     * }
     */
    public static MemorySegment _PyImport_GetModuleId(MemorySegment name) {
        var mh$ = _PyImport_GetModuleId.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyImport_GetModuleId", name);
            }
            return (MemorySegment)mh$.invokeExact(name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyImport_SetModule {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyImport_SetModule");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyImport_SetModule(PyObject *name, PyObject *module)
     * }
     */
    public static FunctionDescriptor _PyImport_SetModule$descriptor() {
        return _PyImport_SetModule.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyImport_SetModule(PyObject *name, PyObject *module)
     * }
     */
    public static MethodHandle _PyImport_SetModule$handle() {
        return _PyImport_SetModule.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyImport_SetModule(PyObject *name, PyObject *module)
     * }
     */
    public static MemorySegment _PyImport_SetModule$address() {
        return _PyImport_SetModule.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyImport_SetModule(PyObject *name, PyObject *module)
     * }
     */
    public static int _PyImport_SetModule(MemorySegment name, MemorySegment module) {
        var mh$ = _PyImport_SetModule.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyImport_SetModule", name, module);
            }
            return (int)mh$.invokeExact(name, module);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyImport_SetModuleString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyImport_SetModuleString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyImport_SetModuleString(const char *name, PyObject *module)
     * }
     */
    public static FunctionDescriptor _PyImport_SetModuleString$descriptor() {
        return _PyImport_SetModuleString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyImport_SetModuleString(const char *name, PyObject *module)
     * }
     */
    public static MethodHandle _PyImport_SetModuleString$handle() {
        return _PyImport_SetModuleString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyImport_SetModuleString(const char *name, PyObject *module)
     * }
     */
    public static MemorySegment _PyImport_SetModuleString$address() {
        return _PyImport_SetModuleString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyImport_SetModuleString(const char *name, PyObject *module)
     * }
     */
    public static int _PyImport_SetModuleString(MemorySegment name, MemorySegment module) {
        var mh$ = _PyImport_SetModuleString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyImport_SetModuleString", name, module);
            }
            return (int)mh$.invokeExact(name, module);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyImport_AcquireLock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyImport_AcquireLock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _PyImport_AcquireLock(PyInterpreterState *interp)
     * }
     */
    public static FunctionDescriptor _PyImport_AcquireLock$descriptor() {
        return _PyImport_AcquireLock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _PyImport_AcquireLock(PyInterpreterState *interp)
     * }
     */
    public static MethodHandle _PyImport_AcquireLock$handle() {
        return _PyImport_AcquireLock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _PyImport_AcquireLock(PyInterpreterState *interp)
     * }
     */
    public static MemorySegment _PyImport_AcquireLock$address() {
        return _PyImport_AcquireLock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _PyImport_AcquireLock(PyInterpreterState *interp)
     * }
     */
    public static void _PyImport_AcquireLock(MemorySegment interp) {
        var mh$ = _PyImport_AcquireLock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyImport_AcquireLock", interp);
            }
            mh$.invokeExact(interp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyImport_ReleaseLock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyImport_ReleaseLock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyImport_ReleaseLock(PyInterpreterState *interp)
     * }
     */
    public static FunctionDescriptor _PyImport_ReleaseLock$descriptor() {
        return _PyImport_ReleaseLock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyImport_ReleaseLock(PyInterpreterState *interp)
     * }
     */
    public static MethodHandle _PyImport_ReleaseLock$handle() {
        return _PyImport_ReleaseLock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyImport_ReleaseLock(PyInterpreterState *interp)
     * }
     */
    public static MemorySegment _PyImport_ReleaseLock$address() {
        return _PyImport_ReleaseLock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyImport_ReleaseLock(PyInterpreterState *interp)
     * }
     */
    public static int _PyImport_ReleaseLock(MemorySegment interp) {
        var mh$ = _PyImport_ReleaseLock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyImport_ReleaseLock", interp);
            }
            return (int)mh$.invokeExact(interp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyImport_FixupBuiltin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyImport_FixupBuiltin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyImport_FixupBuiltin(PyObject *mod, const char *name, PyObject *modules)
     * }
     */
    public static FunctionDescriptor _PyImport_FixupBuiltin$descriptor() {
        return _PyImport_FixupBuiltin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyImport_FixupBuiltin(PyObject *mod, const char *name, PyObject *modules)
     * }
     */
    public static MethodHandle _PyImport_FixupBuiltin$handle() {
        return _PyImport_FixupBuiltin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyImport_FixupBuiltin(PyObject *mod, const char *name, PyObject *modules)
     * }
     */
    public static MemorySegment _PyImport_FixupBuiltin$address() {
        return _PyImport_FixupBuiltin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyImport_FixupBuiltin(PyObject *mod, const char *name, PyObject *modules)
     * }
     */
    public static int _PyImport_FixupBuiltin(MemorySegment mod, MemorySegment name, MemorySegment modules) {
        var mh$ = _PyImport_FixupBuiltin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyImport_FixupBuiltin", mod, name, modules);
            }
            return (int)mh$.invokeExact(mod, name, modules);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyImport_FixupExtensionObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyImport_FixupExtensionObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyImport_FixupExtensionObject(PyObject *, PyObject *, PyObject *, PyObject *)
     * }
     */
    public static FunctionDescriptor _PyImport_FixupExtensionObject$descriptor() {
        return _PyImport_FixupExtensionObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyImport_FixupExtensionObject(PyObject *, PyObject *, PyObject *, PyObject *)
     * }
     */
    public static MethodHandle _PyImport_FixupExtensionObject$handle() {
        return _PyImport_FixupExtensionObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyImport_FixupExtensionObject(PyObject *, PyObject *, PyObject *, PyObject *)
     * }
     */
    public static MemorySegment _PyImport_FixupExtensionObject$address() {
        return _PyImport_FixupExtensionObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyImport_FixupExtensionObject(PyObject *, PyObject *, PyObject *, PyObject *)
     * }
     */
    public static int _PyImport_FixupExtensionObject(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = _PyImport_FixupExtensionObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyImport_FixupExtensionObject", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyImport_Inittab$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyImport_Inittab").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern struct _inittab *PyImport_Inittab
     * }
     */
    public static AddressLayout PyImport_Inittab$layout() {
        return PyImport_Inittab$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern struct _inittab *PyImport_Inittab
     * }
     */
    public static MemorySegment PyImport_Inittab$segment() {
        return PyImport_Inittab$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern struct _inittab *PyImport_Inittab
     * }
     */
    public static MemorySegment PyImport_Inittab() {
        return PyImport_Inittab$constants.SEGMENT.get(PyImport_Inittab$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern struct _inittab *PyImport_Inittab
     * }
     */
    public static void PyImport_Inittab(MemorySegment varValue) {
        PyImport_Inittab$constants.SEGMENT.set(PyImport_Inittab$constants.LAYOUT, 0L, varValue);
    }

    private static class PyImport_ExtendInittab {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyImport_ExtendInittab");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyImport_ExtendInittab(struct _inittab *newtab)
     * }
     */
    public static FunctionDescriptor PyImport_ExtendInittab$descriptor() {
        return PyImport_ExtendInittab.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyImport_ExtendInittab(struct _inittab *newtab)
     * }
     */
    public static MethodHandle PyImport_ExtendInittab$handle() {
        return PyImport_ExtendInittab.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyImport_ExtendInittab(struct _inittab *newtab)
     * }
     */
    public static MemorySegment PyImport_ExtendInittab$address() {
        return PyImport_ExtendInittab.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyImport_ExtendInittab(struct _inittab *newtab)
     * }
     */
    public static int PyImport_ExtendInittab(MemorySegment newtab) {
        var mh$ = PyImport_ExtendInittab.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyImport_ExtendInittab", newtab);
            }
            return (int)mh$.invokeExact(newtab);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyImport_FrozenModules$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyImport_FrozenModules").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const struct _frozen *PyImport_FrozenModules
     * }
     */
    public static AddressLayout PyImport_FrozenModules$layout() {
        return PyImport_FrozenModules$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const struct _frozen *PyImport_FrozenModules
     * }
     */
    public static MemorySegment PyImport_FrozenModules$segment() {
        return PyImport_FrozenModules$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const struct _frozen *PyImport_FrozenModules
     * }
     */
    public static MemorySegment PyImport_FrozenModules() {
        return PyImport_FrozenModules$constants.SEGMENT.get(PyImport_FrozenModules$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const struct _frozen *PyImport_FrozenModules
     * }
     */
    public static void PyImport_FrozenModules(MemorySegment varValue) {
        PyImport_FrozenModules$constants.SEGMENT.set(PyImport_FrozenModules$constants.LAYOUT, 0L, varValue);
    }

    private static class _PyImport_GetModuleAttr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyImport_GetModuleAttr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern PyObject *_PyImport_GetModuleAttr(PyObject *, PyObject *)
     * }
     */
    public static FunctionDescriptor _PyImport_GetModuleAttr$descriptor() {
        return _PyImport_GetModuleAttr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern PyObject *_PyImport_GetModuleAttr(PyObject *, PyObject *)
     * }
     */
    public static MethodHandle _PyImport_GetModuleAttr$handle() {
        return _PyImport_GetModuleAttr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern PyObject *_PyImport_GetModuleAttr(PyObject *, PyObject *)
     * }
     */
    public static MemorySegment _PyImport_GetModuleAttr$address() {
        return _PyImport_GetModuleAttr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern PyObject *_PyImport_GetModuleAttr(PyObject *, PyObject *)
     * }
     */
    public static MemorySegment _PyImport_GetModuleAttr(MemorySegment x0, MemorySegment x1) {
        var mh$ = _PyImport_GetModuleAttr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyImport_GetModuleAttr", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyImport_GetModuleAttrString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyImport_GetModuleAttrString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern PyObject *_PyImport_GetModuleAttrString(const char *, const char *)
     * }
     */
    public static FunctionDescriptor _PyImport_GetModuleAttrString$descriptor() {
        return _PyImport_GetModuleAttrString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern PyObject *_PyImport_GetModuleAttrString(const char *, const char *)
     * }
     */
    public static MethodHandle _PyImport_GetModuleAttrString$handle() {
        return _PyImport_GetModuleAttrString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern PyObject *_PyImport_GetModuleAttrString(const char *, const char *)
     * }
     */
    public static MemorySegment _PyImport_GetModuleAttrString$address() {
        return _PyImport_GetModuleAttrString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern PyObject *_PyImport_GetModuleAttrString(const char *, const char *)
     * }
     */
    public static MemorySegment _PyImport_GetModuleAttrString(MemorySegment x0, MemorySegment x1) {
        var mh$ = _PyImport_GetModuleAttrString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyImport_GetModuleAttrString", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_CallNoArgs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_CallNoArgs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyObject_CallNoArgs(PyObject *func)
     * }
     */
    public static FunctionDescriptor PyObject_CallNoArgs$descriptor() {
        return PyObject_CallNoArgs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyObject_CallNoArgs(PyObject *func)
     * }
     */
    public static MethodHandle PyObject_CallNoArgs$handle() {
        return PyObject_CallNoArgs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyObject_CallNoArgs(PyObject *func)
     * }
     */
    public static MemorySegment PyObject_CallNoArgs$address() {
        return PyObject_CallNoArgs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyObject_CallNoArgs(PyObject *func)
     * }
     */
    public static MemorySegment PyObject_CallNoArgs(MemorySegment func) {
        var mh$ = PyObject_CallNoArgs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_CallNoArgs", func);
            }
            return (MemorySegment)mh$.invokeExact(func);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_Call {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_Call");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyObject_Call(PyObject *callable, PyObject *args, PyObject *kwargs)
     * }
     */
    public static FunctionDescriptor PyObject_Call$descriptor() {
        return PyObject_Call.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyObject_Call(PyObject *callable, PyObject *args, PyObject *kwargs)
     * }
     */
    public static MethodHandle PyObject_Call$handle() {
        return PyObject_Call.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyObject_Call(PyObject *callable, PyObject *args, PyObject *kwargs)
     * }
     */
    public static MemorySegment PyObject_Call$address() {
        return PyObject_Call.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyObject_Call(PyObject *callable, PyObject *args, PyObject *kwargs)
     * }
     */
    public static MemorySegment PyObject_Call(MemorySegment callable, MemorySegment args, MemorySegment kwargs) {
        var mh$ = PyObject_Call.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_Call", callable, args, kwargs);
            }
            return (MemorySegment)mh$.invokeExact(callable, args, kwargs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_CallObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_CallObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyObject_CallObject(PyObject *callable, PyObject *args)
     * }
     */
    public static FunctionDescriptor PyObject_CallObject$descriptor() {
        return PyObject_CallObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyObject_CallObject(PyObject *callable, PyObject *args)
     * }
     */
    public static MethodHandle PyObject_CallObject$handle() {
        return PyObject_CallObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyObject_CallObject(PyObject *callable, PyObject *args)
     * }
     */
    public static MemorySegment PyObject_CallObject$address() {
        return PyObject_CallObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyObject_CallObject(PyObject *callable, PyObject *args)
     * }
     */
    public static MemorySegment PyObject_CallObject(MemorySegment callable, MemorySegment args) {
        var mh$ = PyObject_CallObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_CallObject", callable, args);
            }
            return (MemorySegment)mh$.invokeExact(callable, args);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * PyObject *PyObject_CallFunction(PyObject *callable, const char *format, ...)
     * }
     */
    public static class PyObject_CallFunction {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_POINTER,
                Python_h.C_POINTER,
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_CallFunction");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private PyObject_CallFunction(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * PyObject *PyObject_CallFunction(PyObject *callable, const char *format, ...)
         * }
         */
        public static PyObject_CallFunction makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new PyObject_CallFunction(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public MemorySegment apply(MemorySegment callable, MemorySegment format, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("PyObject_CallFunction", callable, format, x2);
                }
                return (MemorySegment)spreader.invokeExact(callable, format, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * PyObject *PyObject_CallMethod(PyObject *obj, const char *name, const char *format, ...)
     * }
     */
    public static class PyObject_CallMethod {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_POINTER,
                Python_h.C_POINTER,
                Python_h.C_POINTER,
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_CallMethod");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private PyObject_CallMethod(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * PyObject *PyObject_CallMethod(PyObject *obj, const char *name, const char *format, ...)
         * }
         */
        public static PyObject_CallMethod makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new PyObject_CallMethod(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public MemorySegment apply(MemorySegment obj, MemorySegment name, MemorySegment format, Object... x3) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("PyObject_CallMethod", obj, name, format, x3);
                }
                return (MemorySegment)spreader.invokeExact(obj, name, format, x3);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * PyObject *_PyObject_CallFunction_SizeT(PyObject *callable, const char *format, ...)
     * }
     */
    public static class _PyObject_CallFunction_SizeT {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_POINTER,
                Python_h.C_POINTER,
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("_PyObject_CallFunction_SizeT");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private _PyObject_CallFunction_SizeT(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * PyObject *_PyObject_CallFunction_SizeT(PyObject *callable, const char *format, ...)
         * }
         */
        public static _PyObject_CallFunction_SizeT makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new _PyObject_CallFunction_SizeT(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public MemorySegment apply(MemorySegment callable, MemorySegment format, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("_PyObject_CallFunction_SizeT", callable, format, x2);
                }
                return (MemorySegment)spreader.invokeExact(callable, format, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * PyObject *_PyObject_CallMethod_SizeT(PyObject *obj, const char *name, const char *format, ...)
     * }
     */
    public static class _PyObject_CallMethod_SizeT {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_POINTER,
                Python_h.C_POINTER,
                Python_h.C_POINTER,
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("_PyObject_CallMethod_SizeT");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private _PyObject_CallMethod_SizeT(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * PyObject *_PyObject_CallMethod_SizeT(PyObject *obj, const char *name, const char *format, ...)
         * }
         */
        public static _PyObject_CallMethod_SizeT makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new _PyObject_CallMethod_SizeT(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public MemorySegment apply(MemorySegment obj, MemorySegment name, MemorySegment format, Object... x3) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("_PyObject_CallMethod_SizeT", obj, name, format, x3);
                }
                return (MemorySegment)spreader.invokeExact(obj, name, format, x3);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * PyObject *PyObject_CallFunctionObjArgs(PyObject *callable, ...)
     * }
     */
    public static class PyObject_CallFunctionObjArgs {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_POINTER,
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_CallFunctionObjArgs");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private PyObject_CallFunctionObjArgs(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * PyObject *PyObject_CallFunctionObjArgs(PyObject *callable, ...)
         * }
         */
        public static PyObject_CallFunctionObjArgs makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new PyObject_CallFunctionObjArgs(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public MemorySegment apply(MemorySegment callable, Object... x1) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("PyObject_CallFunctionObjArgs", callable, x1);
                }
                return (MemorySegment)spreader.invokeExact(callable, x1);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * PyObject *PyObject_CallMethodObjArgs(PyObject *obj, PyObject *name, ...)
     * }
     */
    public static class PyObject_CallMethodObjArgs {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_POINTER,
                Python_h.C_POINTER,
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_CallMethodObjArgs");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private PyObject_CallMethodObjArgs(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * PyObject *PyObject_CallMethodObjArgs(PyObject *obj, PyObject *name, ...)
         * }
         */
        public static PyObject_CallMethodObjArgs makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new PyObject_CallMethodObjArgs(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public MemorySegment apply(MemorySegment obj, MemorySegment name, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("PyObject_CallMethodObjArgs", obj, name, x2);
                }
                return (MemorySegment)spreader.invokeExact(obj, name, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class PyVectorcall_NARGS {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyVectorcall_NARGS");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_ssize_t PyVectorcall_NARGS(size_t nargsf)
     * }
     */
    public static FunctionDescriptor PyVectorcall_NARGS$descriptor() {
        return PyVectorcall_NARGS.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_ssize_t PyVectorcall_NARGS(size_t nargsf)
     * }
     */
    public static MethodHandle PyVectorcall_NARGS$handle() {
        return PyVectorcall_NARGS.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_ssize_t PyVectorcall_NARGS(size_t nargsf)
     * }
     */
    public static MemorySegment PyVectorcall_NARGS$address() {
        return PyVectorcall_NARGS.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_ssize_t PyVectorcall_NARGS(size_t nargsf)
     * }
     */
    public static long PyVectorcall_NARGS(long nargsf) {
        var mh$ = PyVectorcall_NARGS.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyVectorcall_NARGS", nargsf);
            }
            return (long)mh$.invokeExact(nargsf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyVectorcall_Call {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyVectorcall_Call");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyVectorcall_Call(PyObject *callable, PyObject *tuple, PyObject *dict)
     * }
     */
    public static FunctionDescriptor PyVectorcall_Call$descriptor() {
        return PyVectorcall_Call.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyVectorcall_Call(PyObject *callable, PyObject *tuple, PyObject *dict)
     * }
     */
    public static MethodHandle PyVectorcall_Call$handle() {
        return PyVectorcall_Call.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyVectorcall_Call(PyObject *callable, PyObject *tuple, PyObject *dict)
     * }
     */
    public static MemorySegment PyVectorcall_Call$address() {
        return PyVectorcall_Call.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyVectorcall_Call(PyObject *callable, PyObject *tuple, PyObject *dict)
     * }
     */
    public static MemorySegment PyVectorcall_Call(MemorySegment callable, MemorySegment tuple, MemorySegment dict) {
        var mh$ = PyVectorcall_Call.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyVectorcall_Call", callable, tuple, dict);
            }
            return (MemorySegment)mh$.invokeExact(callable, tuple, dict);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_Vectorcall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_Vectorcall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyObject_Vectorcall(PyObject *callable, PyObject *const *args, size_t nargsf, PyObject *kwnames)
     * }
     */
    public static FunctionDescriptor PyObject_Vectorcall$descriptor() {
        return PyObject_Vectorcall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyObject_Vectorcall(PyObject *callable, PyObject *const *args, size_t nargsf, PyObject *kwnames)
     * }
     */
    public static MethodHandle PyObject_Vectorcall$handle() {
        return PyObject_Vectorcall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyObject_Vectorcall(PyObject *callable, PyObject *const *args, size_t nargsf, PyObject *kwnames)
     * }
     */
    public static MemorySegment PyObject_Vectorcall$address() {
        return PyObject_Vectorcall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyObject_Vectorcall(PyObject *callable, PyObject *const *args, size_t nargsf, PyObject *kwnames)
     * }
     */
    public static MemorySegment PyObject_Vectorcall(MemorySegment callable, MemorySegment args, long nargsf, MemorySegment kwnames) {
        var mh$ = PyObject_Vectorcall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_Vectorcall", callable, args, nargsf, kwnames);
            }
            return (MemorySegment)mh$.invokeExact(callable, args, nargsf, kwnames);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_VectorcallMethod {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_VectorcallMethod");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyObject_VectorcallMethod(PyObject *name, PyObject *const *args, size_t nargsf, PyObject *kwnames)
     * }
     */
    public static FunctionDescriptor PyObject_VectorcallMethod$descriptor() {
        return PyObject_VectorcallMethod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyObject_VectorcallMethod(PyObject *name, PyObject *const *args, size_t nargsf, PyObject *kwnames)
     * }
     */
    public static MethodHandle PyObject_VectorcallMethod$handle() {
        return PyObject_VectorcallMethod.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyObject_VectorcallMethod(PyObject *name, PyObject *const *args, size_t nargsf, PyObject *kwnames)
     * }
     */
    public static MemorySegment PyObject_VectorcallMethod$address() {
        return PyObject_VectorcallMethod.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyObject_VectorcallMethod(PyObject *name, PyObject *const *args, size_t nargsf, PyObject *kwnames)
     * }
     */
    public static MemorySegment PyObject_VectorcallMethod(MemorySegment name, MemorySegment args, long nargsf, MemorySegment kwnames) {
        var mh$ = PyObject_VectorcallMethod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_VectorcallMethod", name, args, nargsf, kwnames);
            }
            return (MemorySegment)mh$.invokeExact(name, args, nargsf, kwnames);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_Type {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_Type");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyObject_Type(PyObject *o)
     * }
     */
    public static FunctionDescriptor PyObject_Type$descriptor() {
        return PyObject_Type.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyObject_Type(PyObject *o)
     * }
     */
    public static MethodHandle PyObject_Type$handle() {
        return PyObject_Type.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyObject_Type(PyObject *o)
     * }
     */
    public static MemorySegment PyObject_Type$address() {
        return PyObject_Type.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyObject_Type(PyObject *o)
     * }
     */
    public static MemorySegment PyObject_Type(MemorySegment o) {
        var mh$ = PyObject_Type.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_Type", o);
            }
            return (MemorySegment)mh$.invokeExact(o);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_Size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_Size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_ssize_t PyObject_Size(PyObject *o)
     * }
     */
    public static FunctionDescriptor PyObject_Size$descriptor() {
        return PyObject_Size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_ssize_t PyObject_Size(PyObject *o)
     * }
     */
    public static MethodHandle PyObject_Size$handle() {
        return PyObject_Size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_ssize_t PyObject_Size(PyObject *o)
     * }
     */
    public static MemorySegment PyObject_Size$address() {
        return PyObject_Size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_ssize_t PyObject_Size(PyObject *o)
     * }
     */
    public static long PyObject_Size(MemorySegment o) {
        var mh$ = PyObject_Size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_Size", o);
            }
            return (long)mh$.invokeExact(o);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_Length {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_Length");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_ssize_t PyObject_Length(PyObject *o)
     * }
     */
    public static FunctionDescriptor PyObject_Length$descriptor() {
        return PyObject_Length.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_ssize_t PyObject_Length(PyObject *o)
     * }
     */
    public static MethodHandle PyObject_Length$handle() {
        return PyObject_Length.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_ssize_t PyObject_Length(PyObject *o)
     * }
     */
    public static MemorySegment PyObject_Length$address() {
        return PyObject_Length.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_ssize_t PyObject_Length(PyObject *o)
     * }
     */
    public static long PyObject_Length(MemorySegment o) {
        var mh$ = PyObject_Length.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_Length", o);
            }
            return (long)mh$.invokeExact(o);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_GetItem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_GetItem");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyObject_GetItem(PyObject *o, PyObject *key)
     * }
     */
    public static FunctionDescriptor PyObject_GetItem$descriptor() {
        return PyObject_GetItem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyObject_GetItem(PyObject *o, PyObject *key)
     * }
     */
    public static MethodHandle PyObject_GetItem$handle() {
        return PyObject_GetItem.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyObject_GetItem(PyObject *o, PyObject *key)
     * }
     */
    public static MemorySegment PyObject_GetItem$address() {
        return PyObject_GetItem.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyObject_GetItem(PyObject *o, PyObject *key)
     * }
     */
    public static MemorySegment PyObject_GetItem(MemorySegment o, MemorySegment key) {
        var mh$ = PyObject_GetItem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_GetItem", o, key);
            }
            return (MemorySegment)mh$.invokeExact(o, key);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_SetItem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_SetItem");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyObject_SetItem(PyObject *o, PyObject *key, PyObject *v)
     * }
     */
    public static FunctionDescriptor PyObject_SetItem$descriptor() {
        return PyObject_SetItem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyObject_SetItem(PyObject *o, PyObject *key, PyObject *v)
     * }
     */
    public static MethodHandle PyObject_SetItem$handle() {
        return PyObject_SetItem.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyObject_SetItem(PyObject *o, PyObject *key, PyObject *v)
     * }
     */
    public static MemorySegment PyObject_SetItem$address() {
        return PyObject_SetItem.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyObject_SetItem(PyObject *o, PyObject *key, PyObject *v)
     * }
     */
    public static int PyObject_SetItem(MemorySegment o, MemorySegment key, MemorySegment v) {
        var mh$ = PyObject_SetItem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_SetItem", o, key, v);
            }
            return (int)mh$.invokeExact(o, key, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_DelItemString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_DelItemString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyObject_DelItemString(PyObject *o, const char *key)
     * }
     */
    public static FunctionDescriptor PyObject_DelItemString$descriptor() {
        return PyObject_DelItemString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyObject_DelItemString(PyObject *o, const char *key)
     * }
     */
    public static MethodHandle PyObject_DelItemString$handle() {
        return PyObject_DelItemString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyObject_DelItemString(PyObject *o, const char *key)
     * }
     */
    public static MemorySegment PyObject_DelItemString$address() {
        return PyObject_DelItemString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyObject_DelItemString(PyObject *o, const char *key)
     * }
     */
    public static int PyObject_DelItemString(MemorySegment o, MemorySegment key) {
        var mh$ = PyObject_DelItemString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_DelItemString", o, key);
            }
            return (int)mh$.invokeExact(o, key);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_DelItem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_DelItem");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyObject_DelItem(PyObject *o, PyObject *key)
     * }
     */
    public static FunctionDescriptor PyObject_DelItem$descriptor() {
        return PyObject_DelItem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyObject_DelItem(PyObject *o, PyObject *key)
     * }
     */
    public static MethodHandle PyObject_DelItem$handle() {
        return PyObject_DelItem.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyObject_DelItem(PyObject *o, PyObject *key)
     * }
     */
    public static MemorySegment PyObject_DelItem$address() {
        return PyObject_DelItem.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyObject_DelItem(PyObject *o, PyObject *key)
     * }
     */
    public static int PyObject_DelItem(MemorySegment o, MemorySegment key) {
        var mh$ = PyObject_DelItem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_DelItem", o, key);
            }
            return (int)mh$.invokeExact(o, key);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_AsCharBuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_AsCharBuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyObject_AsCharBuffer(PyObject *obj, const char **buffer, Py_ssize_t *buffer_len)
     * }
     */
    public static FunctionDescriptor PyObject_AsCharBuffer$descriptor() {
        return PyObject_AsCharBuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyObject_AsCharBuffer(PyObject *obj, const char **buffer, Py_ssize_t *buffer_len)
     * }
     */
    public static MethodHandle PyObject_AsCharBuffer$handle() {
        return PyObject_AsCharBuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyObject_AsCharBuffer(PyObject *obj, const char **buffer, Py_ssize_t *buffer_len)
     * }
     */
    public static MemorySegment PyObject_AsCharBuffer$address() {
        return PyObject_AsCharBuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyObject_AsCharBuffer(PyObject *obj, const char **buffer, Py_ssize_t *buffer_len)
     * }
     */
    public static int PyObject_AsCharBuffer(MemorySegment obj, MemorySegment buffer, MemorySegment buffer_len) {
        var mh$ = PyObject_AsCharBuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_AsCharBuffer", obj, buffer, buffer_len);
            }
            return (int)mh$.invokeExact(obj, buffer, buffer_len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_CheckReadBuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_CheckReadBuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyObject_CheckReadBuffer(PyObject *obj)
     * }
     */
    public static FunctionDescriptor PyObject_CheckReadBuffer$descriptor() {
        return PyObject_CheckReadBuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyObject_CheckReadBuffer(PyObject *obj)
     * }
     */
    public static MethodHandle PyObject_CheckReadBuffer$handle() {
        return PyObject_CheckReadBuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyObject_CheckReadBuffer(PyObject *obj)
     * }
     */
    public static MemorySegment PyObject_CheckReadBuffer$address() {
        return PyObject_CheckReadBuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyObject_CheckReadBuffer(PyObject *obj)
     * }
     */
    public static int PyObject_CheckReadBuffer(MemorySegment obj) {
        var mh$ = PyObject_CheckReadBuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_CheckReadBuffer", obj);
            }
            return (int)mh$.invokeExact(obj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_AsReadBuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_AsReadBuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyObject_AsReadBuffer(PyObject *obj, const void **buffer, Py_ssize_t *buffer_len)
     * }
     */
    public static FunctionDescriptor PyObject_AsReadBuffer$descriptor() {
        return PyObject_AsReadBuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyObject_AsReadBuffer(PyObject *obj, const void **buffer, Py_ssize_t *buffer_len)
     * }
     */
    public static MethodHandle PyObject_AsReadBuffer$handle() {
        return PyObject_AsReadBuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyObject_AsReadBuffer(PyObject *obj, const void **buffer, Py_ssize_t *buffer_len)
     * }
     */
    public static MemorySegment PyObject_AsReadBuffer$address() {
        return PyObject_AsReadBuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyObject_AsReadBuffer(PyObject *obj, const void **buffer, Py_ssize_t *buffer_len)
     * }
     */
    public static int PyObject_AsReadBuffer(MemorySegment obj, MemorySegment buffer, MemorySegment buffer_len) {
        var mh$ = PyObject_AsReadBuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_AsReadBuffer", obj, buffer, buffer_len);
            }
            return (int)mh$.invokeExact(obj, buffer, buffer_len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_AsWriteBuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_AsWriteBuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyObject_AsWriteBuffer(PyObject *obj, void **buffer, Py_ssize_t *buffer_len)
     * }
     */
    public static FunctionDescriptor PyObject_AsWriteBuffer$descriptor() {
        return PyObject_AsWriteBuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyObject_AsWriteBuffer(PyObject *obj, void **buffer, Py_ssize_t *buffer_len)
     * }
     */
    public static MethodHandle PyObject_AsWriteBuffer$handle() {
        return PyObject_AsWriteBuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyObject_AsWriteBuffer(PyObject *obj, void **buffer, Py_ssize_t *buffer_len)
     * }
     */
    public static MemorySegment PyObject_AsWriteBuffer$address() {
        return PyObject_AsWriteBuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyObject_AsWriteBuffer(PyObject *obj, void **buffer, Py_ssize_t *buffer_len)
     * }
     */
    public static int PyObject_AsWriteBuffer(MemorySegment obj, MemorySegment buffer, MemorySegment buffer_len) {
        var mh$ = PyObject_AsWriteBuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_AsWriteBuffer", obj, buffer, buffer_len);
            }
            return (int)mh$.invokeExact(obj, buffer, buffer_len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_Format {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_Format");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyObject_Format(PyObject *obj, PyObject *format_spec)
     * }
     */
    public static FunctionDescriptor PyObject_Format$descriptor() {
        return PyObject_Format.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyObject_Format(PyObject *obj, PyObject *format_spec)
     * }
     */
    public static MethodHandle PyObject_Format$handle() {
        return PyObject_Format.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyObject_Format(PyObject *obj, PyObject *format_spec)
     * }
     */
    public static MemorySegment PyObject_Format$address() {
        return PyObject_Format.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyObject_Format(PyObject *obj, PyObject *format_spec)
     * }
     */
    public static MemorySegment PyObject_Format(MemorySegment obj, MemorySegment format_spec) {
        var mh$ = PyObject_Format.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_Format", obj, format_spec);
            }
            return (MemorySegment)mh$.invokeExact(obj, format_spec);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_GetIter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_GetIter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyObject_GetIter(PyObject *)
     * }
     */
    public static FunctionDescriptor PyObject_GetIter$descriptor() {
        return PyObject_GetIter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyObject_GetIter(PyObject *)
     * }
     */
    public static MethodHandle PyObject_GetIter$handle() {
        return PyObject_GetIter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyObject_GetIter(PyObject *)
     * }
     */
    public static MemorySegment PyObject_GetIter$address() {
        return PyObject_GetIter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyObject_GetIter(PyObject *)
     * }
     */
    public static MemorySegment PyObject_GetIter(MemorySegment x0) {
        var mh$ = PyObject_GetIter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_GetIter", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_GetAIter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_GetAIter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyObject_GetAIter(PyObject *)
     * }
     */
    public static FunctionDescriptor PyObject_GetAIter$descriptor() {
        return PyObject_GetAIter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyObject_GetAIter(PyObject *)
     * }
     */
    public static MethodHandle PyObject_GetAIter$handle() {
        return PyObject_GetAIter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyObject_GetAIter(PyObject *)
     * }
     */
    public static MemorySegment PyObject_GetAIter$address() {
        return PyObject_GetAIter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyObject_GetAIter(PyObject *)
     * }
     */
    public static MemorySegment PyObject_GetAIter(MemorySegment x0) {
        var mh$ = PyObject_GetAIter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_GetAIter", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyIter_Check {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyIter_Check");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyIter_Check(PyObject *)
     * }
     */
    public static FunctionDescriptor PyIter_Check$descriptor() {
        return PyIter_Check.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyIter_Check(PyObject *)
     * }
     */
    public static MethodHandle PyIter_Check$handle() {
        return PyIter_Check.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyIter_Check(PyObject *)
     * }
     */
    public static MemorySegment PyIter_Check$address() {
        return PyIter_Check.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyIter_Check(PyObject *)
     * }
     */
    public static int PyIter_Check(MemorySegment x0) {
        var mh$ = PyIter_Check.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyIter_Check", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyAIter_Check {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyAIter_Check");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyAIter_Check(PyObject *)
     * }
     */
    public static FunctionDescriptor PyAIter_Check$descriptor() {
        return PyAIter_Check.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyAIter_Check(PyObject *)
     * }
     */
    public static MethodHandle PyAIter_Check$handle() {
        return PyAIter_Check.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyAIter_Check(PyObject *)
     * }
     */
    public static MemorySegment PyAIter_Check$address() {
        return PyAIter_Check.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyAIter_Check(PyObject *)
     * }
     */
    public static int PyAIter_Check(MemorySegment x0) {
        var mh$ = PyAIter_Check.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyAIter_Check", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyIter_Next {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyIter_Next");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyIter_Next(PyObject *)
     * }
     */
    public static FunctionDescriptor PyIter_Next$descriptor() {
        return PyIter_Next.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyIter_Next(PyObject *)
     * }
     */
    public static MethodHandle PyIter_Next$handle() {
        return PyIter_Next.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyIter_Next(PyObject *)
     * }
     */
    public static MemorySegment PyIter_Next$address() {
        return PyIter_Next.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyIter_Next(PyObject *)
     * }
     */
    public static MemorySegment PyIter_Next(MemorySegment x0) {
        var mh$ = PyIter_Next.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyIter_Next", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyIter_Send {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyIter_Send");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PySendResult PyIter_Send(PyObject *, PyObject *, PyObject **)
     * }
     */
    public static FunctionDescriptor PyIter_Send$descriptor() {
        return PyIter_Send.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PySendResult PyIter_Send(PyObject *, PyObject *, PyObject **)
     * }
     */
    public static MethodHandle PyIter_Send$handle() {
        return PyIter_Send.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PySendResult PyIter_Send(PyObject *, PyObject *, PyObject **)
     * }
     */
    public static MemorySegment PyIter_Send$address() {
        return PyIter_Send.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PySendResult PyIter_Send(PyObject *, PyObject *, PyObject **)
     * }
     */
    public static int PyIter_Send(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = PyIter_Send.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyIter_Send", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyNumber_Check {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyNumber_Check");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyNumber_Check(PyObject *o)
     * }
     */
    public static FunctionDescriptor PyNumber_Check$descriptor() {
        return PyNumber_Check.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyNumber_Check(PyObject *o)
     * }
     */
    public static MethodHandle PyNumber_Check$handle() {
        return PyNumber_Check.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyNumber_Check(PyObject *o)
     * }
     */
    public static MemorySegment PyNumber_Check$address() {
        return PyNumber_Check.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyNumber_Check(PyObject *o)
     * }
     */
    public static int PyNumber_Check(MemorySegment o) {
        var mh$ = PyNumber_Check.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyNumber_Check", o);
            }
            return (int)mh$.invokeExact(o);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyNumber_Add {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyNumber_Add");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Add(PyObject *o1, PyObject *o2)
     * }
     */
    public static FunctionDescriptor PyNumber_Add$descriptor() {
        return PyNumber_Add.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Add(PyObject *o1, PyObject *o2)
     * }
     */
    public static MethodHandle PyNumber_Add$handle() {
        return PyNumber_Add.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Add(PyObject *o1, PyObject *o2)
     * }
     */
    public static MemorySegment PyNumber_Add$address() {
        return PyNumber_Add.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyNumber_Add(PyObject *o1, PyObject *o2)
     * }
     */
    public static MemorySegment PyNumber_Add(MemorySegment o1, MemorySegment o2) {
        var mh$ = PyNumber_Add.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyNumber_Add", o1, o2);
            }
            return (MemorySegment)mh$.invokeExact(o1, o2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyNumber_Subtract {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyNumber_Subtract");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Subtract(PyObject *o1, PyObject *o2)
     * }
     */
    public static FunctionDescriptor PyNumber_Subtract$descriptor() {
        return PyNumber_Subtract.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Subtract(PyObject *o1, PyObject *o2)
     * }
     */
    public static MethodHandle PyNumber_Subtract$handle() {
        return PyNumber_Subtract.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Subtract(PyObject *o1, PyObject *o2)
     * }
     */
    public static MemorySegment PyNumber_Subtract$address() {
        return PyNumber_Subtract.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyNumber_Subtract(PyObject *o1, PyObject *o2)
     * }
     */
    public static MemorySegment PyNumber_Subtract(MemorySegment o1, MemorySegment o2) {
        var mh$ = PyNumber_Subtract.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyNumber_Subtract", o1, o2);
            }
            return (MemorySegment)mh$.invokeExact(o1, o2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyNumber_Multiply {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyNumber_Multiply");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Multiply(PyObject *o1, PyObject *o2)
     * }
     */
    public static FunctionDescriptor PyNumber_Multiply$descriptor() {
        return PyNumber_Multiply.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Multiply(PyObject *o1, PyObject *o2)
     * }
     */
    public static MethodHandle PyNumber_Multiply$handle() {
        return PyNumber_Multiply.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Multiply(PyObject *o1, PyObject *o2)
     * }
     */
    public static MemorySegment PyNumber_Multiply$address() {
        return PyNumber_Multiply.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyNumber_Multiply(PyObject *o1, PyObject *o2)
     * }
     */
    public static MemorySegment PyNumber_Multiply(MemorySegment o1, MemorySegment o2) {
        var mh$ = PyNumber_Multiply.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyNumber_Multiply", o1, o2);
            }
            return (MemorySegment)mh$.invokeExact(o1, o2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyNumber_MatrixMultiply {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyNumber_MatrixMultiply");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyNumber_MatrixMultiply(PyObject *o1, PyObject *o2)
     * }
     */
    public static FunctionDescriptor PyNumber_MatrixMultiply$descriptor() {
        return PyNumber_MatrixMultiply.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyNumber_MatrixMultiply(PyObject *o1, PyObject *o2)
     * }
     */
    public static MethodHandle PyNumber_MatrixMultiply$handle() {
        return PyNumber_MatrixMultiply.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyNumber_MatrixMultiply(PyObject *o1, PyObject *o2)
     * }
     */
    public static MemorySegment PyNumber_MatrixMultiply$address() {
        return PyNumber_MatrixMultiply.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyNumber_MatrixMultiply(PyObject *o1, PyObject *o2)
     * }
     */
    public static MemorySegment PyNumber_MatrixMultiply(MemorySegment o1, MemorySegment o2) {
        var mh$ = PyNumber_MatrixMultiply.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyNumber_MatrixMultiply", o1, o2);
            }
            return (MemorySegment)mh$.invokeExact(o1, o2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyNumber_FloorDivide {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyNumber_FloorDivide");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyNumber_FloorDivide(PyObject *o1, PyObject *o2)
     * }
     */
    public static FunctionDescriptor PyNumber_FloorDivide$descriptor() {
        return PyNumber_FloorDivide.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyNumber_FloorDivide(PyObject *o1, PyObject *o2)
     * }
     */
    public static MethodHandle PyNumber_FloorDivide$handle() {
        return PyNumber_FloorDivide.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyNumber_FloorDivide(PyObject *o1, PyObject *o2)
     * }
     */
    public static MemorySegment PyNumber_FloorDivide$address() {
        return PyNumber_FloorDivide.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyNumber_FloorDivide(PyObject *o1, PyObject *o2)
     * }
     */
    public static MemorySegment PyNumber_FloorDivide(MemorySegment o1, MemorySegment o2) {
        var mh$ = PyNumber_FloorDivide.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyNumber_FloorDivide", o1, o2);
            }
            return (MemorySegment)mh$.invokeExact(o1, o2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyNumber_TrueDivide {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyNumber_TrueDivide");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyNumber_TrueDivide(PyObject *o1, PyObject *o2)
     * }
     */
    public static FunctionDescriptor PyNumber_TrueDivide$descriptor() {
        return PyNumber_TrueDivide.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyNumber_TrueDivide(PyObject *o1, PyObject *o2)
     * }
     */
    public static MethodHandle PyNumber_TrueDivide$handle() {
        return PyNumber_TrueDivide.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyNumber_TrueDivide(PyObject *o1, PyObject *o2)
     * }
     */
    public static MemorySegment PyNumber_TrueDivide$address() {
        return PyNumber_TrueDivide.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyNumber_TrueDivide(PyObject *o1, PyObject *o2)
     * }
     */
    public static MemorySegment PyNumber_TrueDivide(MemorySegment o1, MemorySegment o2) {
        var mh$ = PyNumber_TrueDivide.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyNumber_TrueDivide", o1, o2);
            }
            return (MemorySegment)mh$.invokeExact(o1, o2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyNumber_Remainder {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyNumber_Remainder");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Remainder(PyObject *o1, PyObject *o2)
     * }
     */
    public static FunctionDescriptor PyNumber_Remainder$descriptor() {
        return PyNumber_Remainder.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Remainder(PyObject *o1, PyObject *o2)
     * }
     */
    public static MethodHandle PyNumber_Remainder$handle() {
        return PyNumber_Remainder.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Remainder(PyObject *o1, PyObject *o2)
     * }
     */
    public static MemorySegment PyNumber_Remainder$address() {
        return PyNumber_Remainder.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyNumber_Remainder(PyObject *o1, PyObject *o2)
     * }
     */
    public static MemorySegment PyNumber_Remainder(MemorySegment o1, MemorySegment o2) {
        var mh$ = PyNumber_Remainder.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyNumber_Remainder", o1, o2);
            }
            return (MemorySegment)mh$.invokeExact(o1, o2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyNumber_Divmod {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyNumber_Divmod");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Divmod(PyObject *o1, PyObject *o2)
     * }
     */
    public static FunctionDescriptor PyNumber_Divmod$descriptor() {
        return PyNumber_Divmod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Divmod(PyObject *o1, PyObject *o2)
     * }
     */
    public static MethodHandle PyNumber_Divmod$handle() {
        return PyNumber_Divmod.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Divmod(PyObject *o1, PyObject *o2)
     * }
     */
    public static MemorySegment PyNumber_Divmod$address() {
        return PyNumber_Divmod.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyNumber_Divmod(PyObject *o1, PyObject *o2)
     * }
     */
    public static MemorySegment PyNumber_Divmod(MemorySegment o1, MemorySegment o2) {
        var mh$ = PyNumber_Divmod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyNumber_Divmod", o1, o2);
            }
            return (MemorySegment)mh$.invokeExact(o1, o2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyNumber_Power {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyNumber_Power");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Power(PyObject *o1, PyObject *o2, PyObject *o3)
     * }
     */
    public static FunctionDescriptor PyNumber_Power$descriptor() {
        return PyNumber_Power.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Power(PyObject *o1, PyObject *o2, PyObject *o3)
     * }
     */
    public static MethodHandle PyNumber_Power$handle() {
        return PyNumber_Power.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Power(PyObject *o1, PyObject *o2, PyObject *o3)
     * }
     */
    public static MemorySegment PyNumber_Power$address() {
        return PyNumber_Power.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyNumber_Power(PyObject *o1, PyObject *o2, PyObject *o3)
     * }
     */
    public static MemorySegment PyNumber_Power(MemorySegment o1, MemorySegment o2, MemorySegment o3) {
        var mh$ = PyNumber_Power.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyNumber_Power", o1, o2, o3);
            }
            return (MemorySegment)mh$.invokeExact(o1, o2, o3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyNumber_Negative {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyNumber_Negative");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Negative(PyObject *o)
     * }
     */
    public static FunctionDescriptor PyNumber_Negative$descriptor() {
        return PyNumber_Negative.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Negative(PyObject *o)
     * }
     */
    public static MethodHandle PyNumber_Negative$handle() {
        return PyNumber_Negative.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Negative(PyObject *o)
     * }
     */
    public static MemorySegment PyNumber_Negative$address() {
        return PyNumber_Negative.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyNumber_Negative(PyObject *o)
     * }
     */
    public static MemorySegment PyNumber_Negative(MemorySegment o) {
        var mh$ = PyNumber_Negative.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyNumber_Negative", o);
            }
            return (MemorySegment)mh$.invokeExact(o);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyNumber_Positive {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyNumber_Positive");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Positive(PyObject *o)
     * }
     */
    public static FunctionDescriptor PyNumber_Positive$descriptor() {
        return PyNumber_Positive.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Positive(PyObject *o)
     * }
     */
    public static MethodHandle PyNumber_Positive$handle() {
        return PyNumber_Positive.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Positive(PyObject *o)
     * }
     */
    public static MemorySegment PyNumber_Positive$address() {
        return PyNumber_Positive.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyNumber_Positive(PyObject *o)
     * }
     */
    public static MemorySegment PyNumber_Positive(MemorySegment o) {
        var mh$ = PyNumber_Positive.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyNumber_Positive", o);
            }
            return (MemorySegment)mh$.invokeExact(o);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyNumber_Absolute {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyNumber_Absolute");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Absolute(PyObject *o)
     * }
     */
    public static FunctionDescriptor PyNumber_Absolute$descriptor() {
        return PyNumber_Absolute.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Absolute(PyObject *o)
     * }
     */
    public static MethodHandle PyNumber_Absolute$handle() {
        return PyNumber_Absolute.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Absolute(PyObject *o)
     * }
     */
    public static MemorySegment PyNumber_Absolute$address() {
        return PyNumber_Absolute.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyNumber_Absolute(PyObject *o)
     * }
     */
    public static MemorySegment PyNumber_Absolute(MemorySegment o) {
        var mh$ = PyNumber_Absolute.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyNumber_Absolute", o);
            }
            return (MemorySegment)mh$.invokeExact(o);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyNumber_Invert {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyNumber_Invert");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Invert(PyObject *o)
     * }
     */
    public static FunctionDescriptor PyNumber_Invert$descriptor() {
        return PyNumber_Invert.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Invert(PyObject *o)
     * }
     */
    public static MethodHandle PyNumber_Invert$handle() {
        return PyNumber_Invert.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Invert(PyObject *o)
     * }
     */
    public static MemorySegment PyNumber_Invert$address() {
        return PyNumber_Invert.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyNumber_Invert(PyObject *o)
     * }
     */
    public static MemorySegment PyNumber_Invert(MemorySegment o) {
        var mh$ = PyNumber_Invert.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyNumber_Invert", o);
            }
            return (MemorySegment)mh$.invokeExact(o);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyNumber_Lshift {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyNumber_Lshift");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Lshift(PyObject *o1, PyObject *o2)
     * }
     */
    public static FunctionDescriptor PyNumber_Lshift$descriptor() {
        return PyNumber_Lshift.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Lshift(PyObject *o1, PyObject *o2)
     * }
     */
    public static MethodHandle PyNumber_Lshift$handle() {
        return PyNumber_Lshift.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Lshift(PyObject *o1, PyObject *o2)
     * }
     */
    public static MemorySegment PyNumber_Lshift$address() {
        return PyNumber_Lshift.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyNumber_Lshift(PyObject *o1, PyObject *o2)
     * }
     */
    public static MemorySegment PyNumber_Lshift(MemorySegment o1, MemorySegment o2) {
        var mh$ = PyNumber_Lshift.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyNumber_Lshift", o1, o2);
            }
            return (MemorySegment)mh$.invokeExact(o1, o2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyNumber_Rshift {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyNumber_Rshift");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Rshift(PyObject *o1, PyObject *o2)
     * }
     */
    public static FunctionDescriptor PyNumber_Rshift$descriptor() {
        return PyNumber_Rshift.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Rshift(PyObject *o1, PyObject *o2)
     * }
     */
    public static MethodHandle PyNumber_Rshift$handle() {
        return PyNumber_Rshift.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Rshift(PyObject *o1, PyObject *o2)
     * }
     */
    public static MemorySegment PyNumber_Rshift$address() {
        return PyNumber_Rshift.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyNumber_Rshift(PyObject *o1, PyObject *o2)
     * }
     */
    public static MemorySegment PyNumber_Rshift(MemorySegment o1, MemorySegment o2) {
        var mh$ = PyNumber_Rshift.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyNumber_Rshift", o1, o2);
            }
            return (MemorySegment)mh$.invokeExact(o1, o2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyNumber_And {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyNumber_And");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyNumber_And(PyObject *o1, PyObject *o2)
     * }
     */
    public static FunctionDescriptor PyNumber_And$descriptor() {
        return PyNumber_And.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyNumber_And(PyObject *o1, PyObject *o2)
     * }
     */
    public static MethodHandle PyNumber_And$handle() {
        return PyNumber_And.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyNumber_And(PyObject *o1, PyObject *o2)
     * }
     */
    public static MemorySegment PyNumber_And$address() {
        return PyNumber_And.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyNumber_And(PyObject *o1, PyObject *o2)
     * }
     */
    public static MemorySegment PyNumber_And(MemorySegment o1, MemorySegment o2) {
        var mh$ = PyNumber_And.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyNumber_And", o1, o2);
            }
            return (MemorySegment)mh$.invokeExact(o1, o2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyNumber_Xor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyNumber_Xor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Xor(PyObject *o1, PyObject *o2)
     * }
     */
    public static FunctionDescriptor PyNumber_Xor$descriptor() {
        return PyNumber_Xor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Xor(PyObject *o1, PyObject *o2)
     * }
     */
    public static MethodHandle PyNumber_Xor$handle() {
        return PyNumber_Xor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Xor(PyObject *o1, PyObject *o2)
     * }
     */
    public static MemorySegment PyNumber_Xor$address() {
        return PyNumber_Xor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyNumber_Xor(PyObject *o1, PyObject *o2)
     * }
     */
    public static MemorySegment PyNumber_Xor(MemorySegment o1, MemorySegment o2) {
        var mh$ = PyNumber_Xor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyNumber_Xor", o1, o2);
            }
            return (MemorySegment)mh$.invokeExact(o1, o2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyNumber_Or {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyNumber_Or");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Or(PyObject *o1, PyObject *o2)
     * }
     */
    public static FunctionDescriptor PyNumber_Or$descriptor() {
        return PyNumber_Or.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Or(PyObject *o1, PyObject *o2)
     * }
     */
    public static MethodHandle PyNumber_Or$handle() {
        return PyNumber_Or.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Or(PyObject *o1, PyObject *o2)
     * }
     */
    public static MemorySegment PyNumber_Or$address() {
        return PyNumber_Or.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyNumber_Or(PyObject *o1, PyObject *o2)
     * }
     */
    public static MemorySegment PyNumber_Or(MemorySegment o1, MemorySegment o2) {
        var mh$ = PyNumber_Or.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyNumber_Or", o1, o2);
            }
            return (MemorySegment)mh$.invokeExact(o1, o2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyIndex_Check {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyIndex_Check");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyIndex_Check(PyObject *)
     * }
     */
    public static FunctionDescriptor PyIndex_Check$descriptor() {
        return PyIndex_Check.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyIndex_Check(PyObject *)
     * }
     */
    public static MethodHandle PyIndex_Check$handle() {
        return PyIndex_Check.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyIndex_Check(PyObject *)
     * }
     */
    public static MemorySegment PyIndex_Check$address() {
        return PyIndex_Check.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyIndex_Check(PyObject *)
     * }
     */
    public static int PyIndex_Check(MemorySegment x0) {
        var mh$ = PyIndex_Check.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyIndex_Check", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyNumber_Index {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyNumber_Index");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Index(PyObject *o)
     * }
     */
    public static FunctionDescriptor PyNumber_Index$descriptor() {
        return PyNumber_Index.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Index(PyObject *o)
     * }
     */
    public static MethodHandle PyNumber_Index$handle() {
        return PyNumber_Index.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Index(PyObject *o)
     * }
     */
    public static MemorySegment PyNumber_Index$address() {
        return PyNumber_Index.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyNumber_Index(PyObject *o)
     * }
     */
    public static MemorySegment PyNumber_Index(MemorySegment o) {
        var mh$ = PyNumber_Index.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyNumber_Index", o);
            }
            return (MemorySegment)mh$.invokeExact(o);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyNumber_AsSsize_t {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyNumber_AsSsize_t");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_ssize_t PyNumber_AsSsize_t(PyObject *o, PyObject *exc)
     * }
     */
    public static FunctionDescriptor PyNumber_AsSsize_t$descriptor() {
        return PyNumber_AsSsize_t.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_ssize_t PyNumber_AsSsize_t(PyObject *o, PyObject *exc)
     * }
     */
    public static MethodHandle PyNumber_AsSsize_t$handle() {
        return PyNumber_AsSsize_t.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_ssize_t PyNumber_AsSsize_t(PyObject *o, PyObject *exc)
     * }
     */
    public static MemorySegment PyNumber_AsSsize_t$address() {
        return PyNumber_AsSsize_t.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_ssize_t PyNumber_AsSsize_t(PyObject *o, PyObject *exc)
     * }
     */
    public static long PyNumber_AsSsize_t(MemorySegment o, MemorySegment exc) {
        var mh$ = PyNumber_AsSsize_t.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyNumber_AsSsize_t", o, exc);
            }
            return (long)mh$.invokeExact(o, exc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyNumber_Long {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyNumber_Long");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Long(PyObject *o)
     * }
     */
    public static FunctionDescriptor PyNumber_Long$descriptor() {
        return PyNumber_Long.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Long(PyObject *o)
     * }
     */
    public static MethodHandle PyNumber_Long$handle() {
        return PyNumber_Long.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Long(PyObject *o)
     * }
     */
    public static MemorySegment PyNumber_Long$address() {
        return PyNumber_Long.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyNumber_Long(PyObject *o)
     * }
     */
    public static MemorySegment PyNumber_Long(MemorySegment o) {
        var mh$ = PyNumber_Long.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyNumber_Long", o);
            }
            return (MemorySegment)mh$.invokeExact(o);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyNumber_Float {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyNumber_Float");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Float(PyObject *o)
     * }
     */
    public static FunctionDescriptor PyNumber_Float$descriptor() {
        return PyNumber_Float.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Float(PyObject *o)
     * }
     */
    public static MethodHandle PyNumber_Float$handle() {
        return PyNumber_Float.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Float(PyObject *o)
     * }
     */
    public static MemorySegment PyNumber_Float$address() {
        return PyNumber_Float.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyNumber_Float(PyObject *o)
     * }
     */
    public static MemorySegment PyNumber_Float(MemorySegment o) {
        var mh$ = PyNumber_Float.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyNumber_Float", o);
            }
            return (MemorySegment)mh$.invokeExact(o);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyNumber_InPlaceAdd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyNumber_InPlaceAdd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyNumber_InPlaceAdd(PyObject *o1, PyObject *o2)
     * }
     */
    public static FunctionDescriptor PyNumber_InPlaceAdd$descriptor() {
        return PyNumber_InPlaceAdd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyNumber_InPlaceAdd(PyObject *o1, PyObject *o2)
     * }
     */
    public static MethodHandle PyNumber_InPlaceAdd$handle() {
        return PyNumber_InPlaceAdd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyNumber_InPlaceAdd(PyObject *o1, PyObject *o2)
     * }
     */
    public static MemorySegment PyNumber_InPlaceAdd$address() {
        return PyNumber_InPlaceAdd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyNumber_InPlaceAdd(PyObject *o1, PyObject *o2)
     * }
     */
    public static MemorySegment PyNumber_InPlaceAdd(MemorySegment o1, MemorySegment o2) {
        var mh$ = PyNumber_InPlaceAdd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyNumber_InPlaceAdd", o1, o2);
            }
            return (MemorySegment)mh$.invokeExact(o1, o2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyNumber_InPlaceSubtract {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyNumber_InPlaceSubtract");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyNumber_InPlaceSubtract(PyObject *o1, PyObject *o2)
     * }
     */
    public static FunctionDescriptor PyNumber_InPlaceSubtract$descriptor() {
        return PyNumber_InPlaceSubtract.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyNumber_InPlaceSubtract(PyObject *o1, PyObject *o2)
     * }
     */
    public static MethodHandle PyNumber_InPlaceSubtract$handle() {
        return PyNumber_InPlaceSubtract.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyNumber_InPlaceSubtract(PyObject *o1, PyObject *o2)
     * }
     */
    public static MemorySegment PyNumber_InPlaceSubtract$address() {
        return PyNumber_InPlaceSubtract.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyNumber_InPlaceSubtract(PyObject *o1, PyObject *o2)
     * }
     */
    public static MemorySegment PyNumber_InPlaceSubtract(MemorySegment o1, MemorySegment o2) {
        var mh$ = PyNumber_InPlaceSubtract.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyNumber_InPlaceSubtract", o1, o2);
            }
            return (MemorySegment)mh$.invokeExact(o1, o2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyNumber_InPlaceMultiply {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyNumber_InPlaceMultiply");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyNumber_InPlaceMultiply(PyObject *o1, PyObject *o2)
     * }
     */
    public static FunctionDescriptor PyNumber_InPlaceMultiply$descriptor() {
        return PyNumber_InPlaceMultiply.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyNumber_InPlaceMultiply(PyObject *o1, PyObject *o2)
     * }
     */
    public static MethodHandle PyNumber_InPlaceMultiply$handle() {
        return PyNumber_InPlaceMultiply.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyNumber_InPlaceMultiply(PyObject *o1, PyObject *o2)
     * }
     */
    public static MemorySegment PyNumber_InPlaceMultiply$address() {
        return PyNumber_InPlaceMultiply.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyNumber_InPlaceMultiply(PyObject *o1, PyObject *o2)
     * }
     */
    public static MemorySegment PyNumber_InPlaceMultiply(MemorySegment o1, MemorySegment o2) {
        var mh$ = PyNumber_InPlaceMultiply.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyNumber_InPlaceMultiply", o1, o2);
            }
            return (MemorySegment)mh$.invokeExact(o1, o2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyNumber_InPlaceMatrixMultiply {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyNumber_InPlaceMatrixMultiply");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyNumber_InPlaceMatrixMultiply(PyObject *o1, PyObject *o2)
     * }
     */
    public static FunctionDescriptor PyNumber_InPlaceMatrixMultiply$descriptor() {
        return PyNumber_InPlaceMatrixMultiply.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyNumber_InPlaceMatrixMultiply(PyObject *o1, PyObject *o2)
     * }
     */
    public static MethodHandle PyNumber_InPlaceMatrixMultiply$handle() {
        return PyNumber_InPlaceMatrixMultiply.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyNumber_InPlaceMatrixMultiply(PyObject *o1, PyObject *o2)
     * }
     */
    public static MemorySegment PyNumber_InPlaceMatrixMultiply$address() {
        return PyNumber_InPlaceMatrixMultiply.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyNumber_InPlaceMatrixMultiply(PyObject *o1, PyObject *o2)
     * }
     */
    public static MemorySegment PyNumber_InPlaceMatrixMultiply(MemorySegment o1, MemorySegment o2) {
        var mh$ = PyNumber_InPlaceMatrixMultiply.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyNumber_InPlaceMatrixMultiply", o1, o2);
            }
            return (MemorySegment)mh$.invokeExact(o1, o2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyNumber_InPlaceFloorDivide {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyNumber_InPlaceFloorDivide");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyNumber_InPlaceFloorDivide(PyObject *o1, PyObject *o2)
     * }
     */
    public static FunctionDescriptor PyNumber_InPlaceFloorDivide$descriptor() {
        return PyNumber_InPlaceFloorDivide.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyNumber_InPlaceFloorDivide(PyObject *o1, PyObject *o2)
     * }
     */
    public static MethodHandle PyNumber_InPlaceFloorDivide$handle() {
        return PyNumber_InPlaceFloorDivide.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyNumber_InPlaceFloorDivide(PyObject *o1, PyObject *o2)
     * }
     */
    public static MemorySegment PyNumber_InPlaceFloorDivide$address() {
        return PyNumber_InPlaceFloorDivide.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyNumber_InPlaceFloorDivide(PyObject *o1, PyObject *o2)
     * }
     */
    public static MemorySegment PyNumber_InPlaceFloorDivide(MemorySegment o1, MemorySegment o2) {
        var mh$ = PyNumber_InPlaceFloorDivide.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyNumber_InPlaceFloorDivide", o1, o2);
            }
            return (MemorySegment)mh$.invokeExact(o1, o2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyNumber_InPlaceTrueDivide {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyNumber_InPlaceTrueDivide");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyNumber_InPlaceTrueDivide(PyObject *o1, PyObject *o2)
     * }
     */
    public static FunctionDescriptor PyNumber_InPlaceTrueDivide$descriptor() {
        return PyNumber_InPlaceTrueDivide.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyNumber_InPlaceTrueDivide(PyObject *o1, PyObject *o2)
     * }
     */
    public static MethodHandle PyNumber_InPlaceTrueDivide$handle() {
        return PyNumber_InPlaceTrueDivide.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyNumber_InPlaceTrueDivide(PyObject *o1, PyObject *o2)
     * }
     */
    public static MemorySegment PyNumber_InPlaceTrueDivide$address() {
        return PyNumber_InPlaceTrueDivide.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyNumber_InPlaceTrueDivide(PyObject *o1, PyObject *o2)
     * }
     */
    public static MemorySegment PyNumber_InPlaceTrueDivide(MemorySegment o1, MemorySegment o2) {
        var mh$ = PyNumber_InPlaceTrueDivide.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyNumber_InPlaceTrueDivide", o1, o2);
            }
            return (MemorySegment)mh$.invokeExact(o1, o2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyNumber_InPlaceRemainder {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyNumber_InPlaceRemainder");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyNumber_InPlaceRemainder(PyObject *o1, PyObject *o2)
     * }
     */
    public static FunctionDescriptor PyNumber_InPlaceRemainder$descriptor() {
        return PyNumber_InPlaceRemainder.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyNumber_InPlaceRemainder(PyObject *o1, PyObject *o2)
     * }
     */
    public static MethodHandle PyNumber_InPlaceRemainder$handle() {
        return PyNumber_InPlaceRemainder.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyNumber_InPlaceRemainder(PyObject *o1, PyObject *o2)
     * }
     */
    public static MemorySegment PyNumber_InPlaceRemainder$address() {
        return PyNumber_InPlaceRemainder.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyNumber_InPlaceRemainder(PyObject *o1, PyObject *o2)
     * }
     */
    public static MemorySegment PyNumber_InPlaceRemainder(MemorySegment o1, MemorySegment o2) {
        var mh$ = PyNumber_InPlaceRemainder.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyNumber_InPlaceRemainder", o1, o2);
            }
            return (MemorySegment)mh$.invokeExact(o1, o2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyNumber_InPlacePower {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyNumber_InPlacePower");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyNumber_InPlacePower(PyObject *o1, PyObject *o2, PyObject *o3)
     * }
     */
    public static FunctionDescriptor PyNumber_InPlacePower$descriptor() {
        return PyNumber_InPlacePower.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyNumber_InPlacePower(PyObject *o1, PyObject *o2, PyObject *o3)
     * }
     */
    public static MethodHandle PyNumber_InPlacePower$handle() {
        return PyNumber_InPlacePower.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyNumber_InPlacePower(PyObject *o1, PyObject *o2, PyObject *o3)
     * }
     */
    public static MemorySegment PyNumber_InPlacePower$address() {
        return PyNumber_InPlacePower.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyNumber_InPlacePower(PyObject *o1, PyObject *o2, PyObject *o3)
     * }
     */
    public static MemorySegment PyNumber_InPlacePower(MemorySegment o1, MemorySegment o2, MemorySegment o3) {
        var mh$ = PyNumber_InPlacePower.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyNumber_InPlacePower", o1, o2, o3);
            }
            return (MemorySegment)mh$.invokeExact(o1, o2, o3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyNumber_InPlaceLshift {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyNumber_InPlaceLshift");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyNumber_InPlaceLshift(PyObject *o1, PyObject *o2)
     * }
     */
    public static FunctionDescriptor PyNumber_InPlaceLshift$descriptor() {
        return PyNumber_InPlaceLshift.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyNumber_InPlaceLshift(PyObject *o1, PyObject *o2)
     * }
     */
    public static MethodHandle PyNumber_InPlaceLshift$handle() {
        return PyNumber_InPlaceLshift.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyNumber_InPlaceLshift(PyObject *o1, PyObject *o2)
     * }
     */
    public static MemorySegment PyNumber_InPlaceLshift$address() {
        return PyNumber_InPlaceLshift.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyNumber_InPlaceLshift(PyObject *o1, PyObject *o2)
     * }
     */
    public static MemorySegment PyNumber_InPlaceLshift(MemorySegment o1, MemorySegment o2) {
        var mh$ = PyNumber_InPlaceLshift.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyNumber_InPlaceLshift", o1, o2);
            }
            return (MemorySegment)mh$.invokeExact(o1, o2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyNumber_InPlaceRshift {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyNumber_InPlaceRshift");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyNumber_InPlaceRshift(PyObject *o1, PyObject *o2)
     * }
     */
    public static FunctionDescriptor PyNumber_InPlaceRshift$descriptor() {
        return PyNumber_InPlaceRshift.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyNumber_InPlaceRshift(PyObject *o1, PyObject *o2)
     * }
     */
    public static MethodHandle PyNumber_InPlaceRshift$handle() {
        return PyNumber_InPlaceRshift.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyNumber_InPlaceRshift(PyObject *o1, PyObject *o2)
     * }
     */
    public static MemorySegment PyNumber_InPlaceRshift$address() {
        return PyNumber_InPlaceRshift.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyNumber_InPlaceRshift(PyObject *o1, PyObject *o2)
     * }
     */
    public static MemorySegment PyNumber_InPlaceRshift(MemorySegment o1, MemorySegment o2) {
        var mh$ = PyNumber_InPlaceRshift.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyNumber_InPlaceRshift", o1, o2);
            }
            return (MemorySegment)mh$.invokeExact(o1, o2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyNumber_InPlaceAnd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyNumber_InPlaceAnd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyNumber_InPlaceAnd(PyObject *o1, PyObject *o2)
     * }
     */
    public static FunctionDescriptor PyNumber_InPlaceAnd$descriptor() {
        return PyNumber_InPlaceAnd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyNumber_InPlaceAnd(PyObject *o1, PyObject *o2)
     * }
     */
    public static MethodHandle PyNumber_InPlaceAnd$handle() {
        return PyNumber_InPlaceAnd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyNumber_InPlaceAnd(PyObject *o1, PyObject *o2)
     * }
     */
    public static MemorySegment PyNumber_InPlaceAnd$address() {
        return PyNumber_InPlaceAnd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyNumber_InPlaceAnd(PyObject *o1, PyObject *o2)
     * }
     */
    public static MemorySegment PyNumber_InPlaceAnd(MemorySegment o1, MemorySegment o2) {
        var mh$ = PyNumber_InPlaceAnd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyNumber_InPlaceAnd", o1, o2);
            }
            return (MemorySegment)mh$.invokeExact(o1, o2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyNumber_InPlaceXor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyNumber_InPlaceXor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyNumber_InPlaceXor(PyObject *o1, PyObject *o2)
     * }
     */
    public static FunctionDescriptor PyNumber_InPlaceXor$descriptor() {
        return PyNumber_InPlaceXor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyNumber_InPlaceXor(PyObject *o1, PyObject *o2)
     * }
     */
    public static MethodHandle PyNumber_InPlaceXor$handle() {
        return PyNumber_InPlaceXor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyNumber_InPlaceXor(PyObject *o1, PyObject *o2)
     * }
     */
    public static MemorySegment PyNumber_InPlaceXor$address() {
        return PyNumber_InPlaceXor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyNumber_InPlaceXor(PyObject *o1, PyObject *o2)
     * }
     */
    public static MemorySegment PyNumber_InPlaceXor(MemorySegment o1, MemorySegment o2) {
        var mh$ = PyNumber_InPlaceXor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyNumber_InPlaceXor", o1, o2);
            }
            return (MemorySegment)mh$.invokeExact(o1, o2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyNumber_InPlaceOr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyNumber_InPlaceOr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyNumber_InPlaceOr(PyObject *o1, PyObject *o2)
     * }
     */
    public static FunctionDescriptor PyNumber_InPlaceOr$descriptor() {
        return PyNumber_InPlaceOr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyNumber_InPlaceOr(PyObject *o1, PyObject *o2)
     * }
     */
    public static MethodHandle PyNumber_InPlaceOr$handle() {
        return PyNumber_InPlaceOr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyNumber_InPlaceOr(PyObject *o1, PyObject *o2)
     * }
     */
    public static MemorySegment PyNumber_InPlaceOr$address() {
        return PyNumber_InPlaceOr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyNumber_InPlaceOr(PyObject *o1, PyObject *o2)
     * }
     */
    public static MemorySegment PyNumber_InPlaceOr(MemorySegment o1, MemorySegment o2) {
        var mh$ = PyNumber_InPlaceOr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyNumber_InPlaceOr", o1, o2);
            }
            return (MemorySegment)mh$.invokeExact(o1, o2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyNumber_ToBase {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyNumber_ToBase");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyNumber_ToBase(PyObject *n, int base)
     * }
     */
    public static FunctionDescriptor PyNumber_ToBase$descriptor() {
        return PyNumber_ToBase.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyNumber_ToBase(PyObject *n, int base)
     * }
     */
    public static MethodHandle PyNumber_ToBase$handle() {
        return PyNumber_ToBase.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyNumber_ToBase(PyObject *n, int base)
     * }
     */
    public static MemorySegment PyNumber_ToBase$address() {
        return PyNumber_ToBase.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyNumber_ToBase(PyObject *n, int base)
     * }
     */
    public static MemorySegment PyNumber_ToBase(MemorySegment n, int base) {
        var mh$ = PyNumber_ToBase.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyNumber_ToBase", n, base);
            }
            return (MemorySegment)mh$.invokeExact(n, base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PySequence_Check {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PySequence_Check");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PySequence_Check(PyObject *o)
     * }
     */
    public static FunctionDescriptor PySequence_Check$descriptor() {
        return PySequence_Check.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PySequence_Check(PyObject *o)
     * }
     */
    public static MethodHandle PySequence_Check$handle() {
        return PySequence_Check.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PySequence_Check(PyObject *o)
     * }
     */
    public static MemorySegment PySequence_Check$address() {
        return PySequence_Check.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PySequence_Check(PyObject *o)
     * }
     */
    public static int PySequence_Check(MemorySegment o) {
        var mh$ = PySequence_Check.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PySequence_Check", o);
            }
            return (int)mh$.invokeExact(o);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PySequence_Size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PySequence_Size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_ssize_t PySequence_Size(PyObject *o)
     * }
     */
    public static FunctionDescriptor PySequence_Size$descriptor() {
        return PySequence_Size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_ssize_t PySequence_Size(PyObject *o)
     * }
     */
    public static MethodHandle PySequence_Size$handle() {
        return PySequence_Size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_ssize_t PySequence_Size(PyObject *o)
     * }
     */
    public static MemorySegment PySequence_Size$address() {
        return PySequence_Size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_ssize_t PySequence_Size(PyObject *o)
     * }
     */
    public static long PySequence_Size(MemorySegment o) {
        var mh$ = PySequence_Size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PySequence_Size", o);
            }
            return (long)mh$.invokeExact(o);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PySequence_Length {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PySequence_Length");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_ssize_t PySequence_Length(PyObject *o)
     * }
     */
    public static FunctionDescriptor PySequence_Length$descriptor() {
        return PySequence_Length.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_ssize_t PySequence_Length(PyObject *o)
     * }
     */
    public static MethodHandle PySequence_Length$handle() {
        return PySequence_Length.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_ssize_t PySequence_Length(PyObject *o)
     * }
     */
    public static MemorySegment PySequence_Length$address() {
        return PySequence_Length.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_ssize_t PySequence_Length(PyObject *o)
     * }
     */
    public static long PySequence_Length(MemorySegment o) {
        var mh$ = PySequence_Length.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PySequence_Length", o);
            }
            return (long)mh$.invokeExact(o);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PySequence_Concat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PySequence_Concat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PySequence_Concat(PyObject *o1, PyObject *o2)
     * }
     */
    public static FunctionDescriptor PySequence_Concat$descriptor() {
        return PySequence_Concat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PySequence_Concat(PyObject *o1, PyObject *o2)
     * }
     */
    public static MethodHandle PySequence_Concat$handle() {
        return PySequence_Concat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PySequence_Concat(PyObject *o1, PyObject *o2)
     * }
     */
    public static MemorySegment PySequence_Concat$address() {
        return PySequence_Concat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PySequence_Concat(PyObject *o1, PyObject *o2)
     * }
     */
    public static MemorySegment PySequence_Concat(MemorySegment o1, MemorySegment o2) {
        var mh$ = PySequence_Concat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PySequence_Concat", o1, o2);
            }
            return (MemorySegment)mh$.invokeExact(o1, o2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PySequence_Repeat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PySequence_Repeat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PySequence_Repeat(PyObject *o, Py_ssize_t count)
     * }
     */
    public static FunctionDescriptor PySequence_Repeat$descriptor() {
        return PySequence_Repeat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PySequence_Repeat(PyObject *o, Py_ssize_t count)
     * }
     */
    public static MethodHandle PySequence_Repeat$handle() {
        return PySequence_Repeat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PySequence_Repeat(PyObject *o, Py_ssize_t count)
     * }
     */
    public static MemorySegment PySequence_Repeat$address() {
        return PySequence_Repeat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PySequence_Repeat(PyObject *o, Py_ssize_t count)
     * }
     */
    public static MemorySegment PySequence_Repeat(MemorySegment o, long count) {
        var mh$ = PySequence_Repeat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PySequence_Repeat", o, count);
            }
            return (MemorySegment)mh$.invokeExact(o, count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PySequence_GetItem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PySequence_GetItem");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PySequence_GetItem(PyObject *o, Py_ssize_t i)
     * }
     */
    public static FunctionDescriptor PySequence_GetItem$descriptor() {
        return PySequence_GetItem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PySequence_GetItem(PyObject *o, Py_ssize_t i)
     * }
     */
    public static MethodHandle PySequence_GetItem$handle() {
        return PySequence_GetItem.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PySequence_GetItem(PyObject *o, Py_ssize_t i)
     * }
     */
    public static MemorySegment PySequence_GetItem$address() {
        return PySequence_GetItem.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PySequence_GetItem(PyObject *o, Py_ssize_t i)
     * }
     */
    public static MemorySegment PySequence_GetItem(MemorySegment o, long i) {
        var mh$ = PySequence_GetItem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PySequence_GetItem", o, i);
            }
            return (MemorySegment)mh$.invokeExact(o, i);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PySequence_GetSlice {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PySequence_GetSlice");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PySequence_GetSlice(PyObject *o, Py_ssize_t i1, Py_ssize_t i2)
     * }
     */
    public static FunctionDescriptor PySequence_GetSlice$descriptor() {
        return PySequence_GetSlice.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PySequence_GetSlice(PyObject *o, Py_ssize_t i1, Py_ssize_t i2)
     * }
     */
    public static MethodHandle PySequence_GetSlice$handle() {
        return PySequence_GetSlice.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PySequence_GetSlice(PyObject *o, Py_ssize_t i1, Py_ssize_t i2)
     * }
     */
    public static MemorySegment PySequence_GetSlice$address() {
        return PySequence_GetSlice.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PySequence_GetSlice(PyObject *o, Py_ssize_t i1, Py_ssize_t i2)
     * }
     */
    public static MemorySegment PySequence_GetSlice(MemorySegment o, long i1, long i2) {
        var mh$ = PySequence_GetSlice.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PySequence_GetSlice", o, i1, i2);
            }
            return (MemorySegment)mh$.invokeExact(o, i1, i2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PySequence_SetItem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PySequence_SetItem");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PySequence_SetItem(PyObject *o, Py_ssize_t i, PyObject *v)
     * }
     */
    public static FunctionDescriptor PySequence_SetItem$descriptor() {
        return PySequence_SetItem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PySequence_SetItem(PyObject *o, Py_ssize_t i, PyObject *v)
     * }
     */
    public static MethodHandle PySequence_SetItem$handle() {
        return PySequence_SetItem.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PySequence_SetItem(PyObject *o, Py_ssize_t i, PyObject *v)
     * }
     */
    public static MemorySegment PySequence_SetItem$address() {
        return PySequence_SetItem.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PySequence_SetItem(PyObject *o, Py_ssize_t i, PyObject *v)
     * }
     */
    public static int PySequence_SetItem(MemorySegment o, long i, MemorySegment v) {
        var mh$ = PySequence_SetItem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PySequence_SetItem", o, i, v);
            }
            return (int)mh$.invokeExact(o, i, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PySequence_DelItem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PySequence_DelItem");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PySequence_DelItem(PyObject *o, Py_ssize_t i)
     * }
     */
    public static FunctionDescriptor PySequence_DelItem$descriptor() {
        return PySequence_DelItem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PySequence_DelItem(PyObject *o, Py_ssize_t i)
     * }
     */
    public static MethodHandle PySequence_DelItem$handle() {
        return PySequence_DelItem.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PySequence_DelItem(PyObject *o, Py_ssize_t i)
     * }
     */
    public static MemorySegment PySequence_DelItem$address() {
        return PySequence_DelItem.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PySequence_DelItem(PyObject *o, Py_ssize_t i)
     * }
     */
    public static int PySequence_DelItem(MemorySegment o, long i) {
        var mh$ = PySequence_DelItem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PySequence_DelItem", o, i);
            }
            return (int)mh$.invokeExact(o, i);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PySequence_SetSlice {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PySequence_SetSlice");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PySequence_SetSlice(PyObject *o, Py_ssize_t i1, Py_ssize_t i2, PyObject *v)
     * }
     */
    public static FunctionDescriptor PySequence_SetSlice$descriptor() {
        return PySequence_SetSlice.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PySequence_SetSlice(PyObject *o, Py_ssize_t i1, Py_ssize_t i2, PyObject *v)
     * }
     */
    public static MethodHandle PySequence_SetSlice$handle() {
        return PySequence_SetSlice.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PySequence_SetSlice(PyObject *o, Py_ssize_t i1, Py_ssize_t i2, PyObject *v)
     * }
     */
    public static MemorySegment PySequence_SetSlice$address() {
        return PySequence_SetSlice.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PySequence_SetSlice(PyObject *o, Py_ssize_t i1, Py_ssize_t i2, PyObject *v)
     * }
     */
    public static int PySequence_SetSlice(MemorySegment o, long i1, long i2, MemorySegment v) {
        var mh$ = PySequence_SetSlice.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PySequence_SetSlice", o, i1, i2, v);
            }
            return (int)mh$.invokeExact(o, i1, i2, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PySequence_DelSlice {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PySequence_DelSlice");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PySequence_DelSlice(PyObject *o, Py_ssize_t i1, Py_ssize_t i2)
     * }
     */
    public static FunctionDescriptor PySequence_DelSlice$descriptor() {
        return PySequence_DelSlice.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PySequence_DelSlice(PyObject *o, Py_ssize_t i1, Py_ssize_t i2)
     * }
     */
    public static MethodHandle PySequence_DelSlice$handle() {
        return PySequence_DelSlice.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PySequence_DelSlice(PyObject *o, Py_ssize_t i1, Py_ssize_t i2)
     * }
     */
    public static MemorySegment PySequence_DelSlice$address() {
        return PySequence_DelSlice.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PySequence_DelSlice(PyObject *o, Py_ssize_t i1, Py_ssize_t i2)
     * }
     */
    public static int PySequence_DelSlice(MemorySegment o, long i1, long i2) {
        var mh$ = PySequence_DelSlice.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PySequence_DelSlice", o, i1, i2);
            }
            return (int)mh$.invokeExact(o, i1, i2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PySequence_Tuple {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PySequence_Tuple");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PySequence_Tuple(PyObject *o)
     * }
     */
    public static FunctionDescriptor PySequence_Tuple$descriptor() {
        return PySequence_Tuple.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PySequence_Tuple(PyObject *o)
     * }
     */
    public static MethodHandle PySequence_Tuple$handle() {
        return PySequence_Tuple.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PySequence_Tuple(PyObject *o)
     * }
     */
    public static MemorySegment PySequence_Tuple$address() {
        return PySequence_Tuple.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PySequence_Tuple(PyObject *o)
     * }
     */
    public static MemorySegment PySequence_Tuple(MemorySegment o) {
        var mh$ = PySequence_Tuple.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PySequence_Tuple", o);
            }
            return (MemorySegment)mh$.invokeExact(o);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PySequence_List {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PySequence_List");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PySequence_List(PyObject *o)
     * }
     */
    public static FunctionDescriptor PySequence_List$descriptor() {
        return PySequence_List.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PySequence_List(PyObject *o)
     * }
     */
    public static MethodHandle PySequence_List$handle() {
        return PySequence_List.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PySequence_List(PyObject *o)
     * }
     */
    public static MemorySegment PySequence_List$address() {
        return PySequence_List.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PySequence_List(PyObject *o)
     * }
     */
    public static MemorySegment PySequence_List(MemorySegment o) {
        var mh$ = PySequence_List.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PySequence_List", o);
            }
            return (MemorySegment)mh$.invokeExact(o);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PySequence_Fast {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PySequence_Fast");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PySequence_Fast(PyObject *o, const char *m)
     * }
     */
    public static FunctionDescriptor PySequence_Fast$descriptor() {
        return PySequence_Fast.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PySequence_Fast(PyObject *o, const char *m)
     * }
     */
    public static MethodHandle PySequence_Fast$handle() {
        return PySequence_Fast.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PySequence_Fast(PyObject *o, const char *m)
     * }
     */
    public static MemorySegment PySequence_Fast$address() {
        return PySequence_Fast.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PySequence_Fast(PyObject *o, const char *m)
     * }
     */
    public static MemorySegment PySequence_Fast(MemorySegment o, MemorySegment m) {
        var mh$ = PySequence_Fast.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PySequence_Fast", o, m);
            }
            return (MemorySegment)mh$.invokeExact(o, m);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PySequence_Count {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PySequence_Count");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_ssize_t PySequence_Count(PyObject *o, PyObject *value)
     * }
     */
    public static FunctionDescriptor PySequence_Count$descriptor() {
        return PySequence_Count.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_ssize_t PySequence_Count(PyObject *o, PyObject *value)
     * }
     */
    public static MethodHandle PySequence_Count$handle() {
        return PySequence_Count.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_ssize_t PySequence_Count(PyObject *o, PyObject *value)
     * }
     */
    public static MemorySegment PySequence_Count$address() {
        return PySequence_Count.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_ssize_t PySequence_Count(PyObject *o, PyObject *value)
     * }
     */
    public static long PySequence_Count(MemorySegment o, MemorySegment value) {
        var mh$ = PySequence_Count.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PySequence_Count", o, value);
            }
            return (long)mh$.invokeExact(o, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PySequence_Contains {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PySequence_Contains");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PySequence_Contains(PyObject *seq, PyObject *ob)
     * }
     */
    public static FunctionDescriptor PySequence_Contains$descriptor() {
        return PySequence_Contains.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PySequence_Contains(PyObject *seq, PyObject *ob)
     * }
     */
    public static MethodHandle PySequence_Contains$handle() {
        return PySequence_Contains.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PySequence_Contains(PyObject *seq, PyObject *ob)
     * }
     */
    public static MemorySegment PySequence_Contains$address() {
        return PySequence_Contains.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PySequence_Contains(PyObject *seq, PyObject *ob)
     * }
     */
    public static int PySequence_Contains(MemorySegment seq, MemorySegment ob) {
        var mh$ = PySequence_Contains.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PySequence_Contains", seq, ob);
            }
            return (int)mh$.invokeExact(seq, ob);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PySequence_In {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PySequence_In");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PySequence_In(PyObject *o, PyObject *value)
     * }
     */
    public static FunctionDescriptor PySequence_In$descriptor() {
        return PySequence_In.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PySequence_In(PyObject *o, PyObject *value)
     * }
     */
    public static MethodHandle PySequence_In$handle() {
        return PySequence_In.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PySequence_In(PyObject *o, PyObject *value)
     * }
     */
    public static MemorySegment PySequence_In$address() {
        return PySequence_In.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PySequence_In(PyObject *o, PyObject *value)
     * }
     */
    public static int PySequence_In(MemorySegment o, MemorySegment value) {
        var mh$ = PySequence_In.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PySequence_In", o, value);
            }
            return (int)mh$.invokeExact(o, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PySequence_Index {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PySequence_Index");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_ssize_t PySequence_Index(PyObject *o, PyObject *value)
     * }
     */
    public static FunctionDescriptor PySequence_Index$descriptor() {
        return PySequence_Index.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_ssize_t PySequence_Index(PyObject *o, PyObject *value)
     * }
     */
    public static MethodHandle PySequence_Index$handle() {
        return PySequence_Index.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_ssize_t PySequence_Index(PyObject *o, PyObject *value)
     * }
     */
    public static MemorySegment PySequence_Index$address() {
        return PySequence_Index.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_ssize_t PySequence_Index(PyObject *o, PyObject *value)
     * }
     */
    public static long PySequence_Index(MemorySegment o, MemorySegment value) {
        var mh$ = PySequence_Index.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PySequence_Index", o, value);
            }
            return (long)mh$.invokeExact(o, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PySequence_InPlaceConcat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PySequence_InPlaceConcat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PySequence_InPlaceConcat(PyObject *o1, PyObject *o2)
     * }
     */
    public static FunctionDescriptor PySequence_InPlaceConcat$descriptor() {
        return PySequence_InPlaceConcat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PySequence_InPlaceConcat(PyObject *o1, PyObject *o2)
     * }
     */
    public static MethodHandle PySequence_InPlaceConcat$handle() {
        return PySequence_InPlaceConcat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PySequence_InPlaceConcat(PyObject *o1, PyObject *o2)
     * }
     */
    public static MemorySegment PySequence_InPlaceConcat$address() {
        return PySequence_InPlaceConcat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PySequence_InPlaceConcat(PyObject *o1, PyObject *o2)
     * }
     */
    public static MemorySegment PySequence_InPlaceConcat(MemorySegment o1, MemorySegment o2) {
        var mh$ = PySequence_InPlaceConcat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PySequence_InPlaceConcat", o1, o2);
            }
            return (MemorySegment)mh$.invokeExact(o1, o2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PySequence_InPlaceRepeat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PySequence_InPlaceRepeat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PySequence_InPlaceRepeat(PyObject *o, Py_ssize_t count)
     * }
     */
    public static FunctionDescriptor PySequence_InPlaceRepeat$descriptor() {
        return PySequence_InPlaceRepeat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PySequence_InPlaceRepeat(PyObject *o, Py_ssize_t count)
     * }
     */
    public static MethodHandle PySequence_InPlaceRepeat$handle() {
        return PySequence_InPlaceRepeat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PySequence_InPlaceRepeat(PyObject *o, Py_ssize_t count)
     * }
     */
    public static MemorySegment PySequence_InPlaceRepeat$address() {
        return PySequence_InPlaceRepeat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PySequence_InPlaceRepeat(PyObject *o, Py_ssize_t count)
     * }
     */
    public static MemorySegment PySequence_InPlaceRepeat(MemorySegment o, long count) {
        var mh$ = PySequence_InPlaceRepeat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PySequence_InPlaceRepeat", o, count);
            }
            return (MemorySegment)mh$.invokeExact(o, count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyMapping_Check {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyMapping_Check");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyMapping_Check(PyObject *o)
     * }
     */
    public static FunctionDescriptor PyMapping_Check$descriptor() {
        return PyMapping_Check.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyMapping_Check(PyObject *o)
     * }
     */
    public static MethodHandle PyMapping_Check$handle() {
        return PyMapping_Check.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyMapping_Check(PyObject *o)
     * }
     */
    public static MemorySegment PyMapping_Check$address() {
        return PyMapping_Check.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyMapping_Check(PyObject *o)
     * }
     */
    public static int PyMapping_Check(MemorySegment o) {
        var mh$ = PyMapping_Check.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyMapping_Check", o);
            }
            return (int)mh$.invokeExact(o);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyMapping_Size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyMapping_Size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_ssize_t PyMapping_Size(PyObject *o)
     * }
     */
    public static FunctionDescriptor PyMapping_Size$descriptor() {
        return PyMapping_Size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_ssize_t PyMapping_Size(PyObject *o)
     * }
     */
    public static MethodHandle PyMapping_Size$handle() {
        return PyMapping_Size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_ssize_t PyMapping_Size(PyObject *o)
     * }
     */
    public static MemorySegment PyMapping_Size$address() {
        return PyMapping_Size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_ssize_t PyMapping_Size(PyObject *o)
     * }
     */
    public static long PyMapping_Size(MemorySegment o) {
        var mh$ = PyMapping_Size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyMapping_Size", o);
            }
            return (long)mh$.invokeExact(o);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyMapping_Length {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyMapping_Length");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_ssize_t PyMapping_Length(PyObject *o)
     * }
     */
    public static FunctionDescriptor PyMapping_Length$descriptor() {
        return PyMapping_Length.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_ssize_t PyMapping_Length(PyObject *o)
     * }
     */
    public static MethodHandle PyMapping_Length$handle() {
        return PyMapping_Length.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_ssize_t PyMapping_Length(PyObject *o)
     * }
     */
    public static MemorySegment PyMapping_Length$address() {
        return PyMapping_Length.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_ssize_t PyMapping_Length(PyObject *o)
     * }
     */
    public static long PyMapping_Length(MemorySegment o) {
        var mh$ = PyMapping_Length.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyMapping_Length", o);
            }
            return (long)mh$.invokeExact(o);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyMapping_HasKeyString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyMapping_HasKeyString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyMapping_HasKeyString(PyObject *o, const char *key)
     * }
     */
    public static FunctionDescriptor PyMapping_HasKeyString$descriptor() {
        return PyMapping_HasKeyString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyMapping_HasKeyString(PyObject *o, const char *key)
     * }
     */
    public static MethodHandle PyMapping_HasKeyString$handle() {
        return PyMapping_HasKeyString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyMapping_HasKeyString(PyObject *o, const char *key)
     * }
     */
    public static MemorySegment PyMapping_HasKeyString$address() {
        return PyMapping_HasKeyString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyMapping_HasKeyString(PyObject *o, const char *key)
     * }
     */
    public static int PyMapping_HasKeyString(MemorySegment o, MemorySegment key) {
        var mh$ = PyMapping_HasKeyString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyMapping_HasKeyString", o, key);
            }
            return (int)mh$.invokeExact(o, key);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyMapping_HasKey {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyMapping_HasKey");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyMapping_HasKey(PyObject *o, PyObject *key)
     * }
     */
    public static FunctionDescriptor PyMapping_HasKey$descriptor() {
        return PyMapping_HasKey.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyMapping_HasKey(PyObject *o, PyObject *key)
     * }
     */
    public static MethodHandle PyMapping_HasKey$handle() {
        return PyMapping_HasKey.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyMapping_HasKey(PyObject *o, PyObject *key)
     * }
     */
    public static MemorySegment PyMapping_HasKey$address() {
        return PyMapping_HasKey.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyMapping_HasKey(PyObject *o, PyObject *key)
     * }
     */
    public static int PyMapping_HasKey(MemorySegment o, MemorySegment key) {
        var mh$ = PyMapping_HasKey.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyMapping_HasKey", o, key);
            }
            return (int)mh$.invokeExact(o, key);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyMapping_Keys {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyMapping_Keys");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyMapping_Keys(PyObject *o)
     * }
     */
    public static FunctionDescriptor PyMapping_Keys$descriptor() {
        return PyMapping_Keys.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyMapping_Keys(PyObject *o)
     * }
     */
    public static MethodHandle PyMapping_Keys$handle() {
        return PyMapping_Keys.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyMapping_Keys(PyObject *o)
     * }
     */
    public static MemorySegment PyMapping_Keys$address() {
        return PyMapping_Keys.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyMapping_Keys(PyObject *o)
     * }
     */
    public static MemorySegment PyMapping_Keys(MemorySegment o) {
        var mh$ = PyMapping_Keys.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyMapping_Keys", o);
            }
            return (MemorySegment)mh$.invokeExact(o);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyMapping_Values {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyMapping_Values");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyMapping_Values(PyObject *o)
     * }
     */
    public static FunctionDescriptor PyMapping_Values$descriptor() {
        return PyMapping_Values.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyMapping_Values(PyObject *o)
     * }
     */
    public static MethodHandle PyMapping_Values$handle() {
        return PyMapping_Values.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyMapping_Values(PyObject *o)
     * }
     */
    public static MemorySegment PyMapping_Values$address() {
        return PyMapping_Values.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyMapping_Values(PyObject *o)
     * }
     */
    public static MemorySegment PyMapping_Values(MemorySegment o) {
        var mh$ = PyMapping_Values.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyMapping_Values", o);
            }
            return (MemorySegment)mh$.invokeExact(o);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyMapping_Items {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyMapping_Items");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyMapping_Items(PyObject *o)
     * }
     */
    public static FunctionDescriptor PyMapping_Items$descriptor() {
        return PyMapping_Items.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyMapping_Items(PyObject *o)
     * }
     */
    public static MethodHandle PyMapping_Items$handle() {
        return PyMapping_Items.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyMapping_Items(PyObject *o)
     * }
     */
    public static MemorySegment PyMapping_Items$address() {
        return PyMapping_Items.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyMapping_Items(PyObject *o)
     * }
     */
    public static MemorySegment PyMapping_Items(MemorySegment o) {
        var mh$ = PyMapping_Items.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyMapping_Items", o);
            }
            return (MemorySegment)mh$.invokeExact(o);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyMapping_GetItemString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyMapping_GetItemString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyMapping_GetItemString(PyObject *o, const char *key)
     * }
     */
    public static FunctionDescriptor PyMapping_GetItemString$descriptor() {
        return PyMapping_GetItemString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyMapping_GetItemString(PyObject *o, const char *key)
     * }
     */
    public static MethodHandle PyMapping_GetItemString$handle() {
        return PyMapping_GetItemString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyMapping_GetItemString(PyObject *o, const char *key)
     * }
     */
    public static MemorySegment PyMapping_GetItemString$address() {
        return PyMapping_GetItemString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyMapping_GetItemString(PyObject *o, const char *key)
     * }
     */
    public static MemorySegment PyMapping_GetItemString(MemorySegment o, MemorySegment key) {
        var mh$ = PyMapping_GetItemString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyMapping_GetItemString", o, key);
            }
            return (MemorySegment)mh$.invokeExact(o, key);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyMapping_SetItemString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyMapping_SetItemString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyMapping_SetItemString(PyObject *o, const char *key, PyObject *value)
     * }
     */
    public static FunctionDescriptor PyMapping_SetItemString$descriptor() {
        return PyMapping_SetItemString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyMapping_SetItemString(PyObject *o, const char *key, PyObject *value)
     * }
     */
    public static MethodHandle PyMapping_SetItemString$handle() {
        return PyMapping_SetItemString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyMapping_SetItemString(PyObject *o, const char *key, PyObject *value)
     * }
     */
    public static MemorySegment PyMapping_SetItemString$address() {
        return PyMapping_SetItemString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyMapping_SetItemString(PyObject *o, const char *key, PyObject *value)
     * }
     */
    public static int PyMapping_SetItemString(MemorySegment o, MemorySegment key, MemorySegment value) {
        var mh$ = PyMapping_SetItemString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyMapping_SetItemString", o, key, value);
            }
            return (int)mh$.invokeExact(o, key, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_IsInstance {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_IsInstance");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyObject_IsInstance(PyObject *object, PyObject *typeorclass)
     * }
     */
    public static FunctionDescriptor PyObject_IsInstance$descriptor() {
        return PyObject_IsInstance.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyObject_IsInstance(PyObject *object, PyObject *typeorclass)
     * }
     */
    public static MethodHandle PyObject_IsInstance$handle() {
        return PyObject_IsInstance.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyObject_IsInstance(PyObject *object, PyObject *typeorclass)
     * }
     */
    public static MemorySegment PyObject_IsInstance$address() {
        return PyObject_IsInstance.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyObject_IsInstance(PyObject *object, PyObject *typeorclass)
     * }
     */
    public static int PyObject_IsInstance(MemorySegment object, MemorySegment typeorclass) {
        var mh$ = PyObject_IsInstance.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_IsInstance", object, typeorclass);
            }
            return (int)mh$.invokeExact(object, typeorclass);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_IsSubclass {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_IsSubclass");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyObject_IsSubclass(PyObject *object, PyObject *typeorclass)
     * }
     */
    public static FunctionDescriptor PyObject_IsSubclass$descriptor() {
        return PyObject_IsSubclass.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyObject_IsSubclass(PyObject *object, PyObject *typeorclass)
     * }
     */
    public static MethodHandle PyObject_IsSubclass$handle() {
        return PyObject_IsSubclass.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyObject_IsSubclass(PyObject *object, PyObject *typeorclass)
     * }
     */
    public static MemorySegment PyObject_IsSubclass$address() {
        return PyObject_IsSubclass.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyObject_IsSubclass(PyObject *object, PyObject *typeorclass)
     * }
     */
    public static int PyObject_IsSubclass(MemorySegment object, MemorySegment typeorclass) {
        var mh$ = PyObject_IsSubclass.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_IsSubclass", object, typeorclass);
            }
            return (int)mh$.invokeExact(object, typeorclass);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyStack_AsDict {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyStack_AsDict");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *_PyStack_AsDict(PyObject *const *values, PyObject *kwnames)
     * }
     */
    public static FunctionDescriptor _PyStack_AsDict$descriptor() {
        return _PyStack_AsDict.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *_PyStack_AsDict(PyObject *const *values, PyObject *kwnames)
     * }
     */
    public static MethodHandle _PyStack_AsDict$handle() {
        return _PyStack_AsDict.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *_PyStack_AsDict(PyObject *const *values, PyObject *kwnames)
     * }
     */
    public static MemorySegment _PyStack_AsDict$address() {
        return _PyStack_AsDict.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *_PyStack_AsDict(PyObject *const *values, PyObject *kwnames)
     * }
     */
    public static MemorySegment _PyStack_AsDict(MemorySegment values, MemorySegment kwnames) {
        var mh$ = _PyStack_AsDict.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyStack_AsDict", values, kwnames);
            }
            return (MemorySegment)mh$.invokeExact(values, kwnames);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _Py_CheckFunctionResult {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_Py_CheckFunctionResult");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *_Py_CheckFunctionResult(PyThreadState *tstate, PyObject *callable, PyObject *result, const char *where)
     * }
     */
    public static FunctionDescriptor _Py_CheckFunctionResult$descriptor() {
        return _Py_CheckFunctionResult.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *_Py_CheckFunctionResult(PyThreadState *tstate, PyObject *callable, PyObject *result, const char *where)
     * }
     */
    public static MethodHandle _Py_CheckFunctionResult$handle() {
        return _Py_CheckFunctionResult.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *_Py_CheckFunctionResult(PyThreadState *tstate, PyObject *callable, PyObject *result, const char *where)
     * }
     */
    public static MemorySegment _Py_CheckFunctionResult$address() {
        return _Py_CheckFunctionResult.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *_Py_CheckFunctionResult(PyThreadState *tstate, PyObject *callable, PyObject *result, const char *where)
     * }
     */
    public static MemorySegment _Py_CheckFunctionResult(MemorySegment tstate, MemorySegment callable, MemorySegment result, MemorySegment where) {
        var mh$ = _Py_CheckFunctionResult.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_Py_CheckFunctionResult", tstate, callable, result, where);
            }
            return (MemorySegment)mh$.invokeExact(tstate, callable, result, where);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyObject_MakeTpCall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyObject_MakeTpCall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *_PyObject_MakeTpCall(PyThreadState *tstate, PyObject *callable, PyObject *const *args, Py_ssize_t nargs, PyObject *keywords)
     * }
     */
    public static FunctionDescriptor _PyObject_MakeTpCall$descriptor() {
        return _PyObject_MakeTpCall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *_PyObject_MakeTpCall(PyThreadState *tstate, PyObject *callable, PyObject *const *args, Py_ssize_t nargs, PyObject *keywords)
     * }
     */
    public static MethodHandle _PyObject_MakeTpCall$handle() {
        return _PyObject_MakeTpCall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *_PyObject_MakeTpCall(PyThreadState *tstate, PyObject *callable, PyObject *const *args, Py_ssize_t nargs, PyObject *keywords)
     * }
     */
    public static MemorySegment _PyObject_MakeTpCall$address() {
        return _PyObject_MakeTpCall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *_PyObject_MakeTpCall(PyThreadState *tstate, PyObject *callable, PyObject *const *args, Py_ssize_t nargs, PyObject *keywords)
     * }
     */
    public static MemorySegment _PyObject_MakeTpCall(MemorySegment tstate, MemorySegment callable, MemorySegment args, long nargs, MemorySegment keywords) {
        var mh$ = _PyObject_MakeTpCall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyObject_MakeTpCall", tstate, callable, args, nargs, keywords);
            }
            return (MemorySegment)mh$.invokeExact(tstate, callable, args, nargs, keywords);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyVectorcall_Function {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyVectorcall_Function");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * vectorcallfunc PyVectorcall_Function(PyObject *callable)
     * }
     */
    public static FunctionDescriptor PyVectorcall_Function$descriptor() {
        return PyVectorcall_Function.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * vectorcallfunc PyVectorcall_Function(PyObject *callable)
     * }
     */
    public static MethodHandle PyVectorcall_Function$handle() {
        return PyVectorcall_Function.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * vectorcallfunc PyVectorcall_Function(PyObject *callable)
     * }
     */
    public static MemorySegment PyVectorcall_Function$address() {
        return PyVectorcall_Function.ADDR;
    }

    /**
     * {@snippet lang=c :
     * vectorcallfunc PyVectorcall_Function(PyObject *callable)
     * }
     */
    public static MemorySegment PyVectorcall_Function(MemorySegment callable) {
        var mh$ = PyVectorcall_Function.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyVectorcall_Function", callable);
            }
            return (MemorySegment)mh$.invokeExact(callable);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_VectorcallDict {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_VectorcallDict");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyObject_VectorcallDict(PyObject *callable, PyObject *const *args, size_t nargsf, PyObject *kwargs)
     * }
     */
    public static FunctionDescriptor PyObject_VectorcallDict$descriptor() {
        return PyObject_VectorcallDict.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyObject_VectorcallDict(PyObject *callable, PyObject *const *args, size_t nargsf, PyObject *kwargs)
     * }
     */
    public static MethodHandle PyObject_VectorcallDict$handle() {
        return PyObject_VectorcallDict.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyObject_VectorcallDict(PyObject *callable, PyObject *const *args, size_t nargsf, PyObject *kwargs)
     * }
     */
    public static MemorySegment PyObject_VectorcallDict$address() {
        return PyObject_VectorcallDict.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyObject_VectorcallDict(PyObject *callable, PyObject *const *args, size_t nargsf, PyObject *kwargs)
     * }
     */
    public static MemorySegment PyObject_VectorcallDict(MemorySegment callable, MemorySegment args, long nargsf, MemorySegment kwargs) {
        var mh$ = PyObject_VectorcallDict.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_VectorcallDict", callable, args, nargsf, kwargs);
            }
            return (MemorySegment)mh$.invokeExact(callable, args, nargsf, kwargs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyObject_FastCall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyObject_FastCall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *_PyObject_FastCall(PyObject *func, PyObject *const *args, Py_ssize_t nargs)
     * }
     */
    public static FunctionDescriptor _PyObject_FastCall$descriptor() {
        return _PyObject_FastCall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *_PyObject_FastCall(PyObject *func, PyObject *const *args, Py_ssize_t nargs)
     * }
     */
    public static MethodHandle _PyObject_FastCall$handle() {
        return _PyObject_FastCall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *_PyObject_FastCall(PyObject *func, PyObject *const *args, Py_ssize_t nargs)
     * }
     */
    public static MemorySegment _PyObject_FastCall$address() {
        return _PyObject_FastCall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *_PyObject_FastCall(PyObject *func, PyObject *const *args, Py_ssize_t nargs)
     * }
     */
    public static MemorySegment _PyObject_FastCall(MemorySegment func, MemorySegment args, long nargs) {
        var mh$ = _PyObject_FastCall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyObject_FastCall", func, args, nargs);
            }
            return (MemorySegment)mh$.invokeExact(func, args, nargs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_CallOneArg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_CallOneArg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyObject_CallOneArg(PyObject *func, PyObject *arg)
     * }
     */
    public static FunctionDescriptor PyObject_CallOneArg$descriptor() {
        return PyObject_CallOneArg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyObject_CallOneArg(PyObject *func, PyObject *arg)
     * }
     */
    public static MethodHandle PyObject_CallOneArg$handle() {
        return PyObject_CallOneArg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyObject_CallOneArg(PyObject *func, PyObject *arg)
     * }
     */
    public static MemorySegment PyObject_CallOneArg$address() {
        return PyObject_CallOneArg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyObject_CallOneArg(PyObject *func, PyObject *arg)
     * }
     */
    public static MemorySegment PyObject_CallOneArg(MemorySegment func, MemorySegment arg) {
        var mh$ = PyObject_CallOneArg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_CallOneArg", func, arg);
            }
            return (MemorySegment)mh$.invokeExact(func, arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * PyObject *_PyObject_CallMethod(PyObject *obj, PyObject *name, const char *format, ...)
     * }
     */
    public static class _PyObject_CallMethod {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_POINTER,
                Python_h.C_POINTER,
                Python_h.C_POINTER,
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("_PyObject_CallMethod");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private _PyObject_CallMethod(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * PyObject *_PyObject_CallMethod(PyObject *obj, PyObject *name, const char *format, ...)
         * }
         */
        public static _PyObject_CallMethod makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new _PyObject_CallMethod(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public MemorySegment apply(MemorySegment obj, MemorySegment name, MemorySegment format, Object... x3) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("_PyObject_CallMethod", obj, name, format, x3);
                }
                return (MemorySegment)spreader.invokeExact(obj, name, format, x3);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * PyObject *_PyObject_CallMethodId(PyObject *obj, _Py_Identifier *name, const char *format, ...)
     * }
     */
    public static class _PyObject_CallMethodId {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_POINTER,
                Python_h.C_POINTER,
                Python_h.C_POINTER,
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("_PyObject_CallMethodId");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private _PyObject_CallMethodId(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * PyObject *_PyObject_CallMethodId(PyObject *obj, _Py_Identifier *name, const char *format, ...)
         * }
         */
        public static _PyObject_CallMethodId makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new _PyObject_CallMethodId(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public MemorySegment apply(MemorySegment obj, MemorySegment name, MemorySegment format, Object... x3) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("_PyObject_CallMethodId", obj, name, format, x3);
                }
                return (MemorySegment)spreader.invokeExact(obj, name, format, x3);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * PyObject *_PyObject_CallMethodId_SizeT(PyObject *obj, _Py_Identifier *name, const char *format, ...)
     * }
     */
    public static class _PyObject_CallMethodId_SizeT {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_POINTER,
                Python_h.C_POINTER,
                Python_h.C_POINTER,
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("_PyObject_CallMethodId_SizeT");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private _PyObject_CallMethodId_SizeT(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * PyObject *_PyObject_CallMethodId_SizeT(PyObject *obj, _Py_Identifier *name, const char *format, ...)
         * }
         */
        public static _PyObject_CallMethodId_SizeT makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new _PyObject_CallMethodId_SizeT(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public MemorySegment apply(MemorySegment obj, MemorySegment name, MemorySegment format, Object... x3) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("_PyObject_CallMethodId_SizeT", obj, name, format, x3);
                }
                return (MemorySegment)spreader.invokeExact(obj, name, format, x3);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * PyObject *_PyObject_CallMethodIdObjArgs(PyObject *obj, _Py_Identifier *name, ...)
     * }
     */
    public static class _PyObject_CallMethodIdObjArgs {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_POINTER,
                Python_h.C_POINTER,
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("_PyObject_CallMethodIdObjArgs");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private _PyObject_CallMethodIdObjArgs(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * PyObject *_PyObject_CallMethodIdObjArgs(PyObject *obj, _Py_Identifier *name, ...)
         * }
         */
        public static _PyObject_CallMethodIdObjArgs makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new _PyObject_CallMethodIdObjArgs(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public MemorySegment apply(MemorySegment obj, MemorySegment name, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("_PyObject_CallMethodIdObjArgs", obj, name, x2);
                }
                return (MemorySegment)spreader.invokeExact(obj, name, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class _PyObject_HasLen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyObject_HasLen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyObject_HasLen(PyObject *o)
     * }
     */
    public static FunctionDescriptor _PyObject_HasLen$descriptor() {
        return _PyObject_HasLen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyObject_HasLen(PyObject *o)
     * }
     */
    public static MethodHandle _PyObject_HasLen$handle() {
        return _PyObject_HasLen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyObject_HasLen(PyObject *o)
     * }
     */
    public static MemorySegment _PyObject_HasLen$address() {
        return _PyObject_HasLen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyObject_HasLen(PyObject *o)
     * }
     */
    public static int _PyObject_HasLen(MemorySegment o) {
        var mh$ = _PyObject_HasLen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyObject_HasLen", o);
            }
            return (int)mh$.invokeExact(o);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_LengthHint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_LengthHint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_ssize_t PyObject_LengthHint(PyObject *o, Py_ssize_t)
     * }
     */
    public static FunctionDescriptor PyObject_LengthHint$descriptor() {
        return PyObject_LengthHint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_ssize_t PyObject_LengthHint(PyObject *o, Py_ssize_t)
     * }
     */
    public static MethodHandle PyObject_LengthHint$handle() {
        return PyObject_LengthHint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_ssize_t PyObject_LengthHint(PyObject *o, Py_ssize_t)
     * }
     */
    public static MemorySegment PyObject_LengthHint$address() {
        return PyObject_LengthHint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_ssize_t PyObject_LengthHint(PyObject *o, Py_ssize_t)
     * }
     */
    public static long PyObject_LengthHint(MemorySegment o, long x1) {
        var mh$ = PyObject_LengthHint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_LengthHint", o, x1);
            }
            return (long)mh$.invokeExact(o, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PySequence_IterSearch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PySequence_IterSearch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_ssize_t _PySequence_IterSearch(PyObject *seq, PyObject *obj, int operation)
     * }
     */
    public static FunctionDescriptor _PySequence_IterSearch$descriptor() {
        return _PySequence_IterSearch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_ssize_t _PySequence_IterSearch(PyObject *seq, PyObject *obj, int operation)
     * }
     */
    public static MethodHandle _PySequence_IterSearch$handle() {
        return _PySequence_IterSearch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_ssize_t _PySequence_IterSearch(PyObject *seq, PyObject *obj, int operation)
     * }
     */
    public static MemorySegment _PySequence_IterSearch$address() {
        return _PySequence_IterSearch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_ssize_t _PySequence_IterSearch(PyObject *seq, PyObject *obj, int operation)
     * }
     */
    public static long _PySequence_IterSearch(MemorySegment seq, MemorySegment obj, int operation) {
        var mh$ = _PySequence_IterSearch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PySequence_IterSearch", seq, obj, operation);
            }
            return (long)mh$.invokeExact(seq, obj, operation);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyObject_RealIsInstance {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyObject_RealIsInstance");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyObject_RealIsInstance(PyObject *inst, PyObject *cls)
     * }
     */
    public static FunctionDescriptor _PyObject_RealIsInstance$descriptor() {
        return _PyObject_RealIsInstance.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyObject_RealIsInstance(PyObject *inst, PyObject *cls)
     * }
     */
    public static MethodHandle _PyObject_RealIsInstance$handle() {
        return _PyObject_RealIsInstance.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyObject_RealIsInstance(PyObject *inst, PyObject *cls)
     * }
     */
    public static MemorySegment _PyObject_RealIsInstance$address() {
        return _PyObject_RealIsInstance.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyObject_RealIsInstance(PyObject *inst, PyObject *cls)
     * }
     */
    public static int _PyObject_RealIsInstance(MemorySegment inst, MemorySegment cls) {
        var mh$ = _PyObject_RealIsInstance.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyObject_RealIsInstance", inst, cls);
            }
            return (int)mh$.invokeExact(inst, cls);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyObject_RealIsSubclass {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyObject_RealIsSubclass");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyObject_RealIsSubclass(PyObject *derived, PyObject *cls)
     * }
     */
    public static FunctionDescriptor _PyObject_RealIsSubclass$descriptor() {
        return _PyObject_RealIsSubclass.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyObject_RealIsSubclass(PyObject *derived, PyObject *cls)
     * }
     */
    public static MethodHandle _PyObject_RealIsSubclass$handle() {
        return _PyObject_RealIsSubclass.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyObject_RealIsSubclass(PyObject *derived, PyObject *cls)
     * }
     */
    public static MemorySegment _PyObject_RealIsSubclass$address() {
        return _PyObject_RealIsSubclass.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyObject_RealIsSubclass(PyObject *derived, PyObject *cls)
     * }
     */
    public static int _PyObject_RealIsSubclass(MemorySegment derived, MemorySegment cls) {
        var mh$ = _PyObject_RealIsSubclass.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyObject_RealIsSubclass", derived, cls);
            }
            return (int)mh$.invokeExact(derived, cls);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PySequence_BytesToCharpArray {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PySequence_BytesToCharpArray");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *const *_PySequence_BytesToCharpArray(PyObject *self)
     * }
     */
    public static FunctionDescriptor _PySequence_BytesToCharpArray$descriptor() {
        return _PySequence_BytesToCharpArray.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *const *_PySequence_BytesToCharpArray(PyObject *self)
     * }
     */
    public static MethodHandle _PySequence_BytesToCharpArray$handle() {
        return _PySequence_BytesToCharpArray.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *const *_PySequence_BytesToCharpArray(PyObject *self)
     * }
     */
    public static MemorySegment _PySequence_BytesToCharpArray$address() {
        return _PySequence_BytesToCharpArray.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *const *_PySequence_BytesToCharpArray(PyObject *self)
     * }
     */
    public static MemorySegment _PySequence_BytesToCharpArray(MemorySegment self) {
        var mh$ = _PySequence_BytesToCharpArray.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PySequence_BytesToCharpArray", self);
            }
            return (MemorySegment)mh$.invokeExact(self);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _Py_FreeCharPArray {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_Py_FreeCharPArray");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _Py_FreeCharPArray(char *const array[])
     * }
     */
    public static FunctionDescriptor _Py_FreeCharPArray$descriptor() {
        return _Py_FreeCharPArray.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _Py_FreeCharPArray(char *const array[])
     * }
     */
    public static MethodHandle _Py_FreeCharPArray$handle() {
        return _Py_FreeCharPArray.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _Py_FreeCharPArray(char *const array[])
     * }
     */
    public static MemorySegment _Py_FreeCharPArray$address() {
        return _Py_FreeCharPArray.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _Py_FreeCharPArray(char *const array[])
     * }
     */
    public static void _Py_FreeCharPArray(MemorySegment array) {
        var mh$ = _Py_FreeCharPArray.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_Py_FreeCharPArray", array);
            }
            mh$.invokeExact(array);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _Py_add_one_to_index_F {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_Py_add_one_to_index_F");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _Py_add_one_to_index_F(int nd, Py_ssize_t *index, const Py_ssize_t *shape)
     * }
     */
    public static FunctionDescriptor _Py_add_one_to_index_F$descriptor() {
        return _Py_add_one_to_index_F.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _Py_add_one_to_index_F(int nd, Py_ssize_t *index, const Py_ssize_t *shape)
     * }
     */
    public static MethodHandle _Py_add_one_to_index_F$handle() {
        return _Py_add_one_to_index_F.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _Py_add_one_to_index_F(int nd, Py_ssize_t *index, const Py_ssize_t *shape)
     * }
     */
    public static MemorySegment _Py_add_one_to_index_F$address() {
        return _Py_add_one_to_index_F.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _Py_add_one_to_index_F(int nd, Py_ssize_t *index, const Py_ssize_t *shape)
     * }
     */
    public static void _Py_add_one_to_index_F(int nd, MemorySegment index, MemorySegment shape) {
        var mh$ = _Py_add_one_to_index_F.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_Py_add_one_to_index_F", nd, index, shape);
            }
            mh$.invokeExact(nd, index, shape);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _Py_add_one_to_index_C {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_Py_add_one_to_index_C");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _Py_add_one_to_index_C(int nd, Py_ssize_t *index, const Py_ssize_t *shape)
     * }
     */
    public static FunctionDescriptor _Py_add_one_to_index_C$descriptor() {
        return _Py_add_one_to_index_C.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _Py_add_one_to_index_C(int nd, Py_ssize_t *index, const Py_ssize_t *shape)
     * }
     */
    public static MethodHandle _Py_add_one_to_index_C$handle() {
        return _Py_add_one_to_index_C.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _Py_add_one_to_index_C(int nd, Py_ssize_t *index, const Py_ssize_t *shape)
     * }
     */
    public static MemorySegment _Py_add_one_to_index_C$address() {
        return _Py_add_one_to_index_C.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _Py_add_one_to_index_C(int nd, Py_ssize_t *index, const Py_ssize_t *shape)
     * }
     */
    public static void _Py_add_one_to_index_C(int nd, MemorySegment index, MemorySegment shape) {
        var mh$ = _Py_add_one_to_index_C.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_Py_add_one_to_index_C", nd, index, shape);
            }
            mh$.invokeExact(nd, index, shape);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _Py_convert_optional_to_ssize_t {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_Py_convert_optional_to_ssize_t");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _Py_convert_optional_to_ssize_t(PyObject *, void *)
     * }
     */
    public static FunctionDescriptor _Py_convert_optional_to_ssize_t$descriptor() {
        return _Py_convert_optional_to_ssize_t.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _Py_convert_optional_to_ssize_t(PyObject *, void *)
     * }
     */
    public static MethodHandle _Py_convert_optional_to_ssize_t$handle() {
        return _Py_convert_optional_to_ssize_t.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _Py_convert_optional_to_ssize_t(PyObject *, void *)
     * }
     */
    public static MemorySegment _Py_convert_optional_to_ssize_t$address() {
        return _Py_convert_optional_to_ssize_t.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _Py_convert_optional_to_ssize_t(PyObject *, void *)
     * }
     */
    public static int _Py_convert_optional_to_ssize_t(MemorySegment x0, MemorySegment x1) {
        var mh$ = _Py_convert_optional_to_ssize_t.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_Py_convert_optional_to_ssize_t", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyNumber_Index {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyNumber_Index");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *_PyNumber_Index(PyObject *o)
     * }
     */
    public static FunctionDescriptor _PyNumber_Index$descriptor() {
        return _PyNumber_Index.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *_PyNumber_Index(PyObject *o)
     * }
     */
    public static MethodHandle _PyNumber_Index$handle() {
        return _PyNumber_Index.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *_PyNumber_Index(PyObject *o)
     * }
     */
    public static MemorySegment _PyNumber_Index$address() {
        return _PyNumber_Index.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *_PyNumber_Index(PyObject *o)
     * }
     */
    public static MemorySegment _PyNumber_Index(MemorySegment o) {
        var mh$ = _PyNumber_Index.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyNumber_Index", o);
            }
            return (MemorySegment)mh$.invokeExact(o);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyFilter_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyFilter_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyFilter_Type
     * }
     */
    public static GroupLayout PyFilter_Type$layout() {
        return PyFilter_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyFilter_Type
     * }
     */
    public static MemorySegment PyFilter_Type() {
        return PyFilter_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyFilter_Type
     * }
     */
    public static void PyFilter_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyFilter_Type$constants.SEGMENT, 0L, PyFilter_Type$constants.LAYOUT.byteSize());
    }

    private static class PyMap_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyMap_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyMap_Type
     * }
     */
    public static GroupLayout PyMap_Type$layout() {
        return PyMap_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyMap_Type
     * }
     */
    public static MemorySegment PyMap_Type() {
        return PyMap_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyMap_Type
     * }
     */
    public static void PyMap_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyMap_Type$constants.SEGMENT, 0L, PyMap_Type$constants.LAYOUT.byteSize());
    }

    private static class PyZip_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyZip_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyZip_Type
     * }
     */
    public static GroupLayout PyZip_Type$layout() {
        return PyZip_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyZip_Type
     * }
     */
    public static MemorySegment PyZip_Type() {
        return PyZip_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyZip_Type
     * }
     */
    public static void PyZip_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyZip_Type$constants.SEGMENT, 0L, PyZip_Type$constants.LAYOUT.byteSize());
    }

    private static class _Py_ctype_table$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(256, Python_h.C_INT);
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("_Py_ctype_table").reinterpret(LAYOUT.byteSize());
        public static final VarHandle HANDLE = LAYOUT.varHandle(sequenceElement());

        public static final long[] DIMS = { 256 };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const unsigned int _Py_ctype_table[256]
     * }
     */
    public static SequenceLayout _Py_ctype_table$layout() {
        return _Py_ctype_table$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern const unsigned int _Py_ctype_table[256]
     * }
     */
    public static long[] _Py_ctype_table$dimensions() {
        return _Py_ctype_table$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const unsigned int _Py_ctype_table[256]
     * }
     */
    public static MemorySegment _Py_ctype_table() {
        return _Py_ctype_table$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const unsigned int _Py_ctype_table[256]
     * }
     */
    public static void _Py_ctype_table(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, _Py_ctype_table$constants.SEGMENT, 0L, _Py_ctype_table$constants.LAYOUT.byteSize());
    }

    /**
     * Indexed getter for variable:
     * {@snippet lang=c :
     * extern const unsigned int _Py_ctype_table[256]
     * }
     */
    public static int _Py_ctype_table(long index0) {
        return (int)_Py_ctype_table$constants.HANDLE.get(_Py_ctype_table$constants.SEGMENT, 0L, index0);
    }

    /**
     * Indexed setter for variable:
     * {@snippet lang=c :
     * extern const unsigned int _Py_ctype_table[256]
     * }
     */
    public static void _Py_ctype_table(long index0, int varValue) {
        _Py_ctype_table$constants.HANDLE.set(_Py_ctype_table$constants.SEGMENT, 0L, index0, varValue);
    }

    private static class _Py_ctype_tolower$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(256, Python_h.C_CHAR);
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("_Py_ctype_tolower").reinterpret(LAYOUT.byteSize());
        public static final VarHandle HANDLE = LAYOUT.varHandle(sequenceElement());

        public static final long[] DIMS = { 256 };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const unsigned char _Py_ctype_tolower[256]
     * }
     */
    public static SequenceLayout _Py_ctype_tolower$layout() {
        return _Py_ctype_tolower$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern const unsigned char _Py_ctype_tolower[256]
     * }
     */
    public static long[] _Py_ctype_tolower$dimensions() {
        return _Py_ctype_tolower$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const unsigned char _Py_ctype_tolower[256]
     * }
     */
    public static MemorySegment _Py_ctype_tolower() {
        return _Py_ctype_tolower$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const unsigned char _Py_ctype_tolower[256]
     * }
     */
    public static void _Py_ctype_tolower(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, _Py_ctype_tolower$constants.SEGMENT, 0L, _Py_ctype_tolower$constants.LAYOUT.byteSize());
    }

    /**
     * Indexed getter for variable:
     * {@snippet lang=c :
     * extern const unsigned char _Py_ctype_tolower[256]
     * }
     */
    public static byte _Py_ctype_tolower(long index0) {
        return (byte)_Py_ctype_tolower$constants.HANDLE.get(_Py_ctype_tolower$constants.SEGMENT, 0L, index0);
    }

    /**
     * Indexed setter for variable:
     * {@snippet lang=c :
     * extern const unsigned char _Py_ctype_tolower[256]
     * }
     */
    public static void _Py_ctype_tolower(long index0, byte varValue) {
        _Py_ctype_tolower$constants.HANDLE.set(_Py_ctype_tolower$constants.SEGMENT, 0L, index0, varValue);
    }

    private static class _Py_ctype_toupper$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(256, Python_h.C_CHAR);
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("_Py_ctype_toupper").reinterpret(LAYOUT.byteSize());
        public static final VarHandle HANDLE = LAYOUT.varHandle(sequenceElement());

        public static final long[] DIMS = { 256 };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const unsigned char _Py_ctype_toupper[256]
     * }
     */
    public static SequenceLayout _Py_ctype_toupper$layout() {
        return _Py_ctype_toupper$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern const unsigned char _Py_ctype_toupper[256]
     * }
     */
    public static long[] _Py_ctype_toupper$dimensions() {
        return _Py_ctype_toupper$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const unsigned char _Py_ctype_toupper[256]
     * }
     */
    public static MemorySegment _Py_ctype_toupper() {
        return _Py_ctype_toupper$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const unsigned char _Py_ctype_toupper[256]
     * }
     */
    public static void _Py_ctype_toupper(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, _Py_ctype_toupper$constants.SEGMENT, 0L, _Py_ctype_toupper$constants.LAYOUT.byteSize());
    }

    /**
     * Indexed getter for variable:
     * {@snippet lang=c :
     * extern const unsigned char _Py_ctype_toupper[256]
     * }
     */
    public static byte _Py_ctype_toupper(long index0) {
        return (byte)_Py_ctype_toupper$constants.HANDLE.get(_Py_ctype_toupper$constants.SEGMENT, 0L, index0);
    }

    /**
     * Indexed setter for variable:
     * {@snippet lang=c :
     * extern const unsigned char _Py_ctype_toupper[256]
     * }
     */
    public static void _Py_ctype_toupper(long index0, byte varValue) {
        _Py_ctype_toupper$constants.HANDLE.set(_Py_ctype_toupper$constants.SEGMENT, 0L, index0, varValue);
    }

    private static class PyOS_string_to_double {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyOS_string_to_double");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double PyOS_string_to_double(const char *str, char **endptr, PyObject *overflow_exception)
     * }
     */
    public static FunctionDescriptor PyOS_string_to_double$descriptor() {
        return PyOS_string_to_double.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double PyOS_string_to_double(const char *str, char **endptr, PyObject *overflow_exception)
     * }
     */
    public static MethodHandle PyOS_string_to_double$handle() {
        return PyOS_string_to_double.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double PyOS_string_to_double(const char *str, char **endptr, PyObject *overflow_exception)
     * }
     */
    public static MemorySegment PyOS_string_to_double$address() {
        return PyOS_string_to_double.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double PyOS_string_to_double(const char *str, char **endptr, PyObject *overflow_exception)
     * }
     */
    public static double PyOS_string_to_double(MemorySegment str, MemorySegment endptr, MemorySegment overflow_exception) {
        var mh$ = PyOS_string_to_double.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyOS_string_to_double", str, endptr, overflow_exception);
            }
            return (double)mh$.invokeExact(str, endptr, overflow_exception);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyOS_double_to_string {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_DOUBLE,
            Python_h.C_CHAR,
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyOS_double_to_string");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *PyOS_double_to_string(double val, char format_code, int precision, int flags, int *type)
     * }
     */
    public static FunctionDescriptor PyOS_double_to_string$descriptor() {
        return PyOS_double_to_string.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *PyOS_double_to_string(double val, char format_code, int precision, int flags, int *type)
     * }
     */
    public static MethodHandle PyOS_double_to_string$handle() {
        return PyOS_double_to_string.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *PyOS_double_to_string(double val, char format_code, int precision, int flags, int *type)
     * }
     */
    public static MemorySegment PyOS_double_to_string$address() {
        return PyOS_double_to_string.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *PyOS_double_to_string(double val, char format_code, int precision, int flags, int *type)
     * }
     */
    public static MemorySegment PyOS_double_to_string(double val, byte format_code, int precision, int flags, MemorySegment type) {
        var mh$ = PyOS_double_to_string.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyOS_double_to_string", val, format_code, precision, flags, type);
            }
            return (MemorySegment)mh$.invokeExact(val, format_code, precision, flags, type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _Py_string_to_number_with_underscores {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_Py_string_to_number_with_underscores");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *_Py_string_to_number_with_underscores(const char *str, Py_ssize_t len, const char *what, PyObject *obj, void *arg, PyObject *(*innerfunc)(const char *, Py_ssize_t, void *))
     * }
     */
    public static FunctionDescriptor _Py_string_to_number_with_underscores$descriptor() {
        return _Py_string_to_number_with_underscores.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *_Py_string_to_number_with_underscores(const char *str, Py_ssize_t len, const char *what, PyObject *obj, void *arg, PyObject *(*innerfunc)(const char *, Py_ssize_t, void *))
     * }
     */
    public static MethodHandle _Py_string_to_number_with_underscores$handle() {
        return _Py_string_to_number_with_underscores.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *_Py_string_to_number_with_underscores(const char *str, Py_ssize_t len, const char *what, PyObject *obj, void *arg, PyObject *(*innerfunc)(const char *, Py_ssize_t, void *))
     * }
     */
    public static MemorySegment _Py_string_to_number_with_underscores$address() {
        return _Py_string_to_number_with_underscores.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *_Py_string_to_number_with_underscores(const char *str, Py_ssize_t len, const char *what, PyObject *obj, void *arg, PyObject *(*innerfunc)(const char *, Py_ssize_t, void *))
     * }
     */
    public static MemorySegment _Py_string_to_number_with_underscores(MemorySegment str, long len, MemorySegment what, MemorySegment obj, MemorySegment arg, MemorySegment innerfunc) {
        var mh$ = _Py_string_to_number_with_underscores.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_Py_string_to_number_with_underscores", str, len, what, obj, arg, innerfunc);
            }
            return (MemorySegment)mh$.invokeExact(str, len, what, obj, arg, innerfunc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _Py_parse_inf_or_nan {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_Py_parse_inf_or_nan");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double _Py_parse_inf_or_nan(const char *p, char **endptr)
     * }
     */
    public static FunctionDescriptor _Py_parse_inf_or_nan$descriptor() {
        return _Py_parse_inf_or_nan.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double _Py_parse_inf_or_nan(const char *p, char **endptr)
     * }
     */
    public static MethodHandle _Py_parse_inf_or_nan$handle() {
        return _Py_parse_inf_or_nan.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double _Py_parse_inf_or_nan(const char *p, char **endptr)
     * }
     */
    public static MemorySegment _Py_parse_inf_or_nan$address() {
        return _Py_parse_inf_or_nan.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double _Py_parse_inf_or_nan(const char *p, char **endptr)
     * }
     */
    public static double _Py_parse_inf_or_nan(MemorySegment p, MemorySegment endptr) {
        var mh$ = _Py_parse_inf_or_nan.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_Py_parse_inf_or_nan", p, endptr);
            }
            return (double)mh$.invokeExact(p, endptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyOS_mystrnicmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyOS_mystrnicmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyOS_mystrnicmp(const char *, const char *, Py_ssize_t)
     * }
     */
    public static FunctionDescriptor PyOS_mystrnicmp$descriptor() {
        return PyOS_mystrnicmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyOS_mystrnicmp(const char *, const char *, Py_ssize_t)
     * }
     */
    public static MethodHandle PyOS_mystrnicmp$handle() {
        return PyOS_mystrnicmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyOS_mystrnicmp(const char *, const char *, Py_ssize_t)
     * }
     */
    public static MemorySegment PyOS_mystrnicmp$address() {
        return PyOS_mystrnicmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyOS_mystrnicmp(const char *, const char *, Py_ssize_t)
     * }
     */
    public static int PyOS_mystrnicmp(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = PyOS_mystrnicmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyOS_mystrnicmp", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyOS_mystricmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyOS_mystricmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyOS_mystricmp(const char *, const char *)
     * }
     */
    public static FunctionDescriptor PyOS_mystricmp$descriptor() {
        return PyOS_mystricmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyOS_mystricmp(const char *, const char *)
     * }
     */
    public static MethodHandle PyOS_mystricmp$handle() {
        return PyOS_mystricmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyOS_mystricmp(const char *, const char *)
     * }
     */
    public static MemorySegment PyOS_mystricmp$address() {
        return PyOS_mystricmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyOS_mystricmp(const char *, const char *)
     * }
     */
    public static int PyOS_mystricmp(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyOS_mystricmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyOS_mystricmp", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_DecodeLocale {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_DecodeLocale");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *Py_DecodeLocale(const char *arg, size_t *size)
     * }
     */
    public static FunctionDescriptor Py_DecodeLocale$descriptor() {
        return Py_DecodeLocale.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *Py_DecodeLocale(const char *arg, size_t *size)
     * }
     */
    public static MethodHandle Py_DecodeLocale$handle() {
        return Py_DecodeLocale.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *Py_DecodeLocale(const char *arg, size_t *size)
     * }
     */
    public static MemorySegment Py_DecodeLocale$address() {
        return Py_DecodeLocale.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *Py_DecodeLocale(const char *arg, size_t *size)
     * }
     */
    public static MemorySegment Py_DecodeLocale(MemorySegment arg, MemorySegment size) {
        var mh$ = Py_DecodeLocale.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_DecodeLocale", arg, size);
            }
            return (MemorySegment)mh$.invokeExact(arg, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_EncodeLocale {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_EncodeLocale");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *Py_EncodeLocale(const wchar_t *text, size_t *error_pos)
     * }
     */
    public static FunctionDescriptor Py_EncodeLocale$descriptor() {
        return Py_EncodeLocale.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *Py_EncodeLocale(const wchar_t *text, size_t *error_pos)
     * }
     */
    public static MethodHandle Py_EncodeLocale$handle() {
        return Py_EncodeLocale.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *Py_EncodeLocale(const wchar_t *text, size_t *error_pos)
     * }
     */
    public static MemorySegment Py_EncodeLocale$address() {
        return Py_EncodeLocale.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *Py_EncodeLocale(const wchar_t *text, size_t *error_pos)
     * }
     */
    public static MemorySegment Py_EncodeLocale(MemorySegment text, MemorySegment error_pos) {
        var mh$ = Py_EncodeLocale.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_EncodeLocale", text, error_pos);
            }
            return (MemorySegment)mh$.invokeExact(text, error_pos);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _Py_fopen_obj {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_Py_fopen_obj");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FILE *_Py_fopen_obj(PyObject *path, const char *mode)
     * }
     */
    public static FunctionDescriptor _Py_fopen_obj$descriptor() {
        return _Py_fopen_obj.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FILE *_Py_fopen_obj(PyObject *path, const char *mode)
     * }
     */
    public static MethodHandle _Py_fopen_obj$handle() {
        return _Py_fopen_obj.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FILE *_Py_fopen_obj(PyObject *path, const char *mode)
     * }
     */
    public static MemorySegment _Py_fopen_obj$address() {
        return _Py_fopen_obj.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FILE *_Py_fopen_obj(PyObject *path, const char *mode)
     * }
     */
    public static MemorySegment _Py_fopen_obj(MemorySegment path, MemorySegment mode) {
        var mh$ = _Py_fopen_obj.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_Py_fopen_obj", path, mode);
            }
            return (MemorySegment)mh$.invokeExact(path, mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyTraceMalloc_Track {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_LONG_LONG,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyTraceMalloc_Track");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyTraceMalloc_Track(unsigned int domain, uintptr_t ptr, size_t size)
     * }
     */
    public static FunctionDescriptor PyTraceMalloc_Track$descriptor() {
        return PyTraceMalloc_Track.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyTraceMalloc_Track(unsigned int domain, uintptr_t ptr, size_t size)
     * }
     */
    public static MethodHandle PyTraceMalloc_Track$handle() {
        return PyTraceMalloc_Track.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyTraceMalloc_Track(unsigned int domain, uintptr_t ptr, size_t size)
     * }
     */
    public static MemorySegment PyTraceMalloc_Track$address() {
        return PyTraceMalloc_Track.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyTraceMalloc_Track(unsigned int domain, uintptr_t ptr, size_t size)
     * }
     */
    public static int PyTraceMalloc_Track(int domain, long ptr, long size) {
        var mh$ = PyTraceMalloc_Track.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyTraceMalloc_Track", domain, ptr, size);
            }
            return (int)mh$.invokeExact(domain, ptr, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyTraceMalloc_Untrack {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyTraceMalloc_Untrack");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyTraceMalloc_Untrack(unsigned int domain, uintptr_t ptr)
     * }
     */
    public static FunctionDescriptor PyTraceMalloc_Untrack$descriptor() {
        return PyTraceMalloc_Untrack.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyTraceMalloc_Untrack(unsigned int domain, uintptr_t ptr)
     * }
     */
    public static MethodHandle PyTraceMalloc_Untrack$handle() {
        return PyTraceMalloc_Untrack.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyTraceMalloc_Untrack(unsigned int domain, uintptr_t ptr)
     * }
     */
    public static MemorySegment PyTraceMalloc_Untrack$address() {
        return PyTraceMalloc_Untrack.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyTraceMalloc_Untrack(unsigned int domain, uintptr_t ptr)
     * }
     */
    public static int PyTraceMalloc_Untrack(int domain, long ptr) {
        var mh$ = PyTraceMalloc_Untrack.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyTraceMalloc_Untrack", domain, ptr);
            }
            return (int)mh$.invokeExact(domain, ptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyTraceMalloc_GetTraceback {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyTraceMalloc_GetTraceback");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *_PyTraceMalloc_GetTraceback(unsigned int domain, uintptr_t ptr)
     * }
     */
    public static FunctionDescriptor _PyTraceMalloc_GetTraceback$descriptor() {
        return _PyTraceMalloc_GetTraceback.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *_PyTraceMalloc_GetTraceback(unsigned int domain, uintptr_t ptr)
     * }
     */
    public static MethodHandle _PyTraceMalloc_GetTraceback$handle() {
        return _PyTraceMalloc_GetTraceback.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *_PyTraceMalloc_GetTraceback(unsigned int domain, uintptr_t ptr)
     * }
     */
    public static MemorySegment _PyTraceMalloc_GetTraceback$address() {
        return _PyTraceMalloc_GetTraceback.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *_PyTraceMalloc_GetTraceback(unsigned int domain, uintptr_t ptr)
     * }
     */
    public static MemorySegment _PyTraceMalloc_GetTraceback(int domain, long ptr) {
        var mh$ = _PyTraceMalloc_GetTraceback.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyTraceMalloc_GetTraceback", domain, ptr);
            }
            return (MemorySegment)mh$.invokeExact(domain, ptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyTraceMalloc_IsTracing {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyTraceMalloc_IsTracing");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyTraceMalloc_IsTracing()
     * }
     */
    public static FunctionDescriptor _PyTraceMalloc_IsTracing$descriptor() {
        return _PyTraceMalloc_IsTracing.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyTraceMalloc_IsTracing()
     * }
     */
    public static MethodHandle _PyTraceMalloc_IsTracing$handle() {
        return _PyTraceMalloc_IsTracing.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyTraceMalloc_IsTracing()
     * }
     */
    public static MemorySegment _PyTraceMalloc_IsTracing$address() {
        return _PyTraceMalloc_IsTracing.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyTraceMalloc_IsTracing()
     * }
     */
    public static int _PyTraceMalloc_IsTracing() {
        var mh$ = _PyTraceMalloc_IsTracing.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyTraceMalloc_IsTracing");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyTraceMalloc_ClearTraces {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyTraceMalloc_ClearTraces");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _PyTraceMalloc_ClearTraces()
     * }
     */
    public static FunctionDescriptor _PyTraceMalloc_ClearTraces$descriptor() {
        return _PyTraceMalloc_ClearTraces.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _PyTraceMalloc_ClearTraces()
     * }
     */
    public static MethodHandle _PyTraceMalloc_ClearTraces$handle() {
        return _PyTraceMalloc_ClearTraces.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _PyTraceMalloc_ClearTraces()
     * }
     */
    public static MemorySegment _PyTraceMalloc_ClearTraces$address() {
        return _PyTraceMalloc_ClearTraces.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _PyTraceMalloc_ClearTraces()
     * }
     */
    public static void _PyTraceMalloc_ClearTraces() {
        var mh$ = _PyTraceMalloc_ClearTraces.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyTraceMalloc_ClearTraces");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyTraceMalloc_GetTraces {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyTraceMalloc_GetTraces");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *_PyTraceMalloc_GetTraces()
     * }
     */
    public static FunctionDescriptor _PyTraceMalloc_GetTraces$descriptor() {
        return _PyTraceMalloc_GetTraces.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *_PyTraceMalloc_GetTraces()
     * }
     */
    public static MethodHandle _PyTraceMalloc_GetTraces$handle() {
        return _PyTraceMalloc_GetTraces.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *_PyTraceMalloc_GetTraces()
     * }
     */
    public static MemorySegment _PyTraceMalloc_GetTraces$address() {
        return _PyTraceMalloc_GetTraces.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *_PyTraceMalloc_GetTraces()
     * }
     */
    public static MemorySegment _PyTraceMalloc_GetTraces() {
        var mh$ = _PyTraceMalloc_GetTraces.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyTraceMalloc_GetTraces");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyTraceMalloc_GetObjectTraceback {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyTraceMalloc_GetObjectTraceback");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *_PyTraceMalloc_GetObjectTraceback(PyObject *obj)
     * }
     */
    public static FunctionDescriptor _PyTraceMalloc_GetObjectTraceback$descriptor() {
        return _PyTraceMalloc_GetObjectTraceback.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *_PyTraceMalloc_GetObjectTraceback(PyObject *obj)
     * }
     */
    public static MethodHandle _PyTraceMalloc_GetObjectTraceback$handle() {
        return _PyTraceMalloc_GetObjectTraceback.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *_PyTraceMalloc_GetObjectTraceback(PyObject *obj)
     * }
     */
    public static MemorySegment _PyTraceMalloc_GetObjectTraceback$address() {
        return _PyTraceMalloc_GetObjectTraceback.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *_PyTraceMalloc_GetObjectTraceback(PyObject *obj)
     * }
     */
    public static MemorySegment _PyTraceMalloc_GetObjectTraceback(MemorySegment obj) {
        var mh$ = _PyTraceMalloc_GetObjectTraceback.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyTraceMalloc_GetObjectTraceback", obj);
            }
            return (MemorySegment)mh$.invokeExact(obj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyTraceMalloc_Init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyTraceMalloc_Init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyTraceMalloc_Init()
     * }
     */
    public static FunctionDescriptor _PyTraceMalloc_Init$descriptor() {
        return _PyTraceMalloc_Init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyTraceMalloc_Init()
     * }
     */
    public static MethodHandle _PyTraceMalloc_Init$handle() {
        return _PyTraceMalloc_Init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyTraceMalloc_Init()
     * }
     */
    public static MemorySegment _PyTraceMalloc_Init$address() {
        return _PyTraceMalloc_Init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyTraceMalloc_Init()
     * }
     */
    public static int _PyTraceMalloc_Init() {
        var mh$ = _PyTraceMalloc_Init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyTraceMalloc_Init");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyTraceMalloc_Start {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyTraceMalloc_Start");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyTraceMalloc_Start(int max_nframe)
     * }
     */
    public static FunctionDescriptor _PyTraceMalloc_Start$descriptor() {
        return _PyTraceMalloc_Start.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyTraceMalloc_Start(int max_nframe)
     * }
     */
    public static MethodHandle _PyTraceMalloc_Start$handle() {
        return _PyTraceMalloc_Start.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyTraceMalloc_Start(int max_nframe)
     * }
     */
    public static MemorySegment _PyTraceMalloc_Start$address() {
        return _PyTraceMalloc_Start.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyTraceMalloc_Start(int max_nframe)
     * }
     */
    public static int _PyTraceMalloc_Start(int max_nframe) {
        var mh$ = _PyTraceMalloc_Start.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyTraceMalloc_Start", max_nframe);
            }
            return (int)mh$.invokeExact(max_nframe);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyTraceMalloc_Stop {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyTraceMalloc_Stop");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _PyTraceMalloc_Stop()
     * }
     */
    public static FunctionDescriptor _PyTraceMalloc_Stop$descriptor() {
        return _PyTraceMalloc_Stop.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _PyTraceMalloc_Stop()
     * }
     */
    public static MethodHandle _PyTraceMalloc_Stop$handle() {
        return _PyTraceMalloc_Stop.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _PyTraceMalloc_Stop()
     * }
     */
    public static MemorySegment _PyTraceMalloc_Stop$address() {
        return _PyTraceMalloc_Stop.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _PyTraceMalloc_Stop()
     * }
     */
    public static void _PyTraceMalloc_Stop() {
        var mh$ = _PyTraceMalloc_Stop.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyTraceMalloc_Stop");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyTraceMalloc_GetTracebackLimit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyTraceMalloc_GetTracebackLimit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyTraceMalloc_GetTracebackLimit()
     * }
     */
    public static FunctionDescriptor _PyTraceMalloc_GetTracebackLimit$descriptor() {
        return _PyTraceMalloc_GetTracebackLimit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyTraceMalloc_GetTracebackLimit()
     * }
     */
    public static MethodHandle _PyTraceMalloc_GetTracebackLimit$handle() {
        return _PyTraceMalloc_GetTracebackLimit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyTraceMalloc_GetTracebackLimit()
     * }
     */
    public static MemorySegment _PyTraceMalloc_GetTracebackLimit$address() {
        return _PyTraceMalloc_GetTracebackLimit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyTraceMalloc_GetTracebackLimit()
     * }
     */
    public static int _PyTraceMalloc_GetTracebackLimit() {
        var mh$ = _PyTraceMalloc_GetTracebackLimit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyTraceMalloc_GetTracebackLimit");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyTraceMalloc_GetMemory {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyTraceMalloc_GetMemory");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t _PyTraceMalloc_GetMemory()
     * }
     */
    public static FunctionDescriptor _PyTraceMalloc_GetMemory$descriptor() {
        return _PyTraceMalloc_GetMemory.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t _PyTraceMalloc_GetMemory()
     * }
     */
    public static MethodHandle _PyTraceMalloc_GetMemory$handle() {
        return _PyTraceMalloc_GetMemory.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t _PyTraceMalloc_GetMemory()
     * }
     */
    public static MemorySegment _PyTraceMalloc_GetMemory$address() {
        return _PyTraceMalloc_GetMemory.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t _PyTraceMalloc_GetMemory()
     * }
     */
    public static long _PyTraceMalloc_GetMemory() {
        var mh$ = _PyTraceMalloc_GetMemory.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyTraceMalloc_GetMemory");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyTraceMalloc_GetTracedMemory {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyTraceMalloc_GetTracedMemory");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *_PyTraceMalloc_GetTracedMemory()
     * }
     */
    public static FunctionDescriptor _PyTraceMalloc_GetTracedMemory$descriptor() {
        return _PyTraceMalloc_GetTracedMemory.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *_PyTraceMalloc_GetTracedMemory()
     * }
     */
    public static MethodHandle _PyTraceMalloc_GetTracedMemory$handle() {
        return _PyTraceMalloc_GetTracedMemory.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *_PyTraceMalloc_GetTracedMemory()
     * }
     */
    public static MemorySegment _PyTraceMalloc_GetTracedMemory$address() {
        return _PyTraceMalloc_GetTracedMemory.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *_PyTraceMalloc_GetTracedMemory()
     * }
     */
    public static MemorySegment _PyTraceMalloc_GetTracedMemory() {
        var mh$ = _PyTraceMalloc_GetTracedMemory.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyTraceMalloc_GetTracedMemory");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyTraceMalloc_ResetPeak {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyTraceMalloc_ResetPeak");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _PyTraceMalloc_ResetPeak()
     * }
     */
    public static FunctionDescriptor _PyTraceMalloc_ResetPeak$descriptor() {
        return _PyTraceMalloc_ResetPeak.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _PyTraceMalloc_ResetPeak()
     * }
     */
    public static MethodHandle _PyTraceMalloc_ResetPeak$handle() {
        return _PyTraceMalloc_ResetPeak.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _PyTraceMalloc_ResetPeak()
     * }
     */
    public static MemorySegment _PyTraceMalloc_ResetPeak$address() {
        return _PyTraceMalloc_ResetPeak.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _PyTraceMalloc_ResetPeak()
     * }
     */
    public static void _PyTraceMalloc_ResetPeak() {
        var mh$ = _PyTraceMalloc_ResetPeak.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyTraceMalloc_ResetPeak");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int PY_RELEASE_LEVEL = (int)15L;
    /**
     * {@snippet lang=c :
     * #define PY_RELEASE_LEVEL 15
     * }
     */
    public static int PY_RELEASE_LEVEL() {
        return PY_RELEASE_LEVEL;
    }
    /**
     * {@snippet lang=c :
     * #define PY_VERSION "3.12.1"
     * }
     */
    public static MemorySegment PY_VERSION() {
        class Holder {
            static final MemorySegment PY_VERSION
                = Python_h.LIBRARY_ARENA.allocateFrom("3.12.1");
        }
        return Holder.PY_VERSION;
    }
    private static final int PY_VERSION_HEX = (int)51118576L;
    /**
     * {@snippet lang=c :
     * #define PY_VERSION_HEX 51118576
     * }
     */
    public static int PY_VERSION_HEX() {
        return PY_VERSION_HEX;
    }
    private static final int _VCRUNTIME_DISABLED_WARNINGS = (int)4514L;
    /**
     * {@snippet lang=c :
     * #define _VCRUNTIME_DISABLED_WARNINGS 4514
     * }
     */
    public static int _VCRUNTIME_DISABLED_WARNINGS() {
        return _VCRUNTIME_DISABLED_WARNINGS;
    }
    private static final MemorySegment NULL = MemorySegment.ofAddress(0L);
    /**
     * {@snippet lang=c :
     * #define NULL (void*) 0
     * }
     */
    public static MemorySegment NULL() {
        return NULL;
    }
    private static final int _UCRT_DISABLED_WARNINGS = (int)4324L;
    /**
     * {@snippet lang=c :
     * #define _UCRT_DISABLED_WARNINGS 4324
     * }
     */
    public static int _UCRT_DISABLED_WARNINGS() {
        return _UCRT_DISABLED_WARNINGS;
    }
    private static final long _TRUNCATE = -1L;
    /**
     * {@snippet lang=c :
     * #define _TRUNCATE -1
     * }
     */
    public static long _TRUNCATE() {
        return _TRUNCATE;
    }
    private static final long _CRT_SIZE_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define _CRT_SIZE_MAX -1
     * }
     */
    public static long _CRT_SIZE_MAX() {
        return _CRT_SIZE_MAX;
    }
    /**
     * {@snippet lang=c :
     * #define __FILEW__ "C"
     * }
     */
    public static MemorySegment __FILEW__() {
        class Holder {
            static final MemorySegment __FILEW__
                = Python_h.LIBRARY_ARENA.allocateFrom("C");
        }
        return Holder.__FILEW__;
    }
    private static final int __STDC_SECURE_LIB__ = (int)200411L;
    /**
     * {@snippet lang=c :
     * #define __STDC_SECURE_LIB__ 200411
     * }
     */
    public static int __STDC_SECURE_LIB__() {
        return __STDC_SECURE_LIB__;
    }
    private static final int __GOT_SECURE_LIB__ = (int)200411L;
    /**
     * {@snippet lang=c :
     * #define __GOT_SECURE_LIB__ 200411
     * }
     */
    public static int __GOT_SECURE_LIB__() {
        return __GOT_SECURE_LIB__;
    }
    private static final int SH_DENYRW = (int)16L;
    /**
     * {@snippet lang=c :
     * #define SH_DENYRW 16
     * }
     */
    public static int SH_DENYRW() {
        return SH_DENYRW;
    }
    private static final int SH_DENYWR = (int)32L;
    /**
     * {@snippet lang=c :
     * #define SH_DENYWR 32
     * }
     */
    public static int SH_DENYWR() {
        return SH_DENYWR;
    }
    private static final int SH_DENYRD = (int)48L;
    /**
     * {@snippet lang=c :
     * #define SH_DENYRD 48
     * }
     */
    public static int SH_DENYRD() {
        return SH_DENYRD;
    }
    private static final int SH_DENYNO = (int)64L;
    /**
     * {@snippet lang=c :
     * #define SH_DENYNO 64
     * }
     */
    public static int SH_DENYNO() {
        return SH_DENYNO;
    }
    /**
     * {@snippet lang=c :
     * #define PYD_PLATFORM_TAG "win_amd64"
     * }
     */
    public static MemorySegment PYD_PLATFORM_TAG() {
        class Holder {
            static final MemorySegment PYD_PLATFORM_TAG
                = Python_h.LIBRARY_ARENA.allocateFrom("win_amd64");
        }
        return Holder.PYD_PLATFORM_TAG;
    }
    private static final long PY_SSIZE_T_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define PY_SSIZE_T_MAX 9223372036854775807
     * }
     */
    public static long PY_SSIZE_T_MAX() {
        return PY_SSIZE_T_MAX;
    }
    private static final long ADDRESS_TAG_BIT = 4398046511104L;
    /**
     * {@snippet lang=c :
     * #define ADDRESS_TAG_BIT 4398046511104
     * }
     */
    public static long ADDRESS_TAG_BIT() {
        return ADDRESS_TAG_BIT;
    }
    private static final long MAXUINT_PTR = -1L;
    /**
     * {@snippet lang=c :
     * #define MAXUINT_PTR -1
     * }
     */
    public static long MAXUINT_PTR() {
        return MAXUINT_PTR;
    }
    private static final long MAXINT_PTR = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define MAXINT_PTR 9223372036854775807
     * }
     */
    public static long MAXINT_PTR() {
        return MAXINT_PTR;
    }
    private static final long MININT_PTR = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define MININT_PTR -9223372036854775808
     * }
     */
    public static long MININT_PTR() {
        return MININT_PTR;
    }
    private static final long MAXULONG_PTR = -1L;
    /**
     * {@snippet lang=c :
     * #define MAXULONG_PTR -1
     * }
     */
    public static long MAXULONG_PTR() {
        return MAXULONG_PTR;
    }
    private static final long MAXLONG_PTR = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define MAXLONG_PTR 9223372036854775807
     * }
     */
    public static long MAXLONG_PTR() {
        return MAXLONG_PTR;
    }
    private static final long MINLONG_PTR = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define MINLONG_PTR -9223372036854775808
     * }
     */
    public static long MINLONG_PTR() {
        return MINLONG_PTR;
    }
    private static final int MAXUHALF_PTR = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define MAXUHALF_PTR 4294967295
     * }
     */
    public static int MAXUHALF_PTR() {
        return MAXUHALF_PTR;
    }
    private static final int MAXHALF_PTR = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define MAXHALF_PTR 2147483647
     * }
     */
    public static int MAXHALF_PTR() {
        return MAXHALF_PTR;
    }
    private static final int MINHALF_PTR = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define MINHALF_PTR -2147483648
     * }
     */
    public static int MINHALF_PTR() {
        return MINHALF_PTR;
    }
    /**
     * {@snippet lang=c :
     * #define _CRT_INTERNAL_STDIO_SYMBOL_PREFIX ""
     * }
     */
    public static MemorySegment _CRT_INTERNAL_STDIO_SYMBOL_PREFIX() {
        class Holder {
            static final MemorySegment _CRT_INTERNAL_STDIO_SYMBOL_PREFIX
                = Python_h.LIBRARY_ARENA.allocateFrom("");
        }
        return Holder._CRT_INTERNAL_STDIO_SYMBOL_PREFIX;
    }
    private static final long _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION = 1L;
    /**
     * {@snippet lang=c :
     * #define _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION 1
     * }
     */
    public static long _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION() {
        return _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION;
    }
    private static final long _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR = 2L;
    /**
     * {@snippet lang=c :
     * #define _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR 2
     * }
     */
    public static long _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR() {
        return _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR;
    }
    private static final long _CRT_INTERNAL_PRINTF_LEGACY_WIDE_SPECIFIERS = 4L;
    /**
     * {@snippet lang=c :
     * #define _CRT_INTERNAL_PRINTF_LEGACY_WIDE_SPECIFIERS 4
     * }
     */
    public static long _CRT_INTERNAL_PRINTF_LEGACY_WIDE_SPECIFIERS() {
        return _CRT_INTERNAL_PRINTF_LEGACY_WIDE_SPECIFIERS;
    }
    private static final long _CRT_INTERNAL_PRINTF_LEGACY_MSVCRT_COMPATIBILITY = 8L;
    /**
     * {@snippet lang=c :
     * #define _CRT_INTERNAL_PRINTF_LEGACY_MSVCRT_COMPATIBILITY 8
     * }
     */
    public static long _CRT_INTERNAL_PRINTF_LEGACY_MSVCRT_COMPATIBILITY() {
        return _CRT_INTERNAL_PRINTF_LEGACY_MSVCRT_COMPATIBILITY;
    }
    private static final long _CRT_INTERNAL_PRINTF_LEGACY_THREE_DIGIT_EXPONENTS = 16L;
    /**
     * {@snippet lang=c :
     * #define _CRT_INTERNAL_PRINTF_LEGACY_THREE_DIGIT_EXPONENTS 16
     * }
     */
    public static long _CRT_INTERNAL_PRINTF_LEGACY_THREE_DIGIT_EXPONENTS() {
        return _CRT_INTERNAL_PRINTF_LEGACY_THREE_DIGIT_EXPONENTS;
    }
    private static final long _CRT_INTERNAL_PRINTF_STANDARD_ROUNDING = 32L;
    /**
     * {@snippet lang=c :
     * #define _CRT_INTERNAL_PRINTF_STANDARD_ROUNDING 32
     * }
     */
    public static long _CRT_INTERNAL_PRINTF_STANDARD_ROUNDING() {
        return _CRT_INTERNAL_PRINTF_STANDARD_ROUNDING;
    }
    private static final long _CRT_INTERNAL_SCANF_SECURECRT = 1L;
    /**
     * {@snippet lang=c :
     * #define _CRT_INTERNAL_SCANF_SECURECRT 1
     * }
     */
    public static long _CRT_INTERNAL_SCANF_SECURECRT() {
        return _CRT_INTERNAL_SCANF_SECURECRT;
    }
    private static final long _CRT_INTERNAL_SCANF_LEGACY_WIDE_SPECIFIERS = 2L;
    /**
     * {@snippet lang=c :
     * #define _CRT_INTERNAL_SCANF_LEGACY_WIDE_SPECIFIERS 2
     * }
     */
    public static long _CRT_INTERNAL_SCANF_LEGACY_WIDE_SPECIFIERS() {
        return _CRT_INTERNAL_SCANF_LEGACY_WIDE_SPECIFIERS;
    }
    private static final long _CRT_INTERNAL_SCANF_LEGACY_MSVCRT_COMPATIBILITY = 4L;
    /**
     * {@snippet lang=c :
     * #define _CRT_INTERNAL_SCANF_LEGACY_MSVCRT_COMPATIBILITY 4
     * }
     */
    public static long _CRT_INTERNAL_SCANF_LEGACY_MSVCRT_COMPATIBILITY() {
        return _CRT_INTERNAL_SCANF_LEGACY_MSVCRT_COMPATIBILITY;
    }
    private static final short WEOF = (short)65535L;
    /**
     * {@snippet lang=c :
     * #define WEOF 65535
     * }
     */
    public static short WEOF() {
        return WEOF;
    }
    private static final int _NFILE = (int)512L;
    /**
     * {@snippet lang=c :
     * #define _NFILE 512
     * }
     */
    public static int _NFILE() {
        return _NFILE;
    }
    private static final int EOF = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define EOF -1
     * }
     */
    public static int EOF() {
        return EOF;
    }
    private static final int L_tmpnam_s = (int)260L;
    /**
     * {@snippet lang=c :
     * #define L_tmpnam_s 260
     * }
     */
    public static int L_tmpnam_s() {
        return L_tmpnam_s;
    }
    private static final int TMP_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define TMP_MAX 2147483647
     * }
     */
    public static int TMP_MAX() {
        return TMP_MAX;
    }
    private static final int TMP_MAX_S = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define TMP_MAX_S 2147483647
     * }
     */
    public static int TMP_MAX_S() {
        return TMP_MAX_S;
    }
    private static final int _TMP_MAX_S = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define _TMP_MAX_S 2147483647
     * }
     */
    public static int _TMP_MAX_S() {
        return _TMP_MAX_S;
    }
    private static final int SYS_OPEN = (int)20L;
    /**
     * {@snippet lang=c :
     * #define SYS_OPEN 20
     * }
     */
    public static int SYS_OPEN() {
        return SYS_OPEN;
    }
    private static final long PY_LLONG_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define PY_LLONG_MAX 9223372036854775807
     * }
     */
    public static long PY_LLONG_MAX() {
        return PY_LLONG_MAX;
    }
    private static final long PY_LLONG_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define PY_LLONG_MIN -9223372036854775808
     * }
     */
    public static long PY_LLONG_MIN() {
        return PY_LLONG_MIN;
    }
    private static final long PY_ULLONG_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define PY_ULLONG_MAX -1
     * }
     */
    public static long PY_ULLONG_MAX() {
        return PY_ULLONG_MAX;
    }
    /**
     * {@snippet lang=c :
     * #define PLATFORM "win32"
     * }
     */
    public static MemorySegment PLATFORM() {
        class Holder {
            static final MemorySegment PLATFORM
                = Python_h.LIBRARY_ARENA.allocateFrom("win32");
        }
        return Holder.PLATFORM;
    }
    private static final int SIZEOF_PID_T = (int)4L;
    /**
     * {@snippet lang=c :
     * #define SIZEOF_PID_T 4
     * }
     */
    public static int SIZEOF_PID_T() {
        return SIZEOF_PID_T;
    }
    /**
     * {@snippet lang=c :
     * #define _PYTHONFRAMEWORK ""
     * }
     */
    public static MemorySegment _PYTHONFRAMEWORK() {
        class Holder {
            static final MemorySegment _PYTHONFRAMEWORK
                = Python_h.LIBRARY_ARENA.allocateFrom("");
        }
        return Holder._PYTHONFRAMEWORK;
    }
    private static final int _MAX_ITOSTR_BASE16_COUNT = (int)9L;
    /**
     * {@snippet lang=c :
     * #define _MAX_ITOSTR_BASE16_COUNT 9
     * }
     */
    public static int _MAX_ITOSTR_BASE16_COUNT() {
        return _MAX_ITOSTR_BASE16_COUNT;
    }
    private static final int _MAX_ITOSTR_BASE10_COUNT = (int)12L;
    /**
     * {@snippet lang=c :
     * #define _MAX_ITOSTR_BASE10_COUNT 12
     * }
     */
    public static int _MAX_ITOSTR_BASE10_COUNT() {
        return _MAX_ITOSTR_BASE10_COUNT;
    }
    private static final int _MAX_ITOSTR_BASE8_COUNT = (int)12L;
    /**
     * {@snippet lang=c :
     * #define _MAX_ITOSTR_BASE8_COUNT 12
     * }
     */
    public static int _MAX_ITOSTR_BASE8_COUNT() {
        return _MAX_ITOSTR_BASE8_COUNT;
    }
    private static final int _MAX_ITOSTR_BASE2_COUNT = (int)33L;
    /**
     * {@snippet lang=c :
     * #define _MAX_ITOSTR_BASE2_COUNT 33
     * }
     */
    public static int _MAX_ITOSTR_BASE2_COUNT() {
        return _MAX_ITOSTR_BASE2_COUNT;
    }
    private static final int _MAX_LTOSTR_BASE16_COUNT = (int)9L;
    /**
     * {@snippet lang=c :
     * #define _MAX_LTOSTR_BASE16_COUNT 9
     * }
     */
    public static int _MAX_LTOSTR_BASE16_COUNT() {
        return _MAX_LTOSTR_BASE16_COUNT;
    }
    private static final int _MAX_LTOSTR_BASE10_COUNT = (int)12L;
    /**
     * {@snippet lang=c :
     * #define _MAX_LTOSTR_BASE10_COUNT 12
     * }
     */
    public static int _MAX_LTOSTR_BASE10_COUNT() {
        return _MAX_LTOSTR_BASE10_COUNT;
    }
    private static final int _MAX_LTOSTR_BASE8_COUNT = (int)12L;
    /**
     * {@snippet lang=c :
     * #define _MAX_LTOSTR_BASE8_COUNT 12
     * }
     */
    public static int _MAX_LTOSTR_BASE8_COUNT() {
        return _MAX_LTOSTR_BASE8_COUNT;
    }
    private static final int _MAX_LTOSTR_BASE2_COUNT = (int)33L;
    /**
     * {@snippet lang=c :
     * #define _MAX_LTOSTR_BASE2_COUNT 33
     * }
     */
    public static int _MAX_LTOSTR_BASE2_COUNT() {
        return _MAX_LTOSTR_BASE2_COUNT;
    }
    private static final int _MAX_ULTOSTR_BASE16_COUNT = (int)9L;
    /**
     * {@snippet lang=c :
     * #define _MAX_ULTOSTR_BASE16_COUNT 9
     * }
     */
    public static int _MAX_ULTOSTR_BASE16_COUNT() {
        return _MAX_ULTOSTR_BASE16_COUNT;
    }
    private static final int _MAX_ULTOSTR_BASE10_COUNT = (int)11L;
    /**
     * {@snippet lang=c :
     * #define _MAX_ULTOSTR_BASE10_COUNT 11
     * }
     */
    public static int _MAX_ULTOSTR_BASE10_COUNT() {
        return _MAX_ULTOSTR_BASE10_COUNT;
    }
    private static final int _MAX_ULTOSTR_BASE8_COUNT = (int)12L;
    /**
     * {@snippet lang=c :
     * #define _MAX_ULTOSTR_BASE8_COUNT 12
     * }
     */
    public static int _MAX_ULTOSTR_BASE8_COUNT() {
        return _MAX_ULTOSTR_BASE8_COUNT;
    }
    private static final int _MAX_ULTOSTR_BASE2_COUNT = (int)33L;
    /**
     * {@snippet lang=c :
     * #define _MAX_ULTOSTR_BASE2_COUNT 33
     * }
     */
    public static int _MAX_ULTOSTR_BASE2_COUNT() {
        return _MAX_ULTOSTR_BASE2_COUNT;
    }
    private static final int _MAX_I64TOSTR_BASE16_COUNT = (int)17L;
    /**
     * {@snippet lang=c :
     * #define _MAX_I64TOSTR_BASE16_COUNT 17
     * }
     */
    public static int _MAX_I64TOSTR_BASE16_COUNT() {
        return _MAX_I64TOSTR_BASE16_COUNT;
    }
    private static final int _MAX_I64TOSTR_BASE10_COUNT = (int)21L;
    /**
     * {@snippet lang=c :
     * #define _MAX_I64TOSTR_BASE10_COUNT 21
     * }
     */
    public static int _MAX_I64TOSTR_BASE10_COUNT() {
        return _MAX_I64TOSTR_BASE10_COUNT;
    }
    private static final int _MAX_I64TOSTR_BASE8_COUNT = (int)23L;
    /**
     * {@snippet lang=c :
     * #define _MAX_I64TOSTR_BASE8_COUNT 23
     * }
     */
    public static int _MAX_I64TOSTR_BASE8_COUNT() {
        return _MAX_I64TOSTR_BASE8_COUNT;
    }
    private static final int _MAX_I64TOSTR_BASE2_COUNT = (int)65L;
    /**
     * {@snippet lang=c :
     * #define _MAX_I64TOSTR_BASE2_COUNT 65
     * }
     */
    public static int _MAX_I64TOSTR_BASE2_COUNT() {
        return _MAX_I64TOSTR_BASE2_COUNT;
    }
    private static final int _MAX_U64TOSTR_BASE16_COUNT = (int)17L;
    /**
     * {@snippet lang=c :
     * #define _MAX_U64TOSTR_BASE16_COUNT 17
     * }
     */
    public static int _MAX_U64TOSTR_BASE16_COUNT() {
        return _MAX_U64TOSTR_BASE16_COUNT;
    }
    private static final int _MAX_U64TOSTR_BASE10_COUNT = (int)21L;
    /**
     * {@snippet lang=c :
     * #define _MAX_U64TOSTR_BASE10_COUNT 21
     * }
     */
    public static int _MAX_U64TOSTR_BASE10_COUNT() {
        return _MAX_U64TOSTR_BASE10_COUNT;
    }
    private static final int _MAX_U64TOSTR_BASE8_COUNT = (int)23L;
    /**
     * {@snippet lang=c :
     * #define _MAX_U64TOSTR_BASE8_COUNT 23
     * }
     */
    public static int _MAX_U64TOSTR_BASE8_COUNT() {
        return _MAX_U64TOSTR_BASE8_COUNT;
    }
    private static final int _MAX_U64TOSTR_BASE2_COUNT = (int)65L;
    /**
     * {@snippet lang=c :
     * #define _MAX_U64TOSTR_BASE2_COUNT 65
     * }
     */
    public static int _MAX_U64TOSTR_BASE2_COUNT() {
        return _MAX_U64TOSTR_BASE2_COUNT;
    }
    private static final int SCHAR_MIN = (int)-128L;
    /**
     * {@snippet lang=c :
     * #define SCHAR_MIN -128
     * }
     */
    public static int SCHAR_MIN() {
        return SCHAR_MIN;
    }
    private static final int CHAR_MIN = (int)-128L;
    /**
     * {@snippet lang=c :
     * #define CHAR_MIN -128
     * }
     */
    public static int CHAR_MIN() {
        return CHAR_MIN;
    }
    private static final int CHAR_MAX = (int)127L;
    /**
     * {@snippet lang=c :
     * #define CHAR_MAX 127
     * }
     */
    public static int CHAR_MAX() {
        return CHAR_MAX;
    }
    private static final int SHRT_MIN = (int)-32768L;
    /**
     * {@snippet lang=c :
     * #define SHRT_MIN -32768
     * }
     */
    public static int SHRT_MIN() {
        return SHRT_MIN;
    }
    private static final int INT_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define INT_MIN -2147483648
     * }
     */
    public static int INT_MIN() {
        return INT_MIN;
    }
    private static final int UINT_MAX = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define UINT_MAX 4294967295
     * }
     */
    public static int UINT_MAX() {
        return UINT_MAX;
    }
    private static final int LONG_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define LONG_MIN -2147483648
     * }
     */
    public static int LONG_MIN() {
        return LONG_MIN;
    }
    private static final int LONG_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define LONG_MAX 2147483647
     * }
     */
    public static int LONG_MAX() {
        return LONG_MAX;
    }
    private static final int ULONG_MAX = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define ULONG_MAX 4294967295
     * }
     */
    public static int ULONG_MAX() {
        return ULONG_MAX;
    }
    private static final long LLONG_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define LLONG_MAX 9223372036854775807
     * }
     */
    public static long LLONG_MAX() {
        return LLONG_MAX;
    }
    private static final long LLONG_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define LLONG_MIN -9223372036854775808
     * }
     */
    public static long LLONG_MIN() {
        return LLONG_MIN;
    }
    private static final long ULLONG_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define ULLONG_MAX -1
     * }
     */
    public static long ULLONG_MAX() {
        return ULLONG_MAX;
    }
    private static final int _I8_MIN = (int)-128L;
    /**
     * {@snippet lang=c :
     * #define _I8_MIN -128
     * }
     */
    public static int _I8_MIN() {
        return _I8_MIN;
    }
    private static final byte _I8_MAX = (byte)127L;
    /**
     * {@snippet lang=c :
     * #define _I8_MAX 127
     * }
     */
    public static byte _I8_MAX() {
        return _I8_MAX;
    }
    private static final byte _UI8_MAX = (byte)255L;
    /**
     * {@snippet lang=c :
     * #define _UI8_MAX 255
     * }
     */
    public static byte _UI8_MAX() {
        return _UI8_MAX;
    }
    private static final int _I16_MIN = (int)-32768L;
    /**
     * {@snippet lang=c :
     * #define _I16_MIN -32768
     * }
     */
    public static int _I16_MIN() {
        return _I16_MIN;
    }
    private static final short _I16_MAX = (short)32767L;
    /**
     * {@snippet lang=c :
     * #define _I16_MAX 32767
     * }
     */
    public static short _I16_MAX() {
        return _I16_MAX;
    }
    private static final short _UI16_MAX = (short)65535L;
    /**
     * {@snippet lang=c :
     * #define _UI16_MAX 65535
     * }
     */
    public static short _UI16_MAX() {
        return _UI16_MAX;
    }
    private static final int _I32_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define _I32_MIN -2147483648
     * }
     */
    public static int _I32_MIN() {
        return _I32_MIN;
    }
    private static final int _I32_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define _I32_MAX 2147483647
     * }
     */
    public static int _I32_MAX() {
        return _I32_MAX;
    }
    private static final int _UI32_MAX = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define _UI32_MAX 4294967295
     * }
     */
    public static int _UI32_MAX() {
        return _UI32_MAX;
    }
    private static final long _I64_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define _I64_MIN -9223372036854775808
     * }
     */
    public static long _I64_MIN() {
        return _I64_MIN;
    }
    private static final long _I64_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define _I64_MAX 9223372036854775807
     * }
     */
    public static long _I64_MAX() {
        return _I64_MAX;
    }
    private static final long _UI64_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define _UI64_MAX -1
     * }
     */
    public static long _UI64_MAX() {
        return _UI64_MAX;
    }
    private static final long SIZE_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define SIZE_MAX -1
     * }
     */
    public static long SIZE_MAX() {
        return SIZE_MAX;
    }
    private static final long RSIZE_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define RSIZE_MAX 9223372036854775807
     * }
     */
    public static long RSIZE_MAX() {
        return RSIZE_MAX;
    }
    private static final long LONG_LONG_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define LONG_LONG_MAX 9223372036854775807
     * }
     */
    public static long LONG_LONG_MAX() {
        return LONG_LONG_MAX;
    }
    private static final long LONG_LONG_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define LONG_LONG_MIN -9223372036854775808
     * }
     */
    public static long LONG_LONG_MIN() {
        return LONG_LONG_MIN;
    }
    private static final long ULONG_LONG_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define ULONG_LONG_MAX -1
     * }
     */
    public static long ULONG_LONG_MAX() {
        return ULONG_LONG_MAX;
    }
    private static final int _CVTBUFSIZE = (int)349L;
    /**
     * {@snippet lang=c :
     * #define _CVTBUFSIZE 349
     * }
     */
    public static int _CVTBUFSIZE() {
        return _CVTBUFSIZE;
    }
    private static final int EDEADLOCK = (int)36L;
    /**
     * {@snippet lang=c :
     * #define EDEADLOCK 36
     * }
     */
    public static int EDEADLOCK() {
        return EDEADLOCK;
    }
    private static final int _NLSCMPERROR = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define _NLSCMPERROR 2147483647
     * }
     */
    public static int _NLSCMPERROR() {
        return _NLSCMPERROR;
    }
    private static final int _ALPHA = (int)259L;
    /**
     * {@snippet lang=c :
     * #define _ALPHA 259
     * }
     */
    public static int _ALPHA() {
        return _ALPHA;
    }
    private static final int S_IFMT = (int)61440L;
    /**
     * {@snippet lang=c :
     * #define S_IFMT 61440
     * }
     */
    public static int S_IFMT() {
        return S_IFMT;
    }
    private static final int S_IFDIR = (int)16384L;
    /**
     * {@snippet lang=c :
     * #define S_IFDIR 16384
     * }
     */
    public static int S_IFDIR() {
        return S_IFDIR;
    }
    private static final int S_IFCHR = (int)8192L;
    /**
     * {@snippet lang=c :
     * #define S_IFCHR 8192
     * }
     */
    public static int S_IFCHR() {
        return S_IFCHR;
    }
    private static final int S_IFREG = (int)32768L;
    /**
     * {@snippet lang=c :
     * #define S_IFREG 32768
     * }
     */
    public static int S_IFREG() {
        return S_IFREG;
    }
    private static final int S_IREAD = (int)256L;
    /**
     * {@snippet lang=c :
     * #define S_IREAD 256
     * }
     */
    public static int S_IREAD() {
        return S_IREAD;
    }
    private static final int S_IWRITE = (int)128L;
    /**
     * {@snippet lang=c :
     * #define S_IWRITE 128
     * }
     */
    public static int S_IWRITE() {
        return S_IWRITE;
    }
    private static final int S_IEXEC = (int)64L;
    /**
     * {@snippet lang=c :
     * #define S_IEXEC 64
     * }
     */
    public static int S_IEXEC() {
        return S_IEXEC;
    }
    private static final int INT8_MIN = (int)-128L;
    /**
     * {@snippet lang=c :
     * #define INT8_MIN -128
     * }
     */
    public static int INT8_MIN() {
        return INT8_MIN;
    }
    private static final int INT16_MIN = (int)-32768L;
    /**
     * {@snippet lang=c :
     * #define INT16_MIN -32768
     * }
     */
    public static int INT16_MIN() {
        return INT16_MIN;
    }
    private static final int INT32_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define INT32_MIN -2147483648
     * }
     */
    public static int INT32_MIN() {
        return INT32_MIN;
    }
    private static final long INT64_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INT64_MIN -9223372036854775808
     * }
     */
    public static long INT64_MIN() {
        return INT64_MIN;
    }
    private static final byte INT8_MAX = (byte)127L;
    /**
     * {@snippet lang=c :
     * #define INT8_MAX 127
     * }
     */
    public static byte INT8_MAX() {
        return INT8_MAX;
    }
    private static final short INT16_MAX = (short)32767L;
    /**
     * {@snippet lang=c :
     * #define INT16_MAX 32767
     * }
     */
    public static short INT16_MAX() {
        return INT16_MAX;
    }
    private static final int INT32_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define INT32_MAX 2147483647
     * }
     */
    public static int INT32_MAX() {
        return INT32_MAX;
    }
    private static final long INT64_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INT64_MAX 9223372036854775807
     * }
     */
    public static long INT64_MAX() {
        return INT64_MAX;
    }
    private static final byte UINT8_MAX = (byte)255L;
    /**
     * {@snippet lang=c :
     * #define UINT8_MAX 255
     * }
     */
    public static byte UINT8_MAX() {
        return UINT8_MAX;
    }
    private static final short UINT16_MAX = (short)65535L;
    /**
     * {@snippet lang=c :
     * #define UINT16_MAX 65535
     * }
     */
    public static short UINT16_MAX() {
        return UINT16_MAX;
    }
    private static final int UINT32_MAX = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define UINT32_MAX 4294967295
     * }
     */
    public static int UINT32_MAX() {
        return UINT32_MAX;
    }
    private static final long UINT64_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINT64_MAX -1
     * }
     */
    public static long UINT64_MAX() {
        return UINT64_MAX;
    }
    private static final int INT_LEAST8_MIN = (int)-128L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST8_MIN -128
     * }
     */
    public static int INT_LEAST8_MIN() {
        return INT_LEAST8_MIN;
    }
    private static final int INT_LEAST16_MIN = (int)-32768L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST16_MIN -32768
     * }
     */
    public static int INT_LEAST16_MIN() {
        return INT_LEAST16_MIN;
    }
    private static final int INT_LEAST32_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST32_MIN -2147483648
     * }
     */
    public static int INT_LEAST32_MIN() {
        return INT_LEAST32_MIN;
    }
    private static final long INT_LEAST64_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST64_MIN -9223372036854775808
     * }
     */
    public static long INT_LEAST64_MIN() {
        return INT_LEAST64_MIN;
    }
    private static final byte INT_LEAST8_MAX = (byte)127L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST8_MAX 127
     * }
     */
    public static byte INT_LEAST8_MAX() {
        return INT_LEAST8_MAX;
    }
    private static final short INT_LEAST16_MAX = (short)32767L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST16_MAX 32767
     * }
     */
    public static short INT_LEAST16_MAX() {
        return INT_LEAST16_MAX;
    }
    private static final int INT_LEAST32_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST32_MAX 2147483647
     * }
     */
    public static int INT_LEAST32_MAX() {
        return INT_LEAST32_MAX;
    }
    private static final long INT_LEAST64_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST64_MAX 9223372036854775807
     * }
     */
    public static long INT_LEAST64_MAX() {
        return INT_LEAST64_MAX;
    }
    private static final byte UINT_LEAST8_MAX = (byte)255L;
    /**
     * {@snippet lang=c :
     * #define UINT_LEAST8_MAX 255
     * }
     */
    public static byte UINT_LEAST8_MAX() {
        return UINT_LEAST8_MAX;
    }
    private static final short UINT_LEAST16_MAX = (short)65535L;
    /**
     * {@snippet lang=c :
     * #define UINT_LEAST16_MAX 65535
     * }
     */
    public static short UINT_LEAST16_MAX() {
        return UINT_LEAST16_MAX;
    }
    private static final int UINT_LEAST32_MAX = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define UINT_LEAST32_MAX 4294967295
     * }
     */
    public static int UINT_LEAST32_MAX() {
        return UINT_LEAST32_MAX;
    }
    private static final long UINT_LEAST64_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINT_LEAST64_MAX -1
     * }
     */
    public static long UINT_LEAST64_MAX() {
        return UINT_LEAST64_MAX;
    }
    private static final int INT_FAST8_MIN = (int)-128L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST8_MIN -128
     * }
     */
    public static int INT_FAST8_MIN() {
        return INT_FAST8_MIN;
    }
    private static final int INT_FAST16_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST16_MIN -2147483648
     * }
     */
    public static int INT_FAST16_MIN() {
        return INT_FAST16_MIN;
    }
    private static final int INT_FAST32_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST32_MIN -2147483648
     * }
     */
    public static int INT_FAST32_MIN() {
        return INT_FAST32_MIN;
    }
    private static final long INT_FAST64_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST64_MIN -9223372036854775808
     * }
     */
    public static long INT_FAST64_MIN() {
        return INT_FAST64_MIN;
    }
    private static final byte INT_FAST8_MAX = (byte)127L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST8_MAX 127
     * }
     */
    public static byte INT_FAST8_MAX() {
        return INT_FAST8_MAX;
    }
    private static final int INT_FAST16_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST16_MAX 2147483647
     * }
     */
    public static int INT_FAST16_MAX() {
        return INT_FAST16_MAX;
    }
    private static final int INT_FAST32_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST32_MAX 2147483647
     * }
     */
    public static int INT_FAST32_MAX() {
        return INT_FAST32_MAX;
    }
    private static final long INT_FAST64_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST64_MAX 9223372036854775807
     * }
     */
    public static long INT_FAST64_MAX() {
        return INT_FAST64_MAX;
    }
    private static final byte UINT_FAST8_MAX = (byte)255L;
    /**
     * {@snippet lang=c :
     * #define UINT_FAST8_MAX 255
     * }
     */
    public static byte UINT_FAST8_MAX() {
        return UINT_FAST8_MAX;
    }
    private static final int UINT_FAST16_MAX = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define UINT_FAST16_MAX 4294967295
     * }
     */
    public static int UINT_FAST16_MAX() {
        return UINT_FAST16_MAX;
    }
    private static final int UINT_FAST32_MAX = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define UINT_FAST32_MAX 4294967295
     * }
     */
    public static int UINT_FAST32_MAX() {
        return UINT_FAST32_MAX;
    }
    private static final long UINT_FAST64_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINT_FAST64_MAX -1
     * }
     */
    public static long UINT_FAST64_MAX() {
        return UINT_FAST64_MAX;
    }
    private static final long INTPTR_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INTPTR_MIN -9223372036854775808
     * }
     */
    public static long INTPTR_MIN() {
        return INTPTR_MIN;
    }
    private static final long INTPTR_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INTPTR_MAX 9223372036854775807
     * }
     */
    public static long INTPTR_MAX() {
        return INTPTR_MAX;
    }
    private static final long UINTPTR_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINTPTR_MAX -1
     * }
     */
    public static long UINTPTR_MAX() {
        return UINTPTR_MAX;
    }
    private static final long INTMAX_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INTMAX_MIN -9223372036854775808
     * }
     */
    public static long INTMAX_MIN() {
        return INTMAX_MIN;
    }
    private static final long INTMAX_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INTMAX_MAX 9223372036854775807
     * }
     */
    public static long INTMAX_MAX() {
        return INTMAX_MAX;
    }
    private static final long UINTMAX_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINTMAX_MAX -1
     * }
     */
    public static long UINTMAX_MAX() {
        return UINTMAX_MAX;
    }
    private static final long PTRDIFF_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define PTRDIFF_MIN -9223372036854775808
     * }
     */
    public static long PTRDIFF_MIN() {
        return PTRDIFF_MIN;
    }
    private static final long PTRDIFF_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define PTRDIFF_MAX 9223372036854775807
     * }
     */
    public static long PTRDIFF_MAX() {
        return PTRDIFF_MAX;
    }
    private static final int SIG_ATOMIC_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define SIG_ATOMIC_MIN -2147483648
     * }
     */
    public static int SIG_ATOMIC_MIN() {
        return SIG_ATOMIC_MIN;
    }
    private static final int SIG_ATOMIC_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define SIG_ATOMIC_MAX 2147483647
     * }
     */
    public static int SIG_ATOMIC_MAX() {
        return SIG_ATOMIC_MAX;
    }
    /**
     * {@snippet lang=c :
     * #define PRId8 "hhd"
     * }
     */
    public static MemorySegment PRId8() {
        class Holder {
            static final MemorySegment PRId8
                = Python_h.LIBRARY_ARENA.allocateFrom("hhd");
        }
        return Holder.PRId8;
    }
    /**
     * {@snippet lang=c :
     * #define PRId16 "hd"
     * }
     */
    public static MemorySegment PRId16() {
        class Holder {
            static final MemorySegment PRId16
                = Python_h.LIBRARY_ARENA.allocateFrom("hd");
        }
        return Holder.PRId16;
    }
    /**
     * {@snippet lang=c :
     * #define PRId32 "d"
     * }
     */
    public static MemorySegment PRId32() {
        class Holder {
            static final MemorySegment PRId32
                = Python_h.LIBRARY_ARENA.allocateFrom("d");
        }
        return Holder.PRId32;
    }
    /**
     * {@snippet lang=c :
     * #define PRId64 "lld"
     * }
     */
    public static MemorySegment PRId64() {
        class Holder {
            static final MemorySegment PRId64
                = Python_h.LIBRARY_ARENA.allocateFrom("lld");
        }
        return Holder.PRId64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIdLEAST8 "hhd"
     * }
     */
    public static MemorySegment PRIdLEAST8() {
        class Holder {
            static final MemorySegment PRIdLEAST8
                = Python_h.LIBRARY_ARENA.allocateFrom("hhd");
        }
        return Holder.PRIdLEAST8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIdLEAST16 "hd"
     * }
     */
    public static MemorySegment PRIdLEAST16() {
        class Holder {
            static final MemorySegment PRIdLEAST16
                = Python_h.LIBRARY_ARENA.allocateFrom("hd");
        }
        return Holder.PRIdLEAST16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIdLEAST32 "d"
     * }
     */
    public static MemorySegment PRIdLEAST32() {
        class Holder {
            static final MemorySegment PRIdLEAST32
                = Python_h.LIBRARY_ARENA.allocateFrom("d");
        }
        return Holder.PRIdLEAST32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIdLEAST64 "lld"
     * }
     */
    public static MemorySegment PRIdLEAST64() {
        class Holder {
            static final MemorySegment PRIdLEAST64
                = Python_h.LIBRARY_ARENA.allocateFrom("lld");
        }
        return Holder.PRIdLEAST64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIdFAST8 "hhd"
     * }
     */
    public static MemorySegment PRIdFAST8() {
        class Holder {
            static final MemorySegment PRIdFAST8
                = Python_h.LIBRARY_ARENA.allocateFrom("hhd");
        }
        return Holder.PRIdFAST8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIdFAST16 "d"
     * }
     */
    public static MemorySegment PRIdFAST16() {
        class Holder {
            static final MemorySegment PRIdFAST16
                = Python_h.LIBRARY_ARENA.allocateFrom("d");
        }
        return Holder.PRIdFAST16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIdFAST32 "d"
     * }
     */
    public static MemorySegment PRIdFAST32() {
        class Holder {
            static final MemorySegment PRIdFAST32
                = Python_h.LIBRARY_ARENA.allocateFrom("d");
        }
        return Holder.PRIdFAST32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIdFAST64 "lld"
     * }
     */
    public static MemorySegment PRIdFAST64() {
        class Holder {
            static final MemorySegment PRIdFAST64
                = Python_h.LIBRARY_ARENA.allocateFrom("lld");
        }
        return Holder.PRIdFAST64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIdMAX "lld"
     * }
     */
    public static MemorySegment PRIdMAX() {
        class Holder {
            static final MemorySegment PRIdMAX
                = Python_h.LIBRARY_ARENA.allocateFrom("lld");
        }
        return Holder.PRIdMAX;
    }
    /**
     * {@snippet lang=c :
     * #define PRIdPTR "lld"
     * }
     */
    public static MemorySegment PRIdPTR() {
        class Holder {
            static final MemorySegment PRIdPTR
                = Python_h.LIBRARY_ARENA.allocateFrom("lld");
        }
        return Holder.PRIdPTR;
    }
    /**
     * {@snippet lang=c :
     * #define PRIi8 "hhi"
     * }
     */
    public static MemorySegment PRIi8() {
        class Holder {
            static final MemorySegment PRIi8
                = Python_h.LIBRARY_ARENA.allocateFrom("hhi");
        }
        return Holder.PRIi8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIi16 "hi"
     * }
     */
    public static MemorySegment PRIi16() {
        class Holder {
            static final MemorySegment PRIi16
                = Python_h.LIBRARY_ARENA.allocateFrom("hi");
        }
        return Holder.PRIi16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIi32 "i"
     * }
     */
    public static MemorySegment PRIi32() {
        class Holder {
            static final MemorySegment PRIi32
                = Python_h.LIBRARY_ARENA.allocateFrom("i");
        }
        return Holder.PRIi32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIi64 "lli"
     * }
     */
    public static MemorySegment PRIi64() {
        class Holder {
            static final MemorySegment PRIi64
                = Python_h.LIBRARY_ARENA.allocateFrom("lli");
        }
        return Holder.PRIi64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIiLEAST8 "hhi"
     * }
     */
    public static MemorySegment PRIiLEAST8() {
        class Holder {
            static final MemorySegment PRIiLEAST8
                = Python_h.LIBRARY_ARENA.allocateFrom("hhi");
        }
        return Holder.PRIiLEAST8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIiLEAST16 "hi"
     * }
     */
    public static MemorySegment PRIiLEAST16() {
        class Holder {
            static final MemorySegment PRIiLEAST16
                = Python_h.LIBRARY_ARENA.allocateFrom("hi");
        }
        return Holder.PRIiLEAST16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIiLEAST32 "i"
     * }
     */
    public static MemorySegment PRIiLEAST32() {
        class Holder {
            static final MemorySegment PRIiLEAST32
                = Python_h.LIBRARY_ARENA.allocateFrom("i");
        }
        return Holder.PRIiLEAST32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIiLEAST64 "lli"
     * }
     */
    public static MemorySegment PRIiLEAST64() {
        class Holder {
            static final MemorySegment PRIiLEAST64
                = Python_h.LIBRARY_ARENA.allocateFrom("lli");
        }
        return Holder.PRIiLEAST64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIiFAST8 "hhi"
     * }
     */
    public static MemorySegment PRIiFAST8() {
        class Holder {
            static final MemorySegment PRIiFAST8
                = Python_h.LIBRARY_ARENA.allocateFrom("hhi");
        }
        return Holder.PRIiFAST8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIiFAST16 "i"
     * }
     */
    public static MemorySegment PRIiFAST16() {
        class Holder {
            static final MemorySegment PRIiFAST16
                = Python_h.LIBRARY_ARENA.allocateFrom("i");
        }
        return Holder.PRIiFAST16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIiFAST32 "i"
     * }
     */
    public static MemorySegment PRIiFAST32() {
        class Holder {
            static final MemorySegment PRIiFAST32
                = Python_h.LIBRARY_ARENA.allocateFrom("i");
        }
        return Holder.PRIiFAST32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIiFAST64 "lli"
     * }
     */
    public static MemorySegment PRIiFAST64() {
        class Holder {
            static final MemorySegment PRIiFAST64
                = Python_h.LIBRARY_ARENA.allocateFrom("lli");
        }
        return Holder.PRIiFAST64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIiMAX "lli"
     * }
     */
    public static MemorySegment PRIiMAX() {
        class Holder {
            static final MemorySegment PRIiMAX
                = Python_h.LIBRARY_ARENA.allocateFrom("lli");
        }
        return Holder.PRIiMAX;
    }
    /**
     * {@snippet lang=c :
     * #define PRIiPTR "lli"
     * }
     */
    public static MemorySegment PRIiPTR() {
        class Holder {
            static final MemorySegment PRIiPTR
                = Python_h.LIBRARY_ARENA.allocateFrom("lli");
        }
        return Holder.PRIiPTR;
    }
    /**
     * {@snippet lang=c :
     * #define PRIo8 "hho"
     * }
     */
    public static MemorySegment PRIo8() {
        class Holder {
            static final MemorySegment PRIo8
                = Python_h.LIBRARY_ARENA.allocateFrom("hho");
        }
        return Holder.PRIo8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIo16 "ho"
     * }
     */
    public static MemorySegment PRIo16() {
        class Holder {
            static final MemorySegment PRIo16
                = Python_h.LIBRARY_ARENA.allocateFrom("ho");
        }
        return Holder.PRIo16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIo32 "o"
     * }
     */
    public static MemorySegment PRIo32() {
        class Holder {
            static final MemorySegment PRIo32
                = Python_h.LIBRARY_ARENA.allocateFrom("o");
        }
        return Holder.PRIo32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIo64 "llo"
     * }
     */
    public static MemorySegment PRIo64() {
        class Holder {
            static final MemorySegment PRIo64
                = Python_h.LIBRARY_ARENA.allocateFrom("llo");
        }
        return Holder.PRIo64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIoLEAST8 "hho"
     * }
     */
    public static MemorySegment PRIoLEAST8() {
        class Holder {
            static final MemorySegment PRIoLEAST8
                = Python_h.LIBRARY_ARENA.allocateFrom("hho");
        }
        return Holder.PRIoLEAST8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIoLEAST16 "ho"
     * }
     */
    public static MemorySegment PRIoLEAST16() {
        class Holder {
            static final MemorySegment PRIoLEAST16
                = Python_h.LIBRARY_ARENA.allocateFrom("ho");
        }
        return Holder.PRIoLEAST16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIoLEAST32 "o"
     * }
     */
    public static MemorySegment PRIoLEAST32() {
        class Holder {
            static final MemorySegment PRIoLEAST32
                = Python_h.LIBRARY_ARENA.allocateFrom("o");
        }
        return Holder.PRIoLEAST32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIoLEAST64 "llo"
     * }
     */
    public static MemorySegment PRIoLEAST64() {
        class Holder {
            static final MemorySegment PRIoLEAST64
                = Python_h.LIBRARY_ARENA.allocateFrom("llo");
        }
        return Holder.PRIoLEAST64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIoFAST8 "hho"
     * }
     */
    public static MemorySegment PRIoFAST8() {
        class Holder {
            static final MemorySegment PRIoFAST8
                = Python_h.LIBRARY_ARENA.allocateFrom("hho");
        }
        return Holder.PRIoFAST8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIoFAST16 "o"
     * }
     */
    public static MemorySegment PRIoFAST16() {
        class Holder {
            static final MemorySegment PRIoFAST16
                = Python_h.LIBRARY_ARENA.allocateFrom("o");
        }
        return Holder.PRIoFAST16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIoFAST32 "o"
     * }
     */
    public static MemorySegment PRIoFAST32() {
        class Holder {
            static final MemorySegment PRIoFAST32
                = Python_h.LIBRARY_ARENA.allocateFrom("o");
        }
        return Holder.PRIoFAST32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIoFAST64 "llo"
     * }
     */
    public static MemorySegment PRIoFAST64() {
        class Holder {
            static final MemorySegment PRIoFAST64
                = Python_h.LIBRARY_ARENA.allocateFrom("llo");
        }
        return Holder.PRIoFAST64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIoMAX "llo"
     * }
     */
    public static MemorySegment PRIoMAX() {
        class Holder {
            static final MemorySegment PRIoMAX
                = Python_h.LIBRARY_ARENA.allocateFrom("llo");
        }
        return Holder.PRIoMAX;
    }
    /**
     * {@snippet lang=c :
     * #define PRIoPTR "llo"
     * }
     */
    public static MemorySegment PRIoPTR() {
        class Holder {
            static final MemorySegment PRIoPTR
                = Python_h.LIBRARY_ARENA.allocateFrom("llo");
        }
        return Holder.PRIoPTR;
    }
    /**
     * {@snippet lang=c :
     * #define PRIu8 "hhu"
     * }
     */
    public static MemorySegment PRIu8() {
        class Holder {
            static final MemorySegment PRIu8
                = Python_h.LIBRARY_ARENA.allocateFrom("hhu");
        }
        return Holder.PRIu8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIu16 "hu"
     * }
     */
    public static MemorySegment PRIu16() {
        class Holder {
            static final MemorySegment PRIu16
                = Python_h.LIBRARY_ARENA.allocateFrom("hu");
        }
        return Holder.PRIu16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIu32 "u"
     * }
     */
    public static MemorySegment PRIu32() {
        class Holder {
            static final MemorySegment PRIu32
                = Python_h.LIBRARY_ARENA.allocateFrom("u");
        }
        return Holder.PRIu32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIu64 "llu"
     * }
     */
    public static MemorySegment PRIu64() {
        class Holder {
            static final MemorySegment PRIu64
                = Python_h.LIBRARY_ARENA.allocateFrom("llu");
        }
        return Holder.PRIu64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIuLEAST8 "hhu"
     * }
     */
    public static MemorySegment PRIuLEAST8() {
        class Holder {
            static final MemorySegment PRIuLEAST8
                = Python_h.LIBRARY_ARENA.allocateFrom("hhu");
        }
        return Holder.PRIuLEAST8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIuLEAST16 "hu"
     * }
     */
    public static MemorySegment PRIuLEAST16() {
        class Holder {
            static final MemorySegment PRIuLEAST16
                = Python_h.LIBRARY_ARENA.allocateFrom("hu");
        }
        return Holder.PRIuLEAST16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIuLEAST32 "u"
     * }
     */
    public static MemorySegment PRIuLEAST32() {
        class Holder {
            static final MemorySegment PRIuLEAST32
                = Python_h.LIBRARY_ARENA.allocateFrom("u");
        }
        return Holder.PRIuLEAST32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIuLEAST64 "llu"
     * }
     */
    public static MemorySegment PRIuLEAST64() {
        class Holder {
            static final MemorySegment PRIuLEAST64
                = Python_h.LIBRARY_ARENA.allocateFrom("llu");
        }
        return Holder.PRIuLEAST64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIuFAST8 "hhu"
     * }
     */
    public static MemorySegment PRIuFAST8() {
        class Holder {
            static final MemorySegment PRIuFAST8
                = Python_h.LIBRARY_ARENA.allocateFrom("hhu");
        }
        return Holder.PRIuFAST8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIuFAST16 "u"
     * }
     */
    public static MemorySegment PRIuFAST16() {
        class Holder {
            static final MemorySegment PRIuFAST16
                = Python_h.LIBRARY_ARENA.allocateFrom("u");
        }
        return Holder.PRIuFAST16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIuFAST32 "u"
     * }
     */
    public static MemorySegment PRIuFAST32() {
        class Holder {
            static final MemorySegment PRIuFAST32
                = Python_h.LIBRARY_ARENA.allocateFrom("u");
        }
        return Holder.PRIuFAST32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIuFAST64 "llu"
     * }
     */
    public static MemorySegment PRIuFAST64() {
        class Holder {
            static final MemorySegment PRIuFAST64
                = Python_h.LIBRARY_ARENA.allocateFrom("llu");
        }
        return Holder.PRIuFAST64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIuMAX "llu"
     * }
     */
    public static MemorySegment PRIuMAX() {
        class Holder {
            static final MemorySegment PRIuMAX
                = Python_h.LIBRARY_ARENA.allocateFrom("llu");
        }
        return Holder.PRIuMAX;
    }
    /**
     * {@snippet lang=c :
     * #define PRIuPTR "llu"
     * }
     */
    public static MemorySegment PRIuPTR() {
        class Holder {
            static final MemorySegment PRIuPTR
                = Python_h.LIBRARY_ARENA.allocateFrom("llu");
        }
        return Holder.PRIuPTR;
    }
    /**
     * {@snippet lang=c :
     * #define PRIx8 "hhx"
     * }
     */
    public static MemorySegment PRIx8() {
        class Holder {
            static final MemorySegment PRIx8
                = Python_h.LIBRARY_ARENA.allocateFrom("hhx");
        }
        return Holder.PRIx8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIx16 "hx"
     * }
     */
    public static MemorySegment PRIx16() {
        class Holder {
            static final MemorySegment PRIx16
                = Python_h.LIBRARY_ARENA.allocateFrom("hx");
        }
        return Holder.PRIx16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIx32 "x"
     * }
     */
    public static MemorySegment PRIx32() {
        class Holder {
            static final MemorySegment PRIx32
                = Python_h.LIBRARY_ARENA.allocateFrom("x");
        }
        return Holder.PRIx32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIx64 "llx"
     * }
     */
    public static MemorySegment PRIx64() {
        class Holder {
            static final MemorySegment PRIx64
                = Python_h.LIBRARY_ARENA.allocateFrom("llx");
        }
        return Holder.PRIx64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIxLEAST8 "hhx"
     * }
     */
    public static MemorySegment PRIxLEAST8() {
        class Holder {
            static final MemorySegment PRIxLEAST8
                = Python_h.LIBRARY_ARENA.allocateFrom("hhx");
        }
        return Holder.PRIxLEAST8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIxLEAST16 "hx"
     * }
     */
    public static MemorySegment PRIxLEAST16() {
        class Holder {
            static final MemorySegment PRIxLEAST16
                = Python_h.LIBRARY_ARENA.allocateFrom("hx");
        }
        return Holder.PRIxLEAST16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIxLEAST32 "x"
     * }
     */
    public static MemorySegment PRIxLEAST32() {
        class Holder {
            static final MemorySegment PRIxLEAST32
                = Python_h.LIBRARY_ARENA.allocateFrom("x");
        }
        return Holder.PRIxLEAST32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIxLEAST64 "llx"
     * }
     */
    public static MemorySegment PRIxLEAST64() {
        class Holder {
            static final MemorySegment PRIxLEAST64
                = Python_h.LIBRARY_ARENA.allocateFrom("llx");
        }
        return Holder.PRIxLEAST64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIxFAST8 "hhx"
     * }
     */
    public static MemorySegment PRIxFAST8() {
        class Holder {
            static final MemorySegment PRIxFAST8
                = Python_h.LIBRARY_ARENA.allocateFrom("hhx");
        }
        return Holder.PRIxFAST8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIxFAST16 "x"
     * }
     */
    public static MemorySegment PRIxFAST16() {
        class Holder {
            static final MemorySegment PRIxFAST16
                = Python_h.LIBRARY_ARENA.allocateFrom("x");
        }
        return Holder.PRIxFAST16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIxFAST32 "x"
     * }
     */
    public static MemorySegment PRIxFAST32() {
        class Holder {
            static final MemorySegment PRIxFAST32
                = Python_h.LIBRARY_ARENA.allocateFrom("x");
        }
        return Holder.PRIxFAST32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIxFAST64 "llx"
     * }
     */
    public static MemorySegment PRIxFAST64() {
        class Holder {
            static final MemorySegment PRIxFAST64
                = Python_h.LIBRARY_ARENA.allocateFrom("llx");
        }
        return Holder.PRIxFAST64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIxMAX "llx"
     * }
     */
    public static MemorySegment PRIxMAX() {
        class Holder {
            static final MemorySegment PRIxMAX
                = Python_h.LIBRARY_ARENA.allocateFrom("llx");
        }
        return Holder.PRIxMAX;
    }
    /**
     * {@snippet lang=c :
     * #define PRIxPTR "llx"
     * }
     */
    public static MemorySegment PRIxPTR() {
        class Holder {
            static final MemorySegment PRIxPTR
                = Python_h.LIBRARY_ARENA.allocateFrom("llx");
        }
        return Holder.PRIxPTR;
    }
    /**
     * {@snippet lang=c :
     * #define PRIX8 "hhX"
     * }
     */
    public static MemorySegment PRIX8() {
        class Holder {
            static final MemorySegment PRIX8
                = Python_h.LIBRARY_ARENA.allocateFrom("hhX");
        }
        return Holder.PRIX8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIX16 "hX"
     * }
     */
    public static MemorySegment PRIX16() {
        class Holder {
            static final MemorySegment PRIX16
                = Python_h.LIBRARY_ARENA.allocateFrom("hX");
        }
        return Holder.PRIX16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIX32 "X"
     * }
     */
    public static MemorySegment PRIX32() {
        class Holder {
            static final MemorySegment PRIX32
                = Python_h.LIBRARY_ARENA.allocateFrom("X");
        }
        return Holder.PRIX32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIX64 "llX"
     * }
     */
    public static MemorySegment PRIX64() {
        class Holder {
            static final MemorySegment PRIX64
                = Python_h.LIBRARY_ARENA.allocateFrom("llX");
        }
        return Holder.PRIX64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIXLEAST8 "hhX"
     * }
     */
    public static MemorySegment PRIXLEAST8() {
        class Holder {
            static final MemorySegment PRIXLEAST8
                = Python_h.LIBRARY_ARENA.allocateFrom("hhX");
        }
        return Holder.PRIXLEAST8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIXLEAST16 "hX"
     * }
     */
    public static MemorySegment PRIXLEAST16() {
        class Holder {
            static final MemorySegment PRIXLEAST16
                = Python_h.LIBRARY_ARENA.allocateFrom("hX");
        }
        return Holder.PRIXLEAST16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIXLEAST32 "X"
     * }
     */
    public static MemorySegment PRIXLEAST32() {
        class Holder {
            static final MemorySegment PRIXLEAST32
                = Python_h.LIBRARY_ARENA.allocateFrom("X");
        }
        return Holder.PRIXLEAST32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIXLEAST64 "llX"
     * }
     */
    public static MemorySegment PRIXLEAST64() {
        class Holder {
            static final MemorySegment PRIXLEAST64
                = Python_h.LIBRARY_ARENA.allocateFrom("llX");
        }
        return Holder.PRIXLEAST64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIXFAST8 "hhX"
     * }
     */
    public static MemorySegment PRIXFAST8() {
        class Holder {
            static final MemorySegment PRIXFAST8
                = Python_h.LIBRARY_ARENA.allocateFrom("hhX");
        }
        return Holder.PRIXFAST8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIXFAST16 "X"
     * }
     */
    public static MemorySegment PRIXFAST16() {
        class Holder {
            static final MemorySegment PRIXFAST16
                = Python_h.LIBRARY_ARENA.allocateFrom("X");
        }
        return Holder.PRIXFAST16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIXFAST32 "X"
     * }
     */
    public static MemorySegment PRIXFAST32() {
        class Holder {
            static final MemorySegment PRIXFAST32
                = Python_h.LIBRARY_ARENA.allocateFrom("X");
        }
        return Holder.PRIXFAST32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIXFAST64 "llX"
     * }
     */
    public static MemorySegment PRIXFAST64() {
        class Holder {
            static final MemorySegment PRIXFAST64
                = Python_h.LIBRARY_ARENA.allocateFrom("llX");
        }
        return Holder.PRIXFAST64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIXMAX "llX"
     * }
     */
    public static MemorySegment PRIXMAX() {
        class Holder {
            static final MemorySegment PRIXMAX
                = Python_h.LIBRARY_ARENA.allocateFrom("llX");
        }
        return Holder.PRIXMAX;
    }
    /**
     * {@snippet lang=c :
     * #define PRIXPTR "llX"
     * }
     */
    public static MemorySegment PRIXPTR() {
        class Holder {
            static final MemorySegment PRIXPTR
                = Python_h.LIBRARY_ARENA.allocateFrom("llX");
        }
        return Holder.PRIXPTR;
    }
    /**
     * {@snippet lang=c :
     * #define SCNd8 "hhd"
     * }
     */
    public static MemorySegment SCNd8() {
        class Holder {
            static final MemorySegment SCNd8
                = Python_h.LIBRARY_ARENA.allocateFrom("hhd");
        }
        return Holder.SCNd8;
    }
    /**
     * {@snippet lang=c :
     * #define SCNd16 "hd"
     * }
     */
    public static MemorySegment SCNd16() {
        class Holder {
            static final MemorySegment SCNd16
                = Python_h.LIBRARY_ARENA.allocateFrom("hd");
        }
        return Holder.SCNd16;
    }
    /**
     * {@snippet lang=c :
     * #define SCNd32 "d"
     * }
     */
    public static MemorySegment SCNd32() {
        class Holder {
            static final MemorySegment SCNd32
                = Python_h.LIBRARY_ARENA.allocateFrom("d");
        }
        return Holder.SCNd32;
    }
    /**
     * {@snippet lang=c :
     * #define SCNd64 "lld"
     * }
     */
    public static MemorySegment SCNd64() {
        class Holder {
            static final MemorySegment SCNd64
                = Python_h.LIBRARY_ARENA.allocateFrom("lld");
        }
        return Holder.SCNd64;
    }
    /**
     * {@snippet lang=c :
     * #define SCNdLEAST8 "hhd"
     * }
     */
    public static MemorySegment SCNdLEAST8() {
        class Holder {
            static final MemorySegment SCNdLEAST8
                = Python_h.LIBRARY_ARENA.allocateFrom("hhd");
        }
        return Holder.SCNdLEAST8;
    }
    /**
     * {@snippet lang=c :
     * #define SCNdLEAST16 "hd"
     * }
     */
    public static MemorySegment SCNdLEAST16() {
        class Holder {
            static final MemorySegment SCNdLEAST16
                = Python_h.LIBRARY_ARENA.allocateFrom("hd");
        }
        return Holder.SCNdLEAST16;
    }
    /**
     * {@snippet lang=c :
     * #define SCNdLEAST32 "d"
     * }
     */
    public static MemorySegment SCNdLEAST32() {
        class Holder {
            static final MemorySegment SCNdLEAST32
                = Python_h.LIBRARY_ARENA.allocateFrom("d");
        }
        return Holder.SCNdLEAST32;
    }
    /**
     * {@snippet lang=c :
     * #define SCNdLEAST64 "lld"
     * }
     */
    public static MemorySegment SCNdLEAST64() {
        class Holder {
            static final MemorySegment SCNdLEAST64
                = Python_h.LIBRARY_ARENA.allocateFrom("lld");
        }
        return Holder.SCNdLEAST64;
    }
    /**
     * {@snippet lang=c :
     * #define SCNdFAST8 "hhd"
     * }
     */
    public static MemorySegment SCNdFAST8() {
        class Holder {
            static final MemorySegment SCNdFAST8
                = Python_h.LIBRARY_ARENA.allocateFrom("hhd");
        }
        return Holder.SCNdFAST8;
    }
    /**
     * {@snippet lang=c :
     * #define SCNdFAST16 "d"
     * }
     */
    public static MemorySegment SCNdFAST16() {
        class Holder {
            static final MemorySegment SCNdFAST16
                = Python_h.LIBRARY_ARENA.allocateFrom("d");
        }
        return Holder.SCNdFAST16;
    }
    /**
     * {@snippet lang=c :
     * #define SCNdFAST32 "d"
     * }
     */
    public static MemorySegment SCNdFAST32() {
        class Holder {
            static final MemorySegment SCNdFAST32
                = Python_h.LIBRARY_ARENA.allocateFrom("d");
        }
        return Holder.SCNdFAST32;
    }
    /**
     * {@snippet lang=c :
     * #define SCNdFAST64 "lld"
     * }
     */
    public static MemorySegment SCNdFAST64() {
        class Holder {
            static final MemorySegment SCNdFAST64
                = Python_h.LIBRARY_ARENA.allocateFrom("lld");
        }
        return Holder.SCNdFAST64;
    }
    /**
     * {@snippet lang=c :
     * #define SCNdMAX "lld"
     * }
     */
    public static MemorySegment SCNdMAX() {
        class Holder {
            static final MemorySegment SCNdMAX
                = Python_h.LIBRARY_ARENA.allocateFrom("lld");
        }
        return Holder.SCNdMAX;
    }
    /**
     * {@snippet lang=c :
     * #define SCNdPTR "lld"
     * }
     */
    public static MemorySegment SCNdPTR() {
        class Holder {
            static final MemorySegment SCNdPTR
                = Python_h.LIBRARY_ARENA.allocateFrom("lld");
        }
        return Holder.SCNdPTR;
    }
    /**
     * {@snippet lang=c :
     * #define SCNi8 "hhi"
     * }
     */
    public static MemorySegment SCNi8() {
        class Holder {
            static final MemorySegment SCNi8
                = Python_h.LIBRARY_ARENA.allocateFrom("hhi");
        }
        return Holder.SCNi8;
    }
    /**
     * {@snippet lang=c :
     * #define SCNi16 "hi"
     * }
     */
    public static MemorySegment SCNi16() {
        class Holder {
            static final MemorySegment SCNi16
                = Python_h.LIBRARY_ARENA.allocateFrom("hi");
        }
        return Holder.SCNi16;
    }
    /**
     * {@snippet lang=c :
     * #define SCNi32 "i"
     * }
     */
    public static MemorySegment SCNi32() {
        class Holder {
            static final MemorySegment SCNi32
                = Python_h.LIBRARY_ARENA.allocateFrom("i");
        }
        return Holder.SCNi32;
    }
    /**
     * {@snippet lang=c :
     * #define SCNi64 "lli"
     * }
     */
    public static MemorySegment SCNi64() {
        class Holder {
            static final MemorySegment SCNi64
                = Python_h.LIBRARY_ARENA.allocateFrom("lli");
        }
        return Holder.SCNi64;
    }
    /**
     * {@snippet lang=c :
     * #define SCNiLEAST8 "hhi"
     * }
     */
    public static MemorySegment SCNiLEAST8() {
        class Holder {
            static final MemorySegment SCNiLEAST8
                = Python_h.LIBRARY_ARENA.allocateFrom("hhi");
        }
        return Holder.SCNiLEAST8;
    }
    /**
     * {@snippet lang=c :
     * #define SCNiLEAST16 "hi"
     * }
     */
    public static MemorySegment SCNiLEAST16() {
        class Holder {
            static final MemorySegment SCNiLEAST16
                = Python_h.LIBRARY_ARENA.allocateFrom("hi");
        }
        return Holder.SCNiLEAST16;
    }
    /**
     * {@snippet lang=c :
     * #define SCNiLEAST32 "i"
     * }
     */
    public static MemorySegment SCNiLEAST32() {
        class Holder {
            static final MemorySegment SCNiLEAST32
                = Python_h.LIBRARY_ARENA.allocateFrom("i");
        }
        return Holder.SCNiLEAST32;
    }
    /**
     * {@snippet lang=c :
     * #define SCNiLEAST64 "lli"
     * }
     */
    public static MemorySegment SCNiLEAST64() {
        class Holder {
            static final MemorySegment SCNiLEAST64
                = Python_h.LIBRARY_ARENA.allocateFrom("lli");
        }
        return Holder.SCNiLEAST64;
    }
    /**
     * {@snippet lang=c :
     * #define SCNiFAST8 "hhi"
     * }
     */
    public static MemorySegment SCNiFAST8() {
        class Holder {
            static final MemorySegment SCNiFAST8
                = Python_h.LIBRARY_ARENA.allocateFrom("hhi");
        }
        return Holder.SCNiFAST8;
    }
    /**
     * {@snippet lang=c :
     * #define SCNiFAST16 "i"
     * }
     */
    public static MemorySegment SCNiFAST16() {
        class Holder {
            static final MemorySegment SCNiFAST16
                = Python_h.LIBRARY_ARENA.allocateFrom("i");
        }
        return Holder.SCNiFAST16;
    }
    /**
     * {@snippet lang=c :
     * #define SCNiFAST32 "i"
     * }
     */
    public static MemorySegment SCNiFAST32() {
        class Holder {
            static final MemorySegment SCNiFAST32
                = Python_h.LIBRARY_ARENA.allocateFrom("i");
        }
        return Holder.SCNiFAST32;
    }
    /**
     * {@snippet lang=c :
     * #define SCNiFAST64 "lli"
     * }
     */
    public static MemorySegment SCNiFAST64() {
        class Holder {
            static final MemorySegment SCNiFAST64
                = Python_h.LIBRARY_ARENA.allocateFrom("lli");
        }
        return Holder.SCNiFAST64;
    }
    /**
     * {@snippet lang=c :
     * #define SCNiMAX "lli"
     * }
     */
    public static MemorySegment SCNiMAX() {
        class Holder {
            static final MemorySegment SCNiMAX
                = Python_h.LIBRARY_ARENA.allocateFrom("lli");
        }
        return Holder.SCNiMAX;
    }
    /**
     * {@snippet lang=c :
     * #define SCNiPTR "lli"
     * }
     */
    public static MemorySegment SCNiPTR() {
        class Holder {
            static final MemorySegment SCNiPTR
                = Python_h.LIBRARY_ARENA.allocateFrom("lli");
        }
        return Holder.SCNiPTR;
    }
    /**
     * {@snippet lang=c :
     * #define SCNo8 "hho"
     * }
     */
    public static MemorySegment SCNo8() {
        class Holder {
            static final MemorySegment SCNo8
                = Python_h.LIBRARY_ARENA.allocateFrom("hho");
        }
        return Holder.SCNo8;
    }
    /**
     * {@snippet lang=c :
     * #define SCNo16 "ho"
     * }
     */
    public static MemorySegment SCNo16() {
        class Holder {
            static final MemorySegment SCNo16
                = Python_h.LIBRARY_ARENA.allocateFrom("ho");
        }
        return Holder.SCNo16;
    }
    /**
     * {@snippet lang=c :
     * #define SCNo32 "o"
     * }
     */
    public static MemorySegment SCNo32() {
        class Holder {
            static final MemorySegment SCNo32
                = Python_h.LIBRARY_ARENA.allocateFrom("o");
        }
        return Holder.SCNo32;
    }
    /**
     * {@snippet lang=c :
     * #define SCNo64 "llo"
     * }
     */
    public static MemorySegment SCNo64() {
        class Holder {
            static final MemorySegment SCNo64
                = Python_h.LIBRARY_ARENA.allocateFrom("llo");
        }
        return Holder.SCNo64;
    }
    /**
     * {@snippet lang=c :
     * #define SCNoLEAST8 "hho"
     * }
     */
    public static MemorySegment SCNoLEAST8() {
        class Holder {
            static final MemorySegment SCNoLEAST8
                = Python_h.LIBRARY_ARENA.allocateFrom("hho");
        }
        return Holder.SCNoLEAST8;
    }
    /**
     * {@snippet lang=c :
     * #define SCNoLEAST16 "ho"
     * }
     */
    public static MemorySegment SCNoLEAST16() {
        class Holder {
            static final MemorySegment SCNoLEAST16
                = Python_h.LIBRARY_ARENA.allocateFrom("ho");
        }
        return Holder.SCNoLEAST16;
    }
    /**
     * {@snippet lang=c :
     * #define SCNoLEAST32 "o"
     * }
     */
    public static MemorySegment SCNoLEAST32() {
        class Holder {
            static final MemorySegment SCNoLEAST32
                = Python_h.LIBRARY_ARENA.allocateFrom("o");
        }
        return Holder.SCNoLEAST32;
    }
    /**
     * {@snippet lang=c :
     * #define SCNoLEAST64 "llo"
     * }
     */
    public static MemorySegment SCNoLEAST64() {
        class Holder {
            static final MemorySegment SCNoLEAST64
                = Python_h.LIBRARY_ARENA.allocateFrom("llo");
        }
        return Holder.SCNoLEAST64;
    }
    /**
     * {@snippet lang=c :
     * #define SCNoFAST8 "hho"
     * }
     */
    public static MemorySegment SCNoFAST8() {
        class Holder {
            static final MemorySegment SCNoFAST8
                = Python_h.LIBRARY_ARENA.allocateFrom("hho");
        }
        return Holder.SCNoFAST8;
    }
    /**
     * {@snippet lang=c :
     * #define SCNoFAST16 "o"
     * }
     */
    public static MemorySegment SCNoFAST16() {
        class Holder {
            static final MemorySegment SCNoFAST16
                = Python_h.LIBRARY_ARENA.allocateFrom("o");
        }
        return Holder.SCNoFAST16;
    }
    /**
     * {@snippet lang=c :
     * #define SCNoFAST32 "o"
     * }
     */
    public static MemorySegment SCNoFAST32() {
        class Holder {
            static final MemorySegment SCNoFAST32
                = Python_h.LIBRARY_ARENA.allocateFrom("o");
        }
        return Holder.SCNoFAST32;
    }
    /**
     * {@snippet lang=c :
     * #define SCNoFAST64 "llo"
     * }
     */
    public static MemorySegment SCNoFAST64() {
        class Holder {
            static final MemorySegment SCNoFAST64
                = Python_h.LIBRARY_ARENA.allocateFrom("llo");
        }
        return Holder.SCNoFAST64;
    }
    /**
     * {@snippet lang=c :
     * #define SCNoMAX "llo"
     * }
     */
    public static MemorySegment SCNoMAX() {
        class Holder {
            static final MemorySegment SCNoMAX
                = Python_h.LIBRARY_ARENA.allocateFrom("llo");
        }
        return Holder.SCNoMAX;
    }
    /**
     * {@snippet lang=c :
     * #define SCNoPTR "llo"
     * }
     */
    public static MemorySegment SCNoPTR() {
        class Holder {
            static final MemorySegment SCNoPTR
                = Python_h.LIBRARY_ARENA.allocateFrom("llo");
        }
        return Holder.SCNoPTR;
    }
    /**
     * {@snippet lang=c :
     * #define SCNu8 "hhu"
     * }
     */
    public static MemorySegment SCNu8() {
        class Holder {
            static final MemorySegment SCNu8
                = Python_h.LIBRARY_ARENA.allocateFrom("hhu");
        }
        return Holder.SCNu8;
    }
    /**
     * {@snippet lang=c :
     * #define SCNu16 "hu"
     * }
     */
    public static MemorySegment SCNu16() {
        class Holder {
            static final MemorySegment SCNu16
                = Python_h.LIBRARY_ARENA.allocateFrom("hu");
        }
        return Holder.SCNu16;
    }
    /**
     * {@snippet lang=c :
     * #define SCNu32 "u"
     * }
     */
    public static MemorySegment SCNu32() {
        class Holder {
            static final MemorySegment SCNu32
                = Python_h.LIBRARY_ARENA.allocateFrom("u");
        }
        return Holder.SCNu32;
    }
    /**
     * {@snippet lang=c :
     * #define SCNu64 "llu"
     * }
     */
    public static MemorySegment SCNu64() {
        class Holder {
            static final MemorySegment SCNu64
                = Python_h.LIBRARY_ARENA.allocateFrom("llu");
        }
        return Holder.SCNu64;
    }
    /**
     * {@snippet lang=c :
     * #define SCNuLEAST8 "hhu"
     * }
     */
    public static MemorySegment SCNuLEAST8() {
        class Holder {
            static final MemorySegment SCNuLEAST8
                = Python_h.LIBRARY_ARENA.allocateFrom("hhu");
        }
        return Holder.SCNuLEAST8;
    }
    /**
     * {@snippet lang=c :
     * #define SCNuLEAST16 "hu"
     * }
     */
    public static MemorySegment SCNuLEAST16() {
        class Holder {
            static final MemorySegment SCNuLEAST16
                = Python_h.LIBRARY_ARENA.allocateFrom("hu");
        }
        return Holder.SCNuLEAST16;
    }
    /**
     * {@snippet lang=c :
     * #define SCNuLEAST32 "u"
     * }
     */
    public static MemorySegment SCNuLEAST32() {
        class Holder {
            static final MemorySegment SCNuLEAST32
                = Python_h.LIBRARY_ARENA.allocateFrom("u");
        }
        return Holder.SCNuLEAST32;
    }
    /**
     * {@snippet lang=c :
     * #define SCNuLEAST64 "llu"
     * }
     */
    public static MemorySegment SCNuLEAST64() {
        class Holder {
            static final MemorySegment SCNuLEAST64
                = Python_h.LIBRARY_ARENA.allocateFrom("llu");
        }
        return Holder.SCNuLEAST64;
    }
    /**
     * {@snippet lang=c :
     * #define SCNuFAST8 "hhu"
     * }
     */
    public static MemorySegment SCNuFAST8() {
        class Holder {
            static final MemorySegment SCNuFAST8
                = Python_h.LIBRARY_ARENA.allocateFrom("hhu");
        }
        return Holder.SCNuFAST8;
    }
    /**
     * {@snippet lang=c :
     * #define SCNuFAST16 "u"
     * }
     */
    public static MemorySegment SCNuFAST16() {
        class Holder {
            static final MemorySegment SCNuFAST16
                = Python_h.LIBRARY_ARENA.allocateFrom("u");
        }
        return Holder.SCNuFAST16;
    }
    /**
     * {@snippet lang=c :
     * #define SCNuFAST32 "u"
     * }
     */
    public static MemorySegment SCNuFAST32() {
        class Holder {
            static final MemorySegment SCNuFAST32
                = Python_h.LIBRARY_ARENA.allocateFrom("u");
        }
        return Holder.SCNuFAST32;
    }
    /**
     * {@snippet lang=c :
     * #define SCNuFAST64 "llu"
     * }
     */
    public static MemorySegment SCNuFAST64() {
        class Holder {
            static final MemorySegment SCNuFAST64
                = Python_h.LIBRARY_ARENA.allocateFrom("llu");
        }
        return Holder.SCNuFAST64;
    }
    /**
     * {@snippet lang=c :
     * #define SCNuMAX "llu"
     * }
     */
    public static MemorySegment SCNuMAX() {
        class Holder {
            static final MemorySegment SCNuMAX
                = Python_h.LIBRARY_ARENA.allocateFrom("llu");
        }
        return Holder.SCNuMAX;
    }
    /**
     * {@snippet lang=c :
     * #define SCNuPTR "llu"
     * }
     */
    public static MemorySegment SCNuPTR() {
        class Holder {
            static final MemorySegment SCNuPTR
                = Python_h.LIBRARY_ARENA.allocateFrom("llu");
        }
        return Holder.SCNuPTR;
    }
    /**
     * {@snippet lang=c :
     * #define SCNx8 "hhx"
     * }
     */
    public static MemorySegment SCNx8() {
        class Holder {
            static final MemorySegment SCNx8
                = Python_h.LIBRARY_ARENA.allocateFrom("hhx");
        }
        return Holder.SCNx8;
    }
    /**
     * {@snippet lang=c :
     * #define SCNx16 "hx"
     * }
     */
    public static MemorySegment SCNx16() {
        class Holder {
            static final MemorySegment SCNx16
                = Python_h.LIBRARY_ARENA.allocateFrom("hx");
        }
        return Holder.SCNx16;
    }
    /**
     * {@snippet lang=c :
     * #define SCNx32 "x"
     * }
     */
    public static MemorySegment SCNx32() {
        class Holder {
            static final MemorySegment SCNx32
                = Python_h.LIBRARY_ARENA.allocateFrom("x");
        }
        return Holder.SCNx32;
    }
    /**
     * {@snippet lang=c :
     * #define SCNx64 "llx"
     * }
     */
    public static MemorySegment SCNx64() {
        class Holder {
            static final MemorySegment SCNx64
                = Python_h.LIBRARY_ARENA.allocateFrom("llx");
        }
        return Holder.SCNx64;
    }
    /**
     * {@snippet lang=c :
     * #define SCNxLEAST8 "hhx"
     * }
     */
    public static MemorySegment SCNxLEAST8() {
        class Holder {
            static final MemorySegment SCNxLEAST8
                = Python_h.LIBRARY_ARENA.allocateFrom("hhx");
        }
        return Holder.SCNxLEAST8;
    }
    /**
     * {@snippet lang=c :
     * #define SCNxLEAST16 "hx"
     * }
     */
    public static MemorySegment SCNxLEAST16() {
        class Holder {
            static final MemorySegment SCNxLEAST16
                = Python_h.LIBRARY_ARENA.allocateFrom("hx");
        }
        return Holder.SCNxLEAST16;
    }
    /**
     * {@snippet lang=c :
     * #define SCNxLEAST32 "x"
     * }
     */
    public static MemorySegment SCNxLEAST32() {
        class Holder {
            static final MemorySegment SCNxLEAST32
                = Python_h.LIBRARY_ARENA.allocateFrom("x");
        }
        return Holder.SCNxLEAST32;
    }
    /**
     * {@snippet lang=c :
     * #define SCNxLEAST64 "llx"
     * }
     */
    public static MemorySegment SCNxLEAST64() {
        class Holder {
            static final MemorySegment SCNxLEAST64
                = Python_h.LIBRARY_ARENA.allocateFrom("llx");
        }
        return Holder.SCNxLEAST64;
    }
    /**
     * {@snippet lang=c :
     * #define SCNxFAST8 "hhx"
     * }
     */
    public static MemorySegment SCNxFAST8() {
        class Holder {
            static final MemorySegment SCNxFAST8
                = Python_h.LIBRARY_ARENA.allocateFrom("hhx");
        }
        return Holder.SCNxFAST8;
    }
    /**
     * {@snippet lang=c :
     * #define SCNxFAST16 "x"
     * }
     */
    public static MemorySegment SCNxFAST16() {
        class Holder {
            static final MemorySegment SCNxFAST16
                = Python_h.LIBRARY_ARENA.allocateFrom("x");
        }
        return Holder.SCNxFAST16;
    }
    /**
     * {@snippet lang=c :
     * #define SCNxFAST32 "x"
     * }
     */
    public static MemorySegment SCNxFAST32() {
        class Holder {
            static final MemorySegment SCNxFAST32
                = Python_h.LIBRARY_ARENA.allocateFrom("x");
        }
        return Holder.SCNxFAST32;
    }
    /**
     * {@snippet lang=c :
     * #define SCNxFAST64 "llx"
     * }
     */
    public static MemorySegment SCNxFAST64() {
        class Holder {
            static final MemorySegment SCNxFAST64
                = Python_h.LIBRARY_ARENA.allocateFrom("llx");
        }
        return Holder.SCNxFAST64;
    }
    /**
     * {@snippet lang=c :
     * #define SCNxMAX "llx"
     * }
     */
    public static MemorySegment SCNxMAX() {
        class Holder {
            static final MemorySegment SCNxMAX
                = Python_h.LIBRARY_ARENA.allocateFrom("llx");
        }
        return Holder.SCNxMAX;
    }
    /**
     * {@snippet lang=c :
     * #define SCNxPTR "llx"
     * }
     */
    public static MemorySegment SCNxPTR() {
        class Holder {
            static final MemorySegment SCNxPTR
                = Python_h.LIBRARY_ARENA.allocateFrom("llx");
        }
        return Holder.SCNxPTR;
    }
    private static final MemorySegment _Py_NULL = MemorySegment.ofAddress(0L);
    /**
     * {@snippet lang=c :
     * #define _Py_NULL (void*) 0
     * }
     */
    public static MemorySegment _Py_NULL() {
        return _Py_NULL;
    }
    private static final long PY_SSIZE_T_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define PY_SSIZE_T_MIN -9223372036854775808
     * }
     */
    public static long PY_SSIZE_T_MIN() {
        return PY_SSIZE_T_MIN;
    }
    private static final int SIZEOF_PY_HASH_T = (int)8L;
    /**
     * {@snippet lang=c :
     * #define SIZEOF_PY_HASH_T 8
     * }
     */
    public static int SIZEOF_PY_HASH_T() {
        return SIZEOF_PY_HASH_T;
    }
    private static final int SIZEOF_PY_UHASH_T = (int)8L;
    /**
     * {@snippet lang=c :
     * #define SIZEOF_PY_UHASH_T 8
     * }
     */
    public static int SIZEOF_PY_UHASH_T() {
        return SIZEOF_PY_UHASH_T;
    }
    private static final long PY_SIZE_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define PY_SIZE_MAX -1
     * }
     */
    public static long PY_SIZE_MAX() {
        return PY_SIZE_MAX;
    }
    /**
     * {@snippet lang=c :
     * #define PY_FORMAT_SIZE_T "z"
     * }
     */
    public static MemorySegment PY_FORMAT_SIZE_T() {
        class Holder {
            static final MemorySegment PY_FORMAT_SIZE_T
                = Python_h.LIBRARY_ARENA.allocateFrom("z");
        }
        return Holder.PY_FORMAT_SIZE_T;
    }
    private static final double _HUGE_ENUF = 1.0E300d;
    /**
     * {@snippet lang=c :
     * #define _HUGE_ENUF 1.0E300
     * }
     */
    public static double _HUGE_ENUF() {
        return _HUGE_ENUF;
    }
    private static final float INFINITY = Float.valueOf("Infinity");
    /**
     * {@snippet lang=c :
     * #define INFINITY Infinity
     * }
     */
    public static float INFINITY() {
        return INFINITY;
    }
    private static final double HUGE_VAL = Double.valueOf("Infinity");
    /**
     * {@snippet lang=c :
     * #define HUGE_VAL Infinity
     * }
     */
    public static double HUGE_VAL() {
        return HUGE_VAL;
    }
    private static final float HUGE_VALF = Float.valueOf("Infinity");
    /**
     * {@snippet lang=c :
     * #define HUGE_VALF Infinity
     * }
     */
    public static float HUGE_VALF() {
        return HUGE_VALF;
    }
    private static final double HUGE_VALL = Double.valueOf("Infinity");
    /**
     * {@snippet lang=c :
     * #define HUGE_VALL Infinity
     * }
     */
    public static double HUGE_VALL() {
        return HUGE_VALL;
    }
    private static final float NAN = Float.valueOf("NaN");
    /**
     * {@snippet lang=c :
     * #define NAN NaN
     * }
     */
    public static float NAN() {
        return NAN;
    }
    private static final int _DENORM = (int)-2L;
    /**
     * {@snippet lang=c :
     * #define _DENORM -2
     * }
     */
    public static int _DENORM() {
        return _DENORM;
    }
    private static final int _FINITE = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define _FINITE -1
     * }
     */
    public static int _FINITE() {
        return _FINITE;
    }
    private static final int FP_INFINITE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define FP_INFINITE 1
     * }
     */
    public static int FP_INFINITE() {
        return FP_INFINITE;
    }
    private static final int FP_NAN = (int)2L;
    /**
     * {@snippet lang=c :
     * #define FP_NAN 2
     * }
     */
    public static int FP_NAN() {
        return FP_NAN;
    }
    private static final int FP_NORMAL = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define FP_NORMAL -1
     * }
     */
    public static int FP_NORMAL() {
        return FP_NORMAL;
    }
    private static final int FP_SUBNORMAL = (int)-2L;
    /**
     * {@snippet lang=c :
     * #define FP_SUBNORMAL -2
     * }
     */
    public static int FP_SUBNORMAL() {
        return FP_SUBNORMAL;
    }
    private static final int FP_ILOGB0 = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define FP_ILOGB0 -2147483648
     * }
     */
    public static int FP_ILOGB0() {
        return FP_ILOGB0;
    }
    private static final int math_errhandling = (int)3L;
    /**
     * {@snippet lang=c :
     * #define math_errhandling 3
     * }
     */
    public static int math_errhandling() {
        return math_errhandling;
    }
    private static final short _DFRAC = (short)15L;
    /**
     * {@snippet lang=c :
     * #define _DFRAC 15
     * }
     */
    public static short _DFRAC() {
        return _DFRAC;
    }
    private static final short _DMASK = (short)32752L;
    /**
     * {@snippet lang=c :
     * #define _DMASK 32752
     * }
     */
    public static short _DMASK() {
        return _DMASK;
    }
    private static final short _DMAX = (short)2047L;
    /**
     * {@snippet lang=c :
     * #define _DMAX 2047
     * }
     */
    public static short _DMAX() {
        return _DMAX;
    }
    private static final short _DSIGN = (short)32768L;
    /**
     * {@snippet lang=c :
     * #define _DSIGN 32768
     * }
     */
    public static short _DSIGN() {
        return _DSIGN;
    }
    private static final short _FFRAC = (short)127L;
    /**
     * {@snippet lang=c :
     * #define _FFRAC 127
     * }
     */
    public static short _FFRAC() {
        return _FFRAC;
    }
    private static final short _FMASK = (short)32640L;
    /**
     * {@snippet lang=c :
     * #define _FMASK 32640
     * }
     */
    public static short _FMASK() {
        return _FMASK;
    }
    private static final short _FMAX = (short)255L;
    /**
     * {@snippet lang=c :
     * #define _FMAX 255
     * }
     */
    public static short _FMAX() {
        return _FMAX;
    }
    private static final short _FSIGN = (short)32768L;
    /**
     * {@snippet lang=c :
     * #define _FSIGN 32768
     * }
     */
    public static short _FSIGN() {
        return _FSIGN;
    }
    private static final short _LFRAC = (short)65535L;
    /**
     * {@snippet lang=c :
     * #define _LFRAC 65535
     * }
     */
    public static short _LFRAC() {
        return _LFRAC;
    }
    private static final short _LMASK = (short)32767L;
    /**
     * {@snippet lang=c :
     * #define _LMASK 32767
     * }
     */
    public static short _LMASK() {
        return _LMASK;
    }
    private static final short _LMAX = (short)32767L;
    /**
     * {@snippet lang=c :
     * #define _LMAX 32767
     * }
     */
    public static short _LMAX() {
        return _LMAX;
    }
    private static final short _LSIGN = (short)32768L;
    /**
     * {@snippet lang=c :
     * #define _LSIGN 32768
     * }
     */
    public static short _LSIGN() {
        return _LSIGN;
    }
    private static final int _DHUGE_EXP = (int)1842L;
    /**
     * {@snippet lang=c :
     * #define _DHUGE_EXP 1842
     * }
     */
    public static int _DHUGE_EXP() {
        return _DHUGE_EXP;
    }
    private static final int _FHUGE_EXP = (int)229L;
    /**
     * {@snippet lang=c :
     * #define _FHUGE_EXP 229
     * }
     */
    public static int _FHUGE_EXP() {
        return _FHUGE_EXP;
    }
    private static final int _LHUGE_EXP = (int)29490L;
    /**
     * {@snippet lang=c :
     * #define _LHUGE_EXP 29490
     * }
     */
    public static int _LHUGE_EXP() {
        return _LHUGE_EXP;
    }
    private static final int DOMAIN = (int)1L;
    /**
     * {@snippet lang=c :
     * #define DOMAIN 1
     * }
     */
    public static int DOMAIN() {
        return DOMAIN;
    }
    private static final int SING = (int)2L;
    /**
     * {@snippet lang=c :
     * #define SING 2
     * }
     */
    public static int SING() {
        return SING;
    }
    private static final int OVERFLOW = (int)3L;
    /**
     * {@snippet lang=c :
     * #define OVERFLOW 3
     * }
     */
    public static int OVERFLOW() {
        return OVERFLOW;
    }
    private static final int UNDERFLOW = (int)4L;
    /**
     * {@snippet lang=c :
     * #define UNDERFLOW 4
     * }
     */
    public static int UNDERFLOW() {
        return UNDERFLOW;
    }
    private static final int TLOSS = (int)5L;
    /**
     * {@snippet lang=c :
     * #define TLOSS 5
     * }
     */
    public static int TLOSS() {
        return TLOSS;
    }
    private static final int PLOSS = (int)6L;
    /**
     * {@snippet lang=c :
     * #define PLOSS 6
     * }
     */
    public static int PLOSS() {
        return PLOSS;
    }
    private static final int CLOCKS_PER_SEC = (int)1000L;
    /**
     * {@snippet lang=c :
     * #define CLOCKS_PER_SEC 1000
     * }
     */
    public static int CLOCKS_PER_SEC() {
        return CLOCKS_PER_SEC;
    }
    private static final int CLK_TCK = (int)1000L;
    /**
     * {@snippet lang=c :
     * #define CLK_TCK 1000
     * }
     */
    public static int CLK_TCK() {
        return CLK_TCK;
    }
    private static final int PY_DWORD_MAX = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define PY_DWORD_MAX 4294967295
     * }
     */
    public static int PY_DWORD_MAX() {
        return PY_DWORD_MAX;
    }
    private static final double Py_MATH_PIl = 3.141592653589793d;
    /**
     * {@snippet lang=c :
     * #define Py_MATH_PIl 3.141592653589793
     * }
     */
    public static double Py_MATH_PIl() {
        return Py_MATH_PIl;
    }
    private static final double Py_MATH_PI = 3.141592653589793d;
    /**
     * {@snippet lang=c :
     * #define Py_MATH_PI 3.141592653589793
     * }
     */
    public static double Py_MATH_PI() {
        return Py_MATH_PI;
    }
    private static final double Py_MATH_El = 2.718281828459045d;
    /**
     * {@snippet lang=c :
     * #define Py_MATH_El 2.718281828459045
     * }
     */
    public static double Py_MATH_El() {
        return Py_MATH_El;
    }
    private static final double Py_MATH_E = 2.718281828459045d;
    /**
     * {@snippet lang=c :
     * #define Py_MATH_E 2.718281828459045
     * }
     */
    public static double Py_MATH_E() {
        return Py_MATH_E;
    }
    private static final double Py_MATH_TAU = 6.283185307179586d;
    /**
     * {@snippet lang=c :
     * #define Py_MATH_TAU 6.283185307179586
     * }
     */
    public static double Py_MATH_TAU() {
        return Py_MATH_TAU;
    }
    private static final double Py_INFINITY = Double.valueOf("Infinity");
    /**
     * {@snippet lang=c :
     * #define Py_INFINITY Infinity
     * }
     */
    public static double Py_INFINITY() {
        return Py_INFINITY;
    }
    private static final double Py_HUGE_VAL = Double.valueOf("Infinity");
    /**
     * {@snippet lang=c :
     * #define Py_HUGE_VAL Infinity
     * }
     */
    public static double Py_HUGE_VAL() {
        return Py_HUGE_VAL;
    }
    private static final double Py_NAN = Double.valueOf("NaN");
    /**
     * {@snippet lang=c :
     * #define Py_NAN NaN
     * }
     */
    public static double Py_NAN() {
        return Py_NAN;
    }
    private static final int PyBUF_WRITEABLE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define PyBUF_WRITEABLE 1
     * }
     */
    public static int PyBUF_WRITEABLE() {
        return PyBUF_WRITEABLE;
    }
    private static final int PyBUF_STRIDES = (int)24L;
    /**
     * {@snippet lang=c :
     * #define PyBUF_STRIDES 24
     * }
     */
    public static int PyBUF_STRIDES() {
        return PyBUF_STRIDES;
    }
    private static final int PyBUF_C_CONTIGUOUS = (int)56L;
    /**
     * {@snippet lang=c :
     * #define PyBUF_C_CONTIGUOUS 56
     * }
     */
    public static int PyBUF_C_CONTIGUOUS() {
        return PyBUF_C_CONTIGUOUS;
    }
    private static final int PyBUF_F_CONTIGUOUS = (int)88L;
    /**
     * {@snippet lang=c :
     * #define PyBUF_F_CONTIGUOUS 88
     * }
     */
    public static int PyBUF_F_CONTIGUOUS() {
        return PyBUF_F_CONTIGUOUS;
    }
    private static final int PyBUF_ANY_CONTIGUOUS = (int)152L;
    /**
     * {@snippet lang=c :
     * #define PyBUF_ANY_CONTIGUOUS 152
     * }
     */
    public static int PyBUF_ANY_CONTIGUOUS() {
        return PyBUF_ANY_CONTIGUOUS;
    }
    private static final int PyBUF_INDIRECT = (int)280L;
    /**
     * {@snippet lang=c :
     * #define PyBUF_INDIRECT 280
     * }
     */
    public static int PyBUF_INDIRECT() {
        return PyBUF_INDIRECT;
    }
    private static final int PyBUF_CONTIG = (int)9L;
    /**
     * {@snippet lang=c :
     * #define PyBUF_CONTIG 9
     * }
     */
    public static int PyBUF_CONTIG() {
        return PyBUF_CONTIG;
    }
    private static final int PyBUF_CONTIG_RO = (int)8L;
    /**
     * {@snippet lang=c :
     * #define PyBUF_CONTIG_RO 8
     * }
     */
    public static int PyBUF_CONTIG_RO() {
        return PyBUF_CONTIG_RO;
    }
    private static final int PyBUF_STRIDED = (int)25L;
    /**
     * {@snippet lang=c :
     * #define PyBUF_STRIDED 25
     * }
     */
    public static int PyBUF_STRIDED() {
        return PyBUF_STRIDED;
    }
    private static final int PyBUF_STRIDED_RO = (int)24L;
    /**
     * {@snippet lang=c :
     * #define PyBUF_STRIDED_RO 24
     * }
     */
    public static int PyBUF_STRIDED_RO() {
        return PyBUF_STRIDED_RO;
    }
    private static final int PyBUF_RECORDS = (int)29L;
    /**
     * {@snippet lang=c :
     * #define PyBUF_RECORDS 29
     * }
     */
    public static int PyBUF_RECORDS() {
        return PyBUF_RECORDS;
    }
    private static final int PyBUF_RECORDS_RO = (int)28L;
    /**
     * {@snippet lang=c :
     * #define PyBUF_RECORDS_RO 28
     * }
     */
    public static int PyBUF_RECORDS_RO() {
        return PyBUF_RECORDS_RO;
    }
    private static final int PyBUF_FULL = (int)285L;
    /**
     * {@snippet lang=c :
     * #define PyBUF_FULL 285
     * }
     */
    public static int PyBUF_FULL() {
        return PyBUF_FULL;
    }
    private static final int PyBUF_FULL_RO = (int)284L;
    /**
     * {@snippet lang=c :
     * #define PyBUF_FULL_RO 284
     * }
     */
    public static int PyBUF_FULL_RO() {
        return PyBUF_FULL_RO;
    }
    private static final int _Py_IMMORTAL_REFCNT = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define _Py_IMMORTAL_REFCNT 4294967295
     * }
     */
    public static int _Py_IMMORTAL_REFCNT() {
        return _Py_IMMORTAL_REFCNT;
    }
    private static final long Py_INVALID_SIZE = -1L;
    /**
     * {@snippet lang=c :
     * #define Py_INVALID_SIZE -1
     * }
     */
    public static long Py_INVALID_SIZE() {
        return Py_INVALID_SIZE;
    }
    private static final int _Py_TPFLAGS_STATIC_BUILTIN = (int)2L;
    /**
     * {@snippet lang=c :
     * #define _Py_TPFLAGS_STATIC_BUILTIN 2
     * }
     */
    public static int _Py_TPFLAGS_STATIC_BUILTIN() {
        return _Py_TPFLAGS_STATIC_BUILTIN;
    }
    private static final int Py_TPFLAGS_MANAGED_WEAKREF = (int)8L;
    /**
     * {@snippet lang=c :
     * #define Py_TPFLAGS_MANAGED_WEAKREF 8
     * }
     */
    public static int Py_TPFLAGS_MANAGED_WEAKREF() {
        return Py_TPFLAGS_MANAGED_WEAKREF;
    }
    private static final int Py_TPFLAGS_MANAGED_DICT = (int)16L;
    /**
     * {@snippet lang=c :
     * #define Py_TPFLAGS_MANAGED_DICT 16
     * }
     */
    public static int Py_TPFLAGS_MANAGED_DICT() {
        return Py_TPFLAGS_MANAGED_DICT;
    }
    private static final int Py_TPFLAGS_PREHEADER = (int)24L;
    /**
     * {@snippet lang=c :
     * #define Py_TPFLAGS_PREHEADER 24
     * }
     */
    public static int Py_TPFLAGS_PREHEADER() {
        return Py_TPFLAGS_PREHEADER;
    }
    private static final int Py_TPFLAGS_SEQUENCE = (int)32L;
    /**
     * {@snippet lang=c :
     * #define Py_TPFLAGS_SEQUENCE 32
     * }
     */
    public static int Py_TPFLAGS_SEQUENCE() {
        return Py_TPFLAGS_SEQUENCE;
    }
    private static final int Py_TPFLAGS_MAPPING = (int)64L;
    /**
     * {@snippet lang=c :
     * #define Py_TPFLAGS_MAPPING 64
     * }
     */
    public static int Py_TPFLAGS_MAPPING() {
        return Py_TPFLAGS_MAPPING;
    }
    private static final int Py_TPFLAGS_DISALLOW_INSTANTIATION = (int)128L;
    /**
     * {@snippet lang=c :
     * #define Py_TPFLAGS_DISALLOW_INSTANTIATION 128
     * }
     */
    public static int Py_TPFLAGS_DISALLOW_INSTANTIATION() {
        return Py_TPFLAGS_DISALLOW_INSTANTIATION;
    }
    private static final int Py_TPFLAGS_IMMUTABLETYPE = (int)256L;
    /**
     * {@snippet lang=c :
     * #define Py_TPFLAGS_IMMUTABLETYPE 256
     * }
     */
    public static int Py_TPFLAGS_IMMUTABLETYPE() {
        return Py_TPFLAGS_IMMUTABLETYPE;
    }
    private static final int Py_TPFLAGS_HEAPTYPE = (int)512L;
    /**
     * {@snippet lang=c :
     * #define Py_TPFLAGS_HEAPTYPE 512
     * }
     */
    public static int Py_TPFLAGS_HEAPTYPE() {
        return Py_TPFLAGS_HEAPTYPE;
    }
    private static final int Py_TPFLAGS_BASETYPE = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define Py_TPFLAGS_BASETYPE 1024
     * }
     */
    public static int Py_TPFLAGS_BASETYPE() {
        return Py_TPFLAGS_BASETYPE;
    }
    private static final int Py_TPFLAGS_HAVE_VECTORCALL = (int)2048L;
    /**
     * {@snippet lang=c :
     * #define Py_TPFLAGS_HAVE_VECTORCALL 2048
     * }
     */
    public static int Py_TPFLAGS_HAVE_VECTORCALL() {
        return Py_TPFLAGS_HAVE_VECTORCALL;
    }
    private static final int _Py_TPFLAGS_HAVE_VECTORCALL = (int)2048L;
    /**
     * {@snippet lang=c :
     * #define _Py_TPFLAGS_HAVE_VECTORCALL 2048
     * }
     */
    public static int _Py_TPFLAGS_HAVE_VECTORCALL() {
        return _Py_TPFLAGS_HAVE_VECTORCALL;
    }
    private static final int Py_TPFLAGS_READY = (int)4096L;
    /**
     * {@snippet lang=c :
     * #define Py_TPFLAGS_READY 4096
     * }
     */
    public static int Py_TPFLAGS_READY() {
        return Py_TPFLAGS_READY;
    }
    private static final int Py_TPFLAGS_READYING = (int)8192L;
    /**
     * {@snippet lang=c :
     * #define Py_TPFLAGS_READYING 8192
     * }
     */
    public static int Py_TPFLAGS_READYING() {
        return Py_TPFLAGS_READYING;
    }
    private static final int Py_TPFLAGS_HAVE_GC = (int)16384L;
    /**
     * {@snippet lang=c :
     * #define Py_TPFLAGS_HAVE_GC 16384
     * }
     */
    public static int Py_TPFLAGS_HAVE_GC() {
        return Py_TPFLAGS_HAVE_GC;
    }
    private static final int Py_TPFLAGS_METHOD_DESCRIPTOR = (int)131072L;
    /**
     * {@snippet lang=c :
     * #define Py_TPFLAGS_METHOD_DESCRIPTOR 131072
     * }
     */
    public static int Py_TPFLAGS_METHOD_DESCRIPTOR() {
        return Py_TPFLAGS_METHOD_DESCRIPTOR;
    }
    private static final int Py_TPFLAGS_VALID_VERSION_TAG = (int)524288L;
    /**
     * {@snippet lang=c :
     * #define Py_TPFLAGS_VALID_VERSION_TAG 524288
     * }
     */
    public static int Py_TPFLAGS_VALID_VERSION_TAG() {
        return Py_TPFLAGS_VALID_VERSION_TAG;
    }
    private static final int Py_TPFLAGS_IS_ABSTRACT = (int)1048576L;
    /**
     * {@snippet lang=c :
     * #define Py_TPFLAGS_IS_ABSTRACT 1048576
     * }
     */
    public static int Py_TPFLAGS_IS_ABSTRACT() {
        return Py_TPFLAGS_IS_ABSTRACT;
    }
    private static final int _Py_TPFLAGS_MATCH_SELF = (int)4194304L;
    /**
     * {@snippet lang=c :
     * #define _Py_TPFLAGS_MATCH_SELF 4194304
     * }
     */
    public static int _Py_TPFLAGS_MATCH_SELF() {
        return _Py_TPFLAGS_MATCH_SELF;
    }
    private static final int Py_TPFLAGS_ITEMS_AT_END = (int)8388608L;
    /**
     * {@snippet lang=c :
     * #define Py_TPFLAGS_ITEMS_AT_END 8388608
     * }
     */
    public static int Py_TPFLAGS_ITEMS_AT_END() {
        return Py_TPFLAGS_ITEMS_AT_END;
    }
    private static final int Py_TPFLAGS_LONG_SUBCLASS = (int)16777216L;
    /**
     * {@snippet lang=c :
     * #define Py_TPFLAGS_LONG_SUBCLASS 16777216
     * }
     */
    public static int Py_TPFLAGS_LONG_SUBCLASS() {
        return Py_TPFLAGS_LONG_SUBCLASS;
    }
    private static final int Py_TPFLAGS_LIST_SUBCLASS = (int)33554432L;
    /**
     * {@snippet lang=c :
     * #define Py_TPFLAGS_LIST_SUBCLASS 33554432
     * }
     */
    public static int Py_TPFLAGS_LIST_SUBCLASS() {
        return Py_TPFLAGS_LIST_SUBCLASS;
    }
    private static final int Py_TPFLAGS_TUPLE_SUBCLASS = (int)67108864L;
    /**
     * {@snippet lang=c :
     * #define Py_TPFLAGS_TUPLE_SUBCLASS 67108864
     * }
     */
    public static int Py_TPFLAGS_TUPLE_SUBCLASS() {
        return Py_TPFLAGS_TUPLE_SUBCLASS;
    }
    private static final int Py_TPFLAGS_BYTES_SUBCLASS = (int)134217728L;
    /**
     * {@snippet lang=c :
     * #define Py_TPFLAGS_BYTES_SUBCLASS 134217728
     * }
     */
    public static int Py_TPFLAGS_BYTES_SUBCLASS() {
        return Py_TPFLAGS_BYTES_SUBCLASS;
    }
    private static final int Py_TPFLAGS_UNICODE_SUBCLASS = (int)268435456L;
    /**
     * {@snippet lang=c :
     * #define Py_TPFLAGS_UNICODE_SUBCLASS 268435456
     * }
     */
    public static int Py_TPFLAGS_UNICODE_SUBCLASS() {
        return Py_TPFLAGS_UNICODE_SUBCLASS;
    }
    private static final int Py_TPFLAGS_DICT_SUBCLASS = (int)536870912L;
    /**
     * {@snippet lang=c :
     * #define Py_TPFLAGS_DICT_SUBCLASS 536870912
     * }
     */
    public static int Py_TPFLAGS_DICT_SUBCLASS() {
        return Py_TPFLAGS_DICT_SUBCLASS;
    }
    private static final int Py_TPFLAGS_BASE_EXC_SUBCLASS = (int)1073741824L;
    /**
     * {@snippet lang=c :
     * #define Py_TPFLAGS_BASE_EXC_SUBCLASS 1073741824
     * }
     */
    public static int Py_TPFLAGS_BASE_EXC_SUBCLASS() {
        return Py_TPFLAGS_BASE_EXC_SUBCLASS;
    }
    private static final int Py_TPFLAGS_TYPE_SUBCLASS = (int)2147483648L;
    /**
     * {@snippet lang=c :
     * #define Py_TPFLAGS_TYPE_SUBCLASS 2147483648
     * }
     */
    public static int Py_TPFLAGS_TYPE_SUBCLASS() {
        return Py_TPFLAGS_TYPE_SUBCLASS;
    }
    private static final int Py_TPFLAGS_DEFAULT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define Py_TPFLAGS_DEFAULT 0
     * }
     */
    public static int Py_TPFLAGS_DEFAULT() {
        return Py_TPFLAGS_DEFAULT;
    }
    private static final int Py_TPFLAGS_HAVE_FINALIZE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define Py_TPFLAGS_HAVE_FINALIZE 1
     * }
     */
    public static int Py_TPFLAGS_HAVE_FINALIZE() {
        return Py_TPFLAGS_HAVE_FINALIZE;
    }
    private static final int Py_TPFLAGS_HAVE_VERSION_TAG = (int)262144L;
    /**
     * {@snippet lang=c :
     * #define Py_TPFLAGS_HAVE_VERSION_TAG 262144
     * }
     */
    public static int Py_TPFLAGS_HAVE_VERSION_TAG() {
        return Py_TPFLAGS_HAVE_VERSION_TAG;
    }
    private static final int _PyHASH_MULTIPLIER = (int)1000003L;
    /**
     * {@snippet lang=c :
     * #define _PyHASH_MULTIPLIER 1000003
     * }
     */
    public static int _PyHASH_MULTIPLIER() {
        return _PyHASH_MULTIPLIER;
    }
    private static final long _PyHASH_MODULUS = 2305843009213693951L;
    /**
     * {@snippet lang=c :
     * #define _PyHASH_MODULUS 2305843009213693951
     * }
     */
    public static long _PyHASH_MODULUS() {
        return _PyHASH_MODULUS;
    }
    private static final int _PyHASH_IMAG = (int)1000003L;
    /**
     * {@snippet lang=c :
     * #define _PyHASH_IMAG 1000003
     * }
     */
    public static int _PyHASH_IMAG() {
        return _PyHASH_IMAG;
    }
    private static final int Py_HASH_ALGORITHM = (int)3L;
    /**
     * {@snippet lang=c :
     * #define Py_HASH_ALGORITHM 3
     * }
     */
    public static int Py_HASH_ALGORITHM() {
        return Py_HASH_ALGORITHM;
    }
    private static final int Py_UNICODE_SIZE = (int)2L;
    /**
     * {@snippet lang=c :
     * #define Py_UNICODE_SIZE 2
     * }
     */
    public static int Py_UNICODE_SIZE() {
        return Py_UNICODE_SIZE;
    }
    private static final int Py_UNICODE_REPLACEMENT_CHARACTER = (int)65533L;
    /**
     * {@snippet lang=c :
     * #define Py_UNICODE_REPLACEMENT_CHARACTER 65533
     * }
     */
    public static int Py_UNICODE_REPLACEMENT_CHARACTER() {
        return Py_UNICODE_REPLACEMENT_CHARACTER;
    }
    /**
     * {@snippet lang=c :
     * #define _Py_PARSE_PID "i"
     * }
     */
    public static MemorySegment _Py_PARSE_PID() {
        class Holder {
            static final MemorySegment _Py_PARSE_PID
                = Python_h.LIBRARY_ARENA.allocateFrom("i");
        }
        return Holder._Py_PARSE_PID;
    }
    /**
     * {@snippet lang=c :
     * #define _Py_PARSE_INTPTR "L"
     * }
     */
    public static MemorySegment _Py_PARSE_INTPTR() {
        class Holder {
            static final MemorySegment _Py_PARSE_INTPTR
                = Python_h.LIBRARY_ARENA.allocateFrom("L");
        }
        return Holder._Py_PARSE_INTPTR;
    }
    /**
     * {@snippet lang=c :
     * #define _Py_PARSE_UINTPTR "K"
     * }
     */
    public static MemorySegment _Py_PARSE_UINTPTR() {
        class Holder {
            static final MemorySegment _Py_PARSE_UINTPTR
                = Python_h.LIBRARY_ARENA.allocateFrom("K");
        }
        return Holder._Py_PARSE_UINTPTR;
    }
    private static final int _PyLong_DECIMAL_BASE = (int)1000000000L;
    /**
     * {@snippet lang=c :
     * #define _PyLong_DECIMAL_BASE 1000000000
     * }
     */
    public static int _PyLong_DECIMAL_BASE() {
        return _PyLong_DECIMAL_BASE;
    }
    private static final int PyLong_BASE = (int)1073741824L;
    /**
     * {@snippet lang=c :
     * #define PyLong_BASE 1073741824
     * }
     */
    public static int PyLong_BASE() {
        return PyLong_BASE;
    }
    private static final int PyLong_MASK = (int)1073741823L;
    /**
     * {@snippet lang=c :
     * #define PyLong_MASK 1073741823
     * }
     */
    public static int PyLong_MASK() {
        return PyLong_MASK;
    }
    private static final MemorySegment Py_MOD_MULTIPLE_INTERPRETERS_NOT_SUPPORTED = MemorySegment.ofAddress(0L);
    /**
     * {@snippet lang=c :
     * #define Py_MOD_MULTIPLE_INTERPRETERS_NOT_SUPPORTED (void*) 0
     * }
     */
    public static MemorySegment Py_MOD_MULTIPLE_INTERPRETERS_NOT_SUPPORTED() {
        return Py_MOD_MULTIPLE_INTERPRETERS_NOT_SUPPORTED;
    }
    private static final MemorySegment Py_MOD_MULTIPLE_INTERPRETERS_SUPPORTED = MemorySegment.ofAddress(1L);
    /**
     * {@snippet lang=c :
     * #define Py_MOD_MULTIPLE_INTERPRETERS_SUPPORTED (void*) 1
     * }
     */
    public static MemorySegment Py_MOD_MULTIPLE_INTERPRETERS_SUPPORTED() {
        return Py_MOD_MULTIPLE_INTERPRETERS_SUPPORTED;
    }
    private static final MemorySegment Py_MOD_PER_INTERPRETER_GIL_SUPPORTED = MemorySegment.ofAddress(2L);
    /**
     * {@snippet lang=c :
     * #define Py_MOD_PER_INTERPRETER_GIL_SUPPORTED (void*) 2
     * }
     */
    public static MemorySegment Py_MOD_PER_INTERPRETER_GIL_SUPPORTED() {
        return Py_MOD_PER_INTERPRETER_GIL_SUPPORTED;
    }
    /**
     * {@snippet lang=c :
     * #define PY_STDIOTEXTMODE "b"
     * }
     */
    public static MemorySegment PY_STDIOTEXTMODE() {
        class Holder {
            static final MemorySegment PY_STDIOTEXTMODE
                = Python_h.LIBRARY_ARENA.allocateFrom("b");
        }
        return Holder.PY_STDIOTEXTMODE;
    }
    private static final int Py_RTFLAGS_USE_MAIN_OBMALLOC = (int)32L;
    /**
     * {@snippet lang=c :
     * #define Py_RTFLAGS_USE_MAIN_OBMALLOC 32
     * }
     */
    public static int Py_RTFLAGS_USE_MAIN_OBMALLOC() {
        return Py_RTFLAGS_USE_MAIN_OBMALLOC;
    }
    private static final int Py_RTFLAGS_MULTI_INTERP_EXTENSIONS = (int)256L;
    /**
     * {@snippet lang=c :
     * #define Py_RTFLAGS_MULTI_INTERP_EXTENSIONS 256
     * }
     */
    public static int Py_RTFLAGS_MULTI_INTERP_EXTENSIONS() {
        return Py_RTFLAGS_MULTI_INTERP_EXTENSIONS;
    }
    private static final int Py_RTFLAGS_THREADS = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define Py_RTFLAGS_THREADS 1024
     * }
     */
    public static int Py_RTFLAGS_THREADS() {
        return Py_RTFLAGS_THREADS;
    }
    private static final int Py_RTFLAGS_DAEMON_THREADS = (int)2048L;
    /**
     * {@snippet lang=c :
     * #define Py_RTFLAGS_DAEMON_THREADS 2048
     * }
     */
    public static int Py_RTFLAGS_DAEMON_THREADS() {
        return Py_RTFLAGS_DAEMON_THREADS;
    }
    private static final int Py_RTFLAGS_FORK = (int)32768L;
    /**
     * {@snippet lang=c :
     * #define Py_RTFLAGS_FORK 32768
     * }
     */
    public static int Py_RTFLAGS_FORK() {
        return Py_RTFLAGS_FORK;
    }
    private static final int Py_RTFLAGS_EXEC = (int)65536L;
    /**
     * {@snippet lang=c :
     * #define Py_RTFLAGS_EXEC 65536
     * }
     */
    public static int Py_RTFLAGS_EXEC() {
        return Py_RTFLAGS_EXEC;
    }
    private static final long _PyTime_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define _PyTime_MIN -9223372036854775808
     * }
     */
    public static long _PyTime_MIN() {
        return _PyTime_MIN;
    }
    private static final long _PyTime_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define _PyTime_MAX 9223372036854775807
     * }
     */
    public static long _PyTime_MAX() {
        return _PyTime_MAX;
    }
    private static final long PY_TIMEOUT_MAX = 4294967294000L;
    /**
     * {@snippet lang=c :
     * #define PY_TIMEOUT_MAX 4294967294000
     * }
     */
    public static long PY_TIMEOUT_MAX() {
        return PY_TIMEOUT_MAX;
    }
    private static final int PYTHREAD_INVALID_THREAD_ID = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define PYTHREAD_INVALID_THREAD_ID 4294967295
     * }
     */
    public static int PYTHREAD_INVALID_THREAD_ID() {
        return PYTHREAD_INVALID_THREAD_ID;
    }
    /**
     * {@snippet lang=c :
     * #define PYTHON_API_STRING "1013"
     * }
     */
    public static MemorySegment PYTHON_API_STRING() {
        class Holder {
            static final MemorySegment PYTHON_API_STRING
                = Python_h.LIBRARY_ARENA.allocateFrom("1013");
        }
        return Holder.PYTHON_API_STRING;
    }
    /**
     * {@snippet lang=c :
     * #define PYTHON_ABI_STRING "3"
     * }
     */
    public static MemorySegment PYTHON_ABI_STRING() {
        class Holder {
            static final MemorySegment PYTHON_ABI_STRING
                = Python_h.LIBRARY_ARENA.allocateFrom("3");
        }
        return Holder.PYTHON_ABI_STRING;
    }
    private static final int PyCF_MASK = (int)33423360L;
    /**
     * {@snippet lang=c :
     * #define PyCF_MASK 33423360
     * }
     */
    public static int PyCF_MASK() {
        return PyCF_MASK;
    }
    private static final int PyCF_MASK_OBSOLETE = (int)16L;
    /**
     * {@snippet lang=c :
     * #define PyCF_MASK_OBSOLETE 16
     * }
     */
    public static int PyCF_MASK_OBSOLETE() {
        return PyCF_MASK_OBSOLETE;
    }
    private static final int PyCF_COMPILE_MASK = (int)30208L;
    /**
     * {@snippet lang=c :
     * #define PyCF_COMPILE_MASK 30208
     * }
     */
    public static int PyCF_COMPILE_MASK() {
        return PyCF_COMPILE_MASK;
    }
    /**
     * {@snippet lang=c :
     * #define FUTURE_NESTED_SCOPES "nested_scopes"
     * }
     */
    public static MemorySegment FUTURE_NESTED_SCOPES() {
        class Holder {
            static final MemorySegment FUTURE_NESTED_SCOPES
                = Python_h.LIBRARY_ARENA.allocateFrom("nested_scopes");
        }
        return Holder.FUTURE_NESTED_SCOPES;
    }
    /**
     * {@snippet lang=c :
     * #define FUTURE_GENERATORS "generators"
     * }
     */
    public static MemorySegment FUTURE_GENERATORS() {
        class Holder {
            static final MemorySegment FUTURE_GENERATORS
                = Python_h.LIBRARY_ARENA.allocateFrom("generators");
        }
        return Holder.FUTURE_GENERATORS;
    }
    /**
     * {@snippet lang=c :
     * #define FUTURE_DIVISION "division"
     * }
     */
    public static MemorySegment FUTURE_DIVISION() {
        class Holder {
            static final MemorySegment FUTURE_DIVISION
                = Python_h.LIBRARY_ARENA.allocateFrom("division");
        }
        return Holder.FUTURE_DIVISION;
    }
    /**
     * {@snippet lang=c :
     * #define FUTURE_ABSOLUTE_IMPORT "absolute_import"
     * }
     */
    public static MemorySegment FUTURE_ABSOLUTE_IMPORT() {
        class Holder {
            static final MemorySegment FUTURE_ABSOLUTE_IMPORT
                = Python_h.LIBRARY_ARENA.allocateFrom("absolute_import");
        }
        return Holder.FUTURE_ABSOLUTE_IMPORT;
    }
    /**
     * {@snippet lang=c :
     * #define FUTURE_WITH_STATEMENT "with_statement"
     * }
     */
    public static MemorySegment FUTURE_WITH_STATEMENT() {
        class Holder {
            static final MemorySegment FUTURE_WITH_STATEMENT
                = Python_h.LIBRARY_ARENA.allocateFrom("with_statement");
        }
        return Holder.FUTURE_WITH_STATEMENT;
    }
    /**
     * {@snippet lang=c :
     * #define FUTURE_PRINT_FUNCTION "print_function"
     * }
     */
    public static MemorySegment FUTURE_PRINT_FUNCTION() {
        class Holder {
            static final MemorySegment FUTURE_PRINT_FUNCTION
                = Python_h.LIBRARY_ARENA.allocateFrom("print_function");
        }
        return Holder.FUTURE_PRINT_FUNCTION;
    }
    /**
     * {@snippet lang=c :
     * #define FUTURE_UNICODE_LITERALS "unicode_literals"
     * }
     */
    public static MemorySegment FUTURE_UNICODE_LITERALS() {
        class Holder {
            static final MemorySegment FUTURE_UNICODE_LITERALS
                = Python_h.LIBRARY_ARENA.allocateFrom("unicode_literals");
        }
        return Holder.FUTURE_UNICODE_LITERALS;
    }
    /**
     * {@snippet lang=c :
     * #define FUTURE_BARRY_AS_BDFL "barry_as_FLUFL"
     * }
     */
    public static MemorySegment FUTURE_BARRY_AS_BDFL() {
        class Holder {
            static final MemorySegment FUTURE_BARRY_AS_BDFL
                = Python_h.LIBRARY_ARENA.allocateFrom("barry_as_FLUFL");
        }
        return Holder.FUTURE_BARRY_AS_BDFL;
    }
    /**
     * {@snippet lang=c :
     * #define FUTURE_GENERATOR_STOP "generator_stop"
     * }
     */
    public static MemorySegment FUTURE_GENERATOR_STOP() {
        class Holder {
            static final MemorySegment FUTURE_GENERATOR_STOP
                = Python_h.LIBRARY_ARENA.allocateFrom("generator_stop");
        }
        return Holder.FUTURE_GENERATOR_STOP;
    }
    /**
     * {@snippet lang=c :
     * #define FUTURE_ANNOTATIONS "annotations"
     * }
     */
    public static MemorySegment FUTURE_ANNOTATIONS() {
        class Holder {
            static final MemorySegment FUTURE_ANNOTATIONS
                = Python_h.LIBRARY_ARENA.allocateFrom("annotations");
        }
        return Holder.FUTURE_ANNOTATIONS;
    }
    private static final int PY_INVALID_STACK_EFFECT = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define PY_INVALID_STACK_EFFECT 2147483647
     * }
     */
    public static int PY_INVALID_STACK_EFFECT() {
        return PY_INVALID_STACK_EFFECT;
    }
    private static final int PyInterpreterConfig_DEFAULT_GIL = (int)0L;
    /**
     * {@snippet lang=c :
     * #define PyInterpreterConfig_DEFAULT_GIL 0
     * }
     */
    public static int PyInterpreterConfig_DEFAULT_GIL() {
        return PyInterpreterConfig_DEFAULT_GIL;
    }
    private static final int PyInterpreterConfig_SHARED_GIL = (int)1L;
    /**
     * {@snippet lang=c :
     * #define PyInterpreterConfig_SHARED_GIL 1
     * }
     */
    public static int PyInterpreterConfig_SHARED_GIL() {
        return PyInterpreterConfig_SHARED_GIL;
    }
    private static final int PyInterpreterConfig_OWN_GIL = (int)2L;
    /**
     * {@snippet lang=c :
     * #define PyInterpreterConfig_OWN_GIL 2
     * }
     */
    public static int PyInterpreterConfig_OWN_GIL() {
        return PyInterpreterConfig_OWN_GIL;
    }
    private static final long PY_VECTORCALL_ARGUMENTS_OFFSET = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define PY_VECTORCALL_ARGUMENTS_OFFSET -9223372036854775808
     * }
     */
    public static long PY_VECTORCALL_ARGUMENTS_OFFSET() {
        return PY_VECTORCALL_ARGUMENTS_OFFSET;
    }
    private static final int PY_CTF_ALPHA = (int)3L;
    /**
     * {@snippet lang=c :
     * #define PY_CTF_ALPHA 3
     * }
     */
    public static int PY_CTF_ALPHA() {
        return PY_CTF_ALPHA;
    }
    private static final int PY_CTF_ALNUM = (int)7L;
    /**
     * {@snippet lang=c :
     * #define PY_CTF_ALNUM 7
     * }
     */
    public static int PY_CTF_ALNUM() {
        return PY_CTF_ALNUM;
    }
}

