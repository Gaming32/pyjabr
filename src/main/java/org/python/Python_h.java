// Generated by jextract

package org.python;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

public class Python_h extends Python_h_1 {

    Python_h() {
        // Should not be called directly
    }

    private static class PyModule_AddObjectRef {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyModule_AddObjectRef");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyModule_AddObjectRef(PyObject *mod, const char *name, PyObject *value)
     * }
     */
    public static FunctionDescriptor PyModule_AddObjectRef$descriptor() {
        return PyModule_AddObjectRef.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyModule_AddObjectRef(PyObject *mod, const char *name, PyObject *value)
     * }
     */
    public static MethodHandle PyModule_AddObjectRef$handle() {
        return PyModule_AddObjectRef.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyModule_AddObjectRef(PyObject *mod, const char *name, PyObject *value)
     * }
     */
    public static MemorySegment PyModule_AddObjectRef$address() {
        return PyModule_AddObjectRef.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyModule_AddObjectRef(PyObject *mod, const char *name, PyObject *value)
     * }
     */
    public static int PyModule_AddObjectRef(MemorySegment mod, MemorySegment name, MemorySegment value) {
        var mh$ = PyModule_AddObjectRef.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyModule_AddObjectRef", mod, name, value);
            }
            return (int)mh$.invokeExact(mod, name, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyModule_AddObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyModule_AddObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyModule_AddObject(PyObject *mod, const char *, PyObject *value)
     * }
     */
    public static FunctionDescriptor PyModule_AddObject$descriptor() {
        return PyModule_AddObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyModule_AddObject(PyObject *mod, const char *, PyObject *value)
     * }
     */
    public static MethodHandle PyModule_AddObject$handle() {
        return PyModule_AddObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyModule_AddObject(PyObject *mod, const char *, PyObject *value)
     * }
     */
    public static MemorySegment PyModule_AddObject$address() {
        return PyModule_AddObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyModule_AddObject(PyObject *mod, const char *, PyObject *value)
     * }
     */
    public static int PyModule_AddObject(MemorySegment mod, MemorySegment x1, MemorySegment value) {
        var mh$ = PyModule_AddObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyModule_AddObject", mod, x1, value);
            }
            return (int)mh$.invokeExact(mod, x1, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyModule_AddIntConstant {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyModule_AddIntConstant");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyModule_AddIntConstant(PyObject *, const char *, long)
     * }
     */
    public static FunctionDescriptor PyModule_AddIntConstant$descriptor() {
        return PyModule_AddIntConstant.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyModule_AddIntConstant(PyObject *, const char *, long)
     * }
     */
    public static MethodHandle PyModule_AddIntConstant$handle() {
        return PyModule_AddIntConstant.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyModule_AddIntConstant(PyObject *, const char *, long)
     * }
     */
    public static MemorySegment PyModule_AddIntConstant$address() {
        return PyModule_AddIntConstant.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyModule_AddIntConstant(PyObject *, const char *, long)
     * }
     */
    public static int PyModule_AddIntConstant(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = PyModule_AddIntConstant.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyModule_AddIntConstant", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyModule_AddStringConstant {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyModule_AddStringConstant");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyModule_AddStringConstant(PyObject *, const char *, const char *)
     * }
     */
    public static FunctionDescriptor PyModule_AddStringConstant$descriptor() {
        return PyModule_AddStringConstant.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyModule_AddStringConstant(PyObject *, const char *, const char *)
     * }
     */
    public static MethodHandle PyModule_AddStringConstant$handle() {
        return PyModule_AddStringConstant.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyModule_AddStringConstant(PyObject *, const char *, const char *)
     * }
     */
    public static MemorySegment PyModule_AddStringConstant$address() {
        return PyModule_AddStringConstant.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyModule_AddStringConstant(PyObject *, const char *, const char *)
     * }
     */
    public static int PyModule_AddStringConstant(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = PyModule_AddStringConstant.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyModule_AddStringConstant", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyModule_AddType {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyModule_AddType");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyModule_AddType(PyObject *module, PyTypeObject *type)
     * }
     */
    public static FunctionDescriptor PyModule_AddType$descriptor() {
        return PyModule_AddType.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyModule_AddType(PyObject *module, PyTypeObject *type)
     * }
     */
    public static MethodHandle PyModule_AddType$handle() {
        return PyModule_AddType.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyModule_AddType(PyObject *module, PyTypeObject *type)
     * }
     */
    public static MemorySegment PyModule_AddType$address() {
        return PyModule_AddType.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyModule_AddType(PyObject *module, PyTypeObject *type)
     * }
     */
    public static int PyModule_AddType(MemorySegment module, MemorySegment type) {
        var mh$ = PyModule_AddType.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyModule_AddType", module, type);
            }
            return (int)mh$.invokeExact(module, type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyModule_SetDocString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyModule_SetDocString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyModule_SetDocString(PyObject *, const char *)
     * }
     */
    public static FunctionDescriptor PyModule_SetDocString$descriptor() {
        return PyModule_SetDocString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyModule_SetDocString(PyObject *, const char *)
     * }
     */
    public static MethodHandle PyModule_SetDocString$handle() {
        return PyModule_SetDocString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyModule_SetDocString(PyObject *, const char *)
     * }
     */
    public static MemorySegment PyModule_SetDocString$address() {
        return PyModule_SetDocString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyModule_SetDocString(PyObject *, const char *)
     * }
     */
    public static int PyModule_SetDocString(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyModule_SetDocString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyModule_SetDocString", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyModule_AddFunctions {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyModule_AddFunctions");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyModule_AddFunctions(PyObject *, PyMethodDef *)
     * }
     */
    public static FunctionDescriptor PyModule_AddFunctions$descriptor() {
        return PyModule_AddFunctions.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyModule_AddFunctions(PyObject *, PyMethodDef *)
     * }
     */
    public static MethodHandle PyModule_AddFunctions$handle() {
        return PyModule_AddFunctions.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyModule_AddFunctions(PyObject *, PyMethodDef *)
     * }
     */
    public static MemorySegment PyModule_AddFunctions$address() {
        return PyModule_AddFunctions.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyModule_AddFunctions(PyObject *, PyMethodDef *)
     * }
     */
    public static int PyModule_AddFunctions(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyModule_AddFunctions.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyModule_AddFunctions", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyModule_ExecDef {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyModule_ExecDef");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyModule_ExecDef(PyObject *module, PyModuleDef *def)
     * }
     */
    public static FunctionDescriptor PyModule_ExecDef$descriptor() {
        return PyModule_ExecDef.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyModule_ExecDef(PyObject *module, PyModuleDef *def)
     * }
     */
    public static MethodHandle PyModule_ExecDef$handle() {
        return PyModule_ExecDef.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyModule_ExecDef(PyObject *module, PyModuleDef *def)
     * }
     */
    public static MemorySegment PyModule_ExecDef$address() {
        return PyModule_ExecDef.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyModule_ExecDef(PyObject *module, PyModuleDef *def)
     * }
     */
    public static int PyModule_ExecDef(MemorySegment module, MemorySegment def) {
        var mh$ = PyModule_ExecDef.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyModule_ExecDef", module, def);
            }
            return (int)mh$.invokeExact(module, def);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyModule_Create2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyModule_Create2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyModule_Create2(PyModuleDef *, int apiver)
     * }
     */
    public static FunctionDescriptor PyModule_Create2$descriptor() {
        return PyModule_Create2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyModule_Create2(PyModuleDef *, int apiver)
     * }
     */
    public static MethodHandle PyModule_Create2$handle() {
        return PyModule_Create2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyModule_Create2(PyModuleDef *, int apiver)
     * }
     */
    public static MemorySegment PyModule_Create2$address() {
        return PyModule_Create2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyModule_Create2(PyModuleDef *, int apiver)
     * }
     */
    public static MemorySegment PyModule_Create2(MemorySegment x0, int apiver) {
        var mh$ = PyModule_Create2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyModule_Create2", x0, apiver);
            }
            return (MemorySegment)mh$.invokeExact(x0, apiver);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyModule_FromDefAndSpec2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyModule_FromDefAndSpec2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyModule_FromDefAndSpec2(PyModuleDef *def, PyObject *spec, int module_api_version)
     * }
     */
    public static FunctionDescriptor PyModule_FromDefAndSpec2$descriptor() {
        return PyModule_FromDefAndSpec2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyModule_FromDefAndSpec2(PyModuleDef *def, PyObject *spec, int module_api_version)
     * }
     */
    public static MethodHandle PyModule_FromDefAndSpec2$handle() {
        return PyModule_FromDefAndSpec2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyModule_FromDefAndSpec2(PyModuleDef *def, PyObject *spec, int module_api_version)
     * }
     */
    public static MemorySegment PyModule_FromDefAndSpec2$address() {
        return PyModule_FromDefAndSpec2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyModule_FromDefAndSpec2(PyModuleDef *def, PyObject *spec, int module_api_version)
     * }
     */
    public static MemorySegment PyModule_FromDefAndSpec2(MemorySegment def, MemorySegment spec, int module_api_version) {
        var mh$ = PyModule_FromDefAndSpec2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyModule_FromDefAndSpec2", def, spec, module_api_version);
            }
            return (MemorySegment)mh$.invokeExact(def, spec, module_api_version);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_CompileString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_CompileString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *Py_CompileString(const char *, const char *, int)
     * }
     */
    public static FunctionDescriptor Py_CompileString$descriptor() {
        return Py_CompileString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *Py_CompileString(const char *, const char *, int)
     * }
     */
    public static MethodHandle Py_CompileString$handle() {
        return Py_CompileString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *Py_CompileString(const char *, const char *, int)
     * }
     */
    public static MemorySegment Py_CompileString$address() {
        return Py_CompileString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *Py_CompileString(const char *, const char *, int)
     * }
     */
    public static MemorySegment Py_CompileString(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = Py_CompileString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_CompileString", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyErr_Print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_Print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyErr_Print()
     * }
     */
    public static FunctionDescriptor PyErr_Print$descriptor() {
        return PyErr_Print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyErr_Print()
     * }
     */
    public static MethodHandle PyErr_Print$handle() {
        return PyErr_Print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyErr_Print()
     * }
     */
    public static MemorySegment PyErr_Print$address() {
        return PyErr_Print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyErr_Print()
     * }
     */
    public static void PyErr_Print() {
        var mh$ = PyErr_Print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyErr_Print");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyErr_PrintEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_PrintEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyErr_PrintEx(int)
     * }
     */
    public static FunctionDescriptor PyErr_PrintEx$descriptor() {
        return PyErr_PrintEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyErr_PrintEx(int)
     * }
     */
    public static MethodHandle PyErr_PrintEx$handle() {
        return PyErr_PrintEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyErr_PrintEx(int)
     * }
     */
    public static MemorySegment PyErr_PrintEx$address() {
        return PyErr_PrintEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyErr_PrintEx(int)
     * }
     */
    public static void PyErr_PrintEx(int x0) {
        var mh$ = PyErr_PrintEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyErr_PrintEx", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyErr_Display {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_Display");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyErr_Display(PyObject *, PyObject *, PyObject *)
     * }
     */
    public static FunctionDescriptor PyErr_Display$descriptor() {
        return PyErr_Display.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyErr_Display(PyObject *, PyObject *, PyObject *)
     * }
     */
    public static MethodHandle PyErr_Display$handle() {
        return PyErr_Display.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyErr_Display(PyObject *, PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyErr_Display$address() {
        return PyErr_Display.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyErr_Display(PyObject *, PyObject *, PyObject *)
     * }
     */
    public static void PyErr_Display(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = PyErr_Display.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyErr_Display", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyErr_DisplayException {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_DisplayException");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyErr_DisplayException(PyObject *)
     * }
     */
    public static FunctionDescriptor PyErr_DisplayException$descriptor() {
        return PyErr_DisplayException.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyErr_DisplayException(PyObject *)
     * }
     */
    public static MethodHandle PyErr_DisplayException$handle() {
        return PyErr_DisplayException.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyErr_DisplayException(PyObject *)
     * }
     */
    public static MemorySegment PyErr_DisplayException$address() {
        return PyErr_DisplayException.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyErr_DisplayException(PyObject *)
     * }
     */
    public static void PyErr_DisplayException(MemorySegment x0) {
        var mh$ = PyErr_DisplayException.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyErr_DisplayException", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyOS_InputHook$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyOS_InputHook").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int (*PyOS_InputHook)(void)
     * }
     */
    public static AddressLayout PyOS_InputHook$layout() {
        return PyOS_InputHook$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int (*PyOS_InputHook)(void)
     * }
     */
    public static MemorySegment PyOS_InputHook$segment() {
        return PyOS_InputHook$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int (*PyOS_InputHook)(void)
     * }
     */
    public static MemorySegment PyOS_InputHook() {
        return PyOS_InputHook$constants.SEGMENT.get(PyOS_InputHook$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int (*PyOS_InputHook)(void)
     * }
     */
    public static void PyOS_InputHook(MemorySegment varValue) {
        PyOS_InputHook$constants.SEGMENT.set(PyOS_InputHook$constants.LAYOUT, 0L, varValue);
    }

    private static class Py_Initialize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_Initialize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void Py_Initialize()
     * }
     */
    public static FunctionDescriptor Py_Initialize$descriptor() {
        return Py_Initialize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void Py_Initialize()
     * }
     */
    public static MethodHandle Py_Initialize$handle() {
        return Py_Initialize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void Py_Initialize()
     * }
     */
    public static MemorySegment Py_Initialize$address() {
        return Py_Initialize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void Py_Initialize()
     * }
     */
    public static void Py_Initialize() {
        var mh$ = Py_Initialize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_Initialize");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_InitializeEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_InitializeEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void Py_InitializeEx(int)
     * }
     */
    public static FunctionDescriptor Py_InitializeEx$descriptor() {
        return Py_InitializeEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void Py_InitializeEx(int)
     * }
     */
    public static MethodHandle Py_InitializeEx$handle() {
        return Py_InitializeEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void Py_InitializeEx(int)
     * }
     */
    public static MemorySegment Py_InitializeEx$address() {
        return Py_InitializeEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void Py_InitializeEx(int)
     * }
     */
    public static void Py_InitializeEx(int x0) {
        var mh$ = Py_InitializeEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_InitializeEx", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_Finalize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_Finalize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void Py_Finalize()
     * }
     */
    public static FunctionDescriptor Py_Finalize$descriptor() {
        return Py_Finalize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void Py_Finalize()
     * }
     */
    public static MethodHandle Py_Finalize$handle() {
        return Py_Finalize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void Py_Finalize()
     * }
     */
    public static MemorySegment Py_Finalize$address() {
        return Py_Finalize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void Py_Finalize()
     * }
     */
    public static void Py_Finalize() {
        var mh$ = Py_Finalize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_Finalize");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_FinalizeEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_FinalizeEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int Py_FinalizeEx()
     * }
     */
    public static FunctionDescriptor Py_FinalizeEx$descriptor() {
        return Py_FinalizeEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int Py_FinalizeEx()
     * }
     */
    public static MethodHandle Py_FinalizeEx$handle() {
        return Py_FinalizeEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int Py_FinalizeEx()
     * }
     */
    public static MemorySegment Py_FinalizeEx$address() {
        return Py_FinalizeEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int Py_FinalizeEx()
     * }
     */
    public static int Py_FinalizeEx() {
        var mh$ = Py_FinalizeEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_FinalizeEx");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_IsInitialized {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_IsInitialized");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int Py_IsInitialized()
     * }
     */
    public static FunctionDescriptor Py_IsInitialized$descriptor() {
        return Py_IsInitialized.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int Py_IsInitialized()
     * }
     */
    public static MethodHandle Py_IsInitialized$handle() {
        return Py_IsInitialized.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int Py_IsInitialized()
     * }
     */
    public static MemorySegment Py_IsInitialized$address() {
        return Py_IsInitialized.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int Py_IsInitialized()
     * }
     */
    public static int Py_IsInitialized() {
        var mh$ = Py_IsInitialized.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_IsInitialized");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_NewInterpreter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_NewInterpreter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyThreadState *Py_NewInterpreter()
     * }
     */
    public static FunctionDescriptor Py_NewInterpreter$descriptor() {
        return Py_NewInterpreter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyThreadState *Py_NewInterpreter()
     * }
     */
    public static MethodHandle Py_NewInterpreter$handle() {
        return Py_NewInterpreter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyThreadState *Py_NewInterpreter()
     * }
     */
    public static MemorySegment Py_NewInterpreter$address() {
        return Py_NewInterpreter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyThreadState *Py_NewInterpreter()
     * }
     */
    public static MemorySegment Py_NewInterpreter() {
        var mh$ = Py_NewInterpreter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_NewInterpreter");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_EndInterpreter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_EndInterpreter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void Py_EndInterpreter(PyThreadState *)
     * }
     */
    public static FunctionDescriptor Py_EndInterpreter$descriptor() {
        return Py_EndInterpreter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void Py_EndInterpreter(PyThreadState *)
     * }
     */
    public static MethodHandle Py_EndInterpreter$handle() {
        return Py_EndInterpreter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void Py_EndInterpreter(PyThreadState *)
     * }
     */
    public static MemorySegment Py_EndInterpreter$address() {
        return Py_EndInterpreter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void Py_EndInterpreter(PyThreadState *)
     * }
     */
    public static void Py_EndInterpreter(MemorySegment x0) {
        var mh$ = Py_EndInterpreter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_EndInterpreter", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_AtExit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_AtExit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int Py_AtExit(void (*func)(void))
     * }
     */
    public static FunctionDescriptor Py_AtExit$descriptor() {
        return Py_AtExit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int Py_AtExit(void (*func)(void))
     * }
     */
    public static MethodHandle Py_AtExit$handle() {
        return Py_AtExit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int Py_AtExit(void (*func)(void))
     * }
     */
    public static MemorySegment Py_AtExit$address() {
        return Py_AtExit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int Py_AtExit(void (*func)(void))
     * }
     */
    public static int Py_AtExit(MemorySegment func) {
        var mh$ = Py_AtExit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_AtExit", func);
            }
            return (int)mh$.invokeExact(func);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_Exit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_Exit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void Py_Exit(int)
     * }
     */
    public static FunctionDescriptor Py_Exit$descriptor() {
        return Py_Exit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void Py_Exit(int)
     * }
     */
    public static MethodHandle Py_Exit$handle() {
        return Py_Exit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void Py_Exit(int)
     * }
     */
    public static MemorySegment Py_Exit$address() {
        return Py_Exit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void Py_Exit(int)
     * }
     */
    public static void Py_Exit(int x0) {
        var mh$ = Py_Exit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_Exit", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_Main {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_Main");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int Py_Main(int argc, wchar_t **argv)
     * }
     */
    public static FunctionDescriptor Py_Main$descriptor() {
        return Py_Main.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int Py_Main(int argc, wchar_t **argv)
     * }
     */
    public static MethodHandle Py_Main$handle() {
        return Py_Main.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int Py_Main(int argc, wchar_t **argv)
     * }
     */
    public static MemorySegment Py_Main$address() {
        return Py_Main.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int Py_Main(int argc, wchar_t **argv)
     * }
     */
    public static int Py_Main(int argc, MemorySegment argv) {
        var mh$ = Py_Main.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_Main", argc, argv);
            }
            return (int)mh$.invokeExact(argc, argv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_BytesMain {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_BytesMain");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int Py_BytesMain(int argc, char **argv)
     * }
     */
    public static FunctionDescriptor Py_BytesMain$descriptor() {
        return Py_BytesMain.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int Py_BytesMain(int argc, char **argv)
     * }
     */
    public static MethodHandle Py_BytesMain$handle() {
        return Py_BytesMain.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int Py_BytesMain(int argc, char **argv)
     * }
     */
    public static MemorySegment Py_BytesMain$address() {
        return Py_BytesMain.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int Py_BytesMain(int argc, char **argv)
     * }
     */
    public static int Py_BytesMain(int argc, MemorySegment argv) {
        var mh$ = Py_BytesMain.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_BytesMain", argc, argv);
            }
            return (int)mh$.invokeExact(argc, argv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_SetProgramName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_SetProgramName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void Py_SetProgramName(const wchar_t *)
     * }
     */
    public static FunctionDescriptor Py_SetProgramName$descriptor() {
        return Py_SetProgramName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void Py_SetProgramName(const wchar_t *)
     * }
     */
    public static MethodHandle Py_SetProgramName$handle() {
        return Py_SetProgramName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void Py_SetProgramName(const wchar_t *)
     * }
     */
    public static MemorySegment Py_SetProgramName$address() {
        return Py_SetProgramName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void Py_SetProgramName(const wchar_t *)
     * }
     */
    public static void Py_SetProgramName(MemorySegment x0) {
        var mh$ = Py_SetProgramName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_SetProgramName", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_GetProgramName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_GetProgramName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *Py_GetProgramName()
     * }
     */
    public static FunctionDescriptor Py_GetProgramName$descriptor() {
        return Py_GetProgramName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *Py_GetProgramName()
     * }
     */
    public static MethodHandle Py_GetProgramName$handle() {
        return Py_GetProgramName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *Py_GetProgramName()
     * }
     */
    public static MemorySegment Py_GetProgramName$address() {
        return Py_GetProgramName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *Py_GetProgramName()
     * }
     */
    public static MemorySegment Py_GetProgramName() {
        var mh$ = Py_GetProgramName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_GetProgramName");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_SetPythonHome {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_SetPythonHome");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void Py_SetPythonHome(const wchar_t *)
     * }
     */
    public static FunctionDescriptor Py_SetPythonHome$descriptor() {
        return Py_SetPythonHome.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void Py_SetPythonHome(const wchar_t *)
     * }
     */
    public static MethodHandle Py_SetPythonHome$handle() {
        return Py_SetPythonHome.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void Py_SetPythonHome(const wchar_t *)
     * }
     */
    public static MemorySegment Py_SetPythonHome$address() {
        return Py_SetPythonHome.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void Py_SetPythonHome(const wchar_t *)
     * }
     */
    public static void Py_SetPythonHome(MemorySegment x0) {
        var mh$ = Py_SetPythonHome.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_SetPythonHome", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_GetPythonHome {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_GetPythonHome");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *Py_GetPythonHome()
     * }
     */
    public static FunctionDescriptor Py_GetPythonHome$descriptor() {
        return Py_GetPythonHome.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *Py_GetPythonHome()
     * }
     */
    public static MethodHandle Py_GetPythonHome$handle() {
        return Py_GetPythonHome.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *Py_GetPythonHome()
     * }
     */
    public static MemorySegment Py_GetPythonHome$address() {
        return Py_GetPythonHome.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *Py_GetPythonHome()
     * }
     */
    public static MemorySegment Py_GetPythonHome() {
        var mh$ = Py_GetPythonHome.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_GetPythonHome");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_GetProgramFullPath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_GetProgramFullPath");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *Py_GetProgramFullPath()
     * }
     */
    public static FunctionDescriptor Py_GetProgramFullPath$descriptor() {
        return Py_GetProgramFullPath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *Py_GetProgramFullPath()
     * }
     */
    public static MethodHandle Py_GetProgramFullPath$handle() {
        return Py_GetProgramFullPath.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *Py_GetProgramFullPath()
     * }
     */
    public static MemorySegment Py_GetProgramFullPath$address() {
        return Py_GetProgramFullPath.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *Py_GetProgramFullPath()
     * }
     */
    public static MemorySegment Py_GetProgramFullPath() {
        var mh$ = Py_GetProgramFullPath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_GetProgramFullPath");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_GetPrefix {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_GetPrefix");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *Py_GetPrefix()
     * }
     */
    public static FunctionDescriptor Py_GetPrefix$descriptor() {
        return Py_GetPrefix.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *Py_GetPrefix()
     * }
     */
    public static MethodHandle Py_GetPrefix$handle() {
        return Py_GetPrefix.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *Py_GetPrefix()
     * }
     */
    public static MemorySegment Py_GetPrefix$address() {
        return Py_GetPrefix.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *Py_GetPrefix()
     * }
     */
    public static MemorySegment Py_GetPrefix() {
        var mh$ = Py_GetPrefix.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_GetPrefix");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_GetExecPrefix {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_GetExecPrefix");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *Py_GetExecPrefix()
     * }
     */
    public static FunctionDescriptor Py_GetExecPrefix$descriptor() {
        return Py_GetExecPrefix.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *Py_GetExecPrefix()
     * }
     */
    public static MethodHandle Py_GetExecPrefix$handle() {
        return Py_GetExecPrefix.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *Py_GetExecPrefix()
     * }
     */
    public static MemorySegment Py_GetExecPrefix$address() {
        return Py_GetExecPrefix.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *Py_GetExecPrefix()
     * }
     */
    public static MemorySegment Py_GetExecPrefix() {
        var mh$ = Py_GetExecPrefix.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_GetExecPrefix");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_GetPath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_GetPath");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *Py_GetPath()
     * }
     */
    public static FunctionDescriptor Py_GetPath$descriptor() {
        return Py_GetPath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *Py_GetPath()
     * }
     */
    public static MethodHandle Py_GetPath$handle() {
        return Py_GetPath.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *Py_GetPath()
     * }
     */
    public static MemorySegment Py_GetPath$address() {
        return Py_GetPath.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *Py_GetPath()
     * }
     */
    public static MemorySegment Py_GetPath() {
        var mh$ = Py_GetPath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_GetPath");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_SetPath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_SetPath");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void Py_SetPath(const wchar_t *)
     * }
     */
    public static FunctionDescriptor Py_SetPath$descriptor() {
        return Py_SetPath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void Py_SetPath(const wchar_t *)
     * }
     */
    public static MethodHandle Py_SetPath$handle() {
        return Py_SetPath.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void Py_SetPath(const wchar_t *)
     * }
     */
    public static MemorySegment Py_SetPath$address() {
        return Py_SetPath.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void Py_SetPath(const wchar_t *)
     * }
     */
    public static void Py_SetPath(MemorySegment x0) {
        var mh$ = Py_SetPath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_SetPath", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _Py_CheckPython3 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_Py_CheckPython3");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _Py_CheckPython3()
     * }
     */
    public static FunctionDescriptor _Py_CheckPython3$descriptor() {
        return _Py_CheckPython3.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _Py_CheckPython3()
     * }
     */
    public static MethodHandle _Py_CheckPython3$handle() {
        return _Py_CheckPython3.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _Py_CheckPython3()
     * }
     */
    public static MemorySegment _Py_CheckPython3$address() {
        return _Py_CheckPython3.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _Py_CheckPython3()
     * }
     */
    public static int _Py_CheckPython3() {
        var mh$ = _Py_CheckPython3.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_Py_CheckPython3");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_GetVersion {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_GetVersion");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *Py_GetVersion()
     * }
     */
    public static FunctionDescriptor Py_GetVersion$descriptor() {
        return Py_GetVersion.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *Py_GetVersion()
     * }
     */
    public static MethodHandle Py_GetVersion$handle() {
        return Py_GetVersion.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *Py_GetVersion()
     * }
     */
    public static MemorySegment Py_GetVersion$address() {
        return Py_GetVersion.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *Py_GetVersion()
     * }
     */
    public static MemorySegment Py_GetVersion() {
        var mh$ = Py_GetVersion.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_GetVersion");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_GetPlatform {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_GetPlatform");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *Py_GetPlatform()
     * }
     */
    public static FunctionDescriptor Py_GetPlatform$descriptor() {
        return Py_GetPlatform.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *Py_GetPlatform()
     * }
     */
    public static MethodHandle Py_GetPlatform$handle() {
        return Py_GetPlatform.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *Py_GetPlatform()
     * }
     */
    public static MemorySegment Py_GetPlatform$address() {
        return Py_GetPlatform.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *Py_GetPlatform()
     * }
     */
    public static MemorySegment Py_GetPlatform() {
        var mh$ = Py_GetPlatform.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_GetPlatform");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_GetCopyright {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_GetCopyright");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *Py_GetCopyright()
     * }
     */
    public static FunctionDescriptor Py_GetCopyright$descriptor() {
        return Py_GetCopyright.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *Py_GetCopyright()
     * }
     */
    public static MethodHandle Py_GetCopyright$handle() {
        return Py_GetCopyright.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *Py_GetCopyright()
     * }
     */
    public static MemorySegment Py_GetCopyright$address() {
        return Py_GetCopyright.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *Py_GetCopyright()
     * }
     */
    public static MemorySegment Py_GetCopyright() {
        var mh$ = Py_GetCopyright.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_GetCopyright");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_GetCompiler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_GetCompiler");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *Py_GetCompiler()
     * }
     */
    public static FunctionDescriptor Py_GetCompiler$descriptor() {
        return Py_GetCompiler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *Py_GetCompiler()
     * }
     */
    public static MethodHandle Py_GetCompiler$handle() {
        return Py_GetCompiler.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *Py_GetCompiler()
     * }
     */
    public static MemorySegment Py_GetCompiler$address() {
        return Py_GetCompiler.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *Py_GetCompiler()
     * }
     */
    public static MemorySegment Py_GetCompiler() {
        var mh$ = Py_GetCompiler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_GetCompiler");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_GetBuildInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_GetBuildInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *Py_GetBuildInfo()
     * }
     */
    public static FunctionDescriptor Py_GetBuildInfo$descriptor() {
        return Py_GetBuildInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *Py_GetBuildInfo()
     * }
     */
    public static MethodHandle Py_GetBuildInfo$handle() {
        return Py_GetBuildInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *Py_GetBuildInfo()
     * }
     */
    public static MemorySegment Py_GetBuildInfo$address() {
        return Py_GetBuildInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *Py_GetBuildInfo()
     * }
     */
    public static MemorySegment Py_GetBuildInfo() {
        var mh$ = Py_GetBuildInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_GetBuildInfo");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyOS_getsig {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyOS_getsig");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyOS_sighandler_t PyOS_getsig(int)
     * }
     */
    public static FunctionDescriptor PyOS_getsig$descriptor() {
        return PyOS_getsig.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyOS_sighandler_t PyOS_getsig(int)
     * }
     */
    public static MethodHandle PyOS_getsig$handle() {
        return PyOS_getsig.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyOS_sighandler_t PyOS_getsig(int)
     * }
     */
    public static MemorySegment PyOS_getsig$address() {
        return PyOS_getsig.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyOS_sighandler_t PyOS_getsig(int)
     * }
     */
    public static MemorySegment PyOS_getsig(int x0) {
        var mh$ = PyOS_getsig.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyOS_getsig", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyOS_setsig {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyOS_setsig");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyOS_sighandler_t PyOS_setsig(int, PyOS_sighandler_t)
     * }
     */
    public static FunctionDescriptor PyOS_setsig$descriptor() {
        return PyOS_setsig.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyOS_sighandler_t PyOS_setsig(int, PyOS_sighandler_t)
     * }
     */
    public static MethodHandle PyOS_setsig$handle() {
        return PyOS_setsig.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyOS_sighandler_t PyOS_setsig(int, PyOS_sighandler_t)
     * }
     */
    public static MemorySegment PyOS_setsig$address() {
        return PyOS_setsig.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyOS_sighandler_t PyOS_setsig(int, PyOS_sighandler_t)
     * }
     */
    public static MemorySegment PyOS_setsig(int x0, MemorySegment x1) {
        var mh$ = PyOS_setsig.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyOS_setsig", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_Version$constants {
        public static final OfInt LAYOUT = Python_h.C_LONG;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("Py_Version").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const unsigned long Py_Version
     * }
     */
    public static OfInt Py_Version$layout() {
        return Py_Version$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const unsigned long Py_Version
     * }
     */
    public static MemorySegment Py_Version$segment() {
        return Py_Version$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const unsigned long Py_Version
     * }
     */
    public static int Py_Version() {
        return Py_Version$constants.SEGMENT.get(Py_Version$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const unsigned long Py_Version
     * }
     */
    public static void Py_Version(int varValue) {
        Py_Version$constants.SEGMENT.set(Py_Version$constants.LAYOUT, 0L, varValue);
    }

    private static class PyEval_EvalCode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyEval_EvalCode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyEval_EvalCode(PyObject *, PyObject *, PyObject *)
     * }
     */
    public static FunctionDescriptor PyEval_EvalCode$descriptor() {
        return PyEval_EvalCode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyEval_EvalCode(PyObject *, PyObject *, PyObject *)
     * }
     */
    public static MethodHandle PyEval_EvalCode$handle() {
        return PyEval_EvalCode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyEval_EvalCode(PyObject *, PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyEval_EvalCode$address() {
        return PyEval_EvalCode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyEval_EvalCode(PyObject *, PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyEval_EvalCode(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = PyEval_EvalCode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyEval_EvalCode", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyEval_EvalCodeEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyEval_EvalCodeEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyEval_EvalCodeEx(PyObject *co, PyObject *globals, PyObject *locals, PyObject *const *args, int argc, PyObject *const *kwds, int kwdc, PyObject *const *defs, int defc, PyObject *kwdefs, PyObject *closure)
     * }
     */
    public static FunctionDescriptor PyEval_EvalCodeEx$descriptor() {
        return PyEval_EvalCodeEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyEval_EvalCodeEx(PyObject *co, PyObject *globals, PyObject *locals, PyObject *const *args, int argc, PyObject *const *kwds, int kwdc, PyObject *const *defs, int defc, PyObject *kwdefs, PyObject *closure)
     * }
     */
    public static MethodHandle PyEval_EvalCodeEx$handle() {
        return PyEval_EvalCodeEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyEval_EvalCodeEx(PyObject *co, PyObject *globals, PyObject *locals, PyObject *const *args, int argc, PyObject *const *kwds, int kwdc, PyObject *const *defs, int defc, PyObject *kwdefs, PyObject *closure)
     * }
     */
    public static MemorySegment PyEval_EvalCodeEx$address() {
        return PyEval_EvalCodeEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyEval_EvalCodeEx(PyObject *co, PyObject *globals, PyObject *locals, PyObject *const *args, int argc, PyObject *const *kwds, int kwdc, PyObject *const *defs, int defc, PyObject *kwdefs, PyObject *closure)
     * }
     */
    public static MemorySegment PyEval_EvalCodeEx(MemorySegment co, MemorySegment globals, MemorySegment locals, MemorySegment args, int argc, MemorySegment kwds, int kwdc, MemorySegment defs, int defc, MemorySegment kwdefs, MemorySegment closure) {
        var mh$ = PyEval_EvalCodeEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyEval_EvalCodeEx", co, globals, locals, args, argc, kwds, kwdc, defs, defc, kwdefs, closure);
            }
            return (MemorySegment)mh$.invokeExact(co, globals, locals, args, argc, kwds, kwdc, defs, defc, kwdefs, closure);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyEval_CallObjectWithKeywords {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyEval_CallObjectWithKeywords");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyEval_CallObjectWithKeywords(PyObject *callable, PyObject *args, PyObject *kwargs)
     * }
     */
    public static FunctionDescriptor PyEval_CallObjectWithKeywords$descriptor() {
        return PyEval_CallObjectWithKeywords.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyEval_CallObjectWithKeywords(PyObject *callable, PyObject *args, PyObject *kwargs)
     * }
     */
    public static MethodHandle PyEval_CallObjectWithKeywords$handle() {
        return PyEval_CallObjectWithKeywords.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyEval_CallObjectWithKeywords(PyObject *callable, PyObject *args, PyObject *kwargs)
     * }
     */
    public static MemorySegment PyEval_CallObjectWithKeywords$address() {
        return PyEval_CallObjectWithKeywords.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyEval_CallObjectWithKeywords(PyObject *callable, PyObject *args, PyObject *kwargs)
     * }
     */
    public static MemorySegment PyEval_CallObjectWithKeywords(MemorySegment callable, MemorySegment args, MemorySegment kwargs) {
        var mh$ = PyEval_CallObjectWithKeywords.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyEval_CallObjectWithKeywords", callable, args, kwargs);
            }
            return (MemorySegment)mh$.invokeExact(callable, args, kwargs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * PyObject *PyEval_CallFunction(PyObject *callable, const char *format, ...)
     * }
     */
    public static class PyEval_CallFunction {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_POINTER,
                Python_h.C_POINTER,
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("PyEval_CallFunction");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private PyEval_CallFunction(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * PyObject *PyEval_CallFunction(PyObject *callable, const char *format, ...)
         * }
         */
        public static PyEval_CallFunction makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new PyEval_CallFunction(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public MemorySegment apply(MemorySegment callable, MemorySegment format, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("PyEval_CallFunction", callable, format, x2);
                }
                return (MemorySegment)spreader.invokeExact(callable, format, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * PyObject *PyEval_CallMethod(PyObject *obj, const char *name, const char *format, ...)
     * }
     */
    public static class PyEval_CallMethod {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_POINTER,
                Python_h.C_POINTER,
                Python_h.C_POINTER,
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("PyEval_CallMethod");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private PyEval_CallMethod(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * PyObject *PyEval_CallMethod(PyObject *obj, const char *name, const char *format, ...)
         * }
         */
        public static PyEval_CallMethod makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new PyEval_CallMethod(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public MemorySegment apply(MemorySegment obj, MemorySegment name, MemorySegment format, Object... x3) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("PyEval_CallMethod", obj, name, format, x3);
                }
                return (MemorySegment)spreader.invokeExact(obj, name, format, x3);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class PyEval_GetBuiltins {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyEval_GetBuiltins");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyEval_GetBuiltins()
     * }
     */
    public static FunctionDescriptor PyEval_GetBuiltins$descriptor() {
        return PyEval_GetBuiltins.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyEval_GetBuiltins()
     * }
     */
    public static MethodHandle PyEval_GetBuiltins$handle() {
        return PyEval_GetBuiltins.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyEval_GetBuiltins()
     * }
     */
    public static MemorySegment PyEval_GetBuiltins$address() {
        return PyEval_GetBuiltins.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyEval_GetBuiltins()
     * }
     */
    public static MemorySegment PyEval_GetBuiltins() {
        var mh$ = PyEval_GetBuiltins.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyEval_GetBuiltins");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyEval_GetGlobals {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyEval_GetGlobals");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyEval_GetGlobals()
     * }
     */
    public static FunctionDescriptor PyEval_GetGlobals$descriptor() {
        return PyEval_GetGlobals.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyEval_GetGlobals()
     * }
     */
    public static MethodHandle PyEval_GetGlobals$handle() {
        return PyEval_GetGlobals.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyEval_GetGlobals()
     * }
     */
    public static MemorySegment PyEval_GetGlobals$address() {
        return PyEval_GetGlobals.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyEval_GetGlobals()
     * }
     */
    public static MemorySegment PyEval_GetGlobals() {
        var mh$ = PyEval_GetGlobals.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyEval_GetGlobals");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyEval_GetLocals {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyEval_GetLocals");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyEval_GetLocals()
     * }
     */
    public static FunctionDescriptor PyEval_GetLocals$descriptor() {
        return PyEval_GetLocals.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyEval_GetLocals()
     * }
     */
    public static MethodHandle PyEval_GetLocals$handle() {
        return PyEval_GetLocals.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyEval_GetLocals()
     * }
     */
    public static MemorySegment PyEval_GetLocals$address() {
        return PyEval_GetLocals.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyEval_GetLocals()
     * }
     */
    public static MemorySegment PyEval_GetLocals() {
        var mh$ = PyEval_GetLocals.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyEval_GetLocals");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyEval_GetFrame {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyEval_GetFrame");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyFrameObject *PyEval_GetFrame()
     * }
     */
    public static FunctionDescriptor PyEval_GetFrame$descriptor() {
        return PyEval_GetFrame.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyFrameObject *PyEval_GetFrame()
     * }
     */
    public static MethodHandle PyEval_GetFrame$handle() {
        return PyEval_GetFrame.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyFrameObject *PyEval_GetFrame()
     * }
     */
    public static MemorySegment PyEval_GetFrame$address() {
        return PyEval_GetFrame.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyFrameObject *PyEval_GetFrame()
     * }
     */
    public static MemorySegment PyEval_GetFrame() {
        var mh$ = PyEval_GetFrame.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyEval_GetFrame");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_AddPendingCall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_AddPendingCall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int Py_AddPendingCall(int (*func)(void *), void *arg)
     * }
     */
    public static FunctionDescriptor Py_AddPendingCall$descriptor() {
        return Py_AddPendingCall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int Py_AddPendingCall(int (*func)(void *), void *arg)
     * }
     */
    public static MethodHandle Py_AddPendingCall$handle() {
        return Py_AddPendingCall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int Py_AddPendingCall(int (*func)(void *), void *arg)
     * }
     */
    public static MemorySegment Py_AddPendingCall$address() {
        return Py_AddPendingCall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int Py_AddPendingCall(int (*func)(void *), void *arg)
     * }
     */
    public static int Py_AddPendingCall(MemorySegment func, MemorySegment arg) {
        var mh$ = Py_AddPendingCall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_AddPendingCall", func, arg);
            }
            return (int)mh$.invokeExact(func, arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_MakePendingCalls {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_MakePendingCalls");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int Py_MakePendingCalls()
     * }
     */
    public static FunctionDescriptor Py_MakePendingCalls$descriptor() {
        return Py_MakePendingCalls.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int Py_MakePendingCalls()
     * }
     */
    public static MethodHandle Py_MakePendingCalls$handle() {
        return Py_MakePendingCalls.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int Py_MakePendingCalls()
     * }
     */
    public static MemorySegment Py_MakePendingCalls$address() {
        return Py_MakePendingCalls.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int Py_MakePendingCalls()
     * }
     */
    public static int Py_MakePendingCalls() {
        var mh$ = Py_MakePendingCalls.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_MakePendingCalls");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_SetRecursionLimit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_SetRecursionLimit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void Py_SetRecursionLimit(int)
     * }
     */
    public static FunctionDescriptor Py_SetRecursionLimit$descriptor() {
        return Py_SetRecursionLimit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void Py_SetRecursionLimit(int)
     * }
     */
    public static MethodHandle Py_SetRecursionLimit$handle() {
        return Py_SetRecursionLimit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void Py_SetRecursionLimit(int)
     * }
     */
    public static MemorySegment Py_SetRecursionLimit$address() {
        return Py_SetRecursionLimit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void Py_SetRecursionLimit(int)
     * }
     */
    public static void Py_SetRecursionLimit(int x0) {
        var mh$ = Py_SetRecursionLimit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_SetRecursionLimit", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_GetRecursionLimit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_GetRecursionLimit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int Py_GetRecursionLimit()
     * }
     */
    public static FunctionDescriptor Py_GetRecursionLimit$descriptor() {
        return Py_GetRecursionLimit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int Py_GetRecursionLimit()
     * }
     */
    public static MethodHandle Py_GetRecursionLimit$handle() {
        return Py_GetRecursionLimit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int Py_GetRecursionLimit()
     * }
     */
    public static MemorySegment Py_GetRecursionLimit$address() {
        return Py_GetRecursionLimit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int Py_GetRecursionLimit()
     * }
     */
    public static int Py_GetRecursionLimit() {
        var mh$ = Py_GetRecursionLimit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_GetRecursionLimit");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_EnterRecursiveCall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_EnterRecursiveCall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int Py_EnterRecursiveCall(const char *where)
     * }
     */
    public static FunctionDescriptor Py_EnterRecursiveCall$descriptor() {
        return Py_EnterRecursiveCall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int Py_EnterRecursiveCall(const char *where)
     * }
     */
    public static MethodHandle Py_EnterRecursiveCall$handle() {
        return Py_EnterRecursiveCall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int Py_EnterRecursiveCall(const char *where)
     * }
     */
    public static MemorySegment Py_EnterRecursiveCall$address() {
        return Py_EnterRecursiveCall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int Py_EnterRecursiveCall(const char *where)
     * }
     */
    public static int Py_EnterRecursiveCall(MemorySegment where) {
        var mh$ = Py_EnterRecursiveCall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_EnterRecursiveCall", where);
            }
            return (int)mh$.invokeExact(where);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_LeaveRecursiveCall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_LeaveRecursiveCall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void Py_LeaveRecursiveCall()
     * }
     */
    public static FunctionDescriptor Py_LeaveRecursiveCall$descriptor() {
        return Py_LeaveRecursiveCall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void Py_LeaveRecursiveCall()
     * }
     */
    public static MethodHandle Py_LeaveRecursiveCall$handle() {
        return Py_LeaveRecursiveCall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void Py_LeaveRecursiveCall()
     * }
     */
    public static MemorySegment Py_LeaveRecursiveCall$address() {
        return Py_LeaveRecursiveCall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void Py_LeaveRecursiveCall()
     * }
     */
    public static void Py_LeaveRecursiveCall() {
        var mh$ = Py_LeaveRecursiveCall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_LeaveRecursiveCall");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyEval_GetFuncName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyEval_GetFuncName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *PyEval_GetFuncName(PyObject *)
     * }
     */
    public static FunctionDescriptor PyEval_GetFuncName$descriptor() {
        return PyEval_GetFuncName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *PyEval_GetFuncName(PyObject *)
     * }
     */
    public static MethodHandle PyEval_GetFuncName$handle() {
        return PyEval_GetFuncName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *PyEval_GetFuncName(PyObject *)
     * }
     */
    public static MemorySegment PyEval_GetFuncName$address() {
        return PyEval_GetFuncName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *PyEval_GetFuncName(PyObject *)
     * }
     */
    public static MemorySegment PyEval_GetFuncName(MemorySegment x0) {
        var mh$ = PyEval_GetFuncName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyEval_GetFuncName", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyEval_GetFuncDesc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyEval_GetFuncDesc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *PyEval_GetFuncDesc(PyObject *)
     * }
     */
    public static FunctionDescriptor PyEval_GetFuncDesc$descriptor() {
        return PyEval_GetFuncDesc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *PyEval_GetFuncDesc(PyObject *)
     * }
     */
    public static MethodHandle PyEval_GetFuncDesc$handle() {
        return PyEval_GetFuncDesc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *PyEval_GetFuncDesc(PyObject *)
     * }
     */
    public static MemorySegment PyEval_GetFuncDesc$address() {
        return PyEval_GetFuncDesc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *PyEval_GetFuncDesc(PyObject *)
     * }
     */
    public static MemorySegment PyEval_GetFuncDesc(MemorySegment x0) {
        var mh$ = PyEval_GetFuncDesc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyEval_GetFuncDesc", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyEval_EvalFrame {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyEval_EvalFrame");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyEval_EvalFrame(PyFrameObject *)
     * }
     */
    public static FunctionDescriptor PyEval_EvalFrame$descriptor() {
        return PyEval_EvalFrame.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyEval_EvalFrame(PyFrameObject *)
     * }
     */
    public static MethodHandle PyEval_EvalFrame$handle() {
        return PyEval_EvalFrame.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyEval_EvalFrame(PyFrameObject *)
     * }
     */
    public static MemorySegment PyEval_EvalFrame$address() {
        return PyEval_EvalFrame.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyEval_EvalFrame(PyFrameObject *)
     * }
     */
    public static MemorySegment PyEval_EvalFrame(MemorySegment x0) {
        var mh$ = PyEval_EvalFrame.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyEval_EvalFrame", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyEval_EvalFrameEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyEval_EvalFrameEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyEval_EvalFrameEx(PyFrameObject *f, int exc)
     * }
     */
    public static FunctionDescriptor PyEval_EvalFrameEx$descriptor() {
        return PyEval_EvalFrameEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyEval_EvalFrameEx(PyFrameObject *f, int exc)
     * }
     */
    public static MethodHandle PyEval_EvalFrameEx$handle() {
        return PyEval_EvalFrameEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyEval_EvalFrameEx(PyFrameObject *f, int exc)
     * }
     */
    public static MemorySegment PyEval_EvalFrameEx$address() {
        return PyEval_EvalFrameEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyEval_EvalFrameEx(PyFrameObject *f, int exc)
     * }
     */
    public static MemorySegment PyEval_EvalFrameEx(MemorySegment f, int exc) {
        var mh$ = PyEval_EvalFrameEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyEval_EvalFrameEx", f, exc);
            }
            return (MemorySegment)mh$.invokeExact(f, exc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyEval_SaveThread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyEval_SaveThread");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyThreadState *PyEval_SaveThread()
     * }
     */
    public static FunctionDescriptor PyEval_SaveThread$descriptor() {
        return PyEval_SaveThread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyThreadState *PyEval_SaveThread()
     * }
     */
    public static MethodHandle PyEval_SaveThread$handle() {
        return PyEval_SaveThread.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyThreadState *PyEval_SaveThread()
     * }
     */
    public static MemorySegment PyEval_SaveThread$address() {
        return PyEval_SaveThread.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyThreadState *PyEval_SaveThread()
     * }
     */
    public static MemorySegment PyEval_SaveThread() {
        var mh$ = PyEval_SaveThread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyEval_SaveThread");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyEval_RestoreThread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyEval_RestoreThread");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyEval_RestoreThread(PyThreadState *)
     * }
     */
    public static FunctionDescriptor PyEval_RestoreThread$descriptor() {
        return PyEval_RestoreThread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyEval_RestoreThread(PyThreadState *)
     * }
     */
    public static MethodHandle PyEval_RestoreThread$handle() {
        return PyEval_RestoreThread.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyEval_RestoreThread(PyThreadState *)
     * }
     */
    public static MemorySegment PyEval_RestoreThread$address() {
        return PyEval_RestoreThread.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyEval_RestoreThread(PyThreadState *)
     * }
     */
    public static void PyEval_RestoreThread(MemorySegment x0) {
        var mh$ = PyEval_RestoreThread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyEval_RestoreThread", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyEval_ThreadsInitialized {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyEval_ThreadsInitialized");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyEval_ThreadsInitialized()
     * }
     */
    public static FunctionDescriptor PyEval_ThreadsInitialized$descriptor() {
        return PyEval_ThreadsInitialized.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyEval_ThreadsInitialized()
     * }
     */
    public static MethodHandle PyEval_ThreadsInitialized$handle() {
        return PyEval_ThreadsInitialized.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyEval_ThreadsInitialized()
     * }
     */
    public static MemorySegment PyEval_ThreadsInitialized$address() {
        return PyEval_ThreadsInitialized.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyEval_ThreadsInitialized()
     * }
     */
    public static int PyEval_ThreadsInitialized() {
        var mh$ = PyEval_ThreadsInitialized.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyEval_ThreadsInitialized");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyEval_InitThreads {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyEval_InitThreads");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyEval_InitThreads()
     * }
     */
    public static FunctionDescriptor PyEval_InitThreads$descriptor() {
        return PyEval_InitThreads.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyEval_InitThreads()
     * }
     */
    public static MethodHandle PyEval_InitThreads$handle() {
        return PyEval_InitThreads.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyEval_InitThreads()
     * }
     */
    public static MemorySegment PyEval_InitThreads$address() {
        return PyEval_InitThreads.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyEval_InitThreads()
     * }
     */
    public static void PyEval_InitThreads() {
        var mh$ = PyEval_InitThreads.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyEval_InitThreads");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyEval_AcquireLock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyEval_AcquireLock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyEval_AcquireLock()
     * }
     */
    public static FunctionDescriptor PyEval_AcquireLock$descriptor() {
        return PyEval_AcquireLock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyEval_AcquireLock()
     * }
     */
    public static MethodHandle PyEval_AcquireLock$handle() {
        return PyEval_AcquireLock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyEval_AcquireLock()
     * }
     */
    public static MemorySegment PyEval_AcquireLock$address() {
        return PyEval_AcquireLock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyEval_AcquireLock()
     * }
     */
    public static void PyEval_AcquireLock() {
        var mh$ = PyEval_AcquireLock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyEval_AcquireLock");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyEval_ReleaseLock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyEval_ReleaseLock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyEval_ReleaseLock()
     * }
     */
    public static FunctionDescriptor PyEval_ReleaseLock$descriptor() {
        return PyEval_ReleaseLock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyEval_ReleaseLock()
     * }
     */
    public static MethodHandle PyEval_ReleaseLock$handle() {
        return PyEval_ReleaseLock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyEval_ReleaseLock()
     * }
     */
    public static MemorySegment PyEval_ReleaseLock$address() {
        return PyEval_ReleaseLock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyEval_ReleaseLock()
     * }
     */
    public static void PyEval_ReleaseLock() {
        var mh$ = PyEval_ReleaseLock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyEval_ReleaseLock");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyEval_AcquireThread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyEval_AcquireThread");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyEval_AcquireThread(PyThreadState *tstate)
     * }
     */
    public static FunctionDescriptor PyEval_AcquireThread$descriptor() {
        return PyEval_AcquireThread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyEval_AcquireThread(PyThreadState *tstate)
     * }
     */
    public static MethodHandle PyEval_AcquireThread$handle() {
        return PyEval_AcquireThread.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyEval_AcquireThread(PyThreadState *tstate)
     * }
     */
    public static MemorySegment PyEval_AcquireThread$address() {
        return PyEval_AcquireThread.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyEval_AcquireThread(PyThreadState *tstate)
     * }
     */
    public static void PyEval_AcquireThread(MemorySegment tstate) {
        var mh$ = PyEval_AcquireThread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyEval_AcquireThread", tstate);
            }
            mh$.invokeExact(tstate);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyEval_ReleaseThread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyEval_ReleaseThread");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyEval_ReleaseThread(PyThreadState *tstate)
     * }
     */
    public static FunctionDescriptor PyEval_ReleaseThread$descriptor() {
        return PyEval_ReleaseThread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyEval_ReleaseThread(PyThreadState *tstate)
     * }
     */
    public static MethodHandle PyEval_ReleaseThread$handle() {
        return PyEval_ReleaseThread.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyEval_ReleaseThread(PyThreadState *tstate)
     * }
     */
    public static MemorySegment PyEval_ReleaseThread$address() {
        return PyEval_ReleaseThread.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyEval_ReleaseThread(PyThreadState *tstate)
     * }
     */
    public static void PyEval_ReleaseThread(MemorySegment tstate) {
        var mh$ = PyEval_ReleaseThread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyEval_ReleaseThread", tstate);
            }
            mh$.invokeExact(tstate);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PySys_GetObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PySys_GetObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PySys_GetObject(const char *)
     * }
     */
    public static FunctionDescriptor PySys_GetObject$descriptor() {
        return PySys_GetObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PySys_GetObject(const char *)
     * }
     */
    public static MethodHandle PySys_GetObject$handle() {
        return PySys_GetObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PySys_GetObject(const char *)
     * }
     */
    public static MemorySegment PySys_GetObject$address() {
        return PySys_GetObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PySys_GetObject(const char *)
     * }
     */
    public static MemorySegment PySys_GetObject(MemorySegment x0) {
        var mh$ = PySys_GetObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PySys_GetObject", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PySys_SetObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PySys_SetObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PySys_SetObject(const char *, PyObject *)
     * }
     */
    public static FunctionDescriptor PySys_SetObject$descriptor() {
        return PySys_SetObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PySys_SetObject(const char *, PyObject *)
     * }
     */
    public static MethodHandle PySys_SetObject$handle() {
        return PySys_SetObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PySys_SetObject(const char *, PyObject *)
     * }
     */
    public static MemorySegment PySys_SetObject$address() {
        return PySys_SetObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PySys_SetObject(const char *, PyObject *)
     * }
     */
    public static int PySys_SetObject(MemorySegment x0, MemorySegment x1) {
        var mh$ = PySys_SetObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PySys_SetObject", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PySys_SetArgv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PySys_SetArgv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PySys_SetArgv(int, wchar_t **)
     * }
     */
    public static FunctionDescriptor PySys_SetArgv$descriptor() {
        return PySys_SetArgv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PySys_SetArgv(int, wchar_t **)
     * }
     */
    public static MethodHandle PySys_SetArgv$handle() {
        return PySys_SetArgv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PySys_SetArgv(int, wchar_t **)
     * }
     */
    public static MemorySegment PySys_SetArgv$address() {
        return PySys_SetArgv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PySys_SetArgv(int, wchar_t **)
     * }
     */
    public static void PySys_SetArgv(int x0, MemorySegment x1) {
        var mh$ = PySys_SetArgv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PySys_SetArgv", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PySys_SetArgvEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PySys_SetArgvEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PySys_SetArgvEx(int, wchar_t **, int)
     * }
     */
    public static FunctionDescriptor PySys_SetArgvEx$descriptor() {
        return PySys_SetArgvEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PySys_SetArgvEx(int, wchar_t **, int)
     * }
     */
    public static MethodHandle PySys_SetArgvEx$handle() {
        return PySys_SetArgvEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PySys_SetArgvEx(int, wchar_t **, int)
     * }
     */
    public static MemorySegment PySys_SetArgvEx$address() {
        return PySys_SetArgvEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PySys_SetArgvEx(int, wchar_t **, int)
     * }
     */
    public static void PySys_SetArgvEx(int x0, MemorySegment x1, int x2) {
        var mh$ = PySys_SetArgvEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PySys_SetArgvEx", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PySys_SetPath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PySys_SetPath");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PySys_SetPath(const wchar_t *)
     * }
     */
    public static FunctionDescriptor PySys_SetPath$descriptor() {
        return PySys_SetPath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PySys_SetPath(const wchar_t *)
     * }
     */
    public static MethodHandle PySys_SetPath$handle() {
        return PySys_SetPath.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PySys_SetPath(const wchar_t *)
     * }
     */
    public static MemorySegment PySys_SetPath$address() {
        return PySys_SetPath.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PySys_SetPath(const wchar_t *)
     * }
     */
    public static void PySys_SetPath(MemorySegment x0) {
        var mh$ = PySys_SetPath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PySys_SetPath", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * void PySys_WriteStdout(const char *format, ...)
     * }
     */
    public static class PySys_WriteStdout {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.ofVoid(
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("PySys_WriteStdout");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private PySys_WriteStdout(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * void PySys_WriteStdout(const char *format, ...)
         * }
         */
        public static PySys_WriteStdout makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new PySys_WriteStdout(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public void apply(MemorySegment format, Object... x1) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("PySys_WriteStdout", format, x1);
                }
                spreader.invokeExact(format, x1);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * void PySys_WriteStderr(const char *format, ...)
     * }
     */
    public static class PySys_WriteStderr {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.ofVoid(
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("PySys_WriteStderr");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private PySys_WriteStderr(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * void PySys_WriteStderr(const char *format, ...)
         * }
         */
        public static PySys_WriteStderr makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new PySys_WriteStderr(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public void apply(MemorySegment format, Object... x1) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("PySys_WriteStderr", format, x1);
                }
                spreader.invokeExact(format, x1);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * void PySys_FormatStdout(const char *format, ...)
     * }
     */
    public static class PySys_FormatStdout {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.ofVoid(
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("PySys_FormatStdout");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private PySys_FormatStdout(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * void PySys_FormatStdout(const char *format, ...)
         * }
         */
        public static PySys_FormatStdout makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new PySys_FormatStdout(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public void apply(MemorySegment format, Object... x1) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("PySys_FormatStdout", format, x1);
                }
                spreader.invokeExact(format, x1);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * void PySys_FormatStderr(const char *format, ...)
     * }
     */
    public static class PySys_FormatStderr {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.ofVoid(
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("PySys_FormatStderr");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private PySys_FormatStderr(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * void PySys_FormatStderr(const char *format, ...)
         * }
         */
        public static PySys_FormatStderr makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new PySys_FormatStderr(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public void apply(MemorySegment format, Object... x1) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("PySys_FormatStderr", format, x1);
                }
                spreader.invokeExact(format, x1);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class PySys_ResetWarnOptions {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PySys_ResetWarnOptions");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PySys_ResetWarnOptions()
     * }
     */
    public static FunctionDescriptor PySys_ResetWarnOptions$descriptor() {
        return PySys_ResetWarnOptions.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PySys_ResetWarnOptions()
     * }
     */
    public static MethodHandle PySys_ResetWarnOptions$handle() {
        return PySys_ResetWarnOptions.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PySys_ResetWarnOptions()
     * }
     */
    public static MemorySegment PySys_ResetWarnOptions$address() {
        return PySys_ResetWarnOptions.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PySys_ResetWarnOptions()
     * }
     */
    public static void PySys_ResetWarnOptions() {
        var mh$ = PySys_ResetWarnOptions.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PySys_ResetWarnOptions");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PySys_AddWarnOption {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PySys_AddWarnOption");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PySys_AddWarnOption(const wchar_t *)
     * }
     */
    public static FunctionDescriptor PySys_AddWarnOption$descriptor() {
        return PySys_AddWarnOption.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PySys_AddWarnOption(const wchar_t *)
     * }
     */
    public static MethodHandle PySys_AddWarnOption$handle() {
        return PySys_AddWarnOption.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PySys_AddWarnOption(const wchar_t *)
     * }
     */
    public static MemorySegment PySys_AddWarnOption$address() {
        return PySys_AddWarnOption.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PySys_AddWarnOption(const wchar_t *)
     * }
     */
    public static void PySys_AddWarnOption(MemorySegment x0) {
        var mh$ = PySys_AddWarnOption.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PySys_AddWarnOption", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PySys_AddWarnOptionUnicode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PySys_AddWarnOptionUnicode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PySys_AddWarnOptionUnicode(PyObject *)
     * }
     */
    public static FunctionDescriptor PySys_AddWarnOptionUnicode$descriptor() {
        return PySys_AddWarnOptionUnicode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PySys_AddWarnOptionUnicode(PyObject *)
     * }
     */
    public static MethodHandle PySys_AddWarnOptionUnicode$handle() {
        return PySys_AddWarnOptionUnicode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PySys_AddWarnOptionUnicode(PyObject *)
     * }
     */
    public static MemorySegment PySys_AddWarnOptionUnicode$address() {
        return PySys_AddWarnOptionUnicode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PySys_AddWarnOptionUnicode(PyObject *)
     * }
     */
    public static void PySys_AddWarnOptionUnicode(MemorySegment x0) {
        var mh$ = PySys_AddWarnOptionUnicode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PySys_AddWarnOptionUnicode", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PySys_HasWarnOptions {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PySys_HasWarnOptions");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PySys_HasWarnOptions()
     * }
     */
    public static FunctionDescriptor PySys_HasWarnOptions$descriptor() {
        return PySys_HasWarnOptions.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PySys_HasWarnOptions()
     * }
     */
    public static MethodHandle PySys_HasWarnOptions$handle() {
        return PySys_HasWarnOptions.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PySys_HasWarnOptions()
     * }
     */
    public static MemorySegment PySys_HasWarnOptions$address() {
        return PySys_HasWarnOptions.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PySys_HasWarnOptions()
     * }
     */
    public static int PySys_HasWarnOptions() {
        var mh$ = PySys_HasWarnOptions.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PySys_HasWarnOptions");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PySys_AddXOption {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PySys_AddXOption");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PySys_AddXOption(const wchar_t *)
     * }
     */
    public static FunctionDescriptor PySys_AddXOption$descriptor() {
        return PySys_AddXOption.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PySys_AddXOption(const wchar_t *)
     * }
     */
    public static MethodHandle PySys_AddXOption$handle() {
        return PySys_AddXOption.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PySys_AddXOption(const wchar_t *)
     * }
     */
    public static MemorySegment PySys_AddXOption$address() {
        return PySys_AddXOption.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PySys_AddXOption(const wchar_t *)
     * }
     */
    public static void PySys_AddXOption(MemorySegment x0) {
        var mh$ = PySys_AddXOption.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PySys_AddXOption", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PySys_GetXOptions {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PySys_GetXOptions");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PySys_GetXOptions()
     * }
     */
    public static FunctionDescriptor PySys_GetXOptions$descriptor() {
        return PySys_GetXOptions.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PySys_GetXOptions()
     * }
     */
    public static MethodHandle PySys_GetXOptions$handle() {
        return PySys_GetXOptions.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PySys_GetXOptions()
     * }
     */
    public static MemorySegment PySys_GetXOptions$address() {
        return PySys_GetXOptions.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PySys_GetXOptions()
     * }
     */
    public static MemorySegment PySys_GetXOptions() {
        var mh$ = PySys_GetXOptions.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PySys_GetXOptions");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyOS_FSPath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyOS_FSPath");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyOS_FSPath(PyObject *path)
     * }
     */
    public static FunctionDescriptor PyOS_FSPath$descriptor() {
        return PyOS_FSPath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyOS_FSPath(PyObject *path)
     * }
     */
    public static MethodHandle PyOS_FSPath$handle() {
        return PyOS_FSPath.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyOS_FSPath(PyObject *path)
     * }
     */
    public static MemorySegment PyOS_FSPath$address() {
        return PyOS_FSPath.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyOS_FSPath(PyObject *path)
     * }
     */
    public static MemorySegment PyOS_FSPath(MemorySegment path) {
        var mh$ = PyOS_FSPath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyOS_FSPath", path);
            }
            return (MemorySegment)mh$.invokeExact(path);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyOS_InterruptOccurred {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyOS_InterruptOccurred");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyOS_InterruptOccurred()
     * }
     */
    public static FunctionDescriptor PyOS_InterruptOccurred$descriptor() {
        return PyOS_InterruptOccurred.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyOS_InterruptOccurred()
     * }
     */
    public static MethodHandle PyOS_InterruptOccurred$handle() {
        return PyOS_InterruptOccurred.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyOS_InterruptOccurred()
     * }
     */
    public static MemorySegment PyOS_InterruptOccurred$address() {
        return PyOS_InterruptOccurred.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyOS_InterruptOccurred()
     * }
     */
    public static int PyOS_InterruptOccurred() {
        var mh$ = PyOS_InterruptOccurred.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyOS_InterruptOccurred");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyOS_AfterFork {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyOS_AfterFork");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyOS_AfterFork()
     * }
     */
    public static FunctionDescriptor PyOS_AfterFork$descriptor() {
        return PyOS_AfterFork.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyOS_AfterFork()
     * }
     */
    public static MethodHandle PyOS_AfterFork$handle() {
        return PyOS_AfterFork.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyOS_AfterFork()
     * }
     */
    public static MemorySegment PyOS_AfterFork$address() {
        return PyOS_AfterFork.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyOS_AfterFork()
     * }
     */
    public static void PyOS_AfterFork() {
        var mh$ = PyOS_AfterFork.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyOS_AfterFork");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyImport_GetMagicNumber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyImport_GetMagicNumber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long PyImport_GetMagicNumber()
     * }
     */
    public static FunctionDescriptor PyImport_GetMagicNumber$descriptor() {
        return PyImport_GetMagicNumber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long PyImport_GetMagicNumber()
     * }
     */
    public static MethodHandle PyImport_GetMagicNumber$handle() {
        return PyImport_GetMagicNumber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long PyImport_GetMagicNumber()
     * }
     */
    public static MemorySegment PyImport_GetMagicNumber$address() {
        return PyImport_GetMagicNumber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long PyImport_GetMagicNumber()
     * }
     */
    public static int PyImport_GetMagicNumber() {
        var mh$ = PyImport_GetMagicNumber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyImport_GetMagicNumber");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyImport_GetMagicTag {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyImport_GetMagicTag");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *PyImport_GetMagicTag()
     * }
     */
    public static FunctionDescriptor PyImport_GetMagicTag$descriptor() {
        return PyImport_GetMagicTag.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *PyImport_GetMagicTag()
     * }
     */
    public static MethodHandle PyImport_GetMagicTag$handle() {
        return PyImport_GetMagicTag.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *PyImport_GetMagicTag()
     * }
     */
    public static MemorySegment PyImport_GetMagicTag$address() {
        return PyImport_GetMagicTag.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *PyImport_GetMagicTag()
     * }
     */
    public static MemorySegment PyImport_GetMagicTag() {
        var mh$ = PyImport_GetMagicTag.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyImport_GetMagicTag");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyImport_ExecCodeModule {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyImport_ExecCodeModule");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyImport_ExecCodeModule(const char *name, PyObject *co)
     * }
     */
    public static FunctionDescriptor PyImport_ExecCodeModule$descriptor() {
        return PyImport_ExecCodeModule.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyImport_ExecCodeModule(const char *name, PyObject *co)
     * }
     */
    public static MethodHandle PyImport_ExecCodeModule$handle() {
        return PyImport_ExecCodeModule.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyImport_ExecCodeModule(const char *name, PyObject *co)
     * }
     */
    public static MemorySegment PyImport_ExecCodeModule$address() {
        return PyImport_ExecCodeModule.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyImport_ExecCodeModule(const char *name, PyObject *co)
     * }
     */
    public static MemorySegment PyImport_ExecCodeModule(MemorySegment name, MemorySegment co) {
        var mh$ = PyImport_ExecCodeModule.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyImport_ExecCodeModule", name, co);
            }
            return (MemorySegment)mh$.invokeExact(name, co);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyImport_ExecCodeModuleEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyImport_ExecCodeModuleEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyImport_ExecCodeModuleEx(const char *name, PyObject *co, const char *pathname)
     * }
     */
    public static FunctionDescriptor PyImport_ExecCodeModuleEx$descriptor() {
        return PyImport_ExecCodeModuleEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyImport_ExecCodeModuleEx(const char *name, PyObject *co, const char *pathname)
     * }
     */
    public static MethodHandle PyImport_ExecCodeModuleEx$handle() {
        return PyImport_ExecCodeModuleEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyImport_ExecCodeModuleEx(const char *name, PyObject *co, const char *pathname)
     * }
     */
    public static MemorySegment PyImport_ExecCodeModuleEx$address() {
        return PyImport_ExecCodeModuleEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyImport_ExecCodeModuleEx(const char *name, PyObject *co, const char *pathname)
     * }
     */
    public static MemorySegment PyImport_ExecCodeModuleEx(MemorySegment name, MemorySegment co, MemorySegment pathname) {
        var mh$ = PyImport_ExecCodeModuleEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyImport_ExecCodeModuleEx", name, co, pathname);
            }
            return (MemorySegment)mh$.invokeExact(name, co, pathname);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyImport_ExecCodeModuleWithPathnames {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyImport_ExecCodeModuleWithPathnames");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyImport_ExecCodeModuleWithPathnames(const char *name, PyObject *co, const char *pathname, const char *cpathname)
     * }
     */
    public static FunctionDescriptor PyImport_ExecCodeModuleWithPathnames$descriptor() {
        return PyImport_ExecCodeModuleWithPathnames.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyImport_ExecCodeModuleWithPathnames(const char *name, PyObject *co, const char *pathname, const char *cpathname)
     * }
     */
    public static MethodHandle PyImport_ExecCodeModuleWithPathnames$handle() {
        return PyImport_ExecCodeModuleWithPathnames.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyImport_ExecCodeModuleWithPathnames(const char *name, PyObject *co, const char *pathname, const char *cpathname)
     * }
     */
    public static MemorySegment PyImport_ExecCodeModuleWithPathnames$address() {
        return PyImport_ExecCodeModuleWithPathnames.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyImport_ExecCodeModuleWithPathnames(const char *name, PyObject *co, const char *pathname, const char *cpathname)
     * }
     */
    public static MemorySegment PyImport_ExecCodeModuleWithPathnames(MemorySegment name, MemorySegment co, MemorySegment pathname, MemorySegment cpathname) {
        var mh$ = PyImport_ExecCodeModuleWithPathnames.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyImport_ExecCodeModuleWithPathnames", name, co, pathname, cpathname);
            }
            return (MemorySegment)mh$.invokeExact(name, co, pathname, cpathname);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyImport_ExecCodeModuleObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyImport_ExecCodeModuleObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyImport_ExecCodeModuleObject(PyObject *name, PyObject *co, PyObject *pathname, PyObject *cpathname)
     * }
     */
    public static FunctionDescriptor PyImport_ExecCodeModuleObject$descriptor() {
        return PyImport_ExecCodeModuleObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyImport_ExecCodeModuleObject(PyObject *name, PyObject *co, PyObject *pathname, PyObject *cpathname)
     * }
     */
    public static MethodHandle PyImport_ExecCodeModuleObject$handle() {
        return PyImport_ExecCodeModuleObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyImport_ExecCodeModuleObject(PyObject *name, PyObject *co, PyObject *pathname, PyObject *cpathname)
     * }
     */
    public static MemorySegment PyImport_ExecCodeModuleObject$address() {
        return PyImport_ExecCodeModuleObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyImport_ExecCodeModuleObject(PyObject *name, PyObject *co, PyObject *pathname, PyObject *cpathname)
     * }
     */
    public static MemorySegment PyImport_ExecCodeModuleObject(MemorySegment name, MemorySegment co, MemorySegment pathname, MemorySegment cpathname) {
        var mh$ = PyImport_ExecCodeModuleObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyImport_ExecCodeModuleObject", name, co, pathname, cpathname);
            }
            return (MemorySegment)mh$.invokeExact(name, co, pathname, cpathname);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyImport_GetModuleDict {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyImport_GetModuleDict");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyImport_GetModuleDict()
     * }
     */
    public static FunctionDescriptor PyImport_GetModuleDict$descriptor() {
        return PyImport_GetModuleDict.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyImport_GetModuleDict()
     * }
     */
    public static MethodHandle PyImport_GetModuleDict$handle() {
        return PyImport_GetModuleDict.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyImport_GetModuleDict()
     * }
     */
    public static MemorySegment PyImport_GetModuleDict$address() {
        return PyImport_GetModuleDict.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyImport_GetModuleDict()
     * }
     */
    public static MemorySegment PyImport_GetModuleDict() {
        var mh$ = PyImport_GetModuleDict.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyImport_GetModuleDict");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyImport_GetModule {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyImport_GetModule");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyImport_GetModule(PyObject *name)
     * }
     */
    public static FunctionDescriptor PyImport_GetModule$descriptor() {
        return PyImport_GetModule.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyImport_GetModule(PyObject *name)
     * }
     */
    public static MethodHandle PyImport_GetModule$handle() {
        return PyImport_GetModule.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyImport_GetModule(PyObject *name)
     * }
     */
    public static MemorySegment PyImport_GetModule$address() {
        return PyImport_GetModule.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyImport_GetModule(PyObject *name)
     * }
     */
    public static MemorySegment PyImport_GetModule(MemorySegment name) {
        var mh$ = PyImport_GetModule.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyImport_GetModule", name);
            }
            return (MemorySegment)mh$.invokeExact(name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyImport_AddModuleObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyImport_AddModuleObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyImport_AddModuleObject(PyObject *name)
     * }
     */
    public static FunctionDescriptor PyImport_AddModuleObject$descriptor() {
        return PyImport_AddModuleObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyImport_AddModuleObject(PyObject *name)
     * }
     */
    public static MethodHandle PyImport_AddModuleObject$handle() {
        return PyImport_AddModuleObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyImport_AddModuleObject(PyObject *name)
     * }
     */
    public static MemorySegment PyImport_AddModuleObject$address() {
        return PyImport_AddModuleObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyImport_AddModuleObject(PyObject *name)
     * }
     */
    public static MemorySegment PyImport_AddModuleObject(MemorySegment name) {
        var mh$ = PyImport_AddModuleObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyImport_AddModuleObject", name);
            }
            return (MemorySegment)mh$.invokeExact(name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyImport_AddModule {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyImport_AddModule");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyImport_AddModule(const char *name)
     * }
     */
    public static FunctionDescriptor PyImport_AddModule$descriptor() {
        return PyImport_AddModule.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyImport_AddModule(const char *name)
     * }
     */
    public static MethodHandle PyImport_AddModule$handle() {
        return PyImport_AddModule.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyImport_AddModule(const char *name)
     * }
     */
    public static MemorySegment PyImport_AddModule$address() {
        return PyImport_AddModule.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyImport_AddModule(const char *name)
     * }
     */
    public static MemorySegment PyImport_AddModule(MemorySegment name) {
        var mh$ = PyImport_AddModule.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyImport_AddModule", name);
            }
            return (MemorySegment)mh$.invokeExact(name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyImport_ImportModule {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyImport_ImportModule");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyImport_ImportModule(const char *name)
     * }
     */
    public static FunctionDescriptor PyImport_ImportModule$descriptor() {
        return PyImport_ImportModule.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyImport_ImportModule(const char *name)
     * }
     */
    public static MethodHandle PyImport_ImportModule$handle() {
        return PyImport_ImportModule.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyImport_ImportModule(const char *name)
     * }
     */
    public static MemorySegment PyImport_ImportModule$address() {
        return PyImport_ImportModule.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyImport_ImportModule(const char *name)
     * }
     */
    public static MemorySegment PyImport_ImportModule(MemorySegment name) {
        var mh$ = PyImport_ImportModule.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyImport_ImportModule", name);
            }
            return (MemorySegment)mh$.invokeExact(name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyImport_ImportModuleNoBlock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyImport_ImportModuleNoBlock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyImport_ImportModuleNoBlock(const char *name)
     * }
     */
    public static FunctionDescriptor PyImport_ImportModuleNoBlock$descriptor() {
        return PyImport_ImportModuleNoBlock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyImport_ImportModuleNoBlock(const char *name)
     * }
     */
    public static MethodHandle PyImport_ImportModuleNoBlock$handle() {
        return PyImport_ImportModuleNoBlock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyImport_ImportModuleNoBlock(const char *name)
     * }
     */
    public static MemorySegment PyImport_ImportModuleNoBlock$address() {
        return PyImport_ImportModuleNoBlock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyImport_ImportModuleNoBlock(const char *name)
     * }
     */
    public static MemorySegment PyImport_ImportModuleNoBlock(MemorySegment name) {
        var mh$ = PyImport_ImportModuleNoBlock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyImport_ImportModuleNoBlock", name);
            }
            return (MemorySegment)mh$.invokeExact(name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyImport_ImportModuleLevel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyImport_ImportModuleLevel");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyImport_ImportModuleLevel(const char *name, PyObject *globals, PyObject *locals, PyObject *fromlist, int level)
     * }
     */
    public static FunctionDescriptor PyImport_ImportModuleLevel$descriptor() {
        return PyImport_ImportModuleLevel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyImport_ImportModuleLevel(const char *name, PyObject *globals, PyObject *locals, PyObject *fromlist, int level)
     * }
     */
    public static MethodHandle PyImport_ImportModuleLevel$handle() {
        return PyImport_ImportModuleLevel.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyImport_ImportModuleLevel(const char *name, PyObject *globals, PyObject *locals, PyObject *fromlist, int level)
     * }
     */
    public static MemorySegment PyImport_ImportModuleLevel$address() {
        return PyImport_ImportModuleLevel.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyImport_ImportModuleLevel(const char *name, PyObject *globals, PyObject *locals, PyObject *fromlist, int level)
     * }
     */
    public static MemorySegment PyImport_ImportModuleLevel(MemorySegment name, MemorySegment globals, MemorySegment locals, MemorySegment fromlist, int level) {
        var mh$ = PyImport_ImportModuleLevel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyImport_ImportModuleLevel", name, globals, locals, fromlist, level);
            }
            return (MemorySegment)mh$.invokeExact(name, globals, locals, fromlist, level);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyImport_ImportModuleLevelObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyImport_ImportModuleLevelObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyImport_ImportModuleLevelObject(PyObject *name, PyObject *globals, PyObject *locals, PyObject *fromlist, int level)
     * }
     */
    public static FunctionDescriptor PyImport_ImportModuleLevelObject$descriptor() {
        return PyImport_ImportModuleLevelObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyImport_ImportModuleLevelObject(PyObject *name, PyObject *globals, PyObject *locals, PyObject *fromlist, int level)
     * }
     */
    public static MethodHandle PyImport_ImportModuleLevelObject$handle() {
        return PyImport_ImportModuleLevelObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyImport_ImportModuleLevelObject(PyObject *name, PyObject *globals, PyObject *locals, PyObject *fromlist, int level)
     * }
     */
    public static MemorySegment PyImport_ImportModuleLevelObject$address() {
        return PyImport_ImportModuleLevelObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyImport_ImportModuleLevelObject(PyObject *name, PyObject *globals, PyObject *locals, PyObject *fromlist, int level)
     * }
     */
    public static MemorySegment PyImport_ImportModuleLevelObject(MemorySegment name, MemorySegment globals, MemorySegment locals, MemorySegment fromlist, int level) {
        var mh$ = PyImport_ImportModuleLevelObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyImport_ImportModuleLevelObject", name, globals, locals, fromlist, level);
            }
            return (MemorySegment)mh$.invokeExact(name, globals, locals, fromlist, level);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyImport_GetImporter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyImport_GetImporter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyImport_GetImporter(PyObject *path)
     * }
     */
    public static FunctionDescriptor PyImport_GetImporter$descriptor() {
        return PyImport_GetImporter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyImport_GetImporter(PyObject *path)
     * }
     */
    public static MethodHandle PyImport_GetImporter$handle() {
        return PyImport_GetImporter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyImport_GetImporter(PyObject *path)
     * }
     */
    public static MemorySegment PyImport_GetImporter$address() {
        return PyImport_GetImporter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyImport_GetImporter(PyObject *path)
     * }
     */
    public static MemorySegment PyImport_GetImporter(MemorySegment path) {
        var mh$ = PyImport_GetImporter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyImport_GetImporter", path);
            }
            return (MemorySegment)mh$.invokeExact(path);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyImport_Import {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyImport_Import");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyImport_Import(PyObject *name)
     * }
     */
    public static FunctionDescriptor PyImport_Import$descriptor() {
        return PyImport_Import.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyImport_Import(PyObject *name)
     * }
     */
    public static MethodHandle PyImport_Import$handle() {
        return PyImport_Import.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyImport_Import(PyObject *name)
     * }
     */
    public static MemorySegment PyImport_Import$address() {
        return PyImport_Import.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyImport_Import(PyObject *name)
     * }
     */
    public static MemorySegment PyImport_Import(MemorySegment name) {
        var mh$ = PyImport_Import.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyImport_Import", name);
            }
            return (MemorySegment)mh$.invokeExact(name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyImport_ReloadModule {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyImport_ReloadModule");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyImport_ReloadModule(PyObject *m)
     * }
     */
    public static FunctionDescriptor PyImport_ReloadModule$descriptor() {
        return PyImport_ReloadModule.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyImport_ReloadModule(PyObject *m)
     * }
     */
    public static MethodHandle PyImport_ReloadModule$handle() {
        return PyImport_ReloadModule.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyImport_ReloadModule(PyObject *m)
     * }
     */
    public static MemorySegment PyImport_ReloadModule$address() {
        return PyImport_ReloadModule.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyImport_ReloadModule(PyObject *m)
     * }
     */
    public static MemorySegment PyImport_ReloadModule(MemorySegment m) {
        var mh$ = PyImport_ReloadModule.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyImport_ReloadModule", m);
            }
            return (MemorySegment)mh$.invokeExact(m);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyImport_ImportFrozenModuleObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyImport_ImportFrozenModuleObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyImport_ImportFrozenModuleObject(PyObject *name)
     * }
     */
    public static FunctionDescriptor PyImport_ImportFrozenModuleObject$descriptor() {
        return PyImport_ImportFrozenModuleObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyImport_ImportFrozenModuleObject(PyObject *name)
     * }
     */
    public static MethodHandle PyImport_ImportFrozenModuleObject$handle() {
        return PyImport_ImportFrozenModuleObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyImport_ImportFrozenModuleObject(PyObject *name)
     * }
     */
    public static MemorySegment PyImport_ImportFrozenModuleObject$address() {
        return PyImport_ImportFrozenModuleObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyImport_ImportFrozenModuleObject(PyObject *name)
     * }
     */
    public static int PyImport_ImportFrozenModuleObject(MemorySegment name) {
        var mh$ = PyImport_ImportFrozenModuleObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyImport_ImportFrozenModuleObject", name);
            }
            return (int)mh$.invokeExact(name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyImport_ImportFrozenModule {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyImport_ImportFrozenModule");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyImport_ImportFrozenModule(const char *name)
     * }
     */
    public static FunctionDescriptor PyImport_ImportFrozenModule$descriptor() {
        return PyImport_ImportFrozenModule.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyImport_ImportFrozenModule(const char *name)
     * }
     */
    public static MethodHandle PyImport_ImportFrozenModule$handle() {
        return PyImport_ImportFrozenModule.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyImport_ImportFrozenModule(const char *name)
     * }
     */
    public static MemorySegment PyImport_ImportFrozenModule$address() {
        return PyImport_ImportFrozenModule.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyImport_ImportFrozenModule(const char *name)
     * }
     */
    public static int PyImport_ImportFrozenModule(MemorySegment name) {
        var mh$ = PyImport_ImportFrozenModule.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyImport_ImportFrozenModule", name);
            }
            return (int)mh$.invokeExact(name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyImport_AppendInittab {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyImport_AppendInittab");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyImport_AppendInittab(const char *name, PyObject *(*initfunc)(void))
     * }
     */
    public static FunctionDescriptor PyImport_AppendInittab$descriptor() {
        return PyImport_AppendInittab.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyImport_AppendInittab(const char *name, PyObject *(*initfunc)(void))
     * }
     */
    public static MethodHandle PyImport_AppendInittab$handle() {
        return PyImport_AppendInittab.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyImport_AppendInittab(const char *name, PyObject *(*initfunc)(void))
     * }
     */
    public static MemorySegment PyImport_AppendInittab$address() {
        return PyImport_AppendInittab.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyImport_AppendInittab(const char *name, PyObject *(*initfunc)(void))
     * }
     */
    public static int PyImport_AppendInittab(MemorySegment name, MemorySegment initfunc) {
        var mh$ = PyImport_AppendInittab.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyImport_AppendInittab", name, initfunc);
            }
            return (int)mh$.invokeExact(name, initfunc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_CallNoArgs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_CallNoArgs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyObject_CallNoArgs(PyObject *func)
     * }
     */
    public static FunctionDescriptor PyObject_CallNoArgs$descriptor() {
        return PyObject_CallNoArgs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyObject_CallNoArgs(PyObject *func)
     * }
     */
    public static MethodHandle PyObject_CallNoArgs$handle() {
        return PyObject_CallNoArgs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyObject_CallNoArgs(PyObject *func)
     * }
     */
    public static MemorySegment PyObject_CallNoArgs$address() {
        return PyObject_CallNoArgs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyObject_CallNoArgs(PyObject *func)
     * }
     */
    public static MemorySegment PyObject_CallNoArgs(MemorySegment func) {
        var mh$ = PyObject_CallNoArgs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_CallNoArgs", func);
            }
            return (MemorySegment)mh$.invokeExact(func);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_Call {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_Call");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyObject_Call(PyObject *callable, PyObject *args, PyObject *kwargs)
     * }
     */
    public static FunctionDescriptor PyObject_Call$descriptor() {
        return PyObject_Call.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyObject_Call(PyObject *callable, PyObject *args, PyObject *kwargs)
     * }
     */
    public static MethodHandle PyObject_Call$handle() {
        return PyObject_Call.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyObject_Call(PyObject *callable, PyObject *args, PyObject *kwargs)
     * }
     */
    public static MemorySegment PyObject_Call$address() {
        return PyObject_Call.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyObject_Call(PyObject *callable, PyObject *args, PyObject *kwargs)
     * }
     */
    public static MemorySegment PyObject_Call(MemorySegment callable, MemorySegment args, MemorySegment kwargs) {
        var mh$ = PyObject_Call.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_Call", callable, args, kwargs);
            }
            return (MemorySegment)mh$.invokeExact(callable, args, kwargs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_CallObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_CallObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyObject_CallObject(PyObject *callable, PyObject *args)
     * }
     */
    public static FunctionDescriptor PyObject_CallObject$descriptor() {
        return PyObject_CallObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyObject_CallObject(PyObject *callable, PyObject *args)
     * }
     */
    public static MethodHandle PyObject_CallObject$handle() {
        return PyObject_CallObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyObject_CallObject(PyObject *callable, PyObject *args)
     * }
     */
    public static MemorySegment PyObject_CallObject$address() {
        return PyObject_CallObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyObject_CallObject(PyObject *callable, PyObject *args)
     * }
     */
    public static MemorySegment PyObject_CallObject(MemorySegment callable, MemorySegment args) {
        var mh$ = PyObject_CallObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_CallObject", callable, args);
            }
            return (MemorySegment)mh$.invokeExact(callable, args);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * PyObject *PyObject_CallFunction(PyObject *callable, const char *format, ...)
     * }
     */
    public static class PyObject_CallFunction {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_POINTER,
                Python_h.C_POINTER,
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_CallFunction");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private PyObject_CallFunction(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * PyObject *PyObject_CallFunction(PyObject *callable, const char *format, ...)
         * }
         */
        public static PyObject_CallFunction makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new PyObject_CallFunction(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public MemorySegment apply(MemorySegment callable, MemorySegment format, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("PyObject_CallFunction", callable, format, x2);
                }
                return (MemorySegment)spreader.invokeExact(callable, format, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * PyObject *PyObject_CallMethod(PyObject *obj, const char *name, const char *format, ...)
     * }
     */
    public static class PyObject_CallMethod {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_POINTER,
                Python_h.C_POINTER,
                Python_h.C_POINTER,
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_CallMethod");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private PyObject_CallMethod(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * PyObject *PyObject_CallMethod(PyObject *obj, const char *name, const char *format, ...)
         * }
         */
        public static PyObject_CallMethod makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new PyObject_CallMethod(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public MemorySegment apply(MemorySegment obj, MemorySegment name, MemorySegment format, Object... x3) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("PyObject_CallMethod", obj, name, format, x3);
                }
                return (MemorySegment)spreader.invokeExact(obj, name, format, x3);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * PyObject *_PyObject_CallFunction_SizeT(PyObject *callable, const char *format, ...)
     * }
     */
    public static class _PyObject_CallFunction_SizeT {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_POINTER,
                Python_h.C_POINTER,
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("_PyObject_CallFunction_SizeT");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private _PyObject_CallFunction_SizeT(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * PyObject *_PyObject_CallFunction_SizeT(PyObject *callable, const char *format, ...)
         * }
         */
        public static _PyObject_CallFunction_SizeT makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new _PyObject_CallFunction_SizeT(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public MemorySegment apply(MemorySegment callable, MemorySegment format, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("_PyObject_CallFunction_SizeT", callable, format, x2);
                }
                return (MemorySegment)spreader.invokeExact(callable, format, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * PyObject *_PyObject_CallMethod_SizeT(PyObject *obj, const char *name, const char *format, ...)
     * }
     */
    public static class _PyObject_CallMethod_SizeT {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_POINTER,
                Python_h.C_POINTER,
                Python_h.C_POINTER,
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("_PyObject_CallMethod_SizeT");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private _PyObject_CallMethod_SizeT(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * PyObject *_PyObject_CallMethod_SizeT(PyObject *obj, const char *name, const char *format, ...)
         * }
         */
        public static _PyObject_CallMethod_SizeT makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new _PyObject_CallMethod_SizeT(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public MemorySegment apply(MemorySegment obj, MemorySegment name, MemorySegment format, Object... x3) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("_PyObject_CallMethod_SizeT", obj, name, format, x3);
                }
                return (MemorySegment)spreader.invokeExact(obj, name, format, x3);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * PyObject *PyObject_CallFunctionObjArgs(PyObject *callable, ...)
     * }
     */
    public static class PyObject_CallFunctionObjArgs {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_POINTER,
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_CallFunctionObjArgs");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private PyObject_CallFunctionObjArgs(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * PyObject *PyObject_CallFunctionObjArgs(PyObject *callable, ...)
         * }
         */
        public static PyObject_CallFunctionObjArgs makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new PyObject_CallFunctionObjArgs(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public MemorySegment apply(MemorySegment callable, Object... x1) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("PyObject_CallFunctionObjArgs", callable, x1);
                }
                return (MemorySegment)spreader.invokeExact(callable, x1);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * PyObject *PyObject_CallMethodObjArgs(PyObject *obj, PyObject *name, ...)
     * }
     */
    public static class PyObject_CallMethodObjArgs {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_POINTER,
                Python_h.C_POINTER,
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_CallMethodObjArgs");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private PyObject_CallMethodObjArgs(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * PyObject *PyObject_CallMethodObjArgs(PyObject *obj, PyObject *name, ...)
         * }
         */
        public static PyObject_CallMethodObjArgs makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new PyObject_CallMethodObjArgs(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public MemorySegment apply(MemorySegment obj, MemorySegment name, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("PyObject_CallMethodObjArgs", obj, name, x2);
                }
                return (MemorySegment)spreader.invokeExact(obj, name, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class PyVectorcall_NARGS {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyVectorcall_NARGS");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_ssize_t PyVectorcall_NARGS(size_t nargsf)
     * }
     */
    public static FunctionDescriptor PyVectorcall_NARGS$descriptor() {
        return PyVectorcall_NARGS.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_ssize_t PyVectorcall_NARGS(size_t nargsf)
     * }
     */
    public static MethodHandle PyVectorcall_NARGS$handle() {
        return PyVectorcall_NARGS.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_ssize_t PyVectorcall_NARGS(size_t nargsf)
     * }
     */
    public static MemorySegment PyVectorcall_NARGS$address() {
        return PyVectorcall_NARGS.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_ssize_t PyVectorcall_NARGS(size_t nargsf)
     * }
     */
    public static long PyVectorcall_NARGS(long nargsf) {
        var mh$ = PyVectorcall_NARGS.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyVectorcall_NARGS", nargsf);
            }
            return (long)mh$.invokeExact(nargsf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyVectorcall_Call {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyVectorcall_Call");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyVectorcall_Call(PyObject *callable, PyObject *tuple, PyObject *dict)
     * }
     */
    public static FunctionDescriptor PyVectorcall_Call$descriptor() {
        return PyVectorcall_Call.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyVectorcall_Call(PyObject *callable, PyObject *tuple, PyObject *dict)
     * }
     */
    public static MethodHandle PyVectorcall_Call$handle() {
        return PyVectorcall_Call.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyVectorcall_Call(PyObject *callable, PyObject *tuple, PyObject *dict)
     * }
     */
    public static MemorySegment PyVectorcall_Call$address() {
        return PyVectorcall_Call.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyVectorcall_Call(PyObject *callable, PyObject *tuple, PyObject *dict)
     * }
     */
    public static MemorySegment PyVectorcall_Call(MemorySegment callable, MemorySegment tuple, MemorySegment dict) {
        var mh$ = PyVectorcall_Call.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyVectorcall_Call", callable, tuple, dict);
            }
            return (MemorySegment)mh$.invokeExact(callable, tuple, dict);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_Vectorcall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_Vectorcall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyObject_Vectorcall(PyObject *callable, PyObject *const *args, size_t nargsf, PyObject *kwnames)
     * }
     */
    public static FunctionDescriptor PyObject_Vectorcall$descriptor() {
        return PyObject_Vectorcall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyObject_Vectorcall(PyObject *callable, PyObject *const *args, size_t nargsf, PyObject *kwnames)
     * }
     */
    public static MethodHandle PyObject_Vectorcall$handle() {
        return PyObject_Vectorcall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyObject_Vectorcall(PyObject *callable, PyObject *const *args, size_t nargsf, PyObject *kwnames)
     * }
     */
    public static MemorySegment PyObject_Vectorcall$address() {
        return PyObject_Vectorcall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyObject_Vectorcall(PyObject *callable, PyObject *const *args, size_t nargsf, PyObject *kwnames)
     * }
     */
    public static MemorySegment PyObject_Vectorcall(MemorySegment callable, MemorySegment args, long nargsf, MemorySegment kwnames) {
        var mh$ = PyObject_Vectorcall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_Vectorcall", callable, args, nargsf, kwnames);
            }
            return (MemorySegment)mh$.invokeExact(callable, args, nargsf, kwnames);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_VectorcallMethod {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_VectorcallMethod");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyObject_VectorcallMethod(PyObject *name, PyObject *const *args, size_t nargsf, PyObject *kwnames)
     * }
     */
    public static FunctionDescriptor PyObject_VectorcallMethod$descriptor() {
        return PyObject_VectorcallMethod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyObject_VectorcallMethod(PyObject *name, PyObject *const *args, size_t nargsf, PyObject *kwnames)
     * }
     */
    public static MethodHandle PyObject_VectorcallMethod$handle() {
        return PyObject_VectorcallMethod.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyObject_VectorcallMethod(PyObject *name, PyObject *const *args, size_t nargsf, PyObject *kwnames)
     * }
     */
    public static MemorySegment PyObject_VectorcallMethod$address() {
        return PyObject_VectorcallMethod.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyObject_VectorcallMethod(PyObject *name, PyObject *const *args, size_t nargsf, PyObject *kwnames)
     * }
     */
    public static MemorySegment PyObject_VectorcallMethod(MemorySegment name, MemorySegment args, long nargsf, MemorySegment kwnames) {
        var mh$ = PyObject_VectorcallMethod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_VectorcallMethod", name, args, nargsf, kwnames);
            }
            return (MemorySegment)mh$.invokeExact(name, args, nargsf, kwnames);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_Type {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_Type");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyObject_Type(PyObject *o)
     * }
     */
    public static FunctionDescriptor PyObject_Type$descriptor() {
        return PyObject_Type.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyObject_Type(PyObject *o)
     * }
     */
    public static MethodHandle PyObject_Type$handle() {
        return PyObject_Type.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyObject_Type(PyObject *o)
     * }
     */
    public static MemorySegment PyObject_Type$address() {
        return PyObject_Type.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyObject_Type(PyObject *o)
     * }
     */
    public static MemorySegment PyObject_Type(MemorySegment o) {
        var mh$ = PyObject_Type.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_Type", o);
            }
            return (MemorySegment)mh$.invokeExact(o);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_Size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_Size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_ssize_t PyObject_Size(PyObject *o)
     * }
     */
    public static FunctionDescriptor PyObject_Size$descriptor() {
        return PyObject_Size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_ssize_t PyObject_Size(PyObject *o)
     * }
     */
    public static MethodHandle PyObject_Size$handle() {
        return PyObject_Size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_ssize_t PyObject_Size(PyObject *o)
     * }
     */
    public static MemorySegment PyObject_Size$address() {
        return PyObject_Size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_ssize_t PyObject_Size(PyObject *o)
     * }
     */
    public static long PyObject_Size(MemorySegment o) {
        var mh$ = PyObject_Size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_Size", o);
            }
            return (long)mh$.invokeExact(o);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_Length {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_Length");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_ssize_t PyObject_Length(PyObject *o)
     * }
     */
    public static FunctionDescriptor PyObject_Length$descriptor() {
        return PyObject_Length.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_ssize_t PyObject_Length(PyObject *o)
     * }
     */
    public static MethodHandle PyObject_Length$handle() {
        return PyObject_Length.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_ssize_t PyObject_Length(PyObject *o)
     * }
     */
    public static MemorySegment PyObject_Length$address() {
        return PyObject_Length.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_ssize_t PyObject_Length(PyObject *o)
     * }
     */
    public static long PyObject_Length(MemorySegment o) {
        var mh$ = PyObject_Length.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_Length", o);
            }
            return (long)mh$.invokeExact(o);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_GetItem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_GetItem");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyObject_GetItem(PyObject *o, PyObject *key)
     * }
     */
    public static FunctionDescriptor PyObject_GetItem$descriptor() {
        return PyObject_GetItem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyObject_GetItem(PyObject *o, PyObject *key)
     * }
     */
    public static MethodHandle PyObject_GetItem$handle() {
        return PyObject_GetItem.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyObject_GetItem(PyObject *o, PyObject *key)
     * }
     */
    public static MemorySegment PyObject_GetItem$address() {
        return PyObject_GetItem.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyObject_GetItem(PyObject *o, PyObject *key)
     * }
     */
    public static MemorySegment PyObject_GetItem(MemorySegment o, MemorySegment key) {
        var mh$ = PyObject_GetItem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_GetItem", o, key);
            }
            return (MemorySegment)mh$.invokeExact(o, key);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_SetItem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_SetItem");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyObject_SetItem(PyObject *o, PyObject *key, PyObject *v)
     * }
     */
    public static FunctionDescriptor PyObject_SetItem$descriptor() {
        return PyObject_SetItem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyObject_SetItem(PyObject *o, PyObject *key, PyObject *v)
     * }
     */
    public static MethodHandle PyObject_SetItem$handle() {
        return PyObject_SetItem.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyObject_SetItem(PyObject *o, PyObject *key, PyObject *v)
     * }
     */
    public static MemorySegment PyObject_SetItem$address() {
        return PyObject_SetItem.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyObject_SetItem(PyObject *o, PyObject *key, PyObject *v)
     * }
     */
    public static int PyObject_SetItem(MemorySegment o, MemorySegment key, MemorySegment v) {
        var mh$ = PyObject_SetItem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_SetItem", o, key, v);
            }
            return (int)mh$.invokeExact(o, key, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_DelItemString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_DelItemString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyObject_DelItemString(PyObject *o, const char *key)
     * }
     */
    public static FunctionDescriptor PyObject_DelItemString$descriptor() {
        return PyObject_DelItemString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyObject_DelItemString(PyObject *o, const char *key)
     * }
     */
    public static MethodHandle PyObject_DelItemString$handle() {
        return PyObject_DelItemString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyObject_DelItemString(PyObject *o, const char *key)
     * }
     */
    public static MemorySegment PyObject_DelItemString$address() {
        return PyObject_DelItemString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyObject_DelItemString(PyObject *o, const char *key)
     * }
     */
    public static int PyObject_DelItemString(MemorySegment o, MemorySegment key) {
        var mh$ = PyObject_DelItemString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_DelItemString", o, key);
            }
            return (int)mh$.invokeExact(o, key);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_DelItem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_DelItem");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyObject_DelItem(PyObject *o, PyObject *key)
     * }
     */
    public static FunctionDescriptor PyObject_DelItem$descriptor() {
        return PyObject_DelItem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyObject_DelItem(PyObject *o, PyObject *key)
     * }
     */
    public static MethodHandle PyObject_DelItem$handle() {
        return PyObject_DelItem.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyObject_DelItem(PyObject *o, PyObject *key)
     * }
     */
    public static MemorySegment PyObject_DelItem$address() {
        return PyObject_DelItem.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyObject_DelItem(PyObject *o, PyObject *key)
     * }
     */
    public static int PyObject_DelItem(MemorySegment o, MemorySegment key) {
        var mh$ = PyObject_DelItem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_DelItem", o, key);
            }
            return (int)mh$.invokeExact(o, key);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_AsCharBuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_AsCharBuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyObject_AsCharBuffer(PyObject *obj, const char **buffer, Py_ssize_t *buffer_len)
     * }
     */
    public static FunctionDescriptor PyObject_AsCharBuffer$descriptor() {
        return PyObject_AsCharBuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyObject_AsCharBuffer(PyObject *obj, const char **buffer, Py_ssize_t *buffer_len)
     * }
     */
    public static MethodHandle PyObject_AsCharBuffer$handle() {
        return PyObject_AsCharBuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyObject_AsCharBuffer(PyObject *obj, const char **buffer, Py_ssize_t *buffer_len)
     * }
     */
    public static MemorySegment PyObject_AsCharBuffer$address() {
        return PyObject_AsCharBuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyObject_AsCharBuffer(PyObject *obj, const char **buffer, Py_ssize_t *buffer_len)
     * }
     */
    public static int PyObject_AsCharBuffer(MemorySegment obj, MemorySegment buffer, MemorySegment buffer_len) {
        var mh$ = PyObject_AsCharBuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_AsCharBuffer", obj, buffer, buffer_len);
            }
            return (int)mh$.invokeExact(obj, buffer, buffer_len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_CheckReadBuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_CheckReadBuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyObject_CheckReadBuffer(PyObject *obj)
     * }
     */
    public static FunctionDescriptor PyObject_CheckReadBuffer$descriptor() {
        return PyObject_CheckReadBuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyObject_CheckReadBuffer(PyObject *obj)
     * }
     */
    public static MethodHandle PyObject_CheckReadBuffer$handle() {
        return PyObject_CheckReadBuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyObject_CheckReadBuffer(PyObject *obj)
     * }
     */
    public static MemorySegment PyObject_CheckReadBuffer$address() {
        return PyObject_CheckReadBuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyObject_CheckReadBuffer(PyObject *obj)
     * }
     */
    public static int PyObject_CheckReadBuffer(MemorySegment obj) {
        var mh$ = PyObject_CheckReadBuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_CheckReadBuffer", obj);
            }
            return (int)mh$.invokeExact(obj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_AsReadBuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_AsReadBuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyObject_AsReadBuffer(PyObject *obj, const void **buffer, Py_ssize_t *buffer_len)
     * }
     */
    public static FunctionDescriptor PyObject_AsReadBuffer$descriptor() {
        return PyObject_AsReadBuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyObject_AsReadBuffer(PyObject *obj, const void **buffer, Py_ssize_t *buffer_len)
     * }
     */
    public static MethodHandle PyObject_AsReadBuffer$handle() {
        return PyObject_AsReadBuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyObject_AsReadBuffer(PyObject *obj, const void **buffer, Py_ssize_t *buffer_len)
     * }
     */
    public static MemorySegment PyObject_AsReadBuffer$address() {
        return PyObject_AsReadBuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyObject_AsReadBuffer(PyObject *obj, const void **buffer, Py_ssize_t *buffer_len)
     * }
     */
    public static int PyObject_AsReadBuffer(MemorySegment obj, MemorySegment buffer, MemorySegment buffer_len) {
        var mh$ = PyObject_AsReadBuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_AsReadBuffer", obj, buffer, buffer_len);
            }
            return (int)mh$.invokeExact(obj, buffer, buffer_len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_AsWriteBuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_AsWriteBuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyObject_AsWriteBuffer(PyObject *obj, void **buffer, Py_ssize_t *buffer_len)
     * }
     */
    public static FunctionDescriptor PyObject_AsWriteBuffer$descriptor() {
        return PyObject_AsWriteBuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyObject_AsWriteBuffer(PyObject *obj, void **buffer, Py_ssize_t *buffer_len)
     * }
     */
    public static MethodHandle PyObject_AsWriteBuffer$handle() {
        return PyObject_AsWriteBuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyObject_AsWriteBuffer(PyObject *obj, void **buffer, Py_ssize_t *buffer_len)
     * }
     */
    public static MemorySegment PyObject_AsWriteBuffer$address() {
        return PyObject_AsWriteBuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyObject_AsWriteBuffer(PyObject *obj, void **buffer, Py_ssize_t *buffer_len)
     * }
     */
    public static int PyObject_AsWriteBuffer(MemorySegment obj, MemorySegment buffer, MemorySegment buffer_len) {
        var mh$ = PyObject_AsWriteBuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_AsWriteBuffer", obj, buffer, buffer_len);
            }
            return (int)mh$.invokeExact(obj, buffer, buffer_len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_Format {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_Format");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyObject_Format(PyObject *obj, PyObject *format_spec)
     * }
     */
    public static FunctionDescriptor PyObject_Format$descriptor() {
        return PyObject_Format.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyObject_Format(PyObject *obj, PyObject *format_spec)
     * }
     */
    public static MethodHandle PyObject_Format$handle() {
        return PyObject_Format.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyObject_Format(PyObject *obj, PyObject *format_spec)
     * }
     */
    public static MemorySegment PyObject_Format$address() {
        return PyObject_Format.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyObject_Format(PyObject *obj, PyObject *format_spec)
     * }
     */
    public static MemorySegment PyObject_Format(MemorySegment obj, MemorySegment format_spec) {
        var mh$ = PyObject_Format.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_Format", obj, format_spec);
            }
            return (MemorySegment)mh$.invokeExact(obj, format_spec);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_GetIter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_GetIter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyObject_GetIter(PyObject *)
     * }
     */
    public static FunctionDescriptor PyObject_GetIter$descriptor() {
        return PyObject_GetIter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyObject_GetIter(PyObject *)
     * }
     */
    public static MethodHandle PyObject_GetIter$handle() {
        return PyObject_GetIter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyObject_GetIter(PyObject *)
     * }
     */
    public static MemorySegment PyObject_GetIter$address() {
        return PyObject_GetIter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyObject_GetIter(PyObject *)
     * }
     */
    public static MemorySegment PyObject_GetIter(MemorySegment x0) {
        var mh$ = PyObject_GetIter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_GetIter", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_GetAIter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_GetAIter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyObject_GetAIter(PyObject *)
     * }
     */
    public static FunctionDescriptor PyObject_GetAIter$descriptor() {
        return PyObject_GetAIter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyObject_GetAIter(PyObject *)
     * }
     */
    public static MethodHandle PyObject_GetAIter$handle() {
        return PyObject_GetAIter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyObject_GetAIter(PyObject *)
     * }
     */
    public static MemorySegment PyObject_GetAIter$address() {
        return PyObject_GetAIter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyObject_GetAIter(PyObject *)
     * }
     */
    public static MemorySegment PyObject_GetAIter(MemorySegment x0) {
        var mh$ = PyObject_GetAIter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_GetAIter", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyIter_Check {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyIter_Check");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyIter_Check(PyObject *)
     * }
     */
    public static FunctionDescriptor PyIter_Check$descriptor() {
        return PyIter_Check.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyIter_Check(PyObject *)
     * }
     */
    public static MethodHandle PyIter_Check$handle() {
        return PyIter_Check.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyIter_Check(PyObject *)
     * }
     */
    public static MemorySegment PyIter_Check$address() {
        return PyIter_Check.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyIter_Check(PyObject *)
     * }
     */
    public static int PyIter_Check(MemorySegment x0) {
        var mh$ = PyIter_Check.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyIter_Check", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyAIter_Check {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyAIter_Check");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyAIter_Check(PyObject *)
     * }
     */
    public static FunctionDescriptor PyAIter_Check$descriptor() {
        return PyAIter_Check.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyAIter_Check(PyObject *)
     * }
     */
    public static MethodHandle PyAIter_Check$handle() {
        return PyAIter_Check.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyAIter_Check(PyObject *)
     * }
     */
    public static MemorySegment PyAIter_Check$address() {
        return PyAIter_Check.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyAIter_Check(PyObject *)
     * }
     */
    public static int PyAIter_Check(MemorySegment x0) {
        var mh$ = PyAIter_Check.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyAIter_Check", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyIter_Next {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyIter_Next");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyIter_Next(PyObject *)
     * }
     */
    public static FunctionDescriptor PyIter_Next$descriptor() {
        return PyIter_Next.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyIter_Next(PyObject *)
     * }
     */
    public static MethodHandle PyIter_Next$handle() {
        return PyIter_Next.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyIter_Next(PyObject *)
     * }
     */
    public static MemorySegment PyIter_Next$address() {
        return PyIter_Next.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyIter_Next(PyObject *)
     * }
     */
    public static MemorySegment PyIter_Next(MemorySegment x0) {
        var mh$ = PyIter_Next.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyIter_Next", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyIter_Send {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyIter_Send");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PySendResult PyIter_Send(PyObject *, PyObject *, PyObject **)
     * }
     */
    public static FunctionDescriptor PyIter_Send$descriptor() {
        return PyIter_Send.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PySendResult PyIter_Send(PyObject *, PyObject *, PyObject **)
     * }
     */
    public static MethodHandle PyIter_Send$handle() {
        return PyIter_Send.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PySendResult PyIter_Send(PyObject *, PyObject *, PyObject **)
     * }
     */
    public static MemorySegment PyIter_Send$address() {
        return PyIter_Send.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PySendResult PyIter_Send(PyObject *, PyObject *, PyObject **)
     * }
     */
    public static int PyIter_Send(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = PyIter_Send.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyIter_Send", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyNumber_Check {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyNumber_Check");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyNumber_Check(PyObject *o)
     * }
     */
    public static FunctionDescriptor PyNumber_Check$descriptor() {
        return PyNumber_Check.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyNumber_Check(PyObject *o)
     * }
     */
    public static MethodHandle PyNumber_Check$handle() {
        return PyNumber_Check.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyNumber_Check(PyObject *o)
     * }
     */
    public static MemorySegment PyNumber_Check$address() {
        return PyNumber_Check.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyNumber_Check(PyObject *o)
     * }
     */
    public static int PyNumber_Check(MemorySegment o) {
        var mh$ = PyNumber_Check.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyNumber_Check", o);
            }
            return (int)mh$.invokeExact(o);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyNumber_Add {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyNumber_Add");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Add(PyObject *o1, PyObject *o2)
     * }
     */
    public static FunctionDescriptor PyNumber_Add$descriptor() {
        return PyNumber_Add.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Add(PyObject *o1, PyObject *o2)
     * }
     */
    public static MethodHandle PyNumber_Add$handle() {
        return PyNumber_Add.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Add(PyObject *o1, PyObject *o2)
     * }
     */
    public static MemorySegment PyNumber_Add$address() {
        return PyNumber_Add.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyNumber_Add(PyObject *o1, PyObject *o2)
     * }
     */
    public static MemorySegment PyNumber_Add(MemorySegment o1, MemorySegment o2) {
        var mh$ = PyNumber_Add.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyNumber_Add", o1, o2);
            }
            return (MemorySegment)mh$.invokeExact(o1, o2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyNumber_Subtract {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyNumber_Subtract");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Subtract(PyObject *o1, PyObject *o2)
     * }
     */
    public static FunctionDescriptor PyNumber_Subtract$descriptor() {
        return PyNumber_Subtract.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Subtract(PyObject *o1, PyObject *o2)
     * }
     */
    public static MethodHandle PyNumber_Subtract$handle() {
        return PyNumber_Subtract.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Subtract(PyObject *o1, PyObject *o2)
     * }
     */
    public static MemorySegment PyNumber_Subtract$address() {
        return PyNumber_Subtract.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyNumber_Subtract(PyObject *o1, PyObject *o2)
     * }
     */
    public static MemorySegment PyNumber_Subtract(MemorySegment o1, MemorySegment o2) {
        var mh$ = PyNumber_Subtract.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyNumber_Subtract", o1, o2);
            }
            return (MemorySegment)mh$.invokeExact(o1, o2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyNumber_Multiply {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyNumber_Multiply");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Multiply(PyObject *o1, PyObject *o2)
     * }
     */
    public static FunctionDescriptor PyNumber_Multiply$descriptor() {
        return PyNumber_Multiply.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Multiply(PyObject *o1, PyObject *o2)
     * }
     */
    public static MethodHandle PyNumber_Multiply$handle() {
        return PyNumber_Multiply.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Multiply(PyObject *o1, PyObject *o2)
     * }
     */
    public static MemorySegment PyNumber_Multiply$address() {
        return PyNumber_Multiply.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyNumber_Multiply(PyObject *o1, PyObject *o2)
     * }
     */
    public static MemorySegment PyNumber_Multiply(MemorySegment o1, MemorySegment o2) {
        var mh$ = PyNumber_Multiply.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyNumber_Multiply", o1, o2);
            }
            return (MemorySegment)mh$.invokeExact(o1, o2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyNumber_MatrixMultiply {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyNumber_MatrixMultiply");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyNumber_MatrixMultiply(PyObject *o1, PyObject *o2)
     * }
     */
    public static FunctionDescriptor PyNumber_MatrixMultiply$descriptor() {
        return PyNumber_MatrixMultiply.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyNumber_MatrixMultiply(PyObject *o1, PyObject *o2)
     * }
     */
    public static MethodHandle PyNumber_MatrixMultiply$handle() {
        return PyNumber_MatrixMultiply.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyNumber_MatrixMultiply(PyObject *o1, PyObject *o2)
     * }
     */
    public static MemorySegment PyNumber_MatrixMultiply$address() {
        return PyNumber_MatrixMultiply.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyNumber_MatrixMultiply(PyObject *o1, PyObject *o2)
     * }
     */
    public static MemorySegment PyNumber_MatrixMultiply(MemorySegment o1, MemorySegment o2) {
        var mh$ = PyNumber_MatrixMultiply.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyNumber_MatrixMultiply", o1, o2);
            }
            return (MemorySegment)mh$.invokeExact(o1, o2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyNumber_FloorDivide {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyNumber_FloorDivide");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyNumber_FloorDivide(PyObject *o1, PyObject *o2)
     * }
     */
    public static FunctionDescriptor PyNumber_FloorDivide$descriptor() {
        return PyNumber_FloorDivide.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyNumber_FloorDivide(PyObject *o1, PyObject *o2)
     * }
     */
    public static MethodHandle PyNumber_FloorDivide$handle() {
        return PyNumber_FloorDivide.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyNumber_FloorDivide(PyObject *o1, PyObject *o2)
     * }
     */
    public static MemorySegment PyNumber_FloorDivide$address() {
        return PyNumber_FloorDivide.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyNumber_FloorDivide(PyObject *o1, PyObject *o2)
     * }
     */
    public static MemorySegment PyNumber_FloorDivide(MemorySegment o1, MemorySegment o2) {
        var mh$ = PyNumber_FloorDivide.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyNumber_FloorDivide", o1, o2);
            }
            return (MemorySegment)mh$.invokeExact(o1, o2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyNumber_TrueDivide {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyNumber_TrueDivide");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyNumber_TrueDivide(PyObject *o1, PyObject *o2)
     * }
     */
    public static FunctionDescriptor PyNumber_TrueDivide$descriptor() {
        return PyNumber_TrueDivide.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyNumber_TrueDivide(PyObject *o1, PyObject *o2)
     * }
     */
    public static MethodHandle PyNumber_TrueDivide$handle() {
        return PyNumber_TrueDivide.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyNumber_TrueDivide(PyObject *o1, PyObject *o2)
     * }
     */
    public static MemorySegment PyNumber_TrueDivide$address() {
        return PyNumber_TrueDivide.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyNumber_TrueDivide(PyObject *o1, PyObject *o2)
     * }
     */
    public static MemorySegment PyNumber_TrueDivide(MemorySegment o1, MemorySegment o2) {
        var mh$ = PyNumber_TrueDivide.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyNumber_TrueDivide", o1, o2);
            }
            return (MemorySegment)mh$.invokeExact(o1, o2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyNumber_Remainder {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyNumber_Remainder");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Remainder(PyObject *o1, PyObject *o2)
     * }
     */
    public static FunctionDescriptor PyNumber_Remainder$descriptor() {
        return PyNumber_Remainder.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Remainder(PyObject *o1, PyObject *o2)
     * }
     */
    public static MethodHandle PyNumber_Remainder$handle() {
        return PyNumber_Remainder.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Remainder(PyObject *o1, PyObject *o2)
     * }
     */
    public static MemorySegment PyNumber_Remainder$address() {
        return PyNumber_Remainder.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyNumber_Remainder(PyObject *o1, PyObject *o2)
     * }
     */
    public static MemorySegment PyNumber_Remainder(MemorySegment o1, MemorySegment o2) {
        var mh$ = PyNumber_Remainder.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyNumber_Remainder", o1, o2);
            }
            return (MemorySegment)mh$.invokeExact(o1, o2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyNumber_Divmod {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyNumber_Divmod");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Divmod(PyObject *o1, PyObject *o2)
     * }
     */
    public static FunctionDescriptor PyNumber_Divmod$descriptor() {
        return PyNumber_Divmod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Divmod(PyObject *o1, PyObject *o2)
     * }
     */
    public static MethodHandle PyNumber_Divmod$handle() {
        return PyNumber_Divmod.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Divmod(PyObject *o1, PyObject *o2)
     * }
     */
    public static MemorySegment PyNumber_Divmod$address() {
        return PyNumber_Divmod.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyNumber_Divmod(PyObject *o1, PyObject *o2)
     * }
     */
    public static MemorySegment PyNumber_Divmod(MemorySegment o1, MemorySegment o2) {
        var mh$ = PyNumber_Divmod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyNumber_Divmod", o1, o2);
            }
            return (MemorySegment)mh$.invokeExact(o1, o2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyNumber_Power {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyNumber_Power");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Power(PyObject *o1, PyObject *o2, PyObject *o3)
     * }
     */
    public static FunctionDescriptor PyNumber_Power$descriptor() {
        return PyNumber_Power.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Power(PyObject *o1, PyObject *o2, PyObject *o3)
     * }
     */
    public static MethodHandle PyNumber_Power$handle() {
        return PyNumber_Power.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Power(PyObject *o1, PyObject *o2, PyObject *o3)
     * }
     */
    public static MemorySegment PyNumber_Power$address() {
        return PyNumber_Power.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyNumber_Power(PyObject *o1, PyObject *o2, PyObject *o3)
     * }
     */
    public static MemorySegment PyNumber_Power(MemorySegment o1, MemorySegment o2, MemorySegment o3) {
        var mh$ = PyNumber_Power.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyNumber_Power", o1, o2, o3);
            }
            return (MemorySegment)mh$.invokeExact(o1, o2, o3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyNumber_Negative {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyNumber_Negative");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Negative(PyObject *o)
     * }
     */
    public static FunctionDescriptor PyNumber_Negative$descriptor() {
        return PyNumber_Negative.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Negative(PyObject *o)
     * }
     */
    public static MethodHandle PyNumber_Negative$handle() {
        return PyNumber_Negative.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Negative(PyObject *o)
     * }
     */
    public static MemorySegment PyNumber_Negative$address() {
        return PyNumber_Negative.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyNumber_Negative(PyObject *o)
     * }
     */
    public static MemorySegment PyNumber_Negative(MemorySegment o) {
        var mh$ = PyNumber_Negative.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyNumber_Negative", o);
            }
            return (MemorySegment)mh$.invokeExact(o);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyNumber_Positive {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyNumber_Positive");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Positive(PyObject *o)
     * }
     */
    public static FunctionDescriptor PyNumber_Positive$descriptor() {
        return PyNumber_Positive.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Positive(PyObject *o)
     * }
     */
    public static MethodHandle PyNumber_Positive$handle() {
        return PyNumber_Positive.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Positive(PyObject *o)
     * }
     */
    public static MemorySegment PyNumber_Positive$address() {
        return PyNumber_Positive.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyNumber_Positive(PyObject *o)
     * }
     */
    public static MemorySegment PyNumber_Positive(MemorySegment o) {
        var mh$ = PyNumber_Positive.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyNumber_Positive", o);
            }
            return (MemorySegment)mh$.invokeExact(o);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyNumber_Absolute {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyNumber_Absolute");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Absolute(PyObject *o)
     * }
     */
    public static FunctionDescriptor PyNumber_Absolute$descriptor() {
        return PyNumber_Absolute.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Absolute(PyObject *o)
     * }
     */
    public static MethodHandle PyNumber_Absolute$handle() {
        return PyNumber_Absolute.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Absolute(PyObject *o)
     * }
     */
    public static MemorySegment PyNumber_Absolute$address() {
        return PyNumber_Absolute.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyNumber_Absolute(PyObject *o)
     * }
     */
    public static MemorySegment PyNumber_Absolute(MemorySegment o) {
        var mh$ = PyNumber_Absolute.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyNumber_Absolute", o);
            }
            return (MemorySegment)mh$.invokeExact(o);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyNumber_Invert {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyNumber_Invert");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Invert(PyObject *o)
     * }
     */
    public static FunctionDescriptor PyNumber_Invert$descriptor() {
        return PyNumber_Invert.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Invert(PyObject *o)
     * }
     */
    public static MethodHandle PyNumber_Invert$handle() {
        return PyNumber_Invert.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Invert(PyObject *o)
     * }
     */
    public static MemorySegment PyNumber_Invert$address() {
        return PyNumber_Invert.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyNumber_Invert(PyObject *o)
     * }
     */
    public static MemorySegment PyNumber_Invert(MemorySegment o) {
        var mh$ = PyNumber_Invert.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyNumber_Invert", o);
            }
            return (MemorySegment)mh$.invokeExact(o);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyNumber_Lshift {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyNumber_Lshift");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Lshift(PyObject *o1, PyObject *o2)
     * }
     */
    public static FunctionDescriptor PyNumber_Lshift$descriptor() {
        return PyNumber_Lshift.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Lshift(PyObject *o1, PyObject *o2)
     * }
     */
    public static MethodHandle PyNumber_Lshift$handle() {
        return PyNumber_Lshift.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Lshift(PyObject *o1, PyObject *o2)
     * }
     */
    public static MemorySegment PyNumber_Lshift$address() {
        return PyNumber_Lshift.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyNumber_Lshift(PyObject *o1, PyObject *o2)
     * }
     */
    public static MemorySegment PyNumber_Lshift(MemorySegment o1, MemorySegment o2) {
        var mh$ = PyNumber_Lshift.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyNumber_Lshift", o1, o2);
            }
            return (MemorySegment)mh$.invokeExact(o1, o2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyNumber_Rshift {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyNumber_Rshift");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Rshift(PyObject *o1, PyObject *o2)
     * }
     */
    public static FunctionDescriptor PyNumber_Rshift$descriptor() {
        return PyNumber_Rshift.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Rshift(PyObject *o1, PyObject *o2)
     * }
     */
    public static MethodHandle PyNumber_Rshift$handle() {
        return PyNumber_Rshift.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Rshift(PyObject *o1, PyObject *o2)
     * }
     */
    public static MemorySegment PyNumber_Rshift$address() {
        return PyNumber_Rshift.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyNumber_Rshift(PyObject *o1, PyObject *o2)
     * }
     */
    public static MemorySegment PyNumber_Rshift(MemorySegment o1, MemorySegment o2) {
        var mh$ = PyNumber_Rshift.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyNumber_Rshift", o1, o2);
            }
            return (MemorySegment)mh$.invokeExact(o1, o2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyNumber_And {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyNumber_And");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyNumber_And(PyObject *o1, PyObject *o2)
     * }
     */
    public static FunctionDescriptor PyNumber_And$descriptor() {
        return PyNumber_And.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyNumber_And(PyObject *o1, PyObject *o2)
     * }
     */
    public static MethodHandle PyNumber_And$handle() {
        return PyNumber_And.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyNumber_And(PyObject *o1, PyObject *o2)
     * }
     */
    public static MemorySegment PyNumber_And$address() {
        return PyNumber_And.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyNumber_And(PyObject *o1, PyObject *o2)
     * }
     */
    public static MemorySegment PyNumber_And(MemorySegment o1, MemorySegment o2) {
        var mh$ = PyNumber_And.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyNumber_And", o1, o2);
            }
            return (MemorySegment)mh$.invokeExact(o1, o2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyNumber_Xor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyNumber_Xor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Xor(PyObject *o1, PyObject *o2)
     * }
     */
    public static FunctionDescriptor PyNumber_Xor$descriptor() {
        return PyNumber_Xor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Xor(PyObject *o1, PyObject *o2)
     * }
     */
    public static MethodHandle PyNumber_Xor$handle() {
        return PyNumber_Xor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Xor(PyObject *o1, PyObject *o2)
     * }
     */
    public static MemorySegment PyNumber_Xor$address() {
        return PyNumber_Xor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyNumber_Xor(PyObject *o1, PyObject *o2)
     * }
     */
    public static MemorySegment PyNumber_Xor(MemorySegment o1, MemorySegment o2) {
        var mh$ = PyNumber_Xor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyNumber_Xor", o1, o2);
            }
            return (MemorySegment)mh$.invokeExact(o1, o2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyNumber_Or {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyNumber_Or");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Or(PyObject *o1, PyObject *o2)
     * }
     */
    public static FunctionDescriptor PyNumber_Or$descriptor() {
        return PyNumber_Or.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Or(PyObject *o1, PyObject *o2)
     * }
     */
    public static MethodHandle PyNumber_Or$handle() {
        return PyNumber_Or.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Or(PyObject *o1, PyObject *o2)
     * }
     */
    public static MemorySegment PyNumber_Or$address() {
        return PyNumber_Or.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyNumber_Or(PyObject *o1, PyObject *o2)
     * }
     */
    public static MemorySegment PyNumber_Or(MemorySegment o1, MemorySegment o2) {
        var mh$ = PyNumber_Or.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyNumber_Or", o1, o2);
            }
            return (MemorySegment)mh$.invokeExact(o1, o2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyIndex_Check {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyIndex_Check");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyIndex_Check(PyObject *)
     * }
     */
    public static FunctionDescriptor PyIndex_Check$descriptor() {
        return PyIndex_Check.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyIndex_Check(PyObject *)
     * }
     */
    public static MethodHandle PyIndex_Check$handle() {
        return PyIndex_Check.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyIndex_Check(PyObject *)
     * }
     */
    public static MemorySegment PyIndex_Check$address() {
        return PyIndex_Check.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyIndex_Check(PyObject *)
     * }
     */
    public static int PyIndex_Check(MemorySegment x0) {
        var mh$ = PyIndex_Check.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyIndex_Check", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyNumber_Index {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyNumber_Index");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Index(PyObject *o)
     * }
     */
    public static FunctionDescriptor PyNumber_Index$descriptor() {
        return PyNumber_Index.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Index(PyObject *o)
     * }
     */
    public static MethodHandle PyNumber_Index$handle() {
        return PyNumber_Index.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Index(PyObject *o)
     * }
     */
    public static MemorySegment PyNumber_Index$address() {
        return PyNumber_Index.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyNumber_Index(PyObject *o)
     * }
     */
    public static MemorySegment PyNumber_Index(MemorySegment o) {
        var mh$ = PyNumber_Index.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyNumber_Index", o);
            }
            return (MemorySegment)mh$.invokeExact(o);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyNumber_AsSsize_t {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyNumber_AsSsize_t");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_ssize_t PyNumber_AsSsize_t(PyObject *o, PyObject *exc)
     * }
     */
    public static FunctionDescriptor PyNumber_AsSsize_t$descriptor() {
        return PyNumber_AsSsize_t.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_ssize_t PyNumber_AsSsize_t(PyObject *o, PyObject *exc)
     * }
     */
    public static MethodHandle PyNumber_AsSsize_t$handle() {
        return PyNumber_AsSsize_t.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_ssize_t PyNumber_AsSsize_t(PyObject *o, PyObject *exc)
     * }
     */
    public static MemorySegment PyNumber_AsSsize_t$address() {
        return PyNumber_AsSsize_t.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_ssize_t PyNumber_AsSsize_t(PyObject *o, PyObject *exc)
     * }
     */
    public static long PyNumber_AsSsize_t(MemorySegment o, MemorySegment exc) {
        var mh$ = PyNumber_AsSsize_t.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyNumber_AsSsize_t", o, exc);
            }
            return (long)mh$.invokeExact(o, exc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyNumber_Long {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyNumber_Long");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Long(PyObject *o)
     * }
     */
    public static FunctionDescriptor PyNumber_Long$descriptor() {
        return PyNumber_Long.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Long(PyObject *o)
     * }
     */
    public static MethodHandle PyNumber_Long$handle() {
        return PyNumber_Long.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Long(PyObject *o)
     * }
     */
    public static MemorySegment PyNumber_Long$address() {
        return PyNumber_Long.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyNumber_Long(PyObject *o)
     * }
     */
    public static MemorySegment PyNumber_Long(MemorySegment o) {
        var mh$ = PyNumber_Long.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyNumber_Long", o);
            }
            return (MemorySegment)mh$.invokeExact(o);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyNumber_Float {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyNumber_Float");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Float(PyObject *o)
     * }
     */
    public static FunctionDescriptor PyNumber_Float$descriptor() {
        return PyNumber_Float.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Float(PyObject *o)
     * }
     */
    public static MethodHandle PyNumber_Float$handle() {
        return PyNumber_Float.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Float(PyObject *o)
     * }
     */
    public static MemorySegment PyNumber_Float$address() {
        return PyNumber_Float.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyNumber_Float(PyObject *o)
     * }
     */
    public static MemorySegment PyNumber_Float(MemorySegment o) {
        var mh$ = PyNumber_Float.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyNumber_Float", o);
            }
            return (MemorySegment)mh$.invokeExact(o);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyNumber_InPlaceAdd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyNumber_InPlaceAdd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyNumber_InPlaceAdd(PyObject *o1, PyObject *o2)
     * }
     */
    public static FunctionDescriptor PyNumber_InPlaceAdd$descriptor() {
        return PyNumber_InPlaceAdd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyNumber_InPlaceAdd(PyObject *o1, PyObject *o2)
     * }
     */
    public static MethodHandle PyNumber_InPlaceAdd$handle() {
        return PyNumber_InPlaceAdd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyNumber_InPlaceAdd(PyObject *o1, PyObject *o2)
     * }
     */
    public static MemorySegment PyNumber_InPlaceAdd$address() {
        return PyNumber_InPlaceAdd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyNumber_InPlaceAdd(PyObject *o1, PyObject *o2)
     * }
     */
    public static MemorySegment PyNumber_InPlaceAdd(MemorySegment o1, MemorySegment o2) {
        var mh$ = PyNumber_InPlaceAdd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyNumber_InPlaceAdd", o1, o2);
            }
            return (MemorySegment)mh$.invokeExact(o1, o2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyNumber_InPlaceSubtract {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyNumber_InPlaceSubtract");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyNumber_InPlaceSubtract(PyObject *o1, PyObject *o2)
     * }
     */
    public static FunctionDescriptor PyNumber_InPlaceSubtract$descriptor() {
        return PyNumber_InPlaceSubtract.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyNumber_InPlaceSubtract(PyObject *o1, PyObject *o2)
     * }
     */
    public static MethodHandle PyNumber_InPlaceSubtract$handle() {
        return PyNumber_InPlaceSubtract.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyNumber_InPlaceSubtract(PyObject *o1, PyObject *o2)
     * }
     */
    public static MemorySegment PyNumber_InPlaceSubtract$address() {
        return PyNumber_InPlaceSubtract.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyNumber_InPlaceSubtract(PyObject *o1, PyObject *o2)
     * }
     */
    public static MemorySegment PyNumber_InPlaceSubtract(MemorySegment o1, MemorySegment o2) {
        var mh$ = PyNumber_InPlaceSubtract.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyNumber_InPlaceSubtract", o1, o2);
            }
            return (MemorySegment)mh$.invokeExact(o1, o2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyNumber_InPlaceMultiply {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyNumber_InPlaceMultiply");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyNumber_InPlaceMultiply(PyObject *o1, PyObject *o2)
     * }
     */
    public static FunctionDescriptor PyNumber_InPlaceMultiply$descriptor() {
        return PyNumber_InPlaceMultiply.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyNumber_InPlaceMultiply(PyObject *o1, PyObject *o2)
     * }
     */
    public static MethodHandle PyNumber_InPlaceMultiply$handle() {
        return PyNumber_InPlaceMultiply.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyNumber_InPlaceMultiply(PyObject *o1, PyObject *o2)
     * }
     */
    public static MemorySegment PyNumber_InPlaceMultiply$address() {
        return PyNumber_InPlaceMultiply.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyNumber_InPlaceMultiply(PyObject *o1, PyObject *o2)
     * }
     */
    public static MemorySegment PyNumber_InPlaceMultiply(MemorySegment o1, MemorySegment o2) {
        var mh$ = PyNumber_InPlaceMultiply.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyNumber_InPlaceMultiply", o1, o2);
            }
            return (MemorySegment)mh$.invokeExact(o1, o2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyNumber_InPlaceMatrixMultiply {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyNumber_InPlaceMatrixMultiply");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyNumber_InPlaceMatrixMultiply(PyObject *o1, PyObject *o2)
     * }
     */
    public static FunctionDescriptor PyNumber_InPlaceMatrixMultiply$descriptor() {
        return PyNumber_InPlaceMatrixMultiply.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyNumber_InPlaceMatrixMultiply(PyObject *o1, PyObject *o2)
     * }
     */
    public static MethodHandle PyNumber_InPlaceMatrixMultiply$handle() {
        return PyNumber_InPlaceMatrixMultiply.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyNumber_InPlaceMatrixMultiply(PyObject *o1, PyObject *o2)
     * }
     */
    public static MemorySegment PyNumber_InPlaceMatrixMultiply$address() {
        return PyNumber_InPlaceMatrixMultiply.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyNumber_InPlaceMatrixMultiply(PyObject *o1, PyObject *o2)
     * }
     */
    public static MemorySegment PyNumber_InPlaceMatrixMultiply(MemorySegment o1, MemorySegment o2) {
        var mh$ = PyNumber_InPlaceMatrixMultiply.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyNumber_InPlaceMatrixMultiply", o1, o2);
            }
            return (MemorySegment)mh$.invokeExact(o1, o2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyNumber_InPlaceFloorDivide {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyNumber_InPlaceFloorDivide");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyNumber_InPlaceFloorDivide(PyObject *o1, PyObject *o2)
     * }
     */
    public static FunctionDescriptor PyNumber_InPlaceFloorDivide$descriptor() {
        return PyNumber_InPlaceFloorDivide.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyNumber_InPlaceFloorDivide(PyObject *o1, PyObject *o2)
     * }
     */
    public static MethodHandle PyNumber_InPlaceFloorDivide$handle() {
        return PyNumber_InPlaceFloorDivide.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyNumber_InPlaceFloorDivide(PyObject *o1, PyObject *o2)
     * }
     */
    public static MemorySegment PyNumber_InPlaceFloorDivide$address() {
        return PyNumber_InPlaceFloorDivide.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyNumber_InPlaceFloorDivide(PyObject *o1, PyObject *o2)
     * }
     */
    public static MemorySegment PyNumber_InPlaceFloorDivide(MemorySegment o1, MemorySegment o2) {
        var mh$ = PyNumber_InPlaceFloorDivide.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyNumber_InPlaceFloorDivide", o1, o2);
            }
            return (MemorySegment)mh$.invokeExact(o1, o2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyNumber_InPlaceTrueDivide {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyNumber_InPlaceTrueDivide");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyNumber_InPlaceTrueDivide(PyObject *o1, PyObject *o2)
     * }
     */
    public static FunctionDescriptor PyNumber_InPlaceTrueDivide$descriptor() {
        return PyNumber_InPlaceTrueDivide.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyNumber_InPlaceTrueDivide(PyObject *o1, PyObject *o2)
     * }
     */
    public static MethodHandle PyNumber_InPlaceTrueDivide$handle() {
        return PyNumber_InPlaceTrueDivide.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyNumber_InPlaceTrueDivide(PyObject *o1, PyObject *o2)
     * }
     */
    public static MemorySegment PyNumber_InPlaceTrueDivide$address() {
        return PyNumber_InPlaceTrueDivide.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyNumber_InPlaceTrueDivide(PyObject *o1, PyObject *o2)
     * }
     */
    public static MemorySegment PyNumber_InPlaceTrueDivide(MemorySegment o1, MemorySegment o2) {
        var mh$ = PyNumber_InPlaceTrueDivide.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyNumber_InPlaceTrueDivide", o1, o2);
            }
            return (MemorySegment)mh$.invokeExact(o1, o2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyNumber_InPlaceRemainder {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyNumber_InPlaceRemainder");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyNumber_InPlaceRemainder(PyObject *o1, PyObject *o2)
     * }
     */
    public static FunctionDescriptor PyNumber_InPlaceRemainder$descriptor() {
        return PyNumber_InPlaceRemainder.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyNumber_InPlaceRemainder(PyObject *o1, PyObject *o2)
     * }
     */
    public static MethodHandle PyNumber_InPlaceRemainder$handle() {
        return PyNumber_InPlaceRemainder.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyNumber_InPlaceRemainder(PyObject *o1, PyObject *o2)
     * }
     */
    public static MemorySegment PyNumber_InPlaceRemainder$address() {
        return PyNumber_InPlaceRemainder.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyNumber_InPlaceRemainder(PyObject *o1, PyObject *o2)
     * }
     */
    public static MemorySegment PyNumber_InPlaceRemainder(MemorySegment o1, MemorySegment o2) {
        var mh$ = PyNumber_InPlaceRemainder.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyNumber_InPlaceRemainder", o1, o2);
            }
            return (MemorySegment)mh$.invokeExact(o1, o2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyNumber_InPlacePower {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyNumber_InPlacePower");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyNumber_InPlacePower(PyObject *o1, PyObject *o2, PyObject *o3)
     * }
     */
    public static FunctionDescriptor PyNumber_InPlacePower$descriptor() {
        return PyNumber_InPlacePower.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyNumber_InPlacePower(PyObject *o1, PyObject *o2, PyObject *o3)
     * }
     */
    public static MethodHandle PyNumber_InPlacePower$handle() {
        return PyNumber_InPlacePower.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyNumber_InPlacePower(PyObject *o1, PyObject *o2, PyObject *o3)
     * }
     */
    public static MemorySegment PyNumber_InPlacePower$address() {
        return PyNumber_InPlacePower.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyNumber_InPlacePower(PyObject *o1, PyObject *o2, PyObject *o3)
     * }
     */
    public static MemorySegment PyNumber_InPlacePower(MemorySegment o1, MemorySegment o2, MemorySegment o3) {
        var mh$ = PyNumber_InPlacePower.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyNumber_InPlacePower", o1, o2, o3);
            }
            return (MemorySegment)mh$.invokeExact(o1, o2, o3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyNumber_InPlaceLshift {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyNumber_InPlaceLshift");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyNumber_InPlaceLshift(PyObject *o1, PyObject *o2)
     * }
     */
    public static FunctionDescriptor PyNumber_InPlaceLshift$descriptor() {
        return PyNumber_InPlaceLshift.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyNumber_InPlaceLshift(PyObject *o1, PyObject *o2)
     * }
     */
    public static MethodHandle PyNumber_InPlaceLshift$handle() {
        return PyNumber_InPlaceLshift.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyNumber_InPlaceLshift(PyObject *o1, PyObject *o2)
     * }
     */
    public static MemorySegment PyNumber_InPlaceLshift$address() {
        return PyNumber_InPlaceLshift.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyNumber_InPlaceLshift(PyObject *o1, PyObject *o2)
     * }
     */
    public static MemorySegment PyNumber_InPlaceLshift(MemorySegment o1, MemorySegment o2) {
        var mh$ = PyNumber_InPlaceLshift.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyNumber_InPlaceLshift", o1, o2);
            }
            return (MemorySegment)mh$.invokeExact(o1, o2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyNumber_InPlaceRshift {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyNumber_InPlaceRshift");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyNumber_InPlaceRshift(PyObject *o1, PyObject *o2)
     * }
     */
    public static FunctionDescriptor PyNumber_InPlaceRshift$descriptor() {
        return PyNumber_InPlaceRshift.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyNumber_InPlaceRshift(PyObject *o1, PyObject *o2)
     * }
     */
    public static MethodHandle PyNumber_InPlaceRshift$handle() {
        return PyNumber_InPlaceRshift.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyNumber_InPlaceRshift(PyObject *o1, PyObject *o2)
     * }
     */
    public static MemorySegment PyNumber_InPlaceRshift$address() {
        return PyNumber_InPlaceRshift.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyNumber_InPlaceRshift(PyObject *o1, PyObject *o2)
     * }
     */
    public static MemorySegment PyNumber_InPlaceRshift(MemorySegment o1, MemorySegment o2) {
        var mh$ = PyNumber_InPlaceRshift.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyNumber_InPlaceRshift", o1, o2);
            }
            return (MemorySegment)mh$.invokeExact(o1, o2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyNumber_InPlaceAnd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyNumber_InPlaceAnd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyNumber_InPlaceAnd(PyObject *o1, PyObject *o2)
     * }
     */
    public static FunctionDescriptor PyNumber_InPlaceAnd$descriptor() {
        return PyNumber_InPlaceAnd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyNumber_InPlaceAnd(PyObject *o1, PyObject *o2)
     * }
     */
    public static MethodHandle PyNumber_InPlaceAnd$handle() {
        return PyNumber_InPlaceAnd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyNumber_InPlaceAnd(PyObject *o1, PyObject *o2)
     * }
     */
    public static MemorySegment PyNumber_InPlaceAnd$address() {
        return PyNumber_InPlaceAnd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyNumber_InPlaceAnd(PyObject *o1, PyObject *o2)
     * }
     */
    public static MemorySegment PyNumber_InPlaceAnd(MemorySegment o1, MemorySegment o2) {
        var mh$ = PyNumber_InPlaceAnd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyNumber_InPlaceAnd", o1, o2);
            }
            return (MemorySegment)mh$.invokeExact(o1, o2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyNumber_InPlaceXor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyNumber_InPlaceXor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyNumber_InPlaceXor(PyObject *o1, PyObject *o2)
     * }
     */
    public static FunctionDescriptor PyNumber_InPlaceXor$descriptor() {
        return PyNumber_InPlaceXor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyNumber_InPlaceXor(PyObject *o1, PyObject *o2)
     * }
     */
    public static MethodHandle PyNumber_InPlaceXor$handle() {
        return PyNumber_InPlaceXor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyNumber_InPlaceXor(PyObject *o1, PyObject *o2)
     * }
     */
    public static MemorySegment PyNumber_InPlaceXor$address() {
        return PyNumber_InPlaceXor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyNumber_InPlaceXor(PyObject *o1, PyObject *o2)
     * }
     */
    public static MemorySegment PyNumber_InPlaceXor(MemorySegment o1, MemorySegment o2) {
        var mh$ = PyNumber_InPlaceXor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyNumber_InPlaceXor", o1, o2);
            }
            return (MemorySegment)mh$.invokeExact(o1, o2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyNumber_InPlaceOr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyNumber_InPlaceOr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyNumber_InPlaceOr(PyObject *o1, PyObject *o2)
     * }
     */
    public static FunctionDescriptor PyNumber_InPlaceOr$descriptor() {
        return PyNumber_InPlaceOr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyNumber_InPlaceOr(PyObject *o1, PyObject *o2)
     * }
     */
    public static MethodHandle PyNumber_InPlaceOr$handle() {
        return PyNumber_InPlaceOr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyNumber_InPlaceOr(PyObject *o1, PyObject *o2)
     * }
     */
    public static MemorySegment PyNumber_InPlaceOr$address() {
        return PyNumber_InPlaceOr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyNumber_InPlaceOr(PyObject *o1, PyObject *o2)
     * }
     */
    public static MemorySegment PyNumber_InPlaceOr(MemorySegment o1, MemorySegment o2) {
        var mh$ = PyNumber_InPlaceOr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyNumber_InPlaceOr", o1, o2);
            }
            return (MemorySegment)mh$.invokeExact(o1, o2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyNumber_ToBase {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyNumber_ToBase");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyNumber_ToBase(PyObject *n, int base)
     * }
     */
    public static FunctionDescriptor PyNumber_ToBase$descriptor() {
        return PyNumber_ToBase.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyNumber_ToBase(PyObject *n, int base)
     * }
     */
    public static MethodHandle PyNumber_ToBase$handle() {
        return PyNumber_ToBase.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyNumber_ToBase(PyObject *n, int base)
     * }
     */
    public static MemorySegment PyNumber_ToBase$address() {
        return PyNumber_ToBase.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyNumber_ToBase(PyObject *n, int base)
     * }
     */
    public static MemorySegment PyNumber_ToBase(MemorySegment n, int base) {
        var mh$ = PyNumber_ToBase.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyNumber_ToBase", n, base);
            }
            return (MemorySegment)mh$.invokeExact(n, base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PySequence_Check {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PySequence_Check");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PySequence_Check(PyObject *o)
     * }
     */
    public static FunctionDescriptor PySequence_Check$descriptor() {
        return PySequence_Check.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PySequence_Check(PyObject *o)
     * }
     */
    public static MethodHandle PySequence_Check$handle() {
        return PySequence_Check.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PySequence_Check(PyObject *o)
     * }
     */
    public static MemorySegment PySequence_Check$address() {
        return PySequence_Check.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PySequence_Check(PyObject *o)
     * }
     */
    public static int PySequence_Check(MemorySegment o) {
        var mh$ = PySequence_Check.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PySequence_Check", o);
            }
            return (int)mh$.invokeExact(o);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PySequence_Size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PySequence_Size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_ssize_t PySequence_Size(PyObject *o)
     * }
     */
    public static FunctionDescriptor PySequence_Size$descriptor() {
        return PySequence_Size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_ssize_t PySequence_Size(PyObject *o)
     * }
     */
    public static MethodHandle PySequence_Size$handle() {
        return PySequence_Size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_ssize_t PySequence_Size(PyObject *o)
     * }
     */
    public static MemorySegment PySequence_Size$address() {
        return PySequence_Size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_ssize_t PySequence_Size(PyObject *o)
     * }
     */
    public static long PySequence_Size(MemorySegment o) {
        var mh$ = PySequence_Size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PySequence_Size", o);
            }
            return (long)mh$.invokeExact(o);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PySequence_Length {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PySequence_Length");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_ssize_t PySequence_Length(PyObject *o)
     * }
     */
    public static FunctionDescriptor PySequence_Length$descriptor() {
        return PySequence_Length.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_ssize_t PySequence_Length(PyObject *o)
     * }
     */
    public static MethodHandle PySequence_Length$handle() {
        return PySequence_Length.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_ssize_t PySequence_Length(PyObject *o)
     * }
     */
    public static MemorySegment PySequence_Length$address() {
        return PySequence_Length.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_ssize_t PySequence_Length(PyObject *o)
     * }
     */
    public static long PySequence_Length(MemorySegment o) {
        var mh$ = PySequence_Length.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PySequence_Length", o);
            }
            return (long)mh$.invokeExact(o);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PySequence_Concat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PySequence_Concat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PySequence_Concat(PyObject *o1, PyObject *o2)
     * }
     */
    public static FunctionDescriptor PySequence_Concat$descriptor() {
        return PySequence_Concat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PySequence_Concat(PyObject *o1, PyObject *o2)
     * }
     */
    public static MethodHandle PySequence_Concat$handle() {
        return PySequence_Concat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PySequence_Concat(PyObject *o1, PyObject *o2)
     * }
     */
    public static MemorySegment PySequence_Concat$address() {
        return PySequence_Concat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PySequence_Concat(PyObject *o1, PyObject *o2)
     * }
     */
    public static MemorySegment PySequence_Concat(MemorySegment o1, MemorySegment o2) {
        var mh$ = PySequence_Concat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PySequence_Concat", o1, o2);
            }
            return (MemorySegment)mh$.invokeExact(o1, o2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PySequence_Repeat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PySequence_Repeat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PySequence_Repeat(PyObject *o, Py_ssize_t count)
     * }
     */
    public static FunctionDescriptor PySequence_Repeat$descriptor() {
        return PySequence_Repeat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PySequence_Repeat(PyObject *o, Py_ssize_t count)
     * }
     */
    public static MethodHandle PySequence_Repeat$handle() {
        return PySequence_Repeat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PySequence_Repeat(PyObject *o, Py_ssize_t count)
     * }
     */
    public static MemorySegment PySequence_Repeat$address() {
        return PySequence_Repeat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PySequence_Repeat(PyObject *o, Py_ssize_t count)
     * }
     */
    public static MemorySegment PySequence_Repeat(MemorySegment o, long count) {
        var mh$ = PySequence_Repeat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PySequence_Repeat", o, count);
            }
            return (MemorySegment)mh$.invokeExact(o, count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PySequence_GetItem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PySequence_GetItem");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PySequence_GetItem(PyObject *o, Py_ssize_t i)
     * }
     */
    public static FunctionDescriptor PySequence_GetItem$descriptor() {
        return PySequence_GetItem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PySequence_GetItem(PyObject *o, Py_ssize_t i)
     * }
     */
    public static MethodHandle PySequence_GetItem$handle() {
        return PySequence_GetItem.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PySequence_GetItem(PyObject *o, Py_ssize_t i)
     * }
     */
    public static MemorySegment PySequence_GetItem$address() {
        return PySequence_GetItem.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PySequence_GetItem(PyObject *o, Py_ssize_t i)
     * }
     */
    public static MemorySegment PySequence_GetItem(MemorySegment o, long i) {
        var mh$ = PySequence_GetItem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PySequence_GetItem", o, i);
            }
            return (MemorySegment)mh$.invokeExact(o, i);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PySequence_GetSlice {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PySequence_GetSlice");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PySequence_GetSlice(PyObject *o, Py_ssize_t i1, Py_ssize_t i2)
     * }
     */
    public static FunctionDescriptor PySequence_GetSlice$descriptor() {
        return PySequence_GetSlice.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PySequence_GetSlice(PyObject *o, Py_ssize_t i1, Py_ssize_t i2)
     * }
     */
    public static MethodHandle PySequence_GetSlice$handle() {
        return PySequence_GetSlice.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PySequence_GetSlice(PyObject *o, Py_ssize_t i1, Py_ssize_t i2)
     * }
     */
    public static MemorySegment PySequence_GetSlice$address() {
        return PySequence_GetSlice.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PySequence_GetSlice(PyObject *o, Py_ssize_t i1, Py_ssize_t i2)
     * }
     */
    public static MemorySegment PySequence_GetSlice(MemorySegment o, long i1, long i2) {
        var mh$ = PySequence_GetSlice.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PySequence_GetSlice", o, i1, i2);
            }
            return (MemorySegment)mh$.invokeExact(o, i1, i2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PySequence_SetItem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PySequence_SetItem");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PySequence_SetItem(PyObject *o, Py_ssize_t i, PyObject *v)
     * }
     */
    public static FunctionDescriptor PySequence_SetItem$descriptor() {
        return PySequence_SetItem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PySequence_SetItem(PyObject *o, Py_ssize_t i, PyObject *v)
     * }
     */
    public static MethodHandle PySequence_SetItem$handle() {
        return PySequence_SetItem.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PySequence_SetItem(PyObject *o, Py_ssize_t i, PyObject *v)
     * }
     */
    public static MemorySegment PySequence_SetItem$address() {
        return PySequence_SetItem.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PySequence_SetItem(PyObject *o, Py_ssize_t i, PyObject *v)
     * }
     */
    public static int PySequence_SetItem(MemorySegment o, long i, MemorySegment v) {
        var mh$ = PySequence_SetItem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PySequence_SetItem", o, i, v);
            }
            return (int)mh$.invokeExact(o, i, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PySequence_DelItem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PySequence_DelItem");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PySequence_DelItem(PyObject *o, Py_ssize_t i)
     * }
     */
    public static FunctionDescriptor PySequence_DelItem$descriptor() {
        return PySequence_DelItem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PySequence_DelItem(PyObject *o, Py_ssize_t i)
     * }
     */
    public static MethodHandle PySequence_DelItem$handle() {
        return PySequence_DelItem.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PySequence_DelItem(PyObject *o, Py_ssize_t i)
     * }
     */
    public static MemorySegment PySequence_DelItem$address() {
        return PySequence_DelItem.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PySequence_DelItem(PyObject *o, Py_ssize_t i)
     * }
     */
    public static int PySequence_DelItem(MemorySegment o, long i) {
        var mh$ = PySequence_DelItem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PySequence_DelItem", o, i);
            }
            return (int)mh$.invokeExact(o, i);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PySequence_SetSlice {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PySequence_SetSlice");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PySequence_SetSlice(PyObject *o, Py_ssize_t i1, Py_ssize_t i2, PyObject *v)
     * }
     */
    public static FunctionDescriptor PySequence_SetSlice$descriptor() {
        return PySequence_SetSlice.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PySequence_SetSlice(PyObject *o, Py_ssize_t i1, Py_ssize_t i2, PyObject *v)
     * }
     */
    public static MethodHandle PySequence_SetSlice$handle() {
        return PySequence_SetSlice.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PySequence_SetSlice(PyObject *o, Py_ssize_t i1, Py_ssize_t i2, PyObject *v)
     * }
     */
    public static MemorySegment PySequence_SetSlice$address() {
        return PySequence_SetSlice.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PySequence_SetSlice(PyObject *o, Py_ssize_t i1, Py_ssize_t i2, PyObject *v)
     * }
     */
    public static int PySequence_SetSlice(MemorySegment o, long i1, long i2, MemorySegment v) {
        var mh$ = PySequence_SetSlice.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PySequence_SetSlice", o, i1, i2, v);
            }
            return (int)mh$.invokeExact(o, i1, i2, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PySequence_DelSlice {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PySequence_DelSlice");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PySequence_DelSlice(PyObject *o, Py_ssize_t i1, Py_ssize_t i2)
     * }
     */
    public static FunctionDescriptor PySequence_DelSlice$descriptor() {
        return PySequence_DelSlice.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PySequence_DelSlice(PyObject *o, Py_ssize_t i1, Py_ssize_t i2)
     * }
     */
    public static MethodHandle PySequence_DelSlice$handle() {
        return PySequence_DelSlice.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PySequence_DelSlice(PyObject *o, Py_ssize_t i1, Py_ssize_t i2)
     * }
     */
    public static MemorySegment PySequence_DelSlice$address() {
        return PySequence_DelSlice.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PySequence_DelSlice(PyObject *o, Py_ssize_t i1, Py_ssize_t i2)
     * }
     */
    public static int PySequence_DelSlice(MemorySegment o, long i1, long i2) {
        var mh$ = PySequence_DelSlice.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PySequence_DelSlice", o, i1, i2);
            }
            return (int)mh$.invokeExact(o, i1, i2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PySequence_Tuple {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PySequence_Tuple");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PySequence_Tuple(PyObject *o)
     * }
     */
    public static FunctionDescriptor PySequence_Tuple$descriptor() {
        return PySequence_Tuple.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PySequence_Tuple(PyObject *o)
     * }
     */
    public static MethodHandle PySequence_Tuple$handle() {
        return PySequence_Tuple.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PySequence_Tuple(PyObject *o)
     * }
     */
    public static MemorySegment PySequence_Tuple$address() {
        return PySequence_Tuple.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PySequence_Tuple(PyObject *o)
     * }
     */
    public static MemorySegment PySequence_Tuple(MemorySegment o) {
        var mh$ = PySequence_Tuple.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PySequence_Tuple", o);
            }
            return (MemorySegment)mh$.invokeExact(o);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PySequence_List {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PySequence_List");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PySequence_List(PyObject *o)
     * }
     */
    public static FunctionDescriptor PySequence_List$descriptor() {
        return PySequence_List.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PySequence_List(PyObject *o)
     * }
     */
    public static MethodHandle PySequence_List$handle() {
        return PySequence_List.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PySequence_List(PyObject *o)
     * }
     */
    public static MemorySegment PySequence_List$address() {
        return PySequence_List.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PySequence_List(PyObject *o)
     * }
     */
    public static MemorySegment PySequence_List(MemorySegment o) {
        var mh$ = PySequence_List.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PySequence_List", o);
            }
            return (MemorySegment)mh$.invokeExact(o);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PySequence_Fast {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PySequence_Fast");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PySequence_Fast(PyObject *o, const char *m)
     * }
     */
    public static FunctionDescriptor PySequence_Fast$descriptor() {
        return PySequence_Fast.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PySequence_Fast(PyObject *o, const char *m)
     * }
     */
    public static MethodHandle PySequence_Fast$handle() {
        return PySequence_Fast.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PySequence_Fast(PyObject *o, const char *m)
     * }
     */
    public static MemorySegment PySequence_Fast$address() {
        return PySequence_Fast.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PySequence_Fast(PyObject *o, const char *m)
     * }
     */
    public static MemorySegment PySequence_Fast(MemorySegment o, MemorySegment m) {
        var mh$ = PySequence_Fast.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PySequence_Fast", o, m);
            }
            return (MemorySegment)mh$.invokeExact(o, m);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PySequence_Count {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PySequence_Count");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_ssize_t PySequence_Count(PyObject *o, PyObject *value)
     * }
     */
    public static FunctionDescriptor PySequence_Count$descriptor() {
        return PySequence_Count.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_ssize_t PySequence_Count(PyObject *o, PyObject *value)
     * }
     */
    public static MethodHandle PySequence_Count$handle() {
        return PySequence_Count.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_ssize_t PySequence_Count(PyObject *o, PyObject *value)
     * }
     */
    public static MemorySegment PySequence_Count$address() {
        return PySequence_Count.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_ssize_t PySequence_Count(PyObject *o, PyObject *value)
     * }
     */
    public static long PySequence_Count(MemorySegment o, MemorySegment value) {
        var mh$ = PySequence_Count.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PySequence_Count", o, value);
            }
            return (long)mh$.invokeExact(o, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PySequence_Contains {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PySequence_Contains");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PySequence_Contains(PyObject *seq, PyObject *ob)
     * }
     */
    public static FunctionDescriptor PySequence_Contains$descriptor() {
        return PySequence_Contains.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PySequence_Contains(PyObject *seq, PyObject *ob)
     * }
     */
    public static MethodHandle PySequence_Contains$handle() {
        return PySequence_Contains.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PySequence_Contains(PyObject *seq, PyObject *ob)
     * }
     */
    public static MemorySegment PySequence_Contains$address() {
        return PySequence_Contains.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PySequence_Contains(PyObject *seq, PyObject *ob)
     * }
     */
    public static int PySequence_Contains(MemorySegment seq, MemorySegment ob) {
        var mh$ = PySequence_Contains.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PySequence_Contains", seq, ob);
            }
            return (int)mh$.invokeExact(seq, ob);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PySequence_In {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PySequence_In");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PySequence_In(PyObject *o, PyObject *value)
     * }
     */
    public static FunctionDescriptor PySequence_In$descriptor() {
        return PySequence_In.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PySequence_In(PyObject *o, PyObject *value)
     * }
     */
    public static MethodHandle PySequence_In$handle() {
        return PySequence_In.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PySequence_In(PyObject *o, PyObject *value)
     * }
     */
    public static MemorySegment PySequence_In$address() {
        return PySequence_In.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PySequence_In(PyObject *o, PyObject *value)
     * }
     */
    public static int PySequence_In(MemorySegment o, MemorySegment value) {
        var mh$ = PySequence_In.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PySequence_In", o, value);
            }
            return (int)mh$.invokeExact(o, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PySequence_Index {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PySequence_Index");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_ssize_t PySequence_Index(PyObject *o, PyObject *value)
     * }
     */
    public static FunctionDescriptor PySequence_Index$descriptor() {
        return PySequence_Index.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_ssize_t PySequence_Index(PyObject *o, PyObject *value)
     * }
     */
    public static MethodHandle PySequence_Index$handle() {
        return PySequence_Index.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_ssize_t PySequence_Index(PyObject *o, PyObject *value)
     * }
     */
    public static MemorySegment PySequence_Index$address() {
        return PySequence_Index.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_ssize_t PySequence_Index(PyObject *o, PyObject *value)
     * }
     */
    public static long PySequence_Index(MemorySegment o, MemorySegment value) {
        var mh$ = PySequence_Index.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PySequence_Index", o, value);
            }
            return (long)mh$.invokeExact(o, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PySequence_InPlaceConcat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PySequence_InPlaceConcat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PySequence_InPlaceConcat(PyObject *o1, PyObject *o2)
     * }
     */
    public static FunctionDescriptor PySequence_InPlaceConcat$descriptor() {
        return PySequence_InPlaceConcat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PySequence_InPlaceConcat(PyObject *o1, PyObject *o2)
     * }
     */
    public static MethodHandle PySequence_InPlaceConcat$handle() {
        return PySequence_InPlaceConcat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PySequence_InPlaceConcat(PyObject *o1, PyObject *o2)
     * }
     */
    public static MemorySegment PySequence_InPlaceConcat$address() {
        return PySequence_InPlaceConcat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PySequence_InPlaceConcat(PyObject *o1, PyObject *o2)
     * }
     */
    public static MemorySegment PySequence_InPlaceConcat(MemorySegment o1, MemorySegment o2) {
        var mh$ = PySequence_InPlaceConcat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PySequence_InPlaceConcat", o1, o2);
            }
            return (MemorySegment)mh$.invokeExact(o1, o2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PySequence_InPlaceRepeat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PySequence_InPlaceRepeat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PySequence_InPlaceRepeat(PyObject *o, Py_ssize_t count)
     * }
     */
    public static FunctionDescriptor PySequence_InPlaceRepeat$descriptor() {
        return PySequence_InPlaceRepeat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PySequence_InPlaceRepeat(PyObject *o, Py_ssize_t count)
     * }
     */
    public static MethodHandle PySequence_InPlaceRepeat$handle() {
        return PySequence_InPlaceRepeat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PySequence_InPlaceRepeat(PyObject *o, Py_ssize_t count)
     * }
     */
    public static MemorySegment PySequence_InPlaceRepeat$address() {
        return PySequence_InPlaceRepeat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PySequence_InPlaceRepeat(PyObject *o, Py_ssize_t count)
     * }
     */
    public static MemorySegment PySequence_InPlaceRepeat(MemorySegment o, long count) {
        var mh$ = PySequence_InPlaceRepeat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PySequence_InPlaceRepeat", o, count);
            }
            return (MemorySegment)mh$.invokeExact(o, count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyMapping_Check {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyMapping_Check");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyMapping_Check(PyObject *o)
     * }
     */
    public static FunctionDescriptor PyMapping_Check$descriptor() {
        return PyMapping_Check.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyMapping_Check(PyObject *o)
     * }
     */
    public static MethodHandle PyMapping_Check$handle() {
        return PyMapping_Check.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyMapping_Check(PyObject *o)
     * }
     */
    public static MemorySegment PyMapping_Check$address() {
        return PyMapping_Check.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyMapping_Check(PyObject *o)
     * }
     */
    public static int PyMapping_Check(MemorySegment o) {
        var mh$ = PyMapping_Check.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyMapping_Check", o);
            }
            return (int)mh$.invokeExact(o);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyMapping_Size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyMapping_Size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_ssize_t PyMapping_Size(PyObject *o)
     * }
     */
    public static FunctionDescriptor PyMapping_Size$descriptor() {
        return PyMapping_Size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_ssize_t PyMapping_Size(PyObject *o)
     * }
     */
    public static MethodHandle PyMapping_Size$handle() {
        return PyMapping_Size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_ssize_t PyMapping_Size(PyObject *o)
     * }
     */
    public static MemorySegment PyMapping_Size$address() {
        return PyMapping_Size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_ssize_t PyMapping_Size(PyObject *o)
     * }
     */
    public static long PyMapping_Size(MemorySegment o) {
        var mh$ = PyMapping_Size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyMapping_Size", o);
            }
            return (long)mh$.invokeExact(o);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyMapping_Length {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyMapping_Length");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_ssize_t PyMapping_Length(PyObject *o)
     * }
     */
    public static FunctionDescriptor PyMapping_Length$descriptor() {
        return PyMapping_Length.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_ssize_t PyMapping_Length(PyObject *o)
     * }
     */
    public static MethodHandle PyMapping_Length$handle() {
        return PyMapping_Length.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_ssize_t PyMapping_Length(PyObject *o)
     * }
     */
    public static MemorySegment PyMapping_Length$address() {
        return PyMapping_Length.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_ssize_t PyMapping_Length(PyObject *o)
     * }
     */
    public static long PyMapping_Length(MemorySegment o) {
        var mh$ = PyMapping_Length.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyMapping_Length", o);
            }
            return (long)mh$.invokeExact(o);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyMapping_HasKeyString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyMapping_HasKeyString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyMapping_HasKeyString(PyObject *o, const char *key)
     * }
     */
    public static FunctionDescriptor PyMapping_HasKeyString$descriptor() {
        return PyMapping_HasKeyString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyMapping_HasKeyString(PyObject *o, const char *key)
     * }
     */
    public static MethodHandle PyMapping_HasKeyString$handle() {
        return PyMapping_HasKeyString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyMapping_HasKeyString(PyObject *o, const char *key)
     * }
     */
    public static MemorySegment PyMapping_HasKeyString$address() {
        return PyMapping_HasKeyString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyMapping_HasKeyString(PyObject *o, const char *key)
     * }
     */
    public static int PyMapping_HasKeyString(MemorySegment o, MemorySegment key) {
        var mh$ = PyMapping_HasKeyString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyMapping_HasKeyString", o, key);
            }
            return (int)mh$.invokeExact(o, key);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyMapping_HasKey {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyMapping_HasKey");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyMapping_HasKey(PyObject *o, PyObject *key)
     * }
     */
    public static FunctionDescriptor PyMapping_HasKey$descriptor() {
        return PyMapping_HasKey.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyMapping_HasKey(PyObject *o, PyObject *key)
     * }
     */
    public static MethodHandle PyMapping_HasKey$handle() {
        return PyMapping_HasKey.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyMapping_HasKey(PyObject *o, PyObject *key)
     * }
     */
    public static MemorySegment PyMapping_HasKey$address() {
        return PyMapping_HasKey.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyMapping_HasKey(PyObject *o, PyObject *key)
     * }
     */
    public static int PyMapping_HasKey(MemorySegment o, MemorySegment key) {
        var mh$ = PyMapping_HasKey.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyMapping_HasKey", o, key);
            }
            return (int)mh$.invokeExact(o, key);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyMapping_Keys {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyMapping_Keys");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyMapping_Keys(PyObject *o)
     * }
     */
    public static FunctionDescriptor PyMapping_Keys$descriptor() {
        return PyMapping_Keys.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyMapping_Keys(PyObject *o)
     * }
     */
    public static MethodHandle PyMapping_Keys$handle() {
        return PyMapping_Keys.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyMapping_Keys(PyObject *o)
     * }
     */
    public static MemorySegment PyMapping_Keys$address() {
        return PyMapping_Keys.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyMapping_Keys(PyObject *o)
     * }
     */
    public static MemorySegment PyMapping_Keys(MemorySegment o) {
        var mh$ = PyMapping_Keys.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyMapping_Keys", o);
            }
            return (MemorySegment)mh$.invokeExact(o);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyMapping_Values {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyMapping_Values");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyMapping_Values(PyObject *o)
     * }
     */
    public static FunctionDescriptor PyMapping_Values$descriptor() {
        return PyMapping_Values.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyMapping_Values(PyObject *o)
     * }
     */
    public static MethodHandle PyMapping_Values$handle() {
        return PyMapping_Values.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyMapping_Values(PyObject *o)
     * }
     */
    public static MemorySegment PyMapping_Values$address() {
        return PyMapping_Values.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyMapping_Values(PyObject *o)
     * }
     */
    public static MemorySegment PyMapping_Values(MemorySegment o) {
        var mh$ = PyMapping_Values.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyMapping_Values", o);
            }
            return (MemorySegment)mh$.invokeExact(o);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyMapping_Items {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyMapping_Items");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyMapping_Items(PyObject *o)
     * }
     */
    public static FunctionDescriptor PyMapping_Items$descriptor() {
        return PyMapping_Items.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyMapping_Items(PyObject *o)
     * }
     */
    public static MethodHandle PyMapping_Items$handle() {
        return PyMapping_Items.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyMapping_Items(PyObject *o)
     * }
     */
    public static MemorySegment PyMapping_Items$address() {
        return PyMapping_Items.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyMapping_Items(PyObject *o)
     * }
     */
    public static MemorySegment PyMapping_Items(MemorySegment o) {
        var mh$ = PyMapping_Items.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyMapping_Items", o);
            }
            return (MemorySegment)mh$.invokeExact(o);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyMapping_GetItemString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyMapping_GetItemString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyMapping_GetItemString(PyObject *o, const char *key)
     * }
     */
    public static FunctionDescriptor PyMapping_GetItemString$descriptor() {
        return PyMapping_GetItemString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyMapping_GetItemString(PyObject *o, const char *key)
     * }
     */
    public static MethodHandle PyMapping_GetItemString$handle() {
        return PyMapping_GetItemString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyMapping_GetItemString(PyObject *o, const char *key)
     * }
     */
    public static MemorySegment PyMapping_GetItemString$address() {
        return PyMapping_GetItemString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyMapping_GetItemString(PyObject *o, const char *key)
     * }
     */
    public static MemorySegment PyMapping_GetItemString(MemorySegment o, MemorySegment key) {
        var mh$ = PyMapping_GetItemString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyMapping_GetItemString", o, key);
            }
            return (MemorySegment)mh$.invokeExact(o, key);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyMapping_SetItemString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyMapping_SetItemString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyMapping_SetItemString(PyObject *o, const char *key, PyObject *value)
     * }
     */
    public static FunctionDescriptor PyMapping_SetItemString$descriptor() {
        return PyMapping_SetItemString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyMapping_SetItemString(PyObject *o, const char *key, PyObject *value)
     * }
     */
    public static MethodHandle PyMapping_SetItemString$handle() {
        return PyMapping_SetItemString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyMapping_SetItemString(PyObject *o, const char *key, PyObject *value)
     * }
     */
    public static MemorySegment PyMapping_SetItemString$address() {
        return PyMapping_SetItemString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyMapping_SetItemString(PyObject *o, const char *key, PyObject *value)
     * }
     */
    public static int PyMapping_SetItemString(MemorySegment o, MemorySegment key, MemorySegment value) {
        var mh$ = PyMapping_SetItemString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyMapping_SetItemString", o, key, value);
            }
            return (int)mh$.invokeExact(o, key, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_IsInstance {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_IsInstance");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyObject_IsInstance(PyObject *object, PyObject *typeorclass)
     * }
     */
    public static FunctionDescriptor PyObject_IsInstance$descriptor() {
        return PyObject_IsInstance.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyObject_IsInstance(PyObject *object, PyObject *typeorclass)
     * }
     */
    public static MethodHandle PyObject_IsInstance$handle() {
        return PyObject_IsInstance.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyObject_IsInstance(PyObject *object, PyObject *typeorclass)
     * }
     */
    public static MemorySegment PyObject_IsInstance$address() {
        return PyObject_IsInstance.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyObject_IsInstance(PyObject *object, PyObject *typeorclass)
     * }
     */
    public static int PyObject_IsInstance(MemorySegment object, MemorySegment typeorclass) {
        var mh$ = PyObject_IsInstance.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_IsInstance", object, typeorclass);
            }
            return (int)mh$.invokeExact(object, typeorclass);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_IsSubclass {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_IsSubclass");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyObject_IsSubclass(PyObject *object, PyObject *typeorclass)
     * }
     */
    public static FunctionDescriptor PyObject_IsSubclass$descriptor() {
        return PyObject_IsSubclass.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyObject_IsSubclass(PyObject *object, PyObject *typeorclass)
     * }
     */
    public static MethodHandle PyObject_IsSubclass$handle() {
        return PyObject_IsSubclass.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyObject_IsSubclass(PyObject *object, PyObject *typeorclass)
     * }
     */
    public static MemorySegment PyObject_IsSubclass$address() {
        return PyObject_IsSubclass.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyObject_IsSubclass(PyObject *object, PyObject *typeorclass)
     * }
     */
    public static int PyObject_IsSubclass(MemorySegment object, MemorySegment typeorclass) {
        var mh$ = PyObject_IsSubclass.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_IsSubclass", object, typeorclass);
            }
            return (int)mh$.invokeExact(object, typeorclass);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyFilter_Type$constants {
        public static final GroupLayout LAYOUT = _object.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyFilter_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyFilter_Type
     * }
     */
    public static GroupLayout PyFilter_Type$layout() {
        return PyFilter_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyFilter_Type
     * }
     */
    public static MemorySegment PyFilter_Type() {
        return PyFilter_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyFilter_Type
     * }
     */
    public static void PyFilter_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyFilter_Type$constants.SEGMENT, 0L, PyFilter_Type$constants.LAYOUT.byteSize());
    }

    private static class PyMap_Type$constants {
        public static final GroupLayout LAYOUT = _object.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyMap_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyMap_Type
     * }
     */
    public static GroupLayout PyMap_Type$layout() {
        return PyMap_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyMap_Type
     * }
     */
    public static MemorySegment PyMap_Type() {
        return PyMap_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyMap_Type
     * }
     */
    public static void PyMap_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyMap_Type$constants.SEGMENT, 0L, PyMap_Type$constants.LAYOUT.byteSize());
    }

    private static class PyZip_Type$constants {
        public static final GroupLayout LAYOUT = _object.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyZip_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyZip_Type
     * }
     */
    public static GroupLayout PyZip_Type$layout() {
        return PyZip_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyZip_Type
     * }
     */
    public static MemorySegment PyZip_Type() {
        return PyZip_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyZip_Type
     * }
     */
    public static void PyZip_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyZip_Type$constants.SEGMENT, 0L, PyZip_Type$constants.LAYOUT.byteSize());
    }

    private static class PyOS_string_to_double {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyOS_string_to_double");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double PyOS_string_to_double(const char *str, char **endptr, PyObject *overflow_exception)
     * }
     */
    public static FunctionDescriptor PyOS_string_to_double$descriptor() {
        return PyOS_string_to_double.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double PyOS_string_to_double(const char *str, char **endptr, PyObject *overflow_exception)
     * }
     */
    public static MethodHandle PyOS_string_to_double$handle() {
        return PyOS_string_to_double.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double PyOS_string_to_double(const char *str, char **endptr, PyObject *overflow_exception)
     * }
     */
    public static MemorySegment PyOS_string_to_double$address() {
        return PyOS_string_to_double.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double PyOS_string_to_double(const char *str, char **endptr, PyObject *overflow_exception)
     * }
     */
    public static double PyOS_string_to_double(MemorySegment str, MemorySegment endptr, MemorySegment overflow_exception) {
        var mh$ = PyOS_string_to_double.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyOS_string_to_double", str, endptr, overflow_exception);
            }
            return (double)mh$.invokeExact(str, endptr, overflow_exception);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyOS_double_to_string {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_DOUBLE,
            Python_h.C_CHAR,
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyOS_double_to_string");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *PyOS_double_to_string(double val, char format_code, int precision, int flags, int *type)
     * }
     */
    public static FunctionDescriptor PyOS_double_to_string$descriptor() {
        return PyOS_double_to_string.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *PyOS_double_to_string(double val, char format_code, int precision, int flags, int *type)
     * }
     */
    public static MethodHandle PyOS_double_to_string$handle() {
        return PyOS_double_to_string.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *PyOS_double_to_string(double val, char format_code, int precision, int flags, int *type)
     * }
     */
    public static MemorySegment PyOS_double_to_string$address() {
        return PyOS_double_to_string.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *PyOS_double_to_string(double val, char format_code, int precision, int flags, int *type)
     * }
     */
    public static MemorySegment PyOS_double_to_string(double val, byte format_code, int precision, int flags, MemorySegment type) {
        var mh$ = PyOS_double_to_string.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyOS_double_to_string", val, format_code, precision, flags, type);
            }
            return (MemorySegment)mh$.invokeExact(val, format_code, precision, flags, type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyOS_mystrnicmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyOS_mystrnicmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyOS_mystrnicmp(const char *, const char *, Py_ssize_t)
     * }
     */
    public static FunctionDescriptor PyOS_mystrnicmp$descriptor() {
        return PyOS_mystrnicmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyOS_mystrnicmp(const char *, const char *, Py_ssize_t)
     * }
     */
    public static MethodHandle PyOS_mystrnicmp$handle() {
        return PyOS_mystrnicmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyOS_mystrnicmp(const char *, const char *, Py_ssize_t)
     * }
     */
    public static MemorySegment PyOS_mystrnicmp$address() {
        return PyOS_mystrnicmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyOS_mystrnicmp(const char *, const char *, Py_ssize_t)
     * }
     */
    public static int PyOS_mystrnicmp(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = PyOS_mystrnicmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyOS_mystrnicmp", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyOS_mystricmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyOS_mystricmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyOS_mystricmp(const char *, const char *)
     * }
     */
    public static FunctionDescriptor PyOS_mystricmp$descriptor() {
        return PyOS_mystricmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyOS_mystricmp(const char *, const char *)
     * }
     */
    public static MethodHandle PyOS_mystricmp$handle() {
        return PyOS_mystricmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyOS_mystricmp(const char *, const char *)
     * }
     */
    public static MemorySegment PyOS_mystricmp$address() {
        return PyOS_mystricmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyOS_mystricmp(const char *, const char *)
     * }
     */
    public static int PyOS_mystricmp(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyOS_mystricmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyOS_mystricmp", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_DecodeLocale {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_DecodeLocale");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *Py_DecodeLocale(const char *arg, size_t *size)
     * }
     */
    public static FunctionDescriptor Py_DecodeLocale$descriptor() {
        return Py_DecodeLocale.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *Py_DecodeLocale(const char *arg, size_t *size)
     * }
     */
    public static MethodHandle Py_DecodeLocale$handle() {
        return Py_DecodeLocale.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *Py_DecodeLocale(const char *arg, size_t *size)
     * }
     */
    public static MemorySegment Py_DecodeLocale$address() {
        return Py_DecodeLocale.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *Py_DecodeLocale(const char *arg, size_t *size)
     * }
     */
    public static MemorySegment Py_DecodeLocale(MemorySegment arg, MemorySegment size) {
        var mh$ = Py_DecodeLocale.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_DecodeLocale", arg, size);
            }
            return (MemorySegment)mh$.invokeExact(arg, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_EncodeLocale {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_EncodeLocale");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *Py_EncodeLocale(const wchar_t *text, size_t *error_pos)
     * }
     */
    public static FunctionDescriptor Py_EncodeLocale$descriptor() {
        return Py_EncodeLocale.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *Py_EncodeLocale(const wchar_t *text, size_t *error_pos)
     * }
     */
    public static MethodHandle Py_EncodeLocale$handle() {
        return Py_EncodeLocale.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *Py_EncodeLocale(const wchar_t *text, size_t *error_pos)
     * }
     */
    public static MemorySegment Py_EncodeLocale$address() {
        return Py_EncodeLocale.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *Py_EncodeLocale(const wchar_t *text, size_t *error_pos)
     * }
     */
    public static MemorySegment Py_EncodeLocale(MemorySegment text, MemorySegment error_pos) {
        var mh$ = Py_EncodeLocale.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_EncodeLocale", text, error_pos);
            }
            return (MemorySegment)mh$.invokeExact(text, error_pos);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int PY_RELEASE_LEVEL = (int)15L;
    /**
     * {@snippet lang=c :
     * #define PY_RELEASE_LEVEL 15
     * }
     */
    public static int PY_RELEASE_LEVEL() {
        return PY_RELEASE_LEVEL;
    }
    /**
     * {@snippet lang=c :
     * #define PY_VERSION "3.12.1"
     * }
     */
    public static MemorySegment PY_VERSION() {
        class Holder {
            static final MemorySegment PY_VERSION
                = Python_h.LIBRARY_ARENA.allocateFrom("3.12.1");
        }
        return Holder.PY_VERSION;
    }
    private static final int PY_VERSION_HEX = (int)51118576L;
    /**
     * {@snippet lang=c :
     * #define PY_VERSION_HEX 51118576
     * }
     */
    public static int PY_VERSION_HEX() {
        return PY_VERSION_HEX;
    }
    private static final int _VCRUNTIME_DISABLED_WARNINGS = (int)4514L;
    /**
     * {@snippet lang=c :
     * #define _VCRUNTIME_DISABLED_WARNINGS 4514
     * }
     */
    public static int _VCRUNTIME_DISABLED_WARNINGS() {
        return _VCRUNTIME_DISABLED_WARNINGS;
    }
    private static final MemorySegment NULL = MemorySegment.ofAddress(0L);
    /**
     * {@snippet lang=c :
     * #define NULL (void*) 0
     * }
     */
    public static MemorySegment NULL() {
        return NULL;
    }
    private static final int _UCRT_DISABLED_WARNINGS = (int)4324L;
    /**
     * {@snippet lang=c :
     * #define _UCRT_DISABLED_WARNINGS 4324
     * }
     */
    public static int _UCRT_DISABLED_WARNINGS() {
        return _UCRT_DISABLED_WARNINGS;
    }
    private static final long _TRUNCATE = -1L;
    /**
     * {@snippet lang=c :
     * #define _TRUNCATE -1
     * }
     */
    public static long _TRUNCATE() {
        return _TRUNCATE;
    }
    private static final long _CRT_SIZE_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define _CRT_SIZE_MAX -1
     * }
     */
    public static long _CRT_SIZE_MAX() {
        return _CRT_SIZE_MAX;
    }
    /**
     * {@snippet lang=c :
     * #define __FILEW__ "C"
     * }
     */
    public static MemorySegment __FILEW__() {
        class Holder {
            static final MemorySegment __FILEW__
                = Python_h.LIBRARY_ARENA.allocateFrom("C");
        }
        return Holder.__FILEW__;
    }
    private static final int __STDC_SECURE_LIB__ = (int)200411L;
    /**
     * {@snippet lang=c :
     * #define __STDC_SECURE_LIB__ 200411
     * }
     */
    public static int __STDC_SECURE_LIB__() {
        return __STDC_SECURE_LIB__;
    }
    private static final int __GOT_SECURE_LIB__ = (int)200411L;
    /**
     * {@snippet lang=c :
     * #define __GOT_SECURE_LIB__ 200411
     * }
     */
    public static int __GOT_SECURE_LIB__() {
        return __GOT_SECURE_LIB__;
    }
    private static final int SH_DENYRW = (int)16L;
    /**
     * {@snippet lang=c :
     * #define SH_DENYRW 16
     * }
     */
    public static int SH_DENYRW() {
        return SH_DENYRW;
    }
    private static final int SH_DENYWR = (int)32L;
    /**
     * {@snippet lang=c :
     * #define SH_DENYWR 32
     * }
     */
    public static int SH_DENYWR() {
        return SH_DENYWR;
    }
    private static final int SH_DENYRD = (int)48L;
    /**
     * {@snippet lang=c :
     * #define SH_DENYRD 48
     * }
     */
    public static int SH_DENYRD() {
        return SH_DENYRD;
    }
    private static final int SH_DENYNO = (int)64L;
    /**
     * {@snippet lang=c :
     * #define SH_DENYNO 64
     * }
     */
    public static int SH_DENYNO() {
        return SH_DENYNO;
    }
    /**
     * {@snippet lang=c :
     * #define PYD_PLATFORM_TAG "win_amd64"
     * }
     */
    public static MemorySegment PYD_PLATFORM_TAG() {
        class Holder {
            static final MemorySegment PYD_PLATFORM_TAG
                = Python_h.LIBRARY_ARENA.allocateFrom("win_amd64");
        }
        return Holder.PYD_PLATFORM_TAG;
    }
    private static final long PY_SSIZE_T_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define PY_SSIZE_T_MAX 9223372036854775807
     * }
     */
    public static long PY_SSIZE_T_MAX() {
        return PY_SSIZE_T_MAX;
    }
    private static final long ADDRESS_TAG_BIT = 4398046511104L;
    /**
     * {@snippet lang=c :
     * #define ADDRESS_TAG_BIT 4398046511104
     * }
     */
    public static long ADDRESS_TAG_BIT() {
        return ADDRESS_TAG_BIT;
    }
    private static final long MAXUINT_PTR = -1L;
    /**
     * {@snippet lang=c :
     * #define MAXUINT_PTR -1
     * }
     */
    public static long MAXUINT_PTR() {
        return MAXUINT_PTR;
    }
    private static final long MAXINT_PTR = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define MAXINT_PTR 9223372036854775807
     * }
     */
    public static long MAXINT_PTR() {
        return MAXINT_PTR;
    }
    private static final long MININT_PTR = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define MININT_PTR -9223372036854775808
     * }
     */
    public static long MININT_PTR() {
        return MININT_PTR;
    }
    private static final long MAXULONG_PTR = -1L;
    /**
     * {@snippet lang=c :
     * #define MAXULONG_PTR -1
     * }
     */
    public static long MAXULONG_PTR() {
        return MAXULONG_PTR;
    }
    private static final long MAXLONG_PTR = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define MAXLONG_PTR 9223372036854775807
     * }
     */
    public static long MAXLONG_PTR() {
        return MAXLONG_PTR;
    }
    private static final long MINLONG_PTR = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define MINLONG_PTR -9223372036854775808
     * }
     */
    public static long MINLONG_PTR() {
        return MINLONG_PTR;
    }
    private static final int MAXUHALF_PTR = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define MAXUHALF_PTR 4294967295
     * }
     */
    public static int MAXUHALF_PTR() {
        return MAXUHALF_PTR;
    }
    private static final int MAXHALF_PTR = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define MAXHALF_PTR 2147483647
     * }
     */
    public static int MAXHALF_PTR() {
        return MAXHALF_PTR;
    }
    private static final int MINHALF_PTR = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define MINHALF_PTR -2147483648
     * }
     */
    public static int MINHALF_PTR() {
        return MINHALF_PTR;
    }
    /**
     * {@snippet lang=c :
     * #define _CRT_INTERNAL_STDIO_SYMBOL_PREFIX ""
     * }
     */
    public static MemorySegment _CRT_INTERNAL_STDIO_SYMBOL_PREFIX() {
        class Holder {
            static final MemorySegment _CRT_INTERNAL_STDIO_SYMBOL_PREFIX
                = Python_h.LIBRARY_ARENA.allocateFrom("");
        }
        return Holder._CRT_INTERNAL_STDIO_SYMBOL_PREFIX;
    }
    private static final long _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION = 1L;
    /**
     * {@snippet lang=c :
     * #define _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION 1
     * }
     */
    public static long _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION() {
        return _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION;
    }
    private static final long _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR = 2L;
    /**
     * {@snippet lang=c :
     * #define _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR 2
     * }
     */
    public static long _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR() {
        return _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR;
    }
    private static final long _CRT_INTERNAL_PRINTF_LEGACY_WIDE_SPECIFIERS = 4L;
    /**
     * {@snippet lang=c :
     * #define _CRT_INTERNAL_PRINTF_LEGACY_WIDE_SPECIFIERS 4
     * }
     */
    public static long _CRT_INTERNAL_PRINTF_LEGACY_WIDE_SPECIFIERS() {
        return _CRT_INTERNAL_PRINTF_LEGACY_WIDE_SPECIFIERS;
    }
    private static final long _CRT_INTERNAL_PRINTF_LEGACY_MSVCRT_COMPATIBILITY = 8L;
    /**
     * {@snippet lang=c :
     * #define _CRT_INTERNAL_PRINTF_LEGACY_MSVCRT_COMPATIBILITY 8
     * }
     */
    public static long _CRT_INTERNAL_PRINTF_LEGACY_MSVCRT_COMPATIBILITY() {
        return _CRT_INTERNAL_PRINTF_LEGACY_MSVCRT_COMPATIBILITY;
    }
    private static final long _CRT_INTERNAL_PRINTF_LEGACY_THREE_DIGIT_EXPONENTS = 16L;
    /**
     * {@snippet lang=c :
     * #define _CRT_INTERNAL_PRINTF_LEGACY_THREE_DIGIT_EXPONENTS 16
     * }
     */
    public static long _CRT_INTERNAL_PRINTF_LEGACY_THREE_DIGIT_EXPONENTS() {
        return _CRT_INTERNAL_PRINTF_LEGACY_THREE_DIGIT_EXPONENTS;
    }
    private static final long _CRT_INTERNAL_PRINTF_STANDARD_ROUNDING = 32L;
    /**
     * {@snippet lang=c :
     * #define _CRT_INTERNAL_PRINTF_STANDARD_ROUNDING 32
     * }
     */
    public static long _CRT_INTERNAL_PRINTF_STANDARD_ROUNDING() {
        return _CRT_INTERNAL_PRINTF_STANDARD_ROUNDING;
    }
    private static final long _CRT_INTERNAL_SCANF_SECURECRT = 1L;
    /**
     * {@snippet lang=c :
     * #define _CRT_INTERNAL_SCANF_SECURECRT 1
     * }
     */
    public static long _CRT_INTERNAL_SCANF_SECURECRT() {
        return _CRT_INTERNAL_SCANF_SECURECRT;
    }
    private static final long _CRT_INTERNAL_SCANF_LEGACY_WIDE_SPECIFIERS = 2L;
    /**
     * {@snippet lang=c :
     * #define _CRT_INTERNAL_SCANF_LEGACY_WIDE_SPECIFIERS 2
     * }
     */
    public static long _CRT_INTERNAL_SCANF_LEGACY_WIDE_SPECIFIERS() {
        return _CRT_INTERNAL_SCANF_LEGACY_WIDE_SPECIFIERS;
    }
    private static final long _CRT_INTERNAL_SCANF_LEGACY_MSVCRT_COMPATIBILITY = 4L;
    /**
     * {@snippet lang=c :
     * #define _CRT_INTERNAL_SCANF_LEGACY_MSVCRT_COMPATIBILITY 4
     * }
     */
    public static long _CRT_INTERNAL_SCANF_LEGACY_MSVCRT_COMPATIBILITY() {
        return _CRT_INTERNAL_SCANF_LEGACY_MSVCRT_COMPATIBILITY;
    }
    private static final short WEOF = (short)65535L;
    /**
     * {@snippet lang=c :
     * #define WEOF 65535
     * }
     */
    public static short WEOF() {
        return WEOF;
    }
    private static final int _NFILE = (int)512L;
    /**
     * {@snippet lang=c :
     * #define _NFILE 512
     * }
     */
    public static int _NFILE() {
        return _NFILE;
    }
    private static final int EOF = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define EOF -1
     * }
     */
    public static int EOF() {
        return EOF;
    }
    private static final int L_tmpnam_s = (int)260L;
    /**
     * {@snippet lang=c :
     * #define L_tmpnam_s 260
     * }
     */
    public static int L_tmpnam_s() {
        return L_tmpnam_s;
    }
    private static final int TMP_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define TMP_MAX 2147483647
     * }
     */
    public static int TMP_MAX() {
        return TMP_MAX;
    }
    private static final int TMP_MAX_S = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define TMP_MAX_S 2147483647
     * }
     */
    public static int TMP_MAX_S() {
        return TMP_MAX_S;
    }
    private static final int _TMP_MAX_S = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define _TMP_MAX_S 2147483647
     * }
     */
    public static int _TMP_MAX_S() {
        return _TMP_MAX_S;
    }
    private static final int SYS_OPEN = (int)20L;
    /**
     * {@snippet lang=c :
     * #define SYS_OPEN 20
     * }
     */
    public static int SYS_OPEN() {
        return SYS_OPEN;
    }
    private static final long PY_LLONG_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define PY_LLONG_MAX 9223372036854775807
     * }
     */
    public static long PY_LLONG_MAX() {
        return PY_LLONG_MAX;
    }
    private static final long PY_LLONG_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define PY_LLONG_MIN -9223372036854775808
     * }
     */
    public static long PY_LLONG_MIN() {
        return PY_LLONG_MIN;
    }
    private static final long PY_ULLONG_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define PY_ULLONG_MAX -1
     * }
     */
    public static long PY_ULLONG_MAX() {
        return PY_ULLONG_MAX;
    }
    /**
     * {@snippet lang=c :
     * #define PLATFORM "win32"
     * }
     */
    public static MemorySegment PLATFORM() {
        class Holder {
            static final MemorySegment PLATFORM
                = Python_h.LIBRARY_ARENA.allocateFrom("win32");
        }
        return Holder.PLATFORM;
    }
    private static final int SIZEOF_PID_T = (int)4L;
    /**
     * {@snippet lang=c :
     * #define SIZEOF_PID_T 4
     * }
     */
    public static int SIZEOF_PID_T() {
        return SIZEOF_PID_T;
    }
    /**
     * {@snippet lang=c :
     * #define _PYTHONFRAMEWORK ""
     * }
     */
    public static MemorySegment _PYTHONFRAMEWORK() {
        class Holder {
            static final MemorySegment _PYTHONFRAMEWORK
                = Python_h.LIBRARY_ARENA.allocateFrom("");
        }
        return Holder._PYTHONFRAMEWORK;
    }
    private static final int EDEADLOCK = (int)36L;
    /**
     * {@snippet lang=c :
     * #define EDEADLOCK 36
     * }
     */
    public static int EDEADLOCK() {
        return EDEADLOCK;
    }
    private static final int _ALPHA = (int)259L;
    /**
     * {@snippet lang=c :
     * #define _ALPHA 259
     * }
     */
    public static int _ALPHA() {
        return _ALPHA;
    }
    private static final int _MAX_ITOSTR_BASE16_COUNT = (int)9L;
    /**
     * {@snippet lang=c :
     * #define _MAX_ITOSTR_BASE16_COUNT 9
     * }
     */
    public static int _MAX_ITOSTR_BASE16_COUNT() {
        return _MAX_ITOSTR_BASE16_COUNT;
    }
    private static final int _MAX_ITOSTR_BASE10_COUNT = (int)12L;
    /**
     * {@snippet lang=c :
     * #define _MAX_ITOSTR_BASE10_COUNT 12
     * }
     */
    public static int _MAX_ITOSTR_BASE10_COUNT() {
        return _MAX_ITOSTR_BASE10_COUNT;
    }
    private static final int _MAX_ITOSTR_BASE8_COUNT = (int)12L;
    /**
     * {@snippet lang=c :
     * #define _MAX_ITOSTR_BASE8_COUNT 12
     * }
     */
    public static int _MAX_ITOSTR_BASE8_COUNT() {
        return _MAX_ITOSTR_BASE8_COUNT;
    }
    private static final int _MAX_ITOSTR_BASE2_COUNT = (int)33L;
    /**
     * {@snippet lang=c :
     * #define _MAX_ITOSTR_BASE2_COUNT 33
     * }
     */
    public static int _MAX_ITOSTR_BASE2_COUNT() {
        return _MAX_ITOSTR_BASE2_COUNT;
    }
    private static final int _MAX_LTOSTR_BASE16_COUNT = (int)9L;
    /**
     * {@snippet lang=c :
     * #define _MAX_LTOSTR_BASE16_COUNT 9
     * }
     */
    public static int _MAX_LTOSTR_BASE16_COUNT() {
        return _MAX_LTOSTR_BASE16_COUNT;
    }
    private static final int _MAX_LTOSTR_BASE10_COUNT = (int)12L;
    /**
     * {@snippet lang=c :
     * #define _MAX_LTOSTR_BASE10_COUNT 12
     * }
     */
    public static int _MAX_LTOSTR_BASE10_COUNT() {
        return _MAX_LTOSTR_BASE10_COUNT;
    }
    private static final int _MAX_LTOSTR_BASE8_COUNT = (int)12L;
    /**
     * {@snippet lang=c :
     * #define _MAX_LTOSTR_BASE8_COUNT 12
     * }
     */
    public static int _MAX_LTOSTR_BASE8_COUNT() {
        return _MAX_LTOSTR_BASE8_COUNT;
    }
    private static final int _MAX_LTOSTR_BASE2_COUNT = (int)33L;
    /**
     * {@snippet lang=c :
     * #define _MAX_LTOSTR_BASE2_COUNT 33
     * }
     */
    public static int _MAX_LTOSTR_BASE2_COUNT() {
        return _MAX_LTOSTR_BASE2_COUNT;
    }
    private static final int _MAX_ULTOSTR_BASE16_COUNT = (int)9L;
    /**
     * {@snippet lang=c :
     * #define _MAX_ULTOSTR_BASE16_COUNT 9
     * }
     */
    public static int _MAX_ULTOSTR_BASE16_COUNT() {
        return _MAX_ULTOSTR_BASE16_COUNT;
    }
    private static final int _MAX_ULTOSTR_BASE10_COUNT = (int)11L;
    /**
     * {@snippet lang=c :
     * #define _MAX_ULTOSTR_BASE10_COUNT 11
     * }
     */
    public static int _MAX_ULTOSTR_BASE10_COUNT() {
        return _MAX_ULTOSTR_BASE10_COUNT;
    }
    private static final int _MAX_ULTOSTR_BASE8_COUNT = (int)12L;
    /**
     * {@snippet lang=c :
     * #define _MAX_ULTOSTR_BASE8_COUNT 12
     * }
     */
    public static int _MAX_ULTOSTR_BASE8_COUNT() {
        return _MAX_ULTOSTR_BASE8_COUNT;
    }
    private static final int _MAX_ULTOSTR_BASE2_COUNT = (int)33L;
    /**
     * {@snippet lang=c :
     * #define _MAX_ULTOSTR_BASE2_COUNT 33
     * }
     */
    public static int _MAX_ULTOSTR_BASE2_COUNT() {
        return _MAX_ULTOSTR_BASE2_COUNT;
    }
    private static final int _MAX_I64TOSTR_BASE16_COUNT = (int)17L;
    /**
     * {@snippet lang=c :
     * #define _MAX_I64TOSTR_BASE16_COUNT 17
     * }
     */
    public static int _MAX_I64TOSTR_BASE16_COUNT() {
        return _MAX_I64TOSTR_BASE16_COUNT;
    }
    private static final int _MAX_I64TOSTR_BASE10_COUNT = (int)21L;
    /**
     * {@snippet lang=c :
     * #define _MAX_I64TOSTR_BASE10_COUNT 21
     * }
     */
    public static int _MAX_I64TOSTR_BASE10_COUNT() {
        return _MAX_I64TOSTR_BASE10_COUNT;
    }
    private static final int _MAX_I64TOSTR_BASE8_COUNT = (int)23L;
    /**
     * {@snippet lang=c :
     * #define _MAX_I64TOSTR_BASE8_COUNT 23
     * }
     */
    public static int _MAX_I64TOSTR_BASE8_COUNT() {
        return _MAX_I64TOSTR_BASE8_COUNT;
    }
    private static final int _MAX_I64TOSTR_BASE2_COUNT = (int)65L;
    /**
     * {@snippet lang=c :
     * #define _MAX_I64TOSTR_BASE2_COUNT 65
     * }
     */
    public static int _MAX_I64TOSTR_BASE2_COUNT() {
        return _MAX_I64TOSTR_BASE2_COUNT;
    }
    private static final int _MAX_U64TOSTR_BASE16_COUNT = (int)17L;
    /**
     * {@snippet lang=c :
     * #define _MAX_U64TOSTR_BASE16_COUNT 17
     * }
     */
    public static int _MAX_U64TOSTR_BASE16_COUNT() {
        return _MAX_U64TOSTR_BASE16_COUNT;
    }
    private static final int _MAX_U64TOSTR_BASE10_COUNT = (int)21L;
    /**
     * {@snippet lang=c :
     * #define _MAX_U64TOSTR_BASE10_COUNT 21
     * }
     */
    public static int _MAX_U64TOSTR_BASE10_COUNT() {
        return _MAX_U64TOSTR_BASE10_COUNT;
    }
    private static final int _MAX_U64TOSTR_BASE8_COUNT = (int)23L;
    /**
     * {@snippet lang=c :
     * #define _MAX_U64TOSTR_BASE8_COUNT 23
     * }
     */
    public static int _MAX_U64TOSTR_BASE8_COUNT() {
        return _MAX_U64TOSTR_BASE8_COUNT;
    }
    private static final int _MAX_U64TOSTR_BASE2_COUNT = (int)65L;
    /**
     * {@snippet lang=c :
     * #define _MAX_U64TOSTR_BASE2_COUNT 65
     * }
     */
    public static int _MAX_U64TOSTR_BASE2_COUNT() {
        return _MAX_U64TOSTR_BASE2_COUNT;
    }
    private static final int S_IFMT = (int)61440L;
    /**
     * {@snippet lang=c :
     * #define S_IFMT 61440
     * }
     */
    public static int S_IFMT() {
        return S_IFMT;
    }
    private static final int S_IFDIR = (int)16384L;
    /**
     * {@snippet lang=c :
     * #define S_IFDIR 16384
     * }
     */
    public static int S_IFDIR() {
        return S_IFDIR;
    }
    private static final int S_IFCHR = (int)8192L;
    /**
     * {@snippet lang=c :
     * #define S_IFCHR 8192
     * }
     */
    public static int S_IFCHR() {
        return S_IFCHR;
    }
    private static final int S_IFREG = (int)32768L;
    /**
     * {@snippet lang=c :
     * #define S_IFREG 32768
     * }
     */
    public static int S_IFREG() {
        return S_IFREG;
    }
    private static final int S_IREAD = (int)256L;
    /**
     * {@snippet lang=c :
     * #define S_IREAD 256
     * }
     */
    public static int S_IREAD() {
        return S_IREAD;
    }
    private static final int S_IWRITE = (int)128L;
    /**
     * {@snippet lang=c :
     * #define S_IWRITE 128
     * }
     */
    public static int S_IWRITE() {
        return S_IWRITE;
    }
    private static final int S_IEXEC = (int)64L;
    /**
     * {@snippet lang=c :
     * #define S_IEXEC 64
     * }
     */
    public static int S_IEXEC() {
        return S_IEXEC;
    }
    private static final int INT8_MIN = (int)-128L;
    /**
     * {@snippet lang=c :
     * #define INT8_MIN -128
     * }
     */
    public static int INT8_MIN() {
        return INT8_MIN;
    }
    private static final int INT16_MIN = (int)-32768L;
    /**
     * {@snippet lang=c :
     * #define INT16_MIN -32768
     * }
     */
    public static int INT16_MIN() {
        return INT16_MIN;
    }
    private static final int INT32_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define INT32_MIN -2147483648
     * }
     */
    public static int INT32_MIN() {
        return INT32_MIN;
    }
    private static final long INT64_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INT64_MIN -9223372036854775808
     * }
     */
    public static long INT64_MIN() {
        return INT64_MIN;
    }
    private static final byte INT8_MAX = (byte)127L;
    /**
     * {@snippet lang=c :
     * #define INT8_MAX 127
     * }
     */
    public static byte INT8_MAX() {
        return INT8_MAX;
    }
    private static final short INT16_MAX = (short)32767L;
    /**
     * {@snippet lang=c :
     * #define INT16_MAX 32767
     * }
     */
    public static short INT16_MAX() {
        return INT16_MAX;
    }
    private static final int INT32_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define INT32_MAX 2147483647
     * }
     */
    public static int INT32_MAX() {
        return INT32_MAX;
    }
    private static final long INT64_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INT64_MAX 9223372036854775807
     * }
     */
    public static long INT64_MAX() {
        return INT64_MAX;
    }
    private static final byte UINT8_MAX = (byte)255L;
    /**
     * {@snippet lang=c :
     * #define UINT8_MAX 255
     * }
     */
    public static byte UINT8_MAX() {
        return UINT8_MAX;
    }
    private static final short UINT16_MAX = (short)65535L;
    /**
     * {@snippet lang=c :
     * #define UINT16_MAX 65535
     * }
     */
    public static short UINT16_MAX() {
        return UINT16_MAX;
    }
    private static final int UINT32_MAX = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define UINT32_MAX 4294967295
     * }
     */
    public static int UINT32_MAX() {
        return UINT32_MAX;
    }
    private static final long UINT64_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINT64_MAX -1
     * }
     */
    public static long UINT64_MAX() {
        return UINT64_MAX;
    }
    private static final int INT_LEAST8_MIN = (int)-128L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST8_MIN -128
     * }
     */
    public static int INT_LEAST8_MIN() {
        return INT_LEAST8_MIN;
    }
    private static final int INT_LEAST16_MIN = (int)-32768L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST16_MIN -32768
     * }
     */
    public static int INT_LEAST16_MIN() {
        return INT_LEAST16_MIN;
    }
    private static final int INT_LEAST32_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST32_MIN -2147483648
     * }
     */
    public static int INT_LEAST32_MIN() {
        return INT_LEAST32_MIN;
    }
    private static final long INT_LEAST64_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST64_MIN -9223372036854775808
     * }
     */
    public static long INT_LEAST64_MIN() {
        return INT_LEAST64_MIN;
    }
    private static final byte INT_LEAST8_MAX = (byte)127L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST8_MAX 127
     * }
     */
    public static byte INT_LEAST8_MAX() {
        return INT_LEAST8_MAX;
    }
    private static final short INT_LEAST16_MAX = (short)32767L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST16_MAX 32767
     * }
     */
    public static short INT_LEAST16_MAX() {
        return INT_LEAST16_MAX;
    }
    private static final int INT_LEAST32_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST32_MAX 2147483647
     * }
     */
    public static int INT_LEAST32_MAX() {
        return INT_LEAST32_MAX;
    }
    private static final long INT_LEAST64_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST64_MAX 9223372036854775807
     * }
     */
    public static long INT_LEAST64_MAX() {
        return INT_LEAST64_MAX;
    }
    private static final byte UINT_LEAST8_MAX = (byte)255L;
    /**
     * {@snippet lang=c :
     * #define UINT_LEAST8_MAX 255
     * }
     */
    public static byte UINT_LEAST8_MAX() {
        return UINT_LEAST8_MAX;
    }
    private static final short UINT_LEAST16_MAX = (short)65535L;
    /**
     * {@snippet lang=c :
     * #define UINT_LEAST16_MAX 65535
     * }
     */
    public static short UINT_LEAST16_MAX() {
        return UINT_LEAST16_MAX;
    }
    private static final int UINT_LEAST32_MAX = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define UINT_LEAST32_MAX 4294967295
     * }
     */
    public static int UINT_LEAST32_MAX() {
        return UINT_LEAST32_MAX;
    }
    private static final long UINT_LEAST64_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINT_LEAST64_MAX -1
     * }
     */
    public static long UINT_LEAST64_MAX() {
        return UINT_LEAST64_MAX;
    }
    private static final int INT_FAST8_MIN = (int)-128L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST8_MIN -128
     * }
     */
    public static int INT_FAST8_MIN() {
        return INT_FAST8_MIN;
    }
    private static final int INT_FAST16_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST16_MIN -2147483648
     * }
     */
    public static int INT_FAST16_MIN() {
        return INT_FAST16_MIN;
    }
    private static final int INT_FAST32_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST32_MIN -2147483648
     * }
     */
    public static int INT_FAST32_MIN() {
        return INT_FAST32_MIN;
    }
    private static final long INT_FAST64_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST64_MIN -9223372036854775808
     * }
     */
    public static long INT_FAST64_MIN() {
        return INT_FAST64_MIN;
    }
    private static final byte INT_FAST8_MAX = (byte)127L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST8_MAX 127
     * }
     */
    public static byte INT_FAST8_MAX() {
        return INT_FAST8_MAX;
    }
    private static final int INT_FAST16_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST16_MAX 2147483647
     * }
     */
    public static int INT_FAST16_MAX() {
        return INT_FAST16_MAX;
    }
    private static final int INT_FAST32_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST32_MAX 2147483647
     * }
     */
    public static int INT_FAST32_MAX() {
        return INT_FAST32_MAX;
    }
    private static final long INT_FAST64_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST64_MAX 9223372036854775807
     * }
     */
    public static long INT_FAST64_MAX() {
        return INT_FAST64_MAX;
    }
    private static final byte UINT_FAST8_MAX = (byte)255L;
    /**
     * {@snippet lang=c :
     * #define UINT_FAST8_MAX 255
     * }
     */
    public static byte UINT_FAST8_MAX() {
        return UINT_FAST8_MAX;
    }
    private static final int UINT_FAST16_MAX = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define UINT_FAST16_MAX 4294967295
     * }
     */
    public static int UINT_FAST16_MAX() {
        return UINT_FAST16_MAX;
    }
    private static final int UINT_FAST32_MAX = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define UINT_FAST32_MAX 4294967295
     * }
     */
    public static int UINT_FAST32_MAX() {
        return UINT_FAST32_MAX;
    }
    private static final long UINT_FAST64_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINT_FAST64_MAX -1
     * }
     */
    public static long UINT_FAST64_MAX() {
        return UINT_FAST64_MAX;
    }
    private static final long INTPTR_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INTPTR_MIN -9223372036854775808
     * }
     */
    public static long INTPTR_MIN() {
        return INTPTR_MIN;
    }
    private static final long INTPTR_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INTPTR_MAX 9223372036854775807
     * }
     */
    public static long INTPTR_MAX() {
        return INTPTR_MAX;
    }
    private static final long UINTPTR_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINTPTR_MAX -1
     * }
     */
    public static long UINTPTR_MAX() {
        return UINTPTR_MAX;
    }
    private static final long INTMAX_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INTMAX_MIN -9223372036854775808
     * }
     */
    public static long INTMAX_MIN() {
        return INTMAX_MIN;
    }
    private static final long INTMAX_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INTMAX_MAX 9223372036854775807
     * }
     */
    public static long INTMAX_MAX() {
        return INTMAX_MAX;
    }
    private static final long UINTMAX_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINTMAX_MAX -1
     * }
     */
    public static long UINTMAX_MAX() {
        return UINTMAX_MAX;
    }
    private static final long PTRDIFF_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define PTRDIFF_MIN -9223372036854775808
     * }
     */
    public static long PTRDIFF_MIN() {
        return PTRDIFF_MIN;
    }
    private static final long PTRDIFF_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define PTRDIFF_MAX 9223372036854775807
     * }
     */
    public static long PTRDIFF_MAX() {
        return PTRDIFF_MAX;
    }
    private static final long SIZE_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define SIZE_MAX -1
     * }
     */
    public static long SIZE_MAX() {
        return SIZE_MAX;
    }
    private static final int SIG_ATOMIC_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define SIG_ATOMIC_MIN -2147483648
     * }
     */
    public static int SIG_ATOMIC_MIN() {
        return SIG_ATOMIC_MIN;
    }
    private static final int SIG_ATOMIC_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define SIG_ATOMIC_MAX 2147483647
     * }
     */
    public static int SIG_ATOMIC_MAX() {
        return SIG_ATOMIC_MAX;
    }
    /**
     * {@snippet lang=c :
     * #define PRId8 "hhd"
     * }
     */
    public static MemorySegment PRId8() {
        class Holder {
            static final MemorySegment PRId8
                = Python_h.LIBRARY_ARENA.allocateFrom("hhd");
        }
        return Holder.PRId8;
    }
    /**
     * {@snippet lang=c :
     * #define PRId16 "hd"
     * }
     */
    public static MemorySegment PRId16() {
        class Holder {
            static final MemorySegment PRId16
                = Python_h.LIBRARY_ARENA.allocateFrom("hd");
        }
        return Holder.PRId16;
    }
    /**
     * {@snippet lang=c :
     * #define PRId32 "d"
     * }
     */
    public static MemorySegment PRId32() {
        class Holder {
            static final MemorySegment PRId32
                = Python_h.LIBRARY_ARENA.allocateFrom("d");
        }
        return Holder.PRId32;
    }
    /**
     * {@snippet lang=c :
     * #define PRId64 "lld"
     * }
     */
    public static MemorySegment PRId64() {
        class Holder {
            static final MemorySegment PRId64
                = Python_h.LIBRARY_ARENA.allocateFrom("lld");
        }
        return Holder.PRId64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIdLEAST8 "hhd"
     * }
     */
    public static MemorySegment PRIdLEAST8() {
        class Holder {
            static final MemorySegment PRIdLEAST8
                = Python_h.LIBRARY_ARENA.allocateFrom("hhd");
        }
        return Holder.PRIdLEAST8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIdLEAST16 "hd"
     * }
     */
    public static MemorySegment PRIdLEAST16() {
        class Holder {
            static final MemorySegment PRIdLEAST16
                = Python_h.LIBRARY_ARENA.allocateFrom("hd");
        }
        return Holder.PRIdLEAST16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIdLEAST32 "d"
     * }
     */
    public static MemorySegment PRIdLEAST32() {
        class Holder {
            static final MemorySegment PRIdLEAST32
                = Python_h.LIBRARY_ARENA.allocateFrom("d");
        }
        return Holder.PRIdLEAST32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIdLEAST64 "lld"
     * }
     */
    public static MemorySegment PRIdLEAST64() {
        class Holder {
            static final MemorySegment PRIdLEAST64
                = Python_h.LIBRARY_ARENA.allocateFrom("lld");
        }
        return Holder.PRIdLEAST64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIdFAST8 "hhd"
     * }
     */
    public static MemorySegment PRIdFAST8() {
        class Holder {
            static final MemorySegment PRIdFAST8
                = Python_h.LIBRARY_ARENA.allocateFrom("hhd");
        }
        return Holder.PRIdFAST8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIdFAST16 "d"
     * }
     */
    public static MemorySegment PRIdFAST16() {
        class Holder {
            static final MemorySegment PRIdFAST16
                = Python_h.LIBRARY_ARENA.allocateFrom("d");
        }
        return Holder.PRIdFAST16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIdFAST32 "d"
     * }
     */
    public static MemorySegment PRIdFAST32() {
        class Holder {
            static final MemorySegment PRIdFAST32
                = Python_h.LIBRARY_ARENA.allocateFrom("d");
        }
        return Holder.PRIdFAST32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIdFAST64 "lld"
     * }
     */
    public static MemorySegment PRIdFAST64() {
        class Holder {
            static final MemorySegment PRIdFAST64
                = Python_h.LIBRARY_ARENA.allocateFrom("lld");
        }
        return Holder.PRIdFAST64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIdMAX "lld"
     * }
     */
    public static MemorySegment PRIdMAX() {
        class Holder {
            static final MemorySegment PRIdMAX
                = Python_h.LIBRARY_ARENA.allocateFrom("lld");
        }
        return Holder.PRIdMAX;
    }
    /**
     * {@snippet lang=c :
     * #define PRIdPTR "lld"
     * }
     */
    public static MemorySegment PRIdPTR() {
        class Holder {
            static final MemorySegment PRIdPTR
                = Python_h.LIBRARY_ARENA.allocateFrom("lld");
        }
        return Holder.PRIdPTR;
    }
    /**
     * {@snippet lang=c :
     * #define PRIi8 "hhi"
     * }
     */
    public static MemorySegment PRIi8() {
        class Holder {
            static final MemorySegment PRIi8
                = Python_h.LIBRARY_ARENA.allocateFrom("hhi");
        }
        return Holder.PRIi8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIi16 "hi"
     * }
     */
    public static MemorySegment PRIi16() {
        class Holder {
            static final MemorySegment PRIi16
                = Python_h.LIBRARY_ARENA.allocateFrom("hi");
        }
        return Holder.PRIi16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIi32 "i"
     * }
     */
    public static MemorySegment PRIi32() {
        class Holder {
            static final MemorySegment PRIi32
                = Python_h.LIBRARY_ARENA.allocateFrom("i");
        }
        return Holder.PRIi32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIi64 "lli"
     * }
     */
    public static MemorySegment PRIi64() {
        class Holder {
            static final MemorySegment PRIi64
                = Python_h.LIBRARY_ARENA.allocateFrom("lli");
        }
        return Holder.PRIi64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIiLEAST8 "hhi"
     * }
     */
    public static MemorySegment PRIiLEAST8() {
        class Holder {
            static final MemorySegment PRIiLEAST8
                = Python_h.LIBRARY_ARENA.allocateFrom("hhi");
        }
        return Holder.PRIiLEAST8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIiLEAST16 "hi"
     * }
     */
    public static MemorySegment PRIiLEAST16() {
        class Holder {
            static final MemorySegment PRIiLEAST16
                = Python_h.LIBRARY_ARENA.allocateFrom("hi");
        }
        return Holder.PRIiLEAST16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIiLEAST32 "i"
     * }
     */
    public static MemorySegment PRIiLEAST32() {
        class Holder {
            static final MemorySegment PRIiLEAST32
                = Python_h.LIBRARY_ARENA.allocateFrom("i");
        }
        return Holder.PRIiLEAST32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIiLEAST64 "lli"
     * }
     */
    public static MemorySegment PRIiLEAST64() {
        class Holder {
            static final MemorySegment PRIiLEAST64
                = Python_h.LIBRARY_ARENA.allocateFrom("lli");
        }
        return Holder.PRIiLEAST64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIiFAST8 "hhi"
     * }
     */
    public static MemorySegment PRIiFAST8() {
        class Holder {
            static final MemorySegment PRIiFAST8
                = Python_h.LIBRARY_ARENA.allocateFrom("hhi");
        }
        return Holder.PRIiFAST8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIiFAST16 "i"
     * }
     */
    public static MemorySegment PRIiFAST16() {
        class Holder {
            static final MemorySegment PRIiFAST16
                = Python_h.LIBRARY_ARENA.allocateFrom("i");
        }
        return Holder.PRIiFAST16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIiFAST32 "i"
     * }
     */
    public static MemorySegment PRIiFAST32() {
        class Holder {
            static final MemorySegment PRIiFAST32
                = Python_h.LIBRARY_ARENA.allocateFrom("i");
        }
        return Holder.PRIiFAST32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIiFAST64 "lli"
     * }
     */
    public static MemorySegment PRIiFAST64() {
        class Holder {
            static final MemorySegment PRIiFAST64
                = Python_h.LIBRARY_ARENA.allocateFrom("lli");
        }
        return Holder.PRIiFAST64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIiMAX "lli"
     * }
     */
    public static MemorySegment PRIiMAX() {
        class Holder {
            static final MemorySegment PRIiMAX
                = Python_h.LIBRARY_ARENA.allocateFrom("lli");
        }
        return Holder.PRIiMAX;
    }
    /**
     * {@snippet lang=c :
     * #define PRIiPTR "lli"
     * }
     */
    public static MemorySegment PRIiPTR() {
        class Holder {
            static final MemorySegment PRIiPTR
                = Python_h.LIBRARY_ARENA.allocateFrom("lli");
        }
        return Holder.PRIiPTR;
    }
    /**
     * {@snippet lang=c :
     * #define PRIo8 "hho"
     * }
     */
    public static MemorySegment PRIo8() {
        class Holder {
            static final MemorySegment PRIo8
                = Python_h.LIBRARY_ARENA.allocateFrom("hho");
        }
        return Holder.PRIo8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIo16 "ho"
     * }
     */
    public static MemorySegment PRIo16() {
        class Holder {
            static final MemorySegment PRIo16
                = Python_h.LIBRARY_ARENA.allocateFrom("ho");
        }
        return Holder.PRIo16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIo32 "o"
     * }
     */
    public static MemorySegment PRIo32() {
        class Holder {
            static final MemorySegment PRIo32
                = Python_h.LIBRARY_ARENA.allocateFrom("o");
        }
        return Holder.PRIo32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIo64 "llo"
     * }
     */
    public static MemorySegment PRIo64() {
        class Holder {
            static final MemorySegment PRIo64
                = Python_h.LIBRARY_ARENA.allocateFrom("llo");
        }
        return Holder.PRIo64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIoLEAST8 "hho"
     * }
     */
    public static MemorySegment PRIoLEAST8() {
        class Holder {
            static final MemorySegment PRIoLEAST8
                = Python_h.LIBRARY_ARENA.allocateFrom("hho");
        }
        return Holder.PRIoLEAST8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIoLEAST16 "ho"
     * }
     */
    public static MemorySegment PRIoLEAST16() {
        class Holder {
            static final MemorySegment PRIoLEAST16
                = Python_h.LIBRARY_ARENA.allocateFrom("ho");
        }
        return Holder.PRIoLEAST16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIoLEAST32 "o"
     * }
     */
    public static MemorySegment PRIoLEAST32() {
        class Holder {
            static final MemorySegment PRIoLEAST32
                = Python_h.LIBRARY_ARENA.allocateFrom("o");
        }
        return Holder.PRIoLEAST32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIoLEAST64 "llo"
     * }
     */
    public static MemorySegment PRIoLEAST64() {
        class Holder {
            static final MemorySegment PRIoLEAST64
                = Python_h.LIBRARY_ARENA.allocateFrom("llo");
        }
        return Holder.PRIoLEAST64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIoFAST8 "hho"
     * }
     */
    public static MemorySegment PRIoFAST8() {
        class Holder {
            static final MemorySegment PRIoFAST8
                = Python_h.LIBRARY_ARENA.allocateFrom("hho");
        }
        return Holder.PRIoFAST8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIoFAST16 "o"
     * }
     */
    public static MemorySegment PRIoFAST16() {
        class Holder {
            static final MemorySegment PRIoFAST16
                = Python_h.LIBRARY_ARENA.allocateFrom("o");
        }
        return Holder.PRIoFAST16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIoFAST32 "o"
     * }
     */
    public static MemorySegment PRIoFAST32() {
        class Holder {
            static final MemorySegment PRIoFAST32
                = Python_h.LIBRARY_ARENA.allocateFrom("o");
        }
        return Holder.PRIoFAST32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIoFAST64 "llo"
     * }
     */
    public static MemorySegment PRIoFAST64() {
        class Holder {
            static final MemorySegment PRIoFAST64
                = Python_h.LIBRARY_ARENA.allocateFrom("llo");
        }
        return Holder.PRIoFAST64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIoMAX "llo"
     * }
     */
    public static MemorySegment PRIoMAX() {
        class Holder {
            static final MemorySegment PRIoMAX
                = Python_h.LIBRARY_ARENA.allocateFrom("llo");
        }
        return Holder.PRIoMAX;
    }
    /**
     * {@snippet lang=c :
     * #define PRIoPTR "llo"
     * }
     */
    public static MemorySegment PRIoPTR() {
        class Holder {
            static final MemorySegment PRIoPTR
                = Python_h.LIBRARY_ARENA.allocateFrom("llo");
        }
        return Holder.PRIoPTR;
    }
    /**
     * {@snippet lang=c :
     * #define PRIu8 "hhu"
     * }
     */
    public static MemorySegment PRIu8() {
        class Holder {
            static final MemorySegment PRIu8
                = Python_h.LIBRARY_ARENA.allocateFrom("hhu");
        }
        return Holder.PRIu8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIu16 "hu"
     * }
     */
    public static MemorySegment PRIu16() {
        class Holder {
            static final MemorySegment PRIu16
                = Python_h.LIBRARY_ARENA.allocateFrom("hu");
        }
        return Holder.PRIu16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIu32 "u"
     * }
     */
    public static MemorySegment PRIu32() {
        class Holder {
            static final MemorySegment PRIu32
                = Python_h.LIBRARY_ARENA.allocateFrom("u");
        }
        return Holder.PRIu32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIu64 "llu"
     * }
     */
    public static MemorySegment PRIu64() {
        class Holder {
            static final MemorySegment PRIu64
                = Python_h.LIBRARY_ARENA.allocateFrom("llu");
        }
        return Holder.PRIu64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIuLEAST8 "hhu"
     * }
     */
    public static MemorySegment PRIuLEAST8() {
        class Holder {
            static final MemorySegment PRIuLEAST8
                = Python_h.LIBRARY_ARENA.allocateFrom("hhu");
        }
        return Holder.PRIuLEAST8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIuLEAST16 "hu"
     * }
     */
    public static MemorySegment PRIuLEAST16() {
        class Holder {
            static final MemorySegment PRIuLEAST16
                = Python_h.LIBRARY_ARENA.allocateFrom("hu");
        }
        return Holder.PRIuLEAST16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIuLEAST32 "u"
     * }
     */
    public static MemorySegment PRIuLEAST32() {
        class Holder {
            static final MemorySegment PRIuLEAST32
                = Python_h.LIBRARY_ARENA.allocateFrom("u");
        }
        return Holder.PRIuLEAST32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIuLEAST64 "llu"
     * }
     */
    public static MemorySegment PRIuLEAST64() {
        class Holder {
            static final MemorySegment PRIuLEAST64
                = Python_h.LIBRARY_ARENA.allocateFrom("llu");
        }
        return Holder.PRIuLEAST64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIuFAST8 "hhu"
     * }
     */
    public static MemorySegment PRIuFAST8() {
        class Holder {
            static final MemorySegment PRIuFAST8
                = Python_h.LIBRARY_ARENA.allocateFrom("hhu");
        }
        return Holder.PRIuFAST8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIuFAST16 "u"
     * }
     */
    public static MemorySegment PRIuFAST16() {
        class Holder {
            static final MemorySegment PRIuFAST16
                = Python_h.LIBRARY_ARENA.allocateFrom("u");
        }
        return Holder.PRIuFAST16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIuFAST32 "u"
     * }
     */
    public static MemorySegment PRIuFAST32() {
        class Holder {
            static final MemorySegment PRIuFAST32
                = Python_h.LIBRARY_ARENA.allocateFrom("u");
        }
        return Holder.PRIuFAST32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIuFAST64 "llu"
     * }
     */
    public static MemorySegment PRIuFAST64() {
        class Holder {
            static final MemorySegment PRIuFAST64
                = Python_h.LIBRARY_ARENA.allocateFrom("llu");
        }
        return Holder.PRIuFAST64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIuMAX "llu"
     * }
     */
    public static MemorySegment PRIuMAX() {
        class Holder {
            static final MemorySegment PRIuMAX
                = Python_h.LIBRARY_ARENA.allocateFrom("llu");
        }
        return Holder.PRIuMAX;
    }
    /**
     * {@snippet lang=c :
     * #define PRIuPTR "llu"
     * }
     */
    public static MemorySegment PRIuPTR() {
        class Holder {
            static final MemorySegment PRIuPTR
                = Python_h.LIBRARY_ARENA.allocateFrom("llu");
        }
        return Holder.PRIuPTR;
    }
    /**
     * {@snippet lang=c :
     * #define PRIx8 "hhx"
     * }
     */
    public static MemorySegment PRIx8() {
        class Holder {
            static final MemorySegment PRIx8
                = Python_h.LIBRARY_ARENA.allocateFrom("hhx");
        }
        return Holder.PRIx8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIx16 "hx"
     * }
     */
    public static MemorySegment PRIx16() {
        class Holder {
            static final MemorySegment PRIx16
                = Python_h.LIBRARY_ARENA.allocateFrom("hx");
        }
        return Holder.PRIx16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIx32 "x"
     * }
     */
    public static MemorySegment PRIx32() {
        class Holder {
            static final MemorySegment PRIx32
                = Python_h.LIBRARY_ARENA.allocateFrom("x");
        }
        return Holder.PRIx32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIx64 "llx"
     * }
     */
    public static MemorySegment PRIx64() {
        class Holder {
            static final MemorySegment PRIx64
                = Python_h.LIBRARY_ARENA.allocateFrom("llx");
        }
        return Holder.PRIx64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIxLEAST8 "hhx"
     * }
     */
    public static MemorySegment PRIxLEAST8() {
        class Holder {
            static final MemorySegment PRIxLEAST8
                = Python_h.LIBRARY_ARENA.allocateFrom("hhx");
        }
        return Holder.PRIxLEAST8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIxLEAST16 "hx"
     * }
     */
    public static MemorySegment PRIxLEAST16() {
        class Holder {
            static final MemorySegment PRIxLEAST16
                = Python_h.LIBRARY_ARENA.allocateFrom("hx");
        }
        return Holder.PRIxLEAST16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIxLEAST32 "x"
     * }
     */
    public static MemorySegment PRIxLEAST32() {
        class Holder {
            static final MemorySegment PRIxLEAST32
                = Python_h.LIBRARY_ARENA.allocateFrom("x");
        }
        return Holder.PRIxLEAST32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIxLEAST64 "llx"
     * }
     */
    public static MemorySegment PRIxLEAST64() {
        class Holder {
            static final MemorySegment PRIxLEAST64
                = Python_h.LIBRARY_ARENA.allocateFrom("llx");
        }
        return Holder.PRIxLEAST64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIxFAST8 "hhx"
     * }
     */
    public static MemorySegment PRIxFAST8() {
        class Holder {
            static final MemorySegment PRIxFAST8
                = Python_h.LIBRARY_ARENA.allocateFrom("hhx");
        }
        return Holder.PRIxFAST8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIxFAST16 "x"
     * }
     */
    public static MemorySegment PRIxFAST16() {
        class Holder {
            static final MemorySegment PRIxFAST16
                = Python_h.LIBRARY_ARENA.allocateFrom("x");
        }
        return Holder.PRIxFAST16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIxFAST32 "x"
     * }
     */
    public static MemorySegment PRIxFAST32() {
        class Holder {
            static final MemorySegment PRIxFAST32
                = Python_h.LIBRARY_ARENA.allocateFrom("x");
        }
        return Holder.PRIxFAST32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIxFAST64 "llx"
     * }
     */
    public static MemorySegment PRIxFAST64() {
        class Holder {
            static final MemorySegment PRIxFAST64
                = Python_h.LIBRARY_ARENA.allocateFrom("llx");
        }
        return Holder.PRIxFAST64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIxMAX "llx"
     * }
     */
    public static MemorySegment PRIxMAX() {
        class Holder {
            static final MemorySegment PRIxMAX
                = Python_h.LIBRARY_ARENA.allocateFrom("llx");
        }
        return Holder.PRIxMAX;
    }
    /**
     * {@snippet lang=c :
     * #define PRIxPTR "llx"
     * }
     */
    public static MemorySegment PRIxPTR() {
        class Holder {
            static final MemorySegment PRIxPTR
                = Python_h.LIBRARY_ARENA.allocateFrom("llx");
        }
        return Holder.PRIxPTR;
    }
    /**
     * {@snippet lang=c :
     * #define PRIX8 "hhX"
     * }
     */
    public static MemorySegment PRIX8() {
        class Holder {
            static final MemorySegment PRIX8
                = Python_h.LIBRARY_ARENA.allocateFrom("hhX");
        }
        return Holder.PRIX8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIX16 "hX"
     * }
     */
    public static MemorySegment PRIX16() {
        class Holder {
            static final MemorySegment PRIX16
                = Python_h.LIBRARY_ARENA.allocateFrom("hX");
        }
        return Holder.PRIX16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIX32 "X"
     * }
     */
    public static MemorySegment PRIX32() {
        class Holder {
            static final MemorySegment PRIX32
                = Python_h.LIBRARY_ARENA.allocateFrom("X");
        }
        return Holder.PRIX32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIX64 "llX"
     * }
     */
    public static MemorySegment PRIX64() {
        class Holder {
            static final MemorySegment PRIX64
                = Python_h.LIBRARY_ARENA.allocateFrom("llX");
        }
        return Holder.PRIX64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIXLEAST8 "hhX"
     * }
     */
    public static MemorySegment PRIXLEAST8() {
        class Holder {
            static final MemorySegment PRIXLEAST8
                = Python_h.LIBRARY_ARENA.allocateFrom("hhX");
        }
        return Holder.PRIXLEAST8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIXLEAST16 "hX"
     * }
     */
    public static MemorySegment PRIXLEAST16() {
        class Holder {
            static final MemorySegment PRIXLEAST16
                = Python_h.LIBRARY_ARENA.allocateFrom("hX");
        }
        return Holder.PRIXLEAST16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIXLEAST32 "X"
     * }
     */
    public static MemorySegment PRIXLEAST32() {
        class Holder {
            static final MemorySegment PRIXLEAST32
                = Python_h.LIBRARY_ARENA.allocateFrom("X");
        }
        return Holder.PRIXLEAST32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIXLEAST64 "llX"
     * }
     */
    public static MemorySegment PRIXLEAST64() {
        class Holder {
            static final MemorySegment PRIXLEAST64
                = Python_h.LIBRARY_ARENA.allocateFrom("llX");
        }
        return Holder.PRIXLEAST64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIXFAST8 "hhX"
     * }
     */
    public static MemorySegment PRIXFAST8() {
        class Holder {
            static final MemorySegment PRIXFAST8
                = Python_h.LIBRARY_ARENA.allocateFrom("hhX");
        }
        return Holder.PRIXFAST8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIXFAST16 "X"
     * }
     */
    public static MemorySegment PRIXFAST16() {
        class Holder {
            static final MemorySegment PRIXFAST16
                = Python_h.LIBRARY_ARENA.allocateFrom("X");
        }
        return Holder.PRIXFAST16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIXFAST32 "X"
     * }
     */
    public static MemorySegment PRIXFAST32() {
        class Holder {
            static final MemorySegment PRIXFAST32
                = Python_h.LIBRARY_ARENA.allocateFrom("X");
        }
        return Holder.PRIXFAST32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIXFAST64 "llX"
     * }
     */
    public static MemorySegment PRIXFAST64() {
        class Holder {
            static final MemorySegment PRIXFAST64
                = Python_h.LIBRARY_ARENA.allocateFrom("llX");
        }
        return Holder.PRIXFAST64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIXMAX "llX"
     * }
     */
    public static MemorySegment PRIXMAX() {
        class Holder {
            static final MemorySegment PRIXMAX
                = Python_h.LIBRARY_ARENA.allocateFrom("llX");
        }
        return Holder.PRIXMAX;
    }
    /**
     * {@snippet lang=c :
     * #define PRIXPTR "llX"
     * }
     */
    public static MemorySegment PRIXPTR() {
        class Holder {
            static final MemorySegment PRIXPTR
                = Python_h.LIBRARY_ARENA.allocateFrom("llX");
        }
        return Holder.PRIXPTR;
    }
    /**
     * {@snippet lang=c :
     * #define SCNd8 "hhd"
     * }
     */
    public static MemorySegment SCNd8() {
        class Holder {
            static final MemorySegment SCNd8
                = Python_h.LIBRARY_ARENA.allocateFrom("hhd");
        }
        return Holder.SCNd8;
    }
    /**
     * {@snippet lang=c :
     * #define SCNd16 "hd"
     * }
     */
    public static MemorySegment SCNd16() {
        class Holder {
            static final MemorySegment SCNd16
                = Python_h.LIBRARY_ARENA.allocateFrom("hd");
        }
        return Holder.SCNd16;
    }
    /**
     * {@snippet lang=c :
     * #define SCNd32 "d"
     * }
     */
    public static MemorySegment SCNd32() {
        class Holder {
            static final MemorySegment SCNd32
                = Python_h.LIBRARY_ARENA.allocateFrom("d");
        }
        return Holder.SCNd32;
    }
    /**
     * {@snippet lang=c :
     * #define SCNd64 "lld"
     * }
     */
    public static MemorySegment SCNd64() {
        class Holder {
            static final MemorySegment SCNd64
                = Python_h.LIBRARY_ARENA.allocateFrom("lld");
        }
        return Holder.SCNd64;
    }
    /**
     * {@snippet lang=c :
     * #define SCNdLEAST8 "hhd"
     * }
     */
    public static MemorySegment SCNdLEAST8() {
        class Holder {
            static final MemorySegment SCNdLEAST8
                = Python_h.LIBRARY_ARENA.allocateFrom("hhd");
        }
        return Holder.SCNdLEAST8;
    }
    /**
     * {@snippet lang=c :
     * #define SCNdLEAST16 "hd"
     * }
     */
    public static MemorySegment SCNdLEAST16() {
        class Holder {
            static final MemorySegment SCNdLEAST16
                = Python_h.LIBRARY_ARENA.allocateFrom("hd");
        }
        return Holder.SCNdLEAST16;
    }
    /**
     * {@snippet lang=c :
     * #define SCNdLEAST32 "d"
     * }
     */
    public static MemorySegment SCNdLEAST32() {
        class Holder {
            static final MemorySegment SCNdLEAST32
                = Python_h.LIBRARY_ARENA.allocateFrom("d");
        }
        return Holder.SCNdLEAST32;
    }
    /**
     * {@snippet lang=c :
     * #define SCNdLEAST64 "lld"
     * }
     */
    public static MemorySegment SCNdLEAST64() {
        class Holder {
            static final MemorySegment SCNdLEAST64
                = Python_h.LIBRARY_ARENA.allocateFrom("lld");
        }
        return Holder.SCNdLEAST64;
    }
    /**
     * {@snippet lang=c :
     * #define SCNdFAST8 "hhd"
     * }
     */
    public static MemorySegment SCNdFAST8() {
        class Holder {
            static final MemorySegment SCNdFAST8
                = Python_h.LIBRARY_ARENA.allocateFrom("hhd");
        }
        return Holder.SCNdFAST8;
    }
    /**
     * {@snippet lang=c :
     * #define SCNdFAST16 "d"
     * }
     */
    public static MemorySegment SCNdFAST16() {
        class Holder {
            static final MemorySegment SCNdFAST16
                = Python_h.LIBRARY_ARENA.allocateFrom("d");
        }
        return Holder.SCNdFAST16;
    }
    /**
     * {@snippet lang=c :
     * #define SCNdFAST32 "d"
     * }
     */
    public static MemorySegment SCNdFAST32() {
        class Holder {
            static final MemorySegment SCNdFAST32
                = Python_h.LIBRARY_ARENA.allocateFrom("d");
        }
        return Holder.SCNdFAST32;
    }
    /**
     * {@snippet lang=c :
     * #define SCNdFAST64 "lld"
     * }
     */
    public static MemorySegment SCNdFAST64() {
        class Holder {
            static final MemorySegment SCNdFAST64
                = Python_h.LIBRARY_ARENA.allocateFrom("lld");
        }
        return Holder.SCNdFAST64;
    }
    /**
     * {@snippet lang=c :
     * #define SCNdMAX "lld"
     * }
     */
    public static MemorySegment SCNdMAX() {
        class Holder {
            static final MemorySegment SCNdMAX
                = Python_h.LIBRARY_ARENA.allocateFrom("lld");
        }
        return Holder.SCNdMAX;
    }
    /**
     * {@snippet lang=c :
     * #define SCNdPTR "lld"
     * }
     */
    public static MemorySegment SCNdPTR() {
        class Holder {
            static final MemorySegment SCNdPTR
                = Python_h.LIBRARY_ARENA.allocateFrom("lld");
        }
        return Holder.SCNdPTR;
    }
    /**
     * {@snippet lang=c :
     * #define SCNi8 "hhi"
     * }
     */
    public static MemorySegment SCNi8() {
        class Holder {
            static final MemorySegment SCNi8
                = Python_h.LIBRARY_ARENA.allocateFrom("hhi");
        }
        return Holder.SCNi8;
    }
    /**
     * {@snippet lang=c :
     * #define SCNi16 "hi"
     * }
     */
    public static MemorySegment SCNi16() {
        class Holder {
            static final MemorySegment SCNi16
                = Python_h.LIBRARY_ARENA.allocateFrom("hi");
        }
        return Holder.SCNi16;
    }
    /**
     * {@snippet lang=c :
     * #define SCNi32 "i"
     * }
     */
    public static MemorySegment SCNi32() {
        class Holder {
            static final MemorySegment SCNi32
                = Python_h.LIBRARY_ARENA.allocateFrom("i");
        }
        return Holder.SCNi32;
    }
    /**
     * {@snippet lang=c :
     * #define SCNi64 "lli"
     * }
     */
    public static MemorySegment SCNi64() {
        class Holder {
            static final MemorySegment SCNi64
                = Python_h.LIBRARY_ARENA.allocateFrom("lli");
        }
        return Holder.SCNi64;
    }
    /**
     * {@snippet lang=c :
     * #define SCNiLEAST8 "hhi"
     * }
     */
    public static MemorySegment SCNiLEAST8() {
        class Holder {
            static final MemorySegment SCNiLEAST8
                = Python_h.LIBRARY_ARENA.allocateFrom("hhi");
        }
        return Holder.SCNiLEAST8;
    }
    /**
     * {@snippet lang=c :
     * #define SCNiLEAST16 "hi"
     * }
     */
    public static MemorySegment SCNiLEAST16() {
        class Holder {
            static final MemorySegment SCNiLEAST16
                = Python_h.LIBRARY_ARENA.allocateFrom("hi");
        }
        return Holder.SCNiLEAST16;
    }
    /**
     * {@snippet lang=c :
     * #define SCNiLEAST32 "i"
     * }
     */
    public static MemorySegment SCNiLEAST32() {
        class Holder {
            static final MemorySegment SCNiLEAST32
                = Python_h.LIBRARY_ARENA.allocateFrom("i");
        }
        return Holder.SCNiLEAST32;
    }
    /**
     * {@snippet lang=c :
     * #define SCNiLEAST64 "lli"
     * }
     */
    public static MemorySegment SCNiLEAST64() {
        class Holder {
            static final MemorySegment SCNiLEAST64
                = Python_h.LIBRARY_ARENA.allocateFrom("lli");
        }
        return Holder.SCNiLEAST64;
    }
    /**
     * {@snippet lang=c :
     * #define SCNiFAST8 "hhi"
     * }
     */
    public static MemorySegment SCNiFAST8() {
        class Holder {
            static final MemorySegment SCNiFAST8
                = Python_h.LIBRARY_ARENA.allocateFrom("hhi");
        }
        return Holder.SCNiFAST8;
    }
    /**
     * {@snippet lang=c :
     * #define SCNiFAST16 "i"
     * }
     */
    public static MemorySegment SCNiFAST16() {
        class Holder {
            static final MemorySegment SCNiFAST16
                = Python_h.LIBRARY_ARENA.allocateFrom("i");
        }
        return Holder.SCNiFAST16;
    }
    /**
     * {@snippet lang=c :
     * #define SCNiFAST32 "i"
     * }
     */
    public static MemorySegment SCNiFAST32() {
        class Holder {
            static final MemorySegment SCNiFAST32
                = Python_h.LIBRARY_ARENA.allocateFrom("i");
        }
        return Holder.SCNiFAST32;
    }
    /**
     * {@snippet lang=c :
     * #define SCNiFAST64 "lli"
     * }
     */
    public static MemorySegment SCNiFAST64() {
        class Holder {
            static final MemorySegment SCNiFAST64
                = Python_h.LIBRARY_ARENA.allocateFrom("lli");
        }
        return Holder.SCNiFAST64;
    }
    /**
     * {@snippet lang=c :
     * #define SCNiMAX "lli"
     * }
     */
    public static MemorySegment SCNiMAX() {
        class Holder {
            static final MemorySegment SCNiMAX
                = Python_h.LIBRARY_ARENA.allocateFrom("lli");
        }
        return Holder.SCNiMAX;
    }
    /**
     * {@snippet lang=c :
     * #define SCNiPTR "lli"
     * }
     */
    public static MemorySegment SCNiPTR() {
        class Holder {
            static final MemorySegment SCNiPTR
                = Python_h.LIBRARY_ARENA.allocateFrom("lli");
        }
        return Holder.SCNiPTR;
    }
    /**
     * {@snippet lang=c :
     * #define SCNo8 "hho"
     * }
     */
    public static MemorySegment SCNo8() {
        class Holder {
            static final MemorySegment SCNo8
                = Python_h.LIBRARY_ARENA.allocateFrom("hho");
        }
        return Holder.SCNo8;
    }
    /**
     * {@snippet lang=c :
     * #define SCNo16 "ho"
     * }
     */
    public static MemorySegment SCNo16() {
        class Holder {
            static final MemorySegment SCNo16
                = Python_h.LIBRARY_ARENA.allocateFrom("ho");
        }
        return Holder.SCNo16;
    }
    /**
     * {@snippet lang=c :
     * #define SCNo32 "o"
     * }
     */
    public static MemorySegment SCNo32() {
        class Holder {
            static final MemorySegment SCNo32
                = Python_h.LIBRARY_ARENA.allocateFrom("o");
        }
        return Holder.SCNo32;
    }
    /**
     * {@snippet lang=c :
     * #define SCNo64 "llo"
     * }
     */
    public static MemorySegment SCNo64() {
        class Holder {
            static final MemorySegment SCNo64
                = Python_h.LIBRARY_ARENA.allocateFrom("llo");
        }
        return Holder.SCNo64;
    }
    /**
     * {@snippet lang=c :
     * #define SCNoLEAST8 "hho"
     * }
     */
    public static MemorySegment SCNoLEAST8() {
        class Holder {
            static final MemorySegment SCNoLEAST8
                = Python_h.LIBRARY_ARENA.allocateFrom("hho");
        }
        return Holder.SCNoLEAST8;
    }
    /**
     * {@snippet lang=c :
     * #define SCNoLEAST16 "ho"
     * }
     */
    public static MemorySegment SCNoLEAST16() {
        class Holder {
            static final MemorySegment SCNoLEAST16
                = Python_h.LIBRARY_ARENA.allocateFrom("ho");
        }
        return Holder.SCNoLEAST16;
    }
    /**
     * {@snippet lang=c :
     * #define SCNoLEAST32 "o"
     * }
     */
    public static MemorySegment SCNoLEAST32() {
        class Holder {
            static final MemorySegment SCNoLEAST32
                = Python_h.LIBRARY_ARENA.allocateFrom("o");
        }
        return Holder.SCNoLEAST32;
    }
    /**
     * {@snippet lang=c :
     * #define SCNoLEAST64 "llo"
     * }
     */
    public static MemorySegment SCNoLEAST64() {
        class Holder {
            static final MemorySegment SCNoLEAST64
                = Python_h.LIBRARY_ARENA.allocateFrom("llo");
        }
        return Holder.SCNoLEAST64;
    }
    /**
     * {@snippet lang=c :
     * #define SCNoFAST8 "hho"
     * }
     */
    public static MemorySegment SCNoFAST8() {
        class Holder {
            static final MemorySegment SCNoFAST8
                = Python_h.LIBRARY_ARENA.allocateFrom("hho");
        }
        return Holder.SCNoFAST8;
    }
    /**
     * {@snippet lang=c :
     * #define SCNoFAST16 "o"
     * }
     */
    public static MemorySegment SCNoFAST16() {
        class Holder {
            static final MemorySegment SCNoFAST16
                = Python_h.LIBRARY_ARENA.allocateFrom("o");
        }
        return Holder.SCNoFAST16;
    }
    /**
     * {@snippet lang=c :
     * #define SCNoFAST32 "o"
     * }
     */
    public static MemorySegment SCNoFAST32() {
        class Holder {
            static final MemorySegment SCNoFAST32
                = Python_h.LIBRARY_ARENA.allocateFrom("o");
        }
        return Holder.SCNoFAST32;
    }
    /**
     * {@snippet lang=c :
     * #define SCNoFAST64 "llo"
     * }
     */
    public static MemorySegment SCNoFAST64() {
        class Holder {
            static final MemorySegment SCNoFAST64
                = Python_h.LIBRARY_ARENA.allocateFrom("llo");
        }
        return Holder.SCNoFAST64;
    }
    /**
     * {@snippet lang=c :
     * #define SCNoMAX "llo"
     * }
     */
    public static MemorySegment SCNoMAX() {
        class Holder {
            static final MemorySegment SCNoMAX
                = Python_h.LIBRARY_ARENA.allocateFrom("llo");
        }
        return Holder.SCNoMAX;
    }
    /**
     * {@snippet lang=c :
     * #define SCNoPTR "llo"
     * }
     */
    public static MemorySegment SCNoPTR() {
        class Holder {
            static final MemorySegment SCNoPTR
                = Python_h.LIBRARY_ARENA.allocateFrom("llo");
        }
        return Holder.SCNoPTR;
    }
    /**
     * {@snippet lang=c :
     * #define SCNu8 "hhu"
     * }
     */
    public static MemorySegment SCNu8() {
        class Holder {
            static final MemorySegment SCNu8
                = Python_h.LIBRARY_ARENA.allocateFrom("hhu");
        }
        return Holder.SCNu8;
    }
    /**
     * {@snippet lang=c :
     * #define SCNu16 "hu"
     * }
     */
    public static MemorySegment SCNu16() {
        class Holder {
            static final MemorySegment SCNu16
                = Python_h.LIBRARY_ARENA.allocateFrom("hu");
        }
        return Holder.SCNu16;
    }
    /**
     * {@snippet lang=c :
     * #define SCNu32 "u"
     * }
     */
    public static MemorySegment SCNu32() {
        class Holder {
            static final MemorySegment SCNu32
                = Python_h.LIBRARY_ARENA.allocateFrom("u");
        }
        return Holder.SCNu32;
    }
    /**
     * {@snippet lang=c :
     * #define SCNu64 "llu"
     * }
     */
    public static MemorySegment SCNu64() {
        class Holder {
            static final MemorySegment SCNu64
                = Python_h.LIBRARY_ARENA.allocateFrom("llu");
        }
        return Holder.SCNu64;
    }
    /**
     * {@snippet lang=c :
     * #define SCNuLEAST8 "hhu"
     * }
     */
    public static MemorySegment SCNuLEAST8() {
        class Holder {
            static final MemorySegment SCNuLEAST8
                = Python_h.LIBRARY_ARENA.allocateFrom("hhu");
        }
        return Holder.SCNuLEAST8;
    }
    /**
     * {@snippet lang=c :
     * #define SCNuLEAST16 "hu"
     * }
     */
    public static MemorySegment SCNuLEAST16() {
        class Holder {
            static final MemorySegment SCNuLEAST16
                = Python_h.LIBRARY_ARENA.allocateFrom("hu");
        }
        return Holder.SCNuLEAST16;
    }
    /**
     * {@snippet lang=c :
     * #define SCNuLEAST32 "u"
     * }
     */
    public static MemorySegment SCNuLEAST32() {
        class Holder {
            static final MemorySegment SCNuLEAST32
                = Python_h.LIBRARY_ARENA.allocateFrom("u");
        }
        return Holder.SCNuLEAST32;
    }
    /**
     * {@snippet lang=c :
     * #define SCNuLEAST64 "llu"
     * }
     */
    public static MemorySegment SCNuLEAST64() {
        class Holder {
            static final MemorySegment SCNuLEAST64
                = Python_h.LIBRARY_ARENA.allocateFrom("llu");
        }
        return Holder.SCNuLEAST64;
    }
    /**
     * {@snippet lang=c :
     * #define SCNuFAST8 "hhu"
     * }
     */
    public static MemorySegment SCNuFAST8() {
        class Holder {
            static final MemorySegment SCNuFAST8
                = Python_h.LIBRARY_ARENA.allocateFrom("hhu");
        }
        return Holder.SCNuFAST8;
    }
    /**
     * {@snippet lang=c :
     * #define SCNuFAST16 "u"
     * }
     */
    public static MemorySegment SCNuFAST16() {
        class Holder {
            static final MemorySegment SCNuFAST16
                = Python_h.LIBRARY_ARENA.allocateFrom("u");
        }
        return Holder.SCNuFAST16;
    }
    /**
     * {@snippet lang=c :
     * #define SCNuFAST32 "u"
     * }
     */
    public static MemorySegment SCNuFAST32() {
        class Holder {
            static final MemorySegment SCNuFAST32
                = Python_h.LIBRARY_ARENA.allocateFrom("u");
        }
        return Holder.SCNuFAST32;
    }
    /**
     * {@snippet lang=c :
     * #define SCNuFAST64 "llu"
     * }
     */
    public static MemorySegment SCNuFAST64() {
        class Holder {
            static final MemorySegment SCNuFAST64
                = Python_h.LIBRARY_ARENA.allocateFrom("llu");
        }
        return Holder.SCNuFAST64;
    }
    /**
     * {@snippet lang=c :
     * #define SCNuMAX "llu"
     * }
     */
    public static MemorySegment SCNuMAX() {
        class Holder {
            static final MemorySegment SCNuMAX
                = Python_h.LIBRARY_ARENA.allocateFrom("llu");
        }
        return Holder.SCNuMAX;
    }
    /**
     * {@snippet lang=c :
     * #define SCNuPTR "llu"
     * }
     */
    public static MemorySegment SCNuPTR() {
        class Holder {
            static final MemorySegment SCNuPTR
                = Python_h.LIBRARY_ARENA.allocateFrom("llu");
        }
        return Holder.SCNuPTR;
    }
    /**
     * {@snippet lang=c :
     * #define SCNx8 "hhx"
     * }
     */
    public static MemorySegment SCNx8() {
        class Holder {
            static final MemorySegment SCNx8
                = Python_h.LIBRARY_ARENA.allocateFrom("hhx");
        }
        return Holder.SCNx8;
    }
    /**
     * {@snippet lang=c :
     * #define SCNx16 "hx"
     * }
     */
    public static MemorySegment SCNx16() {
        class Holder {
            static final MemorySegment SCNx16
                = Python_h.LIBRARY_ARENA.allocateFrom("hx");
        }
        return Holder.SCNx16;
    }
    /**
     * {@snippet lang=c :
     * #define SCNx32 "x"
     * }
     */
    public static MemorySegment SCNx32() {
        class Holder {
            static final MemorySegment SCNx32
                = Python_h.LIBRARY_ARENA.allocateFrom("x");
        }
        return Holder.SCNx32;
    }
    /**
     * {@snippet lang=c :
     * #define SCNx64 "llx"
     * }
     */
    public static MemorySegment SCNx64() {
        class Holder {
            static final MemorySegment SCNx64
                = Python_h.LIBRARY_ARENA.allocateFrom("llx");
        }
        return Holder.SCNx64;
    }
    /**
     * {@snippet lang=c :
     * #define SCNxLEAST8 "hhx"
     * }
     */
    public static MemorySegment SCNxLEAST8() {
        class Holder {
            static final MemorySegment SCNxLEAST8
                = Python_h.LIBRARY_ARENA.allocateFrom("hhx");
        }
        return Holder.SCNxLEAST8;
    }
    /**
     * {@snippet lang=c :
     * #define SCNxLEAST16 "hx"
     * }
     */
    public static MemorySegment SCNxLEAST16() {
        class Holder {
            static final MemorySegment SCNxLEAST16
                = Python_h.LIBRARY_ARENA.allocateFrom("hx");
        }
        return Holder.SCNxLEAST16;
    }
    /**
     * {@snippet lang=c :
     * #define SCNxLEAST32 "x"
     * }
     */
    public static MemorySegment SCNxLEAST32() {
        class Holder {
            static final MemorySegment SCNxLEAST32
                = Python_h.LIBRARY_ARENA.allocateFrom("x");
        }
        return Holder.SCNxLEAST32;
    }
    /**
     * {@snippet lang=c :
     * #define SCNxLEAST64 "llx"
     * }
     */
    public static MemorySegment SCNxLEAST64() {
        class Holder {
            static final MemorySegment SCNxLEAST64
                = Python_h.LIBRARY_ARENA.allocateFrom("llx");
        }
        return Holder.SCNxLEAST64;
    }
    /**
     * {@snippet lang=c :
     * #define SCNxFAST8 "hhx"
     * }
     */
    public static MemorySegment SCNxFAST8() {
        class Holder {
            static final MemorySegment SCNxFAST8
                = Python_h.LIBRARY_ARENA.allocateFrom("hhx");
        }
        return Holder.SCNxFAST8;
    }
    /**
     * {@snippet lang=c :
     * #define SCNxFAST16 "x"
     * }
     */
    public static MemorySegment SCNxFAST16() {
        class Holder {
            static final MemorySegment SCNxFAST16
                = Python_h.LIBRARY_ARENA.allocateFrom("x");
        }
        return Holder.SCNxFAST16;
    }
    /**
     * {@snippet lang=c :
     * #define SCNxFAST32 "x"
     * }
     */
    public static MemorySegment SCNxFAST32() {
        class Holder {
            static final MemorySegment SCNxFAST32
                = Python_h.LIBRARY_ARENA.allocateFrom("x");
        }
        return Holder.SCNxFAST32;
    }
    /**
     * {@snippet lang=c :
     * #define SCNxFAST64 "llx"
     * }
     */
    public static MemorySegment SCNxFAST64() {
        class Holder {
            static final MemorySegment SCNxFAST64
                = Python_h.LIBRARY_ARENA.allocateFrom("llx");
        }
        return Holder.SCNxFAST64;
    }
    /**
     * {@snippet lang=c :
     * #define SCNxMAX "llx"
     * }
     */
    public static MemorySegment SCNxMAX() {
        class Holder {
            static final MemorySegment SCNxMAX
                = Python_h.LIBRARY_ARENA.allocateFrom("llx");
        }
        return Holder.SCNxMAX;
    }
    /**
     * {@snippet lang=c :
     * #define SCNxPTR "llx"
     * }
     */
    public static MemorySegment SCNxPTR() {
        class Holder {
            static final MemorySegment SCNxPTR
                = Python_h.LIBRARY_ARENA.allocateFrom("llx");
        }
        return Holder.SCNxPTR;
    }
    private static final int SCHAR_MIN = (int)-128L;
    /**
     * {@snippet lang=c :
     * #define SCHAR_MIN -128
     * }
     */
    public static int SCHAR_MIN() {
        return SCHAR_MIN;
    }
    private static final int CHAR_MIN = (int)-128L;
    /**
     * {@snippet lang=c :
     * #define CHAR_MIN -128
     * }
     */
    public static int CHAR_MIN() {
        return CHAR_MIN;
    }
    private static final int CHAR_MAX = (int)127L;
    /**
     * {@snippet lang=c :
     * #define CHAR_MAX 127
     * }
     */
    public static int CHAR_MAX() {
        return CHAR_MAX;
    }
    private static final int SHRT_MIN = (int)-32768L;
    /**
     * {@snippet lang=c :
     * #define SHRT_MIN -32768
     * }
     */
    public static int SHRT_MIN() {
        return SHRT_MIN;
    }
    private static final int INT_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define INT_MIN -2147483648
     * }
     */
    public static int INT_MIN() {
        return INT_MIN;
    }
    private static final int UINT_MAX = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define UINT_MAX 4294967295
     * }
     */
    public static int UINT_MAX() {
        return UINT_MAX;
    }
    private static final int LONG_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define LONG_MIN -2147483648
     * }
     */
    public static int LONG_MIN() {
        return LONG_MIN;
    }
    private static final int LONG_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define LONG_MAX 2147483647
     * }
     */
    public static int LONG_MAX() {
        return LONG_MAX;
    }
    private static final int ULONG_MAX = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define ULONG_MAX 4294967295
     * }
     */
    public static int ULONG_MAX() {
        return ULONG_MAX;
    }
    private static final long LLONG_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define LLONG_MAX 9223372036854775807
     * }
     */
    public static long LLONG_MAX() {
        return LLONG_MAX;
    }
    private static final long LLONG_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define LLONG_MIN -9223372036854775808
     * }
     */
    public static long LLONG_MIN() {
        return LLONG_MIN;
    }
    private static final long ULLONG_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define ULLONG_MAX -1
     * }
     */
    public static long ULLONG_MAX() {
        return ULLONG_MAX;
    }
    private static final int _I8_MIN = (int)-128L;
    /**
     * {@snippet lang=c :
     * #define _I8_MIN -128
     * }
     */
    public static int _I8_MIN() {
        return _I8_MIN;
    }
    private static final byte _I8_MAX = (byte)127L;
    /**
     * {@snippet lang=c :
     * #define _I8_MAX 127
     * }
     */
    public static byte _I8_MAX() {
        return _I8_MAX;
    }
    private static final byte _UI8_MAX = (byte)255L;
    /**
     * {@snippet lang=c :
     * #define _UI8_MAX 255
     * }
     */
    public static byte _UI8_MAX() {
        return _UI8_MAX;
    }
    private static final int _I16_MIN = (int)-32768L;
    /**
     * {@snippet lang=c :
     * #define _I16_MIN -32768
     * }
     */
    public static int _I16_MIN() {
        return _I16_MIN;
    }
    private static final short _I16_MAX = (short)32767L;
    /**
     * {@snippet lang=c :
     * #define _I16_MAX 32767
     * }
     */
    public static short _I16_MAX() {
        return _I16_MAX;
    }
    private static final short _UI16_MAX = (short)65535L;
    /**
     * {@snippet lang=c :
     * #define _UI16_MAX 65535
     * }
     */
    public static short _UI16_MAX() {
        return _UI16_MAX;
    }
    private static final int _I32_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define _I32_MIN -2147483648
     * }
     */
    public static int _I32_MIN() {
        return _I32_MIN;
    }
    private static final int _I32_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define _I32_MAX 2147483647
     * }
     */
    public static int _I32_MAX() {
        return _I32_MAX;
    }
    private static final int _UI32_MAX = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define _UI32_MAX 4294967295
     * }
     */
    public static int _UI32_MAX() {
        return _UI32_MAX;
    }
    private static final long _I64_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define _I64_MIN -9223372036854775808
     * }
     */
    public static long _I64_MIN() {
        return _I64_MIN;
    }
    private static final long _I64_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define _I64_MAX 9223372036854775807
     * }
     */
    public static long _I64_MAX() {
        return _I64_MAX;
    }
    private static final long _UI64_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define _UI64_MAX -1
     * }
     */
    public static long _UI64_MAX() {
        return _UI64_MAX;
    }
    private static final long RSIZE_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define RSIZE_MAX 9223372036854775807
     * }
     */
    public static long RSIZE_MAX() {
        return RSIZE_MAX;
    }
    private static final long LONG_LONG_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define LONG_LONG_MAX 9223372036854775807
     * }
     */
    public static long LONG_LONG_MAX() {
        return LONG_LONG_MAX;
    }
    private static final long LONG_LONG_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define LONG_LONG_MIN -9223372036854775808
     * }
     */
    public static long LONG_LONG_MIN() {
        return LONG_LONG_MIN;
    }
    private static final long ULONG_LONG_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define ULONG_LONG_MAX -1
     * }
     */
    public static long ULONG_LONG_MAX() {
        return ULONG_LONG_MAX;
    }
    private static final MemorySegment _Py_NULL = MemorySegment.ofAddress(0L);
    /**
     * {@snippet lang=c :
     * #define _Py_NULL (void*) 0
     * }
     */
    public static MemorySegment _Py_NULL() {
        return _Py_NULL;
    }
    private static final long PY_SSIZE_T_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define PY_SSIZE_T_MIN -9223372036854775808
     * }
     */
    public static long PY_SSIZE_T_MIN() {
        return PY_SSIZE_T_MIN;
    }
    private static final int SIZEOF_PY_HASH_T = (int)8L;
    /**
     * {@snippet lang=c :
     * #define SIZEOF_PY_HASH_T 8
     * }
     */
    public static int SIZEOF_PY_HASH_T() {
        return SIZEOF_PY_HASH_T;
    }
    private static final int SIZEOF_PY_UHASH_T = (int)8L;
    /**
     * {@snippet lang=c :
     * #define SIZEOF_PY_UHASH_T 8
     * }
     */
    public static int SIZEOF_PY_UHASH_T() {
        return SIZEOF_PY_UHASH_T;
    }
    private static final long PY_SIZE_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define PY_SIZE_MAX -1
     * }
     */
    public static long PY_SIZE_MAX() {
        return PY_SIZE_MAX;
    }
    /**
     * {@snippet lang=c :
     * #define PY_FORMAT_SIZE_T "z"
     * }
     */
    public static MemorySegment PY_FORMAT_SIZE_T() {
        class Holder {
            static final MemorySegment PY_FORMAT_SIZE_T
                = Python_h.LIBRARY_ARENA.allocateFrom("z");
        }
        return Holder.PY_FORMAT_SIZE_T;
    }
    private static final double _HUGE_ENUF = 1.0E300d;
    /**
     * {@snippet lang=c :
     * #define _HUGE_ENUF 1.0E300
     * }
     */
    public static double _HUGE_ENUF() {
        return _HUGE_ENUF;
    }
    private static final float INFINITY = Float.valueOf("Infinity");
    /**
     * {@snippet lang=c :
     * #define INFINITY Infinity
     * }
     */
    public static float INFINITY() {
        return INFINITY;
    }
    private static final double HUGE_VAL = Double.valueOf("Infinity");
    /**
     * {@snippet lang=c :
     * #define HUGE_VAL Infinity
     * }
     */
    public static double HUGE_VAL() {
        return HUGE_VAL;
    }
    private static final float HUGE_VALF = Float.valueOf("Infinity");
    /**
     * {@snippet lang=c :
     * #define HUGE_VALF Infinity
     * }
     */
    public static float HUGE_VALF() {
        return HUGE_VALF;
    }
    private static final double HUGE_VALL = Double.valueOf("Infinity");
    /**
     * {@snippet lang=c :
     * #define HUGE_VALL Infinity
     * }
     */
    public static double HUGE_VALL() {
        return HUGE_VALL;
    }
    private static final float NAN = Float.valueOf("NaN");
    /**
     * {@snippet lang=c :
     * #define NAN NaN
     * }
     */
    public static float NAN() {
        return NAN;
    }
    private static final int _DENORM = (int)-2L;
    /**
     * {@snippet lang=c :
     * #define _DENORM -2
     * }
     */
    public static int _DENORM() {
        return _DENORM;
    }
    private static final int _FINITE = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define _FINITE -1
     * }
     */
    public static int _FINITE() {
        return _FINITE;
    }
    private static final int FP_INFINITE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define FP_INFINITE 1
     * }
     */
    public static int FP_INFINITE() {
        return FP_INFINITE;
    }
    private static final int FP_NAN = (int)2L;
    /**
     * {@snippet lang=c :
     * #define FP_NAN 2
     * }
     */
    public static int FP_NAN() {
        return FP_NAN;
    }
    private static final int FP_NORMAL = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define FP_NORMAL -1
     * }
     */
    public static int FP_NORMAL() {
        return FP_NORMAL;
    }
    private static final int FP_SUBNORMAL = (int)-2L;
    /**
     * {@snippet lang=c :
     * #define FP_SUBNORMAL -2
     * }
     */
    public static int FP_SUBNORMAL() {
        return FP_SUBNORMAL;
    }
    private static final int FP_ILOGB0 = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define FP_ILOGB0 -2147483648
     * }
     */
    public static int FP_ILOGB0() {
        return FP_ILOGB0;
    }
    private static final int math_errhandling = (int)3L;
    /**
     * {@snippet lang=c :
     * #define math_errhandling 3
     * }
     */
    public static int math_errhandling() {
        return math_errhandling;
    }
    private static final short _DFRAC = (short)15L;
    /**
     * {@snippet lang=c :
     * #define _DFRAC 15
     * }
     */
    public static short _DFRAC() {
        return _DFRAC;
    }
    private static final short _DMASK = (short)32752L;
    /**
     * {@snippet lang=c :
     * #define _DMASK 32752
     * }
     */
    public static short _DMASK() {
        return _DMASK;
    }
    private static final short _DMAX = (short)2047L;
    /**
     * {@snippet lang=c :
     * #define _DMAX 2047
     * }
     */
    public static short _DMAX() {
        return _DMAX;
    }
    private static final short _DSIGN = (short)32768L;
    /**
     * {@snippet lang=c :
     * #define _DSIGN 32768
     * }
     */
    public static short _DSIGN() {
        return _DSIGN;
    }
    private static final short _FFRAC = (short)127L;
    /**
     * {@snippet lang=c :
     * #define _FFRAC 127
     * }
     */
    public static short _FFRAC() {
        return _FFRAC;
    }
    private static final short _FMASK = (short)32640L;
    /**
     * {@snippet lang=c :
     * #define _FMASK 32640
     * }
     */
    public static short _FMASK() {
        return _FMASK;
    }
    private static final short _FMAX = (short)255L;
    /**
     * {@snippet lang=c :
     * #define _FMAX 255
     * }
     */
    public static short _FMAX() {
        return _FMAX;
    }
    private static final short _FSIGN = (short)32768L;
    /**
     * {@snippet lang=c :
     * #define _FSIGN 32768
     * }
     */
    public static short _FSIGN() {
        return _FSIGN;
    }
    private static final short _LFRAC = (short)65535L;
    /**
     * {@snippet lang=c :
     * #define _LFRAC 65535
     * }
     */
    public static short _LFRAC() {
        return _LFRAC;
    }
    private static final short _LMASK = (short)32767L;
    /**
     * {@snippet lang=c :
     * #define _LMASK 32767
     * }
     */
    public static short _LMASK() {
        return _LMASK;
    }
    private static final short _LMAX = (short)32767L;
    /**
     * {@snippet lang=c :
     * #define _LMAX 32767
     * }
     */
    public static short _LMAX() {
        return _LMAX;
    }
    private static final short _LSIGN = (short)32768L;
    /**
     * {@snippet lang=c :
     * #define _LSIGN 32768
     * }
     */
    public static short _LSIGN() {
        return _LSIGN;
    }
    private static final int _DHUGE_EXP = (int)1842L;
    /**
     * {@snippet lang=c :
     * #define _DHUGE_EXP 1842
     * }
     */
    public static int _DHUGE_EXP() {
        return _DHUGE_EXP;
    }
    private static final int _FHUGE_EXP = (int)229L;
    /**
     * {@snippet lang=c :
     * #define _FHUGE_EXP 229
     * }
     */
    public static int _FHUGE_EXP() {
        return _FHUGE_EXP;
    }
    private static final int _LHUGE_EXP = (int)29490L;
    /**
     * {@snippet lang=c :
     * #define _LHUGE_EXP 29490
     * }
     */
    public static int _LHUGE_EXP() {
        return _LHUGE_EXP;
    }
    private static final int DOMAIN = (int)1L;
    /**
     * {@snippet lang=c :
     * #define DOMAIN 1
     * }
     */
    public static int DOMAIN() {
        return DOMAIN;
    }
    private static final int SING = (int)2L;
    /**
     * {@snippet lang=c :
     * #define SING 2
     * }
     */
    public static int SING() {
        return SING;
    }
    private static final int OVERFLOW = (int)3L;
    /**
     * {@snippet lang=c :
     * #define OVERFLOW 3
     * }
     */
    public static int OVERFLOW() {
        return OVERFLOW;
    }
    private static final int UNDERFLOW = (int)4L;
    /**
     * {@snippet lang=c :
     * #define UNDERFLOW 4
     * }
     */
    public static int UNDERFLOW() {
        return UNDERFLOW;
    }
    private static final int TLOSS = (int)5L;
    /**
     * {@snippet lang=c :
     * #define TLOSS 5
     * }
     */
    public static int TLOSS() {
        return TLOSS;
    }
    private static final int PLOSS = (int)6L;
    /**
     * {@snippet lang=c :
     * #define PLOSS 6
     * }
     */
    public static int PLOSS() {
        return PLOSS;
    }
    private static final int CLOCKS_PER_SEC = (int)1000L;
    /**
     * {@snippet lang=c :
     * #define CLOCKS_PER_SEC 1000
     * }
     */
    public static int CLOCKS_PER_SEC() {
        return CLOCKS_PER_SEC;
    }
    private static final int CLK_TCK = (int)1000L;
    /**
     * {@snippet lang=c :
     * #define CLK_TCK 1000
     * }
     */
    public static int CLK_TCK() {
        return CLK_TCK;
    }
    private static final int PY_DWORD_MAX = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define PY_DWORD_MAX 4294967295
     * }
     */
    public static int PY_DWORD_MAX() {
        return PY_DWORD_MAX;
    }
    private static final double Py_MATH_PIl = 3.141592653589793d;
    /**
     * {@snippet lang=c :
     * #define Py_MATH_PIl 3.141592653589793
     * }
     */
    public static double Py_MATH_PIl() {
        return Py_MATH_PIl;
    }
    private static final double Py_MATH_PI = 3.141592653589793d;
    /**
     * {@snippet lang=c :
     * #define Py_MATH_PI 3.141592653589793
     * }
     */
    public static double Py_MATH_PI() {
        return Py_MATH_PI;
    }
    private static final double Py_MATH_El = 2.718281828459045d;
    /**
     * {@snippet lang=c :
     * #define Py_MATH_El 2.718281828459045
     * }
     */
    public static double Py_MATH_El() {
        return Py_MATH_El;
    }
    private static final double Py_MATH_E = 2.718281828459045d;
    /**
     * {@snippet lang=c :
     * #define Py_MATH_E 2.718281828459045
     * }
     */
    public static double Py_MATH_E() {
        return Py_MATH_E;
    }
    private static final double Py_MATH_TAU = 6.283185307179586d;
    /**
     * {@snippet lang=c :
     * #define Py_MATH_TAU 6.283185307179586
     * }
     */
    public static double Py_MATH_TAU() {
        return Py_MATH_TAU;
    }
    private static final double Py_INFINITY = Double.valueOf("Infinity");
    /**
     * {@snippet lang=c :
     * #define Py_INFINITY Infinity
     * }
     */
    public static double Py_INFINITY() {
        return Py_INFINITY;
    }
    private static final double Py_HUGE_VAL = Double.valueOf("Infinity");
    /**
     * {@snippet lang=c :
     * #define Py_HUGE_VAL Infinity
     * }
     */
    public static double Py_HUGE_VAL() {
        return Py_HUGE_VAL;
    }
    private static final double Py_NAN = Double.valueOf("NaN");
    /**
     * {@snippet lang=c :
     * #define Py_NAN NaN
     * }
     */
    public static double Py_NAN() {
        return Py_NAN;
    }
    private static final int PyBUF_STRIDES = (int)24L;
    /**
     * {@snippet lang=c :
     * #define PyBUF_STRIDES 24
     * }
     */
    public static int PyBUF_STRIDES() {
        return PyBUF_STRIDES;
    }
    private static final int PyBUF_C_CONTIGUOUS = (int)56L;
    /**
     * {@snippet lang=c :
     * #define PyBUF_C_CONTIGUOUS 56
     * }
     */
    public static int PyBUF_C_CONTIGUOUS() {
        return PyBUF_C_CONTIGUOUS;
    }
    private static final int PyBUF_F_CONTIGUOUS = (int)88L;
    /**
     * {@snippet lang=c :
     * #define PyBUF_F_CONTIGUOUS 88
     * }
     */
    public static int PyBUF_F_CONTIGUOUS() {
        return PyBUF_F_CONTIGUOUS;
    }
    private static final int PyBUF_ANY_CONTIGUOUS = (int)152L;
    /**
     * {@snippet lang=c :
     * #define PyBUF_ANY_CONTIGUOUS 152
     * }
     */
    public static int PyBUF_ANY_CONTIGUOUS() {
        return PyBUF_ANY_CONTIGUOUS;
    }
    private static final int PyBUF_INDIRECT = (int)280L;
    /**
     * {@snippet lang=c :
     * #define PyBUF_INDIRECT 280
     * }
     */
    public static int PyBUF_INDIRECT() {
        return PyBUF_INDIRECT;
    }
    private static final int PyBUF_CONTIG = (int)9L;
    /**
     * {@snippet lang=c :
     * #define PyBUF_CONTIG 9
     * }
     */
    public static int PyBUF_CONTIG() {
        return PyBUF_CONTIG;
    }
    private static final int PyBUF_CONTIG_RO = (int)8L;
    /**
     * {@snippet lang=c :
     * #define PyBUF_CONTIG_RO 8
     * }
     */
    public static int PyBUF_CONTIG_RO() {
        return PyBUF_CONTIG_RO;
    }
    private static final int PyBUF_STRIDED = (int)25L;
    /**
     * {@snippet lang=c :
     * #define PyBUF_STRIDED 25
     * }
     */
    public static int PyBUF_STRIDED() {
        return PyBUF_STRIDED;
    }
    private static final int PyBUF_STRIDED_RO = (int)24L;
    /**
     * {@snippet lang=c :
     * #define PyBUF_STRIDED_RO 24
     * }
     */
    public static int PyBUF_STRIDED_RO() {
        return PyBUF_STRIDED_RO;
    }
    private static final int PyBUF_RECORDS = (int)29L;
    /**
     * {@snippet lang=c :
     * #define PyBUF_RECORDS 29
     * }
     */
    public static int PyBUF_RECORDS() {
        return PyBUF_RECORDS;
    }
    private static final int PyBUF_RECORDS_RO = (int)28L;
    /**
     * {@snippet lang=c :
     * #define PyBUF_RECORDS_RO 28
     * }
     */
    public static int PyBUF_RECORDS_RO() {
        return PyBUF_RECORDS_RO;
    }
    private static final int PyBUF_FULL = (int)285L;
    /**
     * {@snippet lang=c :
     * #define PyBUF_FULL 285
     * }
     */
    public static int PyBUF_FULL() {
        return PyBUF_FULL;
    }
    private static final int PyBUF_FULL_RO = (int)284L;
    /**
     * {@snippet lang=c :
     * #define PyBUF_FULL_RO 284
     * }
     */
    public static int PyBUF_FULL_RO() {
        return PyBUF_FULL_RO;
    }
    private static final int _Py_IMMORTAL_REFCNT = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define _Py_IMMORTAL_REFCNT 4294967295
     * }
     */
    public static int _Py_IMMORTAL_REFCNT() {
        return _Py_IMMORTAL_REFCNT;
    }
    private static final long Py_INVALID_SIZE = -1L;
    /**
     * {@snippet lang=c :
     * #define Py_INVALID_SIZE -1
     * }
     */
    public static long Py_INVALID_SIZE() {
        return Py_INVALID_SIZE;
    }
    private static final int Py_TPFLAGS_DISALLOW_INSTANTIATION = (int)128L;
    /**
     * {@snippet lang=c :
     * #define Py_TPFLAGS_DISALLOW_INSTANTIATION 128
     * }
     */
    public static int Py_TPFLAGS_DISALLOW_INSTANTIATION() {
        return Py_TPFLAGS_DISALLOW_INSTANTIATION;
    }
    private static final int Py_TPFLAGS_IMMUTABLETYPE = (int)256L;
    /**
     * {@snippet lang=c :
     * #define Py_TPFLAGS_IMMUTABLETYPE 256
     * }
     */
    public static int Py_TPFLAGS_IMMUTABLETYPE() {
        return Py_TPFLAGS_IMMUTABLETYPE;
    }
    private static final int Py_TPFLAGS_HEAPTYPE = (int)512L;
    /**
     * {@snippet lang=c :
     * #define Py_TPFLAGS_HEAPTYPE 512
     * }
     */
    public static int Py_TPFLAGS_HEAPTYPE() {
        return Py_TPFLAGS_HEAPTYPE;
    }
    private static final int Py_TPFLAGS_BASETYPE = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define Py_TPFLAGS_BASETYPE 1024
     * }
     */
    public static int Py_TPFLAGS_BASETYPE() {
        return Py_TPFLAGS_BASETYPE;
    }
    private static final int Py_TPFLAGS_HAVE_VECTORCALL = (int)2048L;
    /**
     * {@snippet lang=c :
     * #define Py_TPFLAGS_HAVE_VECTORCALL 2048
     * }
     */
    public static int Py_TPFLAGS_HAVE_VECTORCALL() {
        return Py_TPFLAGS_HAVE_VECTORCALL;
    }
    private static final int Py_TPFLAGS_READY = (int)4096L;
    /**
     * {@snippet lang=c :
     * #define Py_TPFLAGS_READY 4096
     * }
     */
    public static int Py_TPFLAGS_READY() {
        return Py_TPFLAGS_READY;
    }
    private static final int Py_TPFLAGS_READYING = (int)8192L;
    /**
     * {@snippet lang=c :
     * #define Py_TPFLAGS_READYING 8192
     * }
     */
    public static int Py_TPFLAGS_READYING() {
        return Py_TPFLAGS_READYING;
    }
    private static final int Py_TPFLAGS_HAVE_GC = (int)16384L;
    /**
     * {@snippet lang=c :
     * #define Py_TPFLAGS_HAVE_GC 16384
     * }
     */
    public static int Py_TPFLAGS_HAVE_GC() {
        return Py_TPFLAGS_HAVE_GC;
    }
    private static final int Py_TPFLAGS_METHOD_DESCRIPTOR = (int)131072L;
    /**
     * {@snippet lang=c :
     * #define Py_TPFLAGS_METHOD_DESCRIPTOR 131072
     * }
     */
    public static int Py_TPFLAGS_METHOD_DESCRIPTOR() {
        return Py_TPFLAGS_METHOD_DESCRIPTOR;
    }
    private static final int Py_TPFLAGS_VALID_VERSION_TAG = (int)524288L;
    /**
     * {@snippet lang=c :
     * #define Py_TPFLAGS_VALID_VERSION_TAG 524288
     * }
     */
    public static int Py_TPFLAGS_VALID_VERSION_TAG() {
        return Py_TPFLAGS_VALID_VERSION_TAG;
    }
    private static final int Py_TPFLAGS_IS_ABSTRACT = (int)1048576L;
    /**
     * {@snippet lang=c :
     * #define Py_TPFLAGS_IS_ABSTRACT 1048576
     * }
     */
    public static int Py_TPFLAGS_IS_ABSTRACT() {
        return Py_TPFLAGS_IS_ABSTRACT;
    }
    private static final int _Py_TPFLAGS_MATCH_SELF = (int)4194304L;
    /**
     * {@snippet lang=c :
     * #define _Py_TPFLAGS_MATCH_SELF 4194304
     * }
     */
    public static int _Py_TPFLAGS_MATCH_SELF() {
        return _Py_TPFLAGS_MATCH_SELF;
    }
    private static final int Py_TPFLAGS_ITEMS_AT_END = (int)8388608L;
    /**
     * {@snippet lang=c :
     * #define Py_TPFLAGS_ITEMS_AT_END 8388608
     * }
     */
    public static int Py_TPFLAGS_ITEMS_AT_END() {
        return Py_TPFLAGS_ITEMS_AT_END;
    }
    private static final int Py_TPFLAGS_LONG_SUBCLASS = (int)16777216L;
    /**
     * {@snippet lang=c :
     * #define Py_TPFLAGS_LONG_SUBCLASS 16777216
     * }
     */
    public static int Py_TPFLAGS_LONG_SUBCLASS() {
        return Py_TPFLAGS_LONG_SUBCLASS;
    }
    private static final int Py_TPFLAGS_LIST_SUBCLASS = (int)33554432L;
    /**
     * {@snippet lang=c :
     * #define Py_TPFLAGS_LIST_SUBCLASS 33554432
     * }
     */
    public static int Py_TPFLAGS_LIST_SUBCLASS() {
        return Py_TPFLAGS_LIST_SUBCLASS;
    }
    private static final int Py_TPFLAGS_TUPLE_SUBCLASS = (int)67108864L;
    /**
     * {@snippet lang=c :
     * #define Py_TPFLAGS_TUPLE_SUBCLASS 67108864
     * }
     */
    public static int Py_TPFLAGS_TUPLE_SUBCLASS() {
        return Py_TPFLAGS_TUPLE_SUBCLASS;
    }
    private static final int Py_TPFLAGS_BYTES_SUBCLASS = (int)134217728L;
    /**
     * {@snippet lang=c :
     * #define Py_TPFLAGS_BYTES_SUBCLASS 134217728
     * }
     */
    public static int Py_TPFLAGS_BYTES_SUBCLASS() {
        return Py_TPFLAGS_BYTES_SUBCLASS;
    }
    private static final int Py_TPFLAGS_UNICODE_SUBCLASS = (int)268435456L;
    /**
     * {@snippet lang=c :
     * #define Py_TPFLAGS_UNICODE_SUBCLASS 268435456
     * }
     */
    public static int Py_TPFLAGS_UNICODE_SUBCLASS() {
        return Py_TPFLAGS_UNICODE_SUBCLASS;
    }
    private static final int Py_TPFLAGS_DICT_SUBCLASS = (int)536870912L;
    /**
     * {@snippet lang=c :
     * #define Py_TPFLAGS_DICT_SUBCLASS 536870912
     * }
     */
    public static int Py_TPFLAGS_DICT_SUBCLASS() {
        return Py_TPFLAGS_DICT_SUBCLASS;
    }
    private static final int Py_TPFLAGS_BASE_EXC_SUBCLASS = (int)1073741824L;
    /**
     * {@snippet lang=c :
     * #define Py_TPFLAGS_BASE_EXC_SUBCLASS 1073741824
     * }
     */
    public static int Py_TPFLAGS_BASE_EXC_SUBCLASS() {
        return Py_TPFLAGS_BASE_EXC_SUBCLASS;
    }
    private static final int Py_TPFLAGS_TYPE_SUBCLASS = (int)2147483648L;
    /**
     * {@snippet lang=c :
     * #define Py_TPFLAGS_TYPE_SUBCLASS 2147483648
     * }
     */
    public static int Py_TPFLAGS_TYPE_SUBCLASS() {
        return Py_TPFLAGS_TYPE_SUBCLASS;
    }
    private static final int Py_TPFLAGS_DEFAULT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define Py_TPFLAGS_DEFAULT 0
     * }
     */
    public static int Py_TPFLAGS_DEFAULT() {
        return Py_TPFLAGS_DEFAULT;
    }
    private static final int Py_TPFLAGS_HAVE_FINALIZE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define Py_TPFLAGS_HAVE_FINALIZE 1
     * }
     */
    public static int Py_TPFLAGS_HAVE_FINALIZE() {
        return Py_TPFLAGS_HAVE_FINALIZE;
    }
    private static final int Py_TPFLAGS_HAVE_VERSION_TAG = (int)262144L;
    /**
     * {@snippet lang=c :
     * #define Py_TPFLAGS_HAVE_VERSION_TAG 262144
     * }
     */
    public static int Py_TPFLAGS_HAVE_VERSION_TAG() {
        return Py_TPFLAGS_HAVE_VERSION_TAG;
    }
    private static final int _PyHASH_MULTIPLIER = (int)1000003L;
    /**
     * {@snippet lang=c :
     * #define _PyHASH_MULTIPLIER 1000003
     * }
     */
    public static int _PyHASH_MULTIPLIER() {
        return _PyHASH_MULTIPLIER;
    }
    private static final long _PyHASH_MODULUS = 2305843009213693951L;
    /**
     * {@snippet lang=c :
     * #define _PyHASH_MODULUS 2305843009213693951
     * }
     */
    public static long _PyHASH_MODULUS() {
        return _PyHASH_MODULUS;
    }
    private static final int _PyHASH_IMAG = (int)1000003L;
    /**
     * {@snippet lang=c :
     * #define _PyHASH_IMAG 1000003
     * }
     */
    public static int _PyHASH_IMAG() {
        return _PyHASH_IMAG;
    }
    private static final int Py_HASH_ALGORITHM = (int)3L;
    /**
     * {@snippet lang=c :
     * #define Py_HASH_ALGORITHM 3
     * }
     */
    public static int Py_HASH_ALGORITHM() {
        return Py_HASH_ALGORITHM;
    }
    private static final int Py_UNICODE_SIZE = (int)2L;
    /**
     * {@snippet lang=c :
     * #define Py_UNICODE_SIZE 2
     * }
     */
    public static int Py_UNICODE_SIZE() {
        return Py_UNICODE_SIZE;
    }
    private static final int Py_UNICODE_REPLACEMENT_CHARACTER = (int)65533L;
    /**
     * {@snippet lang=c :
     * #define Py_UNICODE_REPLACEMENT_CHARACTER 65533
     * }
     */
    public static int Py_UNICODE_REPLACEMENT_CHARACTER() {
        return Py_UNICODE_REPLACEMENT_CHARACTER;
    }
    /**
     * {@snippet lang=c :
     * #define _Py_PARSE_PID "i"
     * }
     */
    public static MemorySegment _Py_PARSE_PID() {
        class Holder {
            static final MemorySegment _Py_PARSE_PID
                = Python_h.LIBRARY_ARENA.allocateFrom("i");
        }
        return Holder._Py_PARSE_PID;
    }
    /**
     * {@snippet lang=c :
     * #define _Py_PARSE_INTPTR "L"
     * }
     */
    public static MemorySegment _Py_PARSE_INTPTR() {
        class Holder {
            static final MemorySegment _Py_PARSE_INTPTR
                = Python_h.LIBRARY_ARENA.allocateFrom("L");
        }
        return Holder._Py_PARSE_INTPTR;
    }
    /**
     * {@snippet lang=c :
     * #define _Py_PARSE_UINTPTR "K"
     * }
     */
    public static MemorySegment _Py_PARSE_UINTPTR() {
        class Holder {
            static final MemorySegment _Py_PARSE_UINTPTR
                = Python_h.LIBRARY_ARENA.allocateFrom("K");
        }
        return Holder._Py_PARSE_UINTPTR;
    }
    private static final MemorySegment Py_MOD_MULTIPLE_INTERPRETERS_NOT_SUPPORTED = MemorySegment.ofAddress(0L);
    /**
     * {@snippet lang=c :
     * #define Py_MOD_MULTIPLE_INTERPRETERS_NOT_SUPPORTED (void*) 0
     * }
     */
    public static MemorySegment Py_MOD_MULTIPLE_INTERPRETERS_NOT_SUPPORTED() {
        return Py_MOD_MULTIPLE_INTERPRETERS_NOT_SUPPORTED;
    }
    private static final MemorySegment Py_MOD_MULTIPLE_INTERPRETERS_SUPPORTED = MemorySegment.ofAddress(1L);
    /**
     * {@snippet lang=c :
     * #define Py_MOD_MULTIPLE_INTERPRETERS_SUPPORTED (void*) 1
     * }
     */
    public static MemorySegment Py_MOD_MULTIPLE_INTERPRETERS_SUPPORTED() {
        return Py_MOD_MULTIPLE_INTERPRETERS_SUPPORTED;
    }
    private static final MemorySegment Py_MOD_PER_INTERPRETER_GIL_SUPPORTED = MemorySegment.ofAddress(2L);
    /**
     * {@snippet lang=c :
     * #define Py_MOD_PER_INTERPRETER_GIL_SUPPORTED (void*) 2
     * }
     */
    public static MemorySegment Py_MOD_PER_INTERPRETER_GIL_SUPPORTED() {
        return Py_MOD_PER_INTERPRETER_GIL_SUPPORTED;
    }
    /**
     * {@snippet lang=c :
     * #define PY_STDIOTEXTMODE "b"
     * }
     */
    public static MemorySegment PY_STDIOTEXTMODE() {
        class Holder {
            static final MemorySegment PY_STDIOTEXTMODE
                = Python_h.LIBRARY_ARENA.allocateFrom("b");
        }
        return Holder.PY_STDIOTEXTMODE;
    }
    private static final long PY_TIMEOUT_MAX = 4294967294000L;
    /**
     * {@snippet lang=c :
     * #define PY_TIMEOUT_MAX 4294967294000
     * }
     */
    public static long PY_TIMEOUT_MAX() {
        return PY_TIMEOUT_MAX;
    }
    /**
     * {@snippet lang=c :
     * #define PYTHON_API_STRING "1013"
     * }
     */
    public static MemorySegment PYTHON_API_STRING() {
        class Holder {
            static final MemorySegment PYTHON_API_STRING
                = Python_h.LIBRARY_ARENA.allocateFrom("1013");
        }
        return Holder.PYTHON_API_STRING;
    }
    /**
     * {@snippet lang=c :
     * #define PYTHON_ABI_STRING "3"
     * }
     */
    public static MemorySegment PYTHON_ABI_STRING() {
        class Holder {
            static final MemorySegment PYTHON_ABI_STRING
                = Python_h.LIBRARY_ARENA.allocateFrom("3");
        }
        return Holder.PYTHON_ABI_STRING;
    }
    private static final long PY_VECTORCALL_ARGUMENTS_OFFSET = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define PY_VECTORCALL_ARGUMENTS_OFFSET -9223372036854775808
     * }
     */
    public static long PY_VECTORCALL_ARGUMENTS_OFFSET() {
        return PY_VECTORCALL_ARGUMENTS_OFFSET;
    }
}

