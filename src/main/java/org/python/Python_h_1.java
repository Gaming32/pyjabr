// Generated by jextract

package org.python;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

public class Python_h_1 extends Python_h_2 {

    Python_h_1() {
        // Should not be called directly
    }
    /**
     * {@snippet lang=c :
     * typedef unsigned int uint32_t
     * }
     */
    public static final OfInt uint32_t = Python_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long long uint64_t
     * }
     */
    public static final OfLong uint64_t = Python_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef signed char int_least8_t
     * }
     */
    public static final OfByte int_least8_t = Python_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef short int_least16_t
     * }
     */
    public static final OfShort int_least16_t = Python_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef int int_least32_t
     * }
     */
    public static final OfInt int_least32_t = Python_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long long int_least64_t
     * }
     */
    public static final OfLong int_least64_t = Python_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned char uint_least8_t
     * }
     */
    public static final OfByte uint_least8_t = Python_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned short uint_least16_t
     * }
     */
    public static final OfShort uint_least16_t = Python_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int uint_least32_t
     * }
     */
    public static final OfInt uint_least32_t = Python_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long long uint_least64_t
     * }
     */
    public static final OfLong uint_least64_t = Python_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef signed char int_fast8_t
     * }
     */
    public static final OfByte int_fast8_t = Python_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef int int_fast16_t
     * }
     */
    public static final OfInt int_fast16_t = Python_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int int_fast32_t
     * }
     */
    public static final OfInt int_fast32_t = Python_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long long int_fast64_t
     * }
     */
    public static final OfLong int_fast64_t = Python_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned char uint_fast8_t
     * }
     */
    public static final OfByte uint_fast8_t = Python_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned int uint_fast16_t
     * }
     */
    public static final OfInt uint_fast16_t = Python_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int uint_fast32_t
     * }
     */
    public static final OfInt uint_fast32_t = Python_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long long uint_fast64_t
     * }
     */
    public static final OfLong uint_fast64_t = Python_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef long long intmax_t
     * }
     */
    public static final OfLong intmax_t = Python_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long long uintmax_t
     * }
     */
    public static final OfLong uintmax_t = Python_h.C_LONG_LONG;

    private static class imaxabs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("imaxabs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * intmax_t imaxabs(intmax_t _Number)
     * }
     */
    public static FunctionDescriptor imaxabs$descriptor() {
        return imaxabs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * intmax_t imaxabs(intmax_t _Number)
     * }
     */
    public static MethodHandle imaxabs$handle() {
        return imaxabs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * intmax_t imaxabs(intmax_t _Number)
     * }
     */
    public static MemorySegment imaxabs$address() {
        return imaxabs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * intmax_t imaxabs(intmax_t _Number)
     * }
     */
    public static long imaxabs(long _Number) {
        var mh$ = imaxabs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("imaxabs", _Number);
            }
            return (long)mh$.invokeExact(_Number);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class imaxdiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            _Lldiv_t.layout(),
            Python_h.C_LONG_LONG,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("imaxdiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * imaxdiv_t imaxdiv(intmax_t _Numerator, intmax_t _Denominator)
     * }
     */
    public static FunctionDescriptor imaxdiv$descriptor() {
        return imaxdiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * imaxdiv_t imaxdiv(intmax_t _Numerator, intmax_t _Denominator)
     * }
     */
    public static MethodHandle imaxdiv$handle() {
        return imaxdiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * imaxdiv_t imaxdiv(intmax_t _Numerator, intmax_t _Denominator)
     * }
     */
    public static MemorySegment imaxdiv$address() {
        return imaxdiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * imaxdiv_t imaxdiv(intmax_t _Numerator, intmax_t _Denominator)
     * }
     */
    public static MemorySegment imaxdiv(SegmentAllocator allocator, long _Numerator, long _Denominator) {
        var mh$ = imaxdiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("imaxdiv", allocator, _Numerator, _Denominator);
            }
            return (MemorySegment)mh$.invokeExact(allocator, _Numerator, _Denominator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtoimax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("strtoimax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * intmax_t strtoimax(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static FunctionDescriptor strtoimax$descriptor() {
        return strtoimax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * intmax_t strtoimax(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static MethodHandle strtoimax$handle() {
        return strtoimax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * intmax_t strtoimax(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static MemorySegment strtoimax$address() {
        return strtoimax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * intmax_t strtoimax(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static long strtoimax(MemorySegment _String, MemorySegment _EndPtr, int _Radix) {
        var mh$ = strtoimax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtoimax", _String, _EndPtr, _Radix);
            }
            return (long)mh$.invokeExact(_String, _EndPtr, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strtoimax_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_strtoimax_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * intmax_t _strtoimax_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _strtoimax_l$descriptor() {
        return _strtoimax_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * intmax_t _strtoimax_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MethodHandle _strtoimax_l$handle() {
        return _strtoimax_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * intmax_t _strtoimax_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MemorySegment _strtoimax_l$address() {
        return _strtoimax_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * intmax_t _strtoimax_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static long _strtoimax_l(MemorySegment _String, MemorySegment _EndPtr, int _Radix, MemorySegment _Locale) {
        var mh$ = _strtoimax_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strtoimax_l", _String, _EndPtr, _Radix, _Locale);
            }
            return (long)mh$.invokeExact(_String, _EndPtr, _Radix, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtoumax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("strtoumax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uintmax_t strtoumax(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static FunctionDescriptor strtoumax$descriptor() {
        return strtoumax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uintmax_t strtoumax(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static MethodHandle strtoumax$handle() {
        return strtoumax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uintmax_t strtoumax(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static MemorySegment strtoumax$address() {
        return strtoumax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uintmax_t strtoumax(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static long strtoumax(MemorySegment _String, MemorySegment _EndPtr, int _Radix) {
        var mh$ = strtoumax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtoumax", _String, _EndPtr, _Radix);
            }
            return (long)mh$.invokeExact(_String, _EndPtr, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strtoumax_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_strtoumax_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uintmax_t _strtoumax_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _strtoumax_l$descriptor() {
        return _strtoumax_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uintmax_t _strtoumax_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MethodHandle _strtoumax_l$handle() {
        return _strtoumax_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uintmax_t _strtoumax_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MemorySegment _strtoumax_l$address() {
        return _strtoumax_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uintmax_t _strtoumax_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static long _strtoumax_l(MemorySegment _String, MemorySegment _EndPtr, int _Radix, MemorySegment _Locale) {
        var mh$ = _strtoumax_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strtoumax_l", _String, _EndPtr, _Radix, _Locale);
            }
            return (long)mh$.invokeExact(_String, _EndPtr, _Radix, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcstoimax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcstoimax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * intmax_t wcstoimax(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static FunctionDescriptor wcstoimax$descriptor() {
        return wcstoimax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * intmax_t wcstoimax(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static MethodHandle wcstoimax$handle() {
        return wcstoimax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * intmax_t wcstoimax(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static MemorySegment wcstoimax$address() {
        return wcstoimax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * intmax_t wcstoimax(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static long wcstoimax(MemorySegment _String, MemorySegment _EndPtr, int _Radix) {
        var mh$ = wcstoimax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcstoimax", _String, _EndPtr, _Radix);
            }
            return (long)mh$.invokeExact(_String, _EndPtr, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcstoimax_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wcstoimax_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * intmax_t _wcstoimax_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcstoimax_l$descriptor() {
        return _wcstoimax_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * intmax_t _wcstoimax_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcstoimax_l$handle() {
        return _wcstoimax_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * intmax_t _wcstoimax_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcstoimax_l$address() {
        return _wcstoimax_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * intmax_t _wcstoimax_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static long _wcstoimax_l(MemorySegment _String, MemorySegment _EndPtr, int _Radix, MemorySegment _Locale) {
        var mh$ = _wcstoimax_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcstoimax_l", _String, _EndPtr, _Radix, _Locale);
            }
            return (long)mh$.invokeExact(_String, _EndPtr, _Radix, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcstoumax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcstoumax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uintmax_t wcstoumax(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static FunctionDescriptor wcstoumax$descriptor() {
        return wcstoumax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uintmax_t wcstoumax(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static MethodHandle wcstoumax$handle() {
        return wcstoumax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uintmax_t wcstoumax(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static MemorySegment wcstoumax$address() {
        return wcstoumax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uintmax_t wcstoumax(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static long wcstoumax(MemorySegment _String, MemorySegment _EndPtr, int _Radix) {
        var mh$ = wcstoumax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcstoumax", _String, _EndPtr, _Radix);
            }
            return (long)mh$.invokeExact(_String, _EndPtr, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcstoumax_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wcstoumax_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uintmax_t _wcstoumax_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcstoumax_l$descriptor() {
        return _wcstoumax_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uintmax_t _wcstoumax_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcstoumax_l$handle() {
        return _wcstoumax_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uintmax_t _wcstoumax_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcstoumax_l$address() {
        return _wcstoumax_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uintmax_t _wcstoumax_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static long _wcstoumax_l(MemorySegment _String, MemorySegment _EndPtr, int _Radix, MemorySegment _Locale) {
        var mh$ = _wcstoumax_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcstoumax_l", _String, _EndPtr, _Radix, _Locale);
            }
            return (long)mh$.invokeExact(_String, _EndPtr, _Radix, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef uintptr_t Py_uintptr_t
     * }
     */
    public static final OfLong Py_uintptr_t = Python_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef intptr_t Py_intptr_t
     * }
     */
    public static final OfLong Py_intptr_t = Python_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef Py_ssize_t Py_hash_t
     * }
     */
    public static final OfLong Py_hash_t = Python_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef size_t Py_uhash_t
     * }
     */
    public static final OfLong Py_uhash_t = Python_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef Py_ssize_t Py_ssize_clean_t
     * }
     */
    public static final OfLong Py_ssize_clean_t = Python_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef float float_t
     * }
     */
    public static final OfFloat float_t = Python_h.C_FLOAT;
    /**
     * {@snippet lang=c :
     * typedef double double_t
     * }
     */
    public static final OfDouble double_t = Python_h.C_DOUBLE;

    private static class _HUGE$constants {
        public static final OfDouble LAYOUT = Python_h.C_DOUBLE;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("_HUGE").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const double _HUGE
     * }
     */
    public static OfDouble _HUGE$layout() {
        return _HUGE$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const double _HUGE
     * }
     */
    public static MemorySegment _HUGE$segment() {
        return _HUGE$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const double _HUGE
     * }
     */
    public static double _HUGE() {
        return _HUGE$constants.SEGMENT.get(_HUGE$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const double _HUGE
     * }
     */
    public static void _HUGE(double varValue) {
        _HUGE$constants.SEGMENT.set(_HUGE$constants.LAYOUT, 0L, varValue);
    }

    private static class _fperrraise {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_fperrraise");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _fperrraise(int _Except)
     * }
     */
    public static FunctionDescriptor _fperrraise$descriptor() {
        return _fperrraise.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _fperrraise(int _Except)
     * }
     */
    public static MethodHandle _fperrraise$handle() {
        return _fperrraise.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _fperrraise(int _Except)
     * }
     */
    public static MemorySegment _fperrraise$address() {
        return _fperrraise.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _fperrraise(int _Except)
     * }
     */
    public static void _fperrraise(int _Except) {
        var mh$ = _fperrraise.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fperrraise", _Except);
            }
            mh$.invokeExact(_Except);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _dclass {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_SHORT,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_dclass");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * short _dclass(double _X)
     * }
     */
    public static FunctionDescriptor _dclass$descriptor() {
        return _dclass.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * short _dclass(double _X)
     * }
     */
    public static MethodHandle _dclass$handle() {
        return _dclass.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * short _dclass(double _X)
     * }
     */
    public static MemorySegment _dclass$address() {
        return _dclass.ADDR;
    }

    /**
     * {@snippet lang=c :
     * short _dclass(double _X)
     * }
     */
    public static short _dclass(double _X) {
        var mh$ = _dclass.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_dclass", _X);
            }
            return (short)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ldclass {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_SHORT,
            Python_h.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_ldclass");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * short _ldclass(long double _X)
     * }
     */
    public static FunctionDescriptor _ldclass$descriptor() {
        return _ldclass.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * short _ldclass(long double _X)
     * }
     */
    public static MethodHandle _ldclass$handle() {
        return _ldclass.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * short _ldclass(long double _X)
     * }
     */
    public static MemorySegment _ldclass$address() {
        return _ldclass.ADDR;
    }

    /**
     * {@snippet lang=c :
     * short _ldclass(long double _X)
     * }
     */
    public static short _ldclass(double _X) {
        var mh$ = _ldclass.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ldclass", _X);
            }
            return (short)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fdclass {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_SHORT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_fdclass");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * short _fdclass(float _X)
     * }
     */
    public static FunctionDescriptor _fdclass$descriptor() {
        return _fdclass.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * short _fdclass(float _X)
     * }
     */
    public static MethodHandle _fdclass$handle() {
        return _fdclass.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * short _fdclass(float _X)
     * }
     */
    public static MemorySegment _fdclass$address() {
        return _fdclass.ADDR;
    }

    /**
     * {@snippet lang=c :
     * short _fdclass(float _X)
     * }
     */
    public static short _fdclass(float _X) {
        var mh$ = _fdclass.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fdclass", _X);
            }
            return (short)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _dsign {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_dsign");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _dsign(double _X)
     * }
     */
    public static FunctionDescriptor _dsign$descriptor() {
        return _dsign.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _dsign(double _X)
     * }
     */
    public static MethodHandle _dsign$handle() {
        return _dsign.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _dsign(double _X)
     * }
     */
    public static MemorySegment _dsign$address() {
        return _dsign.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _dsign(double _X)
     * }
     */
    public static int _dsign(double _X) {
        var mh$ = _dsign.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_dsign", _X);
            }
            return (int)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ldsign {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_ldsign");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _ldsign(long double _X)
     * }
     */
    public static FunctionDescriptor _ldsign$descriptor() {
        return _ldsign.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _ldsign(long double _X)
     * }
     */
    public static MethodHandle _ldsign$handle() {
        return _ldsign.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _ldsign(long double _X)
     * }
     */
    public static MemorySegment _ldsign$address() {
        return _ldsign.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _ldsign(long double _X)
     * }
     */
    public static int _ldsign(double _X) {
        var mh$ = _ldsign.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ldsign", _X);
            }
            return (int)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fdsign {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_fdsign");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _fdsign(float _X)
     * }
     */
    public static FunctionDescriptor _fdsign$descriptor() {
        return _fdsign.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _fdsign(float _X)
     * }
     */
    public static MethodHandle _fdsign$handle() {
        return _fdsign.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _fdsign(float _X)
     * }
     */
    public static MemorySegment _fdsign$address() {
        return _fdsign.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _fdsign(float _X)
     * }
     */
    public static int _fdsign(float _X) {
        var mh$ = _fdsign.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fdsign", _X);
            }
            return (int)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _dpcomp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_dpcomp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _dpcomp(double _X, double _Y)
     * }
     */
    public static FunctionDescriptor _dpcomp$descriptor() {
        return _dpcomp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _dpcomp(double _X, double _Y)
     * }
     */
    public static MethodHandle _dpcomp$handle() {
        return _dpcomp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _dpcomp(double _X, double _Y)
     * }
     */
    public static MemorySegment _dpcomp$address() {
        return _dpcomp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _dpcomp(double _X, double _Y)
     * }
     */
    public static int _dpcomp(double _X, double _Y) {
        var mh$ = _dpcomp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_dpcomp", _X, _Y);
            }
            return (int)mh$.invokeExact(_X, _Y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ldpcomp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_LONG_DOUBLE,
            Python_h.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_ldpcomp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _ldpcomp(long double _X, long double _Y)
     * }
     */
    public static FunctionDescriptor _ldpcomp$descriptor() {
        return _ldpcomp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _ldpcomp(long double _X, long double _Y)
     * }
     */
    public static MethodHandle _ldpcomp$handle() {
        return _ldpcomp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _ldpcomp(long double _X, long double _Y)
     * }
     */
    public static MemorySegment _ldpcomp$address() {
        return _ldpcomp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _ldpcomp(long double _X, long double _Y)
     * }
     */
    public static int _ldpcomp(double _X, double _Y) {
        var mh$ = _ldpcomp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ldpcomp", _X, _Y);
            }
            return (int)mh$.invokeExact(_X, _Y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fdpcomp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_fdpcomp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _fdpcomp(float _X, float _Y)
     * }
     */
    public static FunctionDescriptor _fdpcomp$descriptor() {
        return _fdpcomp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _fdpcomp(float _X, float _Y)
     * }
     */
    public static MethodHandle _fdpcomp$handle() {
        return _fdpcomp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _fdpcomp(float _X, float _Y)
     * }
     */
    public static MemorySegment _fdpcomp$address() {
        return _fdpcomp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _fdpcomp(float _X, float _Y)
     * }
     */
    public static int _fdpcomp(float _X, float _Y) {
        var mh$ = _fdpcomp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fdpcomp", _X, _Y);
            }
            return (int)mh$.invokeExact(_X, _Y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _dtest {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_SHORT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_dtest");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * short _dtest(double *_Px)
     * }
     */
    public static FunctionDescriptor _dtest$descriptor() {
        return _dtest.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * short _dtest(double *_Px)
     * }
     */
    public static MethodHandle _dtest$handle() {
        return _dtest.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * short _dtest(double *_Px)
     * }
     */
    public static MemorySegment _dtest$address() {
        return _dtest.ADDR;
    }

    /**
     * {@snippet lang=c :
     * short _dtest(double *_Px)
     * }
     */
    public static short _dtest(MemorySegment _Px) {
        var mh$ = _dtest.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_dtest", _Px);
            }
            return (short)mh$.invokeExact(_Px);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ldtest {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_SHORT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_ldtest");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * short _ldtest(long double *_Px)
     * }
     */
    public static FunctionDescriptor _ldtest$descriptor() {
        return _ldtest.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * short _ldtest(long double *_Px)
     * }
     */
    public static MethodHandle _ldtest$handle() {
        return _ldtest.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * short _ldtest(long double *_Px)
     * }
     */
    public static MemorySegment _ldtest$address() {
        return _ldtest.ADDR;
    }

    /**
     * {@snippet lang=c :
     * short _ldtest(long double *_Px)
     * }
     */
    public static short _ldtest(MemorySegment _Px) {
        var mh$ = _ldtest.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ldtest", _Px);
            }
            return (short)mh$.invokeExact(_Px);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fdtest {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_SHORT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_fdtest");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * short _fdtest(float *_Px)
     * }
     */
    public static FunctionDescriptor _fdtest$descriptor() {
        return _fdtest.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * short _fdtest(float *_Px)
     * }
     */
    public static MethodHandle _fdtest$handle() {
        return _fdtest.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * short _fdtest(float *_Px)
     * }
     */
    public static MemorySegment _fdtest$address() {
        return _fdtest.ADDR;
    }

    /**
     * {@snippet lang=c :
     * short _fdtest(float *_Px)
     * }
     */
    public static short _fdtest(MemorySegment _Px) {
        var mh$ = _fdtest.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fdtest", _Px);
            }
            return (short)mh$.invokeExact(_Px);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _d_int {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_SHORT,
            Python_h.C_POINTER,
            Python_h.C_SHORT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_d_int");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * short _d_int(double *_Px, short _Xexp)
     * }
     */
    public static FunctionDescriptor _d_int$descriptor() {
        return _d_int.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * short _d_int(double *_Px, short _Xexp)
     * }
     */
    public static MethodHandle _d_int$handle() {
        return _d_int.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * short _d_int(double *_Px, short _Xexp)
     * }
     */
    public static MemorySegment _d_int$address() {
        return _d_int.ADDR;
    }

    /**
     * {@snippet lang=c :
     * short _d_int(double *_Px, short _Xexp)
     * }
     */
    public static short _d_int(MemorySegment _Px, short _Xexp) {
        var mh$ = _d_int.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_d_int", _Px, _Xexp);
            }
            return (short)mh$.invokeExact(_Px, _Xexp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ld_int {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_SHORT,
            Python_h.C_POINTER,
            Python_h.C_SHORT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_ld_int");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * short _ld_int(long double *_Px, short _Xexp)
     * }
     */
    public static FunctionDescriptor _ld_int$descriptor() {
        return _ld_int.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * short _ld_int(long double *_Px, short _Xexp)
     * }
     */
    public static MethodHandle _ld_int$handle() {
        return _ld_int.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * short _ld_int(long double *_Px, short _Xexp)
     * }
     */
    public static MemorySegment _ld_int$address() {
        return _ld_int.ADDR;
    }

    /**
     * {@snippet lang=c :
     * short _ld_int(long double *_Px, short _Xexp)
     * }
     */
    public static short _ld_int(MemorySegment _Px, short _Xexp) {
        var mh$ = _ld_int.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ld_int", _Px, _Xexp);
            }
            return (short)mh$.invokeExact(_Px, _Xexp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fd_int {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_SHORT,
            Python_h.C_POINTER,
            Python_h.C_SHORT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_fd_int");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * short _fd_int(float *_Px, short _Xexp)
     * }
     */
    public static FunctionDescriptor _fd_int$descriptor() {
        return _fd_int.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * short _fd_int(float *_Px, short _Xexp)
     * }
     */
    public static MethodHandle _fd_int$handle() {
        return _fd_int.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * short _fd_int(float *_Px, short _Xexp)
     * }
     */
    public static MemorySegment _fd_int$address() {
        return _fd_int.ADDR;
    }

    /**
     * {@snippet lang=c :
     * short _fd_int(float *_Px, short _Xexp)
     * }
     */
    public static short _fd_int(MemorySegment _Px, short _Xexp) {
        var mh$ = _fd_int.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fd_int", _Px, _Xexp);
            }
            return (short)mh$.invokeExact(_Px, _Xexp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _dscale {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_SHORT,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_dscale");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * short _dscale(double *_Px, long _Lexp)
     * }
     */
    public static FunctionDescriptor _dscale$descriptor() {
        return _dscale.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * short _dscale(double *_Px, long _Lexp)
     * }
     */
    public static MethodHandle _dscale$handle() {
        return _dscale.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * short _dscale(double *_Px, long _Lexp)
     * }
     */
    public static MemorySegment _dscale$address() {
        return _dscale.ADDR;
    }

    /**
     * {@snippet lang=c :
     * short _dscale(double *_Px, long _Lexp)
     * }
     */
    public static short _dscale(MemorySegment _Px, int _Lexp) {
        var mh$ = _dscale.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_dscale", _Px, _Lexp);
            }
            return (short)mh$.invokeExact(_Px, _Lexp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ldscale {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_SHORT,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_ldscale");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * short _ldscale(long double *_Px, long _Lexp)
     * }
     */
    public static FunctionDescriptor _ldscale$descriptor() {
        return _ldscale.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * short _ldscale(long double *_Px, long _Lexp)
     * }
     */
    public static MethodHandle _ldscale$handle() {
        return _ldscale.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * short _ldscale(long double *_Px, long _Lexp)
     * }
     */
    public static MemorySegment _ldscale$address() {
        return _ldscale.ADDR;
    }

    /**
     * {@snippet lang=c :
     * short _ldscale(long double *_Px, long _Lexp)
     * }
     */
    public static short _ldscale(MemorySegment _Px, int _Lexp) {
        var mh$ = _ldscale.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ldscale", _Px, _Lexp);
            }
            return (short)mh$.invokeExact(_Px, _Lexp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fdscale {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_SHORT,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_fdscale");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * short _fdscale(float *_Px, long _Lexp)
     * }
     */
    public static FunctionDescriptor _fdscale$descriptor() {
        return _fdscale.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * short _fdscale(float *_Px, long _Lexp)
     * }
     */
    public static MethodHandle _fdscale$handle() {
        return _fdscale.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * short _fdscale(float *_Px, long _Lexp)
     * }
     */
    public static MemorySegment _fdscale$address() {
        return _fdscale.ADDR;
    }

    /**
     * {@snippet lang=c :
     * short _fdscale(float *_Px, long _Lexp)
     * }
     */
    public static short _fdscale(MemorySegment _Px, int _Lexp) {
        var mh$ = _fdscale.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fdscale", _Px, _Lexp);
            }
            return (short)mh$.invokeExact(_Px, _Lexp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _dunscale {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_SHORT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_dunscale");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * short _dunscale(short *_Pex, double *_Px)
     * }
     */
    public static FunctionDescriptor _dunscale$descriptor() {
        return _dunscale.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * short _dunscale(short *_Pex, double *_Px)
     * }
     */
    public static MethodHandle _dunscale$handle() {
        return _dunscale.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * short _dunscale(short *_Pex, double *_Px)
     * }
     */
    public static MemorySegment _dunscale$address() {
        return _dunscale.ADDR;
    }

    /**
     * {@snippet lang=c :
     * short _dunscale(short *_Pex, double *_Px)
     * }
     */
    public static short _dunscale(MemorySegment _Pex, MemorySegment _Px) {
        var mh$ = _dunscale.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_dunscale", _Pex, _Px);
            }
            return (short)mh$.invokeExact(_Pex, _Px);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ldunscale {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_SHORT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_ldunscale");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * short _ldunscale(short *_Pex, long double *_Px)
     * }
     */
    public static FunctionDescriptor _ldunscale$descriptor() {
        return _ldunscale.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * short _ldunscale(short *_Pex, long double *_Px)
     * }
     */
    public static MethodHandle _ldunscale$handle() {
        return _ldunscale.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * short _ldunscale(short *_Pex, long double *_Px)
     * }
     */
    public static MemorySegment _ldunscale$address() {
        return _ldunscale.ADDR;
    }

    /**
     * {@snippet lang=c :
     * short _ldunscale(short *_Pex, long double *_Px)
     * }
     */
    public static short _ldunscale(MemorySegment _Pex, MemorySegment _Px) {
        var mh$ = _ldunscale.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ldunscale", _Pex, _Px);
            }
            return (short)mh$.invokeExact(_Pex, _Px);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fdunscale {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_SHORT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_fdunscale");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * short _fdunscale(short *_Pex, float *_Px)
     * }
     */
    public static FunctionDescriptor _fdunscale$descriptor() {
        return _fdunscale.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * short _fdunscale(short *_Pex, float *_Px)
     * }
     */
    public static MethodHandle _fdunscale$handle() {
        return _fdunscale.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * short _fdunscale(short *_Pex, float *_Px)
     * }
     */
    public static MemorySegment _fdunscale$address() {
        return _fdunscale.ADDR;
    }

    /**
     * {@snippet lang=c :
     * short _fdunscale(short *_Pex, float *_Px)
     * }
     */
    public static short _fdunscale(MemorySegment _Pex, MemorySegment _Px) {
        var mh$ = _fdunscale.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fdunscale", _Pex, _Px);
            }
            return (short)mh$.invokeExact(_Pex, _Px);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _dexp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_SHORT,
            Python_h.C_POINTER,
            Python_h.C_DOUBLE,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_dexp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * short _dexp(double *_Px, double _Y, long _Eoff)
     * }
     */
    public static FunctionDescriptor _dexp$descriptor() {
        return _dexp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * short _dexp(double *_Px, double _Y, long _Eoff)
     * }
     */
    public static MethodHandle _dexp$handle() {
        return _dexp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * short _dexp(double *_Px, double _Y, long _Eoff)
     * }
     */
    public static MemorySegment _dexp$address() {
        return _dexp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * short _dexp(double *_Px, double _Y, long _Eoff)
     * }
     */
    public static short _dexp(MemorySegment _Px, double _Y, int _Eoff) {
        var mh$ = _dexp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_dexp", _Px, _Y, _Eoff);
            }
            return (short)mh$.invokeExact(_Px, _Y, _Eoff);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ldexp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_SHORT,
            Python_h.C_POINTER,
            Python_h.C_LONG_DOUBLE,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_ldexp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * short _ldexp(long double *_Px, long double _Y, long _Eoff)
     * }
     */
    public static FunctionDescriptor _ldexp$descriptor() {
        return _ldexp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * short _ldexp(long double *_Px, long double _Y, long _Eoff)
     * }
     */
    public static MethodHandle _ldexp$handle() {
        return _ldexp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * short _ldexp(long double *_Px, long double _Y, long _Eoff)
     * }
     */
    public static MemorySegment _ldexp$address() {
        return _ldexp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * short _ldexp(long double *_Px, long double _Y, long _Eoff)
     * }
     */
    public static short _ldexp(MemorySegment _Px, double _Y, int _Eoff) {
        var mh$ = _ldexp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ldexp", _Px, _Y, _Eoff);
            }
            return (short)mh$.invokeExact(_Px, _Y, _Eoff);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fdexp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_SHORT,
            Python_h.C_POINTER,
            Python_h.C_FLOAT,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_fdexp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * short _fdexp(float *_Px, float _Y, long _Eoff)
     * }
     */
    public static FunctionDescriptor _fdexp$descriptor() {
        return _fdexp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * short _fdexp(float *_Px, float _Y, long _Eoff)
     * }
     */
    public static MethodHandle _fdexp$handle() {
        return _fdexp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * short _fdexp(float *_Px, float _Y, long _Eoff)
     * }
     */
    public static MemorySegment _fdexp$address() {
        return _fdexp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * short _fdexp(float *_Px, float _Y, long _Eoff)
     * }
     */
    public static short _fdexp(MemorySegment _Px, float _Y, int _Eoff) {
        var mh$ = _fdexp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fdexp", _Px, _Y, _Eoff);
            }
            return (short)mh$.invokeExact(_Px, _Y, _Eoff);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _dnorm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_SHORT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_dnorm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * short _dnorm(unsigned short *_Ps)
     * }
     */
    public static FunctionDescriptor _dnorm$descriptor() {
        return _dnorm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * short _dnorm(unsigned short *_Ps)
     * }
     */
    public static MethodHandle _dnorm$handle() {
        return _dnorm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * short _dnorm(unsigned short *_Ps)
     * }
     */
    public static MemorySegment _dnorm$address() {
        return _dnorm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * short _dnorm(unsigned short *_Ps)
     * }
     */
    public static short _dnorm(MemorySegment _Ps) {
        var mh$ = _dnorm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_dnorm", _Ps);
            }
            return (short)mh$.invokeExact(_Ps);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fdnorm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_SHORT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_fdnorm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * short _fdnorm(unsigned short *_Ps)
     * }
     */
    public static FunctionDescriptor _fdnorm$descriptor() {
        return _fdnorm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * short _fdnorm(unsigned short *_Ps)
     * }
     */
    public static MethodHandle _fdnorm$handle() {
        return _fdnorm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * short _fdnorm(unsigned short *_Ps)
     * }
     */
    public static MemorySegment _fdnorm$address() {
        return _fdnorm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * short _fdnorm(unsigned short *_Ps)
     * }
     */
    public static short _fdnorm(MemorySegment _Ps) {
        var mh$ = _fdnorm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fdnorm", _Ps);
            }
            return (short)mh$.invokeExact(_Ps);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _dpoly {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_dpoly");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double _dpoly(double _X, const double *_Tab, int _N)
     * }
     */
    public static FunctionDescriptor _dpoly$descriptor() {
        return _dpoly.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double _dpoly(double _X, const double *_Tab, int _N)
     * }
     */
    public static MethodHandle _dpoly$handle() {
        return _dpoly.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double _dpoly(double _X, const double *_Tab, int _N)
     * }
     */
    public static MemorySegment _dpoly$address() {
        return _dpoly.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double _dpoly(double _X, const double *_Tab, int _N)
     * }
     */
    public static double _dpoly(double _X, MemorySegment _Tab, int _N) {
        var mh$ = _dpoly.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_dpoly", _X, _Tab, _N);
            }
            return (double)mh$.invokeExact(_X, _Tab, _N);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ldpoly {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_DOUBLE,
            Python_h.C_LONG_DOUBLE,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_ldpoly");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double _ldpoly(long double _X, const long double *_Tab, int _N)
     * }
     */
    public static FunctionDescriptor _ldpoly$descriptor() {
        return _ldpoly.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double _ldpoly(long double _X, const long double *_Tab, int _N)
     * }
     */
    public static MethodHandle _ldpoly$handle() {
        return _ldpoly.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double _ldpoly(long double _X, const long double *_Tab, int _N)
     * }
     */
    public static MemorySegment _ldpoly$address() {
        return _ldpoly.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double _ldpoly(long double _X, const long double *_Tab, int _N)
     * }
     */
    public static double _ldpoly(double _X, MemorySegment _Tab, int _N) {
        var mh$ = _ldpoly.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ldpoly", _X, _Tab, _N);
            }
            return (double)mh$.invokeExact(_X, _Tab, _N);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fdpoly {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_fdpoly");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float _fdpoly(float _X, const float *_Tab, int _N)
     * }
     */
    public static FunctionDescriptor _fdpoly$descriptor() {
        return _fdpoly.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float _fdpoly(float _X, const float *_Tab, int _N)
     * }
     */
    public static MethodHandle _fdpoly$handle() {
        return _fdpoly.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float _fdpoly(float _X, const float *_Tab, int _N)
     * }
     */
    public static MemorySegment _fdpoly$address() {
        return _fdpoly.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float _fdpoly(float _X, const float *_Tab, int _N)
     * }
     */
    public static float _fdpoly(float _X, MemorySegment _Tab, int _N) {
        var mh$ = _fdpoly.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fdpoly", _X, _Tab, _N);
            }
            return (float)mh$.invokeExact(_X, _Tab, _N);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _dlog {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_dlog");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double _dlog(double _X, int _Baseflag)
     * }
     */
    public static FunctionDescriptor _dlog$descriptor() {
        return _dlog.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double _dlog(double _X, int _Baseflag)
     * }
     */
    public static MethodHandle _dlog$handle() {
        return _dlog.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double _dlog(double _X, int _Baseflag)
     * }
     */
    public static MemorySegment _dlog$address() {
        return _dlog.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double _dlog(double _X, int _Baseflag)
     * }
     */
    public static double _dlog(double _X, int _Baseflag) {
        var mh$ = _dlog.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_dlog", _X, _Baseflag);
            }
            return (double)mh$.invokeExact(_X, _Baseflag);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ldlog {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_DOUBLE,
            Python_h.C_LONG_DOUBLE,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_ldlog");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double _ldlog(long double _X, int _Baseflag)
     * }
     */
    public static FunctionDescriptor _ldlog$descriptor() {
        return _ldlog.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double _ldlog(long double _X, int _Baseflag)
     * }
     */
    public static MethodHandle _ldlog$handle() {
        return _ldlog.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double _ldlog(long double _X, int _Baseflag)
     * }
     */
    public static MemorySegment _ldlog$address() {
        return _ldlog.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double _ldlog(long double _X, int _Baseflag)
     * }
     */
    public static double _ldlog(double _X, int _Baseflag) {
        var mh$ = _ldlog.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ldlog", _X, _Baseflag);
            }
            return (double)mh$.invokeExact(_X, _Baseflag);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fdlog {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_fdlog");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float _fdlog(float _X, int _Baseflag)
     * }
     */
    public static FunctionDescriptor _fdlog$descriptor() {
        return _fdlog.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float _fdlog(float _X, int _Baseflag)
     * }
     */
    public static MethodHandle _fdlog$handle() {
        return _fdlog.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float _fdlog(float _X, int _Baseflag)
     * }
     */
    public static MemorySegment _fdlog$address() {
        return _fdlog.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float _fdlog(float _X, int _Baseflag)
     * }
     */
    public static float _fdlog(float _X, int _Baseflag) {
        var mh$ = _fdlog.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fdlog", _X, _Baseflag);
            }
            return (float)mh$.invokeExact(_X, _Baseflag);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _dsin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_dsin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double _dsin(double _X, unsigned int _Qoff)
     * }
     */
    public static FunctionDescriptor _dsin$descriptor() {
        return _dsin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double _dsin(double _X, unsigned int _Qoff)
     * }
     */
    public static MethodHandle _dsin$handle() {
        return _dsin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double _dsin(double _X, unsigned int _Qoff)
     * }
     */
    public static MemorySegment _dsin$address() {
        return _dsin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double _dsin(double _X, unsigned int _Qoff)
     * }
     */
    public static double _dsin(double _X, int _Qoff) {
        var mh$ = _dsin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_dsin", _X, _Qoff);
            }
            return (double)mh$.invokeExact(_X, _Qoff);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ldsin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_DOUBLE,
            Python_h.C_LONG_DOUBLE,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_ldsin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double _ldsin(long double _X, unsigned int _Qoff)
     * }
     */
    public static FunctionDescriptor _ldsin$descriptor() {
        return _ldsin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double _ldsin(long double _X, unsigned int _Qoff)
     * }
     */
    public static MethodHandle _ldsin$handle() {
        return _ldsin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double _ldsin(long double _X, unsigned int _Qoff)
     * }
     */
    public static MemorySegment _ldsin$address() {
        return _ldsin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double _ldsin(long double _X, unsigned int _Qoff)
     * }
     */
    public static double _ldsin(double _X, int _Qoff) {
        var mh$ = _ldsin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ldsin", _X, _Qoff);
            }
            return (double)mh$.invokeExact(_X, _Qoff);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fdsin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_fdsin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float _fdsin(float _X, unsigned int _Qoff)
     * }
     */
    public static FunctionDescriptor _fdsin$descriptor() {
        return _fdsin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float _fdsin(float _X, unsigned int _Qoff)
     * }
     */
    public static MethodHandle _fdsin$handle() {
        return _fdsin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float _fdsin(float _X, unsigned int _Qoff)
     * }
     */
    public static MemorySegment _fdsin$address() {
        return _fdsin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float _fdsin(float _X, unsigned int _Qoff)
     * }
     */
    public static float _fdsin(float _X, int _Qoff) {
        var mh$ = _fdsin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fdsin", _X, _Qoff);
            }
            return (float)mh$.invokeExact(_X, _Qoff);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _Denorm_C$constants {
        public static final GroupLayout LAYOUT = _float_const.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("_Denorm_C").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const _float_const _Denorm_C
     * }
     */
    public static GroupLayout _Denorm_C$layout() {
        return _Denorm_C$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const _float_const _Denorm_C
     * }
     */
    public static MemorySegment _Denorm_C() {
        return _Denorm_C$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const _float_const _Denorm_C
     * }
     */
    public static void _Denorm_C(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, _Denorm_C$constants.SEGMENT, 0L, _Denorm_C$constants.LAYOUT.byteSize());
    }

    private static class _Inf_C$constants {
        public static final GroupLayout LAYOUT = _float_const.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("_Inf_C").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const _float_const _Inf_C
     * }
     */
    public static GroupLayout _Inf_C$layout() {
        return _Inf_C$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const _float_const _Inf_C
     * }
     */
    public static MemorySegment _Inf_C() {
        return _Inf_C$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const _float_const _Inf_C
     * }
     */
    public static void _Inf_C(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, _Inf_C$constants.SEGMENT, 0L, _Inf_C$constants.LAYOUT.byteSize());
    }

    private static class _Nan_C$constants {
        public static final GroupLayout LAYOUT = _float_const.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("_Nan_C").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const _float_const _Nan_C
     * }
     */
    public static GroupLayout _Nan_C$layout() {
        return _Nan_C$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const _float_const _Nan_C
     * }
     */
    public static MemorySegment _Nan_C() {
        return _Nan_C$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const _float_const _Nan_C
     * }
     */
    public static void _Nan_C(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, _Nan_C$constants.SEGMENT, 0L, _Nan_C$constants.LAYOUT.byteSize());
    }

    private static class _Snan_C$constants {
        public static final GroupLayout LAYOUT = _float_const.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("_Snan_C").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const _float_const _Snan_C
     * }
     */
    public static GroupLayout _Snan_C$layout() {
        return _Snan_C$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const _float_const _Snan_C
     * }
     */
    public static MemorySegment _Snan_C() {
        return _Snan_C$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const _float_const _Snan_C
     * }
     */
    public static void _Snan_C(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, _Snan_C$constants.SEGMENT, 0L, _Snan_C$constants.LAYOUT.byteSize());
    }

    private static class _Hugeval_C$constants {
        public static final GroupLayout LAYOUT = _float_const.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("_Hugeval_C").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const _float_const _Hugeval_C
     * }
     */
    public static GroupLayout _Hugeval_C$layout() {
        return _Hugeval_C$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const _float_const _Hugeval_C
     * }
     */
    public static MemorySegment _Hugeval_C() {
        return _Hugeval_C$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const _float_const _Hugeval_C
     * }
     */
    public static void _Hugeval_C(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, _Hugeval_C$constants.SEGMENT, 0L, _Hugeval_C$constants.LAYOUT.byteSize());
    }

    private static class _FDenorm_C$constants {
        public static final GroupLayout LAYOUT = _float_const.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("_FDenorm_C").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const _float_const _FDenorm_C
     * }
     */
    public static GroupLayout _FDenorm_C$layout() {
        return _FDenorm_C$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const _float_const _FDenorm_C
     * }
     */
    public static MemorySegment _FDenorm_C() {
        return _FDenorm_C$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const _float_const _FDenorm_C
     * }
     */
    public static void _FDenorm_C(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, _FDenorm_C$constants.SEGMENT, 0L, _FDenorm_C$constants.LAYOUT.byteSize());
    }

    private static class _FInf_C$constants {
        public static final GroupLayout LAYOUT = _float_const.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("_FInf_C").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const _float_const _FInf_C
     * }
     */
    public static GroupLayout _FInf_C$layout() {
        return _FInf_C$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const _float_const _FInf_C
     * }
     */
    public static MemorySegment _FInf_C() {
        return _FInf_C$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const _float_const _FInf_C
     * }
     */
    public static void _FInf_C(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, _FInf_C$constants.SEGMENT, 0L, _FInf_C$constants.LAYOUT.byteSize());
    }

    private static class _FNan_C$constants {
        public static final GroupLayout LAYOUT = _float_const.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("_FNan_C").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const _float_const _FNan_C
     * }
     */
    public static GroupLayout _FNan_C$layout() {
        return _FNan_C$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const _float_const _FNan_C
     * }
     */
    public static MemorySegment _FNan_C() {
        return _FNan_C$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const _float_const _FNan_C
     * }
     */
    public static void _FNan_C(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, _FNan_C$constants.SEGMENT, 0L, _FNan_C$constants.LAYOUT.byteSize());
    }

    private static class _FSnan_C$constants {
        public static final GroupLayout LAYOUT = _float_const.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("_FSnan_C").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const _float_const _FSnan_C
     * }
     */
    public static GroupLayout _FSnan_C$layout() {
        return _FSnan_C$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const _float_const _FSnan_C
     * }
     */
    public static MemorySegment _FSnan_C() {
        return _FSnan_C$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const _float_const _FSnan_C
     * }
     */
    public static void _FSnan_C(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, _FSnan_C$constants.SEGMENT, 0L, _FSnan_C$constants.LAYOUT.byteSize());
    }

    private static class _LDenorm_C$constants {
        public static final GroupLayout LAYOUT = _float_const.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("_LDenorm_C").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const _float_const _LDenorm_C
     * }
     */
    public static GroupLayout _LDenorm_C$layout() {
        return _LDenorm_C$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const _float_const _LDenorm_C
     * }
     */
    public static MemorySegment _LDenorm_C() {
        return _LDenorm_C$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const _float_const _LDenorm_C
     * }
     */
    public static void _LDenorm_C(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, _LDenorm_C$constants.SEGMENT, 0L, _LDenorm_C$constants.LAYOUT.byteSize());
    }

    private static class _LInf_C$constants {
        public static final GroupLayout LAYOUT = _float_const.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("_LInf_C").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const _float_const _LInf_C
     * }
     */
    public static GroupLayout _LInf_C$layout() {
        return _LInf_C$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const _float_const _LInf_C
     * }
     */
    public static MemorySegment _LInf_C() {
        return _LInf_C$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const _float_const _LInf_C
     * }
     */
    public static void _LInf_C(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, _LInf_C$constants.SEGMENT, 0L, _LInf_C$constants.LAYOUT.byteSize());
    }

    private static class _LNan_C$constants {
        public static final GroupLayout LAYOUT = _float_const.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("_LNan_C").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const _float_const _LNan_C
     * }
     */
    public static GroupLayout _LNan_C$layout() {
        return _LNan_C$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const _float_const _LNan_C
     * }
     */
    public static MemorySegment _LNan_C() {
        return _LNan_C$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const _float_const _LNan_C
     * }
     */
    public static void _LNan_C(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, _LNan_C$constants.SEGMENT, 0L, _LNan_C$constants.LAYOUT.byteSize());
    }

    private static class _LSnan_C$constants {
        public static final GroupLayout LAYOUT = _float_const.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("_LSnan_C").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const _float_const _LSnan_C
     * }
     */
    public static GroupLayout _LSnan_C$layout() {
        return _LSnan_C$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const _float_const _LSnan_C
     * }
     */
    public static MemorySegment _LSnan_C() {
        return _LSnan_C$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const _float_const _LSnan_C
     * }
     */
    public static void _LSnan_C(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, _LSnan_C$constants.SEGMENT, 0L, _LSnan_C$constants.LAYOUT.byteSize());
    }

    private static class _Eps_C$constants {
        public static final GroupLayout LAYOUT = _float_const.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("_Eps_C").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const _float_const _Eps_C
     * }
     */
    public static GroupLayout _Eps_C$layout() {
        return _Eps_C$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const _float_const _Eps_C
     * }
     */
    public static MemorySegment _Eps_C() {
        return _Eps_C$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const _float_const _Eps_C
     * }
     */
    public static void _Eps_C(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, _Eps_C$constants.SEGMENT, 0L, _Eps_C$constants.LAYOUT.byteSize());
    }

    private static class _Rteps_C$constants {
        public static final GroupLayout LAYOUT = _float_const.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("_Rteps_C").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const _float_const _Rteps_C
     * }
     */
    public static GroupLayout _Rteps_C$layout() {
        return _Rteps_C$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const _float_const _Rteps_C
     * }
     */
    public static MemorySegment _Rteps_C() {
        return _Rteps_C$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const _float_const _Rteps_C
     * }
     */
    public static void _Rteps_C(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, _Rteps_C$constants.SEGMENT, 0L, _Rteps_C$constants.LAYOUT.byteSize());
    }

    private static class _FEps_C$constants {
        public static final GroupLayout LAYOUT = _float_const.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("_FEps_C").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const _float_const _FEps_C
     * }
     */
    public static GroupLayout _FEps_C$layout() {
        return _FEps_C$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const _float_const _FEps_C
     * }
     */
    public static MemorySegment _FEps_C() {
        return _FEps_C$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const _float_const _FEps_C
     * }
     */
    public static void _FEps_C(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, _FEps_C$constants.SEGMENT, 0L, _FEps_C$constants.LAYOUT.byteSize());
    }

    private static class _FRteps_C$constants {
        public static final GroupLayout LAYOUT = _float_const.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("_FRteps_C").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const _float_const _FRteps_C
     * }
     */
    public static GroupLayout _FRteps_C$layout() {
        return _FRteps_C$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const _float_const _FRteps_C
     * }
     */
    public static MemorySegment _FRteps_C() {
        return _FRteps_C$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const _float_const _FRteps_C
     * }
     */
    public static void _FRteps_C(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, _FRteps_C$constants.SEGMENT, 0L, _FRteps_C$constants.LAYOUT.byteSize());
    }

    private static class _LEps_C$constants {
        public static final GroupLayout LAYOUT = _float_const.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("_LEps_C").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const _float_const _LEps_C
     * }
     */
    public static GroupLayout _LEps_C$layout() {
        return _LEps_C$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const _float_const _LEps_C
     * }
     */
    public static MemorySegment _LEps_C() {
        return _LEps_C$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const _float_const _LEps_C
     * }
     */
    public static void _LEps_C(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, _LEps_C$constants.SEGMENT, 0L, _LEps_C$constants.LAYOUT.byteSize());
    }

    private static class _LRteps_C$constants {
        public static final GroupLayout LAYOUT = _float_const.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("_LRteps_C").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const _float_const _LRteps_C
     * }
     */
    public static GroupLayout _LRteps_C$layout() {
        return _LRteps_C$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const _float_const _LRteps_C
     * }
     */
    public static MemorySegment _LRteps_C() {
        return _LRteps_C$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const _float_const _LRteps_C
     * }
     */
    public static void _LRteps_C(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, _LRteps_C$constants.SEGMENT, 0L, _LRteps_C$constants.LAYOUT.byteSize());
    }

    private static class _Zero_C$constants {
        public static final OfDouble LAYOUT = Python_h.C_DOUBLE;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("_Zero_C").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const double _Zero_C
     * }
     */
    public static OfDouble _Zero_C$layout() {
        return _Zero_C$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const double _Zero_C
     * }
     */
    public static MemorySegment _Zero_C$segment() {
        return _Zero_C$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const double _Zero_C
     * }
     */
    public static double _Zero_C() {
        return _Zero_C$constants.SEGMENT.get(_Zero_C$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const double _Zero_C
     * }
     */
    public static void _Zero_C(double varValue) {
        _Zero_C$constants.SEGMENT.set(_Zero_C$constants.LAYOUT, 0L, varValue);
    }

    private static class _Xbig_C$constants {
        public static final OfDouble LAYOUT = Python_h.C_DOUBLE;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("_Xbig_C").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const double _Xbig_C
     * }
     */
    public static OfDouble _Xbig_C$layout() {
        return _Xbig_C$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const double _Xbig_C
     * }
     */
    public static MemorySegment _Xbig_C$segment() {
        return _Xbig_C$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const double _Xbig_C
     * }
     */
    public static double _Xbig_C() {
        return _Xbig_C$constants.SEGMENT.get(_Xbig_C$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const double _Xbig_C
     * }
     */
    public static void _Xbig_C(double varValue) {
        _Xbig_C$constants.SEGMENT.set(_Xbig_C$constants.LAYOUT, 0L, varValue);
    }

    private static class _FZero_C$constants {
        public static final OfFloat LAYOUT = Python_h.C_FLOAT;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("_FZero_C").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const float _FZero_C
     * }
     */
    public static OfFloat _FZero_C$layout() {
        return _FZero_C$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const float _FZero_C
     * }
     */
    public static MemorySegment _FZero_C$segment() {
        return _FZero_C$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const float _FZero_C
     * }
     */
    public static float _FZero_C() {
        return _FZero_C$constants.SEGMENT.get(_FZero_C$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const float _FZero_C
     * }
     */
    public static void _FZero_C(float varValue) {
        _FZero_C$constants.SEGMENT.set(_FZero_C$constants.LAYOUT, 0L, varValue);
    }

    private static class _FXbig_C$constants {
        public static final OfFloat LAYOUT = Python_h.C_FLOAT;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("_FXbig_C").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const float _FXbig_C
     * }
     */
    public static OfFloat _FXbig_C$layout() {
        return _FXbig_C$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const float _FXbig_C
     * }
     */
    public static MemorySegment _FXbig_C$segment() {
        return _FXbig_C$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const float _FXbig_C
     * }
     */
    public static float _FXbig_C() {
        return _FXbig_C$constants.SEGMENT.get(_FXbig_C$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const float _FXbig_C
     * }
     */
    public static void _FXbig_C(float varValue) {
        _FXbig_C$constants.SEGMENT.set(_FXbig_C$constants.LAYOUT, 0L, varValue);
    }

    private static class _LZero_C$constants {
        public static final OfDouble LAYOUT = Python_h.C_LONG_DOUBLE;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("_LZero_C").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const long double _LZero_C
     * }
     */
    public static OfDouble _LZero_C$layout() {
        return _LZero_C$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const long double _LZero_C
     * }
     */
    public static MemorySegment _LZero_C$segment() {
        return _LZero_C$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const long double _LZero_C
     * }
     */
    public static double _LZero_C() {
        return _LZero_C$constants.SEGMENT.get(_LZero_C$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const long double _LZero_C
     * }
     */
    public static void _LZero_C(double varValue) {
        _LZero_C$constants.SEGMENT.set(_LZero_C$constants.LAYOUT, 0L, varValue);
    }

    private static class _LXbig_C$constants {
        public static final OfDouble LAYOUT = Python_h.C_LONG_DOUBLE;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("_LXbig_C").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const long double _LXbig_C
     * }
     */
    public static OfDouble _LXbig_C$layout() {
        return _LXbig_C$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const long double _LXbig_C
     * }
     */
    public static MemorySegment _LXbig_C$segment() {
        return _LXbig_C$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const long double _LXbig_C
     * }
     */
    public static double _LXbig_C() {
        return _LXbig_C$constants.SEGMENT.get(_LXbig_C$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const long double _LXbig_C
     * }
     */
    public static void _LXbig_C(double varValue) {
        _LXbig_C$constants.SEGMENT.set(_LXbig_C$constants.LAYOUT, 0L, varValue);
    }

    private static class abs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("abs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int abs(int _X)
     * }
     */
    public static FunctionDescriptor abs$descriptor() {
        return abs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int abs(int _X)
     * }
     */
    public static MethodHandle abs$handle() {
        return abs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int abs(int _X)
     * }
     */
    public static MemorySegment abs$address() {
        return abs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int abs(int _X)
     * }
     */
    public static int abs(int _X) {
        var mh$ = abs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("abs", _X);
            }
            return (int)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class labs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("labs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long labs(long _X)
     * }
     */
    public static FunctionDescriptor labs$descriptor() {
        return labs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long labs(long _X)
     * }
     */
    public static MethodHandle labs$handle() {
        return labs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long labs(long _X)
     * }
     */
    public static MemorySegment labs$address() {
        return labs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long labs(long _X)
     * }
     */
    public static int labs(int _X) {
        var mh$ = labs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("labs", _X);
            }
            return (int)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llabs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("llabs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long llabs(long long _X)
     * }
     */
    public static FunctionDescriptor llabs$descriptor() {
        return llabs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long llabs(long long _X)
     * }
     */
    public static MethodHandle llabs$handle() {
        return llabs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long llabs(long long _X)
     * }
     */
    public static MemorySegment llabs$address() {
        return llabs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long llabs(long long _X)
     * }
     */
    public static long llabs(long _X) {
        var mh$ = llabs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llabs", _X);
            }
            return (long)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class acos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("acos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double acos(double _X)
     * }
     */
    public static FunctionDescriptor acos$descriptor() {
        return acos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double acos(double _X)
     * }
     */
    public static MethodHandle acos$handle() {
        return acos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double acos(double _X)
     * }
     */
    public static MemorySegment acos$address() {
        return acos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double acos(double _X)
     * }
     */
    public static double acos(double _X) {
        var mh$ = acos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("acos", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("asin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double asin(double _X)
     * }
     */
    public static FunctionDescriptor asin$descriptor() {
        return asin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double asin(double _X)
     * }
     */
    public static MethodHandle asin$handle() {
        return asin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double asin(double _X)
     * }
     */
    public static MemorySegment asin$address() {
        return asin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double asin(double _X)
     * }
     */
    public static double asin(double _X) {
        var mh$ = asin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("asin", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atan {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("atan");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double atan(double _X)
     * }
     */
    public static FunctionDescriptor atan$descriptor() {
        return atan.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double atan(double _X)
     * }
     */
    public static MethodHandle atan$handle() {
        return atan.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double atan(double _X)
     * }
     */
    public static MemorySegment atan$address() {
        return atan.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double atan(double _X)
     * }
     */
    public static double atan(double _X) {
        var mh$ = atan.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atan", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atan2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("atan2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double atan2(double _Y, double _X)
     * }
     */
    public static FunctionDescriptor atan2$descriptor() {
        return atan2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double atan2(double _Y, double _X)
     * }
     */
    public static MethodHandle atan2$handle() {
        return atan2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double atan2(double _Y, double _X)
     * }
     */
    public static MemorySegment atan2$address() {
        return atan2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double atan2(double _Y, double _X)
     * }
     */
    public static double atan2(double _Y, double _X) {
        var mh$ = atan2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atan2", _Y, _X);
            }
            return (double)mh$.invokeExact(_Y, _X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("cos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double cos(double _X)
     * }
     */
    public static FunctionDescriptor cos$descriptor() {
        return cos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double cos(double _X)
     * }
     */
    public static MethodHandle cos$handle() {
        return cos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double cos(double _X)
     * }
     */
    public static MemorySegment cos$address() {
        return cos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double cos(double _X)
     * }
     */
    public static double cos(double _X) {
        var mh$ = cos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cos", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cosh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("cosh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double cosh(double _X)
     * }
     */
    public static FunctionDescriptor cosh$descriptor() {
        return cosh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double cosh(double _X)
     * }
     */
    public static MethodHandle cosh$handle() {
        return cosh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double cosh(double _X)
     * }
     */
    public static MemorySegment cosh$address() {
        return cosh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double cosh(double _X)
     * }
     */
    public static double cosh(double _X) {
        var mh$ = cosh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cosh", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class exp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("exp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double exp(double _X)
     * }
     */
    public static FunctionDescriptor exp$descriptor() {
        return exp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double exp(double _X)
     * }
     */
    public static MethodHandle exp$handle() {
        return exp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double exp(double _X)
     * }
     */
    public static MemorySegment exp$address() {
        return exp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double exp(double _X)
     * }
     */
    public static double exp(double _X) {
        var mh$ = exp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("exp", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fabs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fabs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double fabs(double _X)
     * }
     */
    public static FunctionDescriptor fabs$descriptor() {
        return fabs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double fabs(double _X)
     * }
     */
    public static MethodHandle fabs$handle() {
        return fabs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double fabs(double _X)
     * }
     */
    public static MemorySegment fabs$address() {
        return fabs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double fabs(double _X)
     * }
     */
    public static double fabs(double _X) {
        var mh$ = fabs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fabs", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fmod {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fmod");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double fmod(double _X, double _Y)
     * }
     */
    public static FunctionDescriptor fmod$descriptor() {
        return fmod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double fmod(double _X, double _Y)
     * }
     */
    public static MethodHandle fmod$handle() {
        return fmod.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double fmod(double _X, double _Y)
     * }
     */
    public static MemorySegment fmod$address() {
        return fmod.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double fmod(double _X, double _Y)
     * }
     */
    public static double fmod(double _X, double _Y) {
        var mh$ = fmod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fmod", _X, _Y);
            }
            return (double)mh$.invokeExact(_X, _Y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class log {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("log");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double log(double _X)
     * }
     */
    public static FunctionDescriptor log$descriptor() {
        return log.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double log(double _X)
     * }
     */
    public static MethodHandle log$handle() {
        return log.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double log(double _X)
     * }
     */
    public static MemorySegment log$address() {
        return log.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double log(double _X)
     * }
     */
    public static double log(double _X) {
        var mh$ = log.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("log", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class log10 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("log10");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double log10(double _X)
     * }
     */
    public static FunctionDescriptor log10$descriptor() {
        return log10.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double log10(double _X)
     * }
     */
    public static MethodHandle log10$handle() {
        return log10.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double log10(double _X)
     * }
     */
    public static MemorySegment log10$address() {
        return log10.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double log10(double _X)
     * }
     */
    public static double log10(double _X) {
        var mh$ = log10.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("log10", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double pow(double _X, double _Y)
     * }
     */
    public static FunctionDescriptor pow$descriptor() {
        return pow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double pow(double _X, double _Y)
     * }
     */
    public static MethodHandle pow$handle() {
        return pow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double pow(double _X, double _Y)
     * }
     */
    public static MemorySegment pow$address() {
        return pow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double pow(double _X, double _Y)
     * }
     */
    public static double pow(double _X, double _Y) {
        var mh$ = pow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pow", _X, _Y);
            }
            return (double)mh$.invokeExact(_X, _Y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("sin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double sin(double _X)
     * }
     */
    public static FunctionDescriptor sin$descriptor() {
        return sin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double sin(double _X)
     * }
     */
    public static MethodHandle sin$handle() {
        return sin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double sin(double _X)
     * }
     */
    public static MemorySegment sin$address() {
        return sin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double sin(double _X)
     * }
     */
    public static double sin(double _X) {
        var mh$ = sin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sin", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sinh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("sinh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double sinh(double _X)
     * }
     */
    public static FunctionDescriptor sinh$descriptor() {
        return sinh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double sinh(double _X)
     * }
     */
    public static MethodHandle sinh$handle() {
        return sinh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double sinh(double _X)
     * }
     */
    public static MemorySegment sinh$address() {
        return sinh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double sinh(double _X)
     * }
     */
    public static double sinh(double _X) {
        var mh$ = sinh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sinh", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sqrt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("sqrt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double sqrt(double _X)
     * }
     */
    public static FunctionDescriptor sqrt$descriptor() {
        return sqrt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double sqrt(double _X)
     * }
     */
    public static MethodHandle sqrt$handle() {
        return sqrt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double sqrt(double _X)
     * }
     */
    public static MemorySegment sqrt$address() {
        return sqrt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double sqrt(double _X)
     * }
     */
    public static double sqrt(double _X) {
        var mh$ = sqrt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sqrt", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tan {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("tan");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double tan(double _X)
     * }
     */
    public static FunctionDescriptor tan$descriptor() {
        return tan.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double tan(double _X)
     * }
     */
    public static MethodHandle tan$handle() {
        return tan.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double tan(double _X)
     * }
     */
    public static MemorySegment tan$address() {
        return tan.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double tan(double _X)
     * }
     */
    public static double tan(double _X) {
        var mh$ = tan.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tan", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tanh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("tanh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double tanh(double _X)
     * }
     */
    public static FunctionDescriptor tanh$descriptor() {
        return tanh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double tanh(double _X)
     * }
     */
    public static MethodHandle tanh$handle() {
        return tanh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double tanh(double _X)
     * }
     */
    public static MemorySegment tanh$address() {
        return tanh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double tanh(double _X)
     * }
     */
    public static double tanh(double _X) {
        var mh$ = tanh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tanh", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class acosh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("acosh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double acosh(double _X)
     * }
     */
    public static FunctionDescriptor acosh$descriptor() {
        return acosh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double acosh(double _X)
     * }
     */
    public static MethodHandle acosh$handle() {
        return acosh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double acosh(double _X)
     * }
     */
    public static MemorySegment acosh$address() {
        return acosh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double acosh(double _X)
     * }
     */
    public static double acosh(double _X) {
        var mh$ = acosh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("acosh", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asinh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("asinh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double asinh(double _X)
     * }
     */
    public static FunctionDescriptor asinh$descriptor() {
        return asinh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double asinh(double _X)
     * }
     */
    public static MethodHandle asinh$handle() {
        return asinh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double asinh(double _X)
     * }
     */
    public static MemorySegment asinh$address() {
        return asinh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double asinh(double _X)
     * }
     */
    public static double asinh(double _X) {
        var mh$ = asinh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("asinh", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atanh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("atanh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double atanh(double _X)
     * }
     */
    public static FunctionDescriptor atanh$descriptor() {
        return atanh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double atanh(double _X)
     * }
     */
    public static MethodHandle atanh$handle() {
        return atanh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double atanh(double _X)
     * }
     */
    public static MemorySegment atanh$address() {
        return atanh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double atanh(double _X)
     * }
     */
    public static double atanh(double _X) {
        var mh$ = atanh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atanh", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atof {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("atof");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double atof(const char *_String)
     * }
     */
    public static FunctionDescriptor atof$descriptor() {
        return atof.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double atof(const char *_String)
     * }
     */
    public static MethodHandle atof$handle() {
        return atof.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double atof(const char *_String)
     * }
     */
    public static MemorySegment atof$address() {
        return atof.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double atof(const char *_String)
     * }
     */
    public static double atof(MemorySegment _String) {
        var mh$ = atof.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atof", _String);
            }
            return (double)mh$.invokeExact(_String);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _atof_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_atof_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double _atof_l(const char *_String, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _atof_l$descriptor() {
        return _atof_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double _atof_l(const char *_String, _locale_t _Locale)
     * }
     */
    public static MethodHandle _atof_l$handle() {
        return _atof_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double _atof_l(const char *_String, _locale_t _Locale)
     * }
     */
    public static MemorySegment _atof_l$address() {
        return _atof_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double _atof_l(const char *_String, _locale_t _Locale)
     * }
     */
    public static double _atof_l(MemorySegment _String, MemorySegment _Locale) {
        var mh$ = _atof_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_atof_l", _String, _Locale);
            }
            return (double)mh$.invokeExact(_String, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _cabs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            _complex.layout()
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_cabs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double _cabs(struct _complex _Complex_value)
     * }
     */
    public static FunctionDescriptor _cabs$descriptor() {
        return _cabs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double _cabs(struct _complex _Complex_value)
     * }
     */
    public static MethodHandle _cabs$handle() {
        return _cabs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double _cabs(struct _complex _Complex_value)
     * }
     */
    public static MemorySegment _cabs$address() {
        return _cabs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double _cabs(struct _complex _Complex_value)
     * }
     */
    public static double _cabs(MemorySegment _Complex_value) {
        var mh$ = _cabs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_cabs", _Complex_value);
            }
            return (double)mh$.invokeExact(_Complex_value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cbrt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("cbrt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double cbrt(double _X)
     * }
     */
    public static FunctionDescriptor cbrt$descriptor() {
        return cbrt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double cbrt(double _X)
     * }
     */
    public static MethodHandle cbrt$handle() {
        return cbrt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double cbrt(double _X)
     * }
     */
    public static MemorySegment cbrt$address() {
        return cbrt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double cbrt(double _X)
     * }
     */
    public static double cbrt(double _X) {
        var mh$ = cbrt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cbrt", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ceil {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("ceil");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double ceil(double _X)
     * }
     */
    public static FunctionDescriptor ceil$descriptor() {
        return ceil.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double ceil(double _X)
     * }
     */
    public static MethodHandle ceil$handle() {
        return ceil.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double ceil(double _X)
     * }
     */
    public static MemorySegment ceil$address() {
        return ceil.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double ceil(double _X)
     * }
     */
    public static double ceil(double _X) {
        var mh$ = ceil.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ceil", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _chgsign {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_chgsign");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double _chgsign(double _X)
     * }
     */
    public static FunctionDescriptor _chgsign$descriptor() {
        return _chgsign.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double _chgsign(double _X)
     * }
     */
    public static MethodHandle _chgsign$handle() {
        return _chgsign.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double _chgsign(double _X)
     * }
     */
    public static MemorySegment _chgsign$address() {
        return _chgsign.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double _chgsign(double _X)
     * }
     */
    public static double _chgsign(double _X) {
        var mh$ = _chgsign.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_chgsign", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class copysign {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("copysign");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double copysign(double _Number, double _Sign)
     * }
     */
    public static FunctionDescriptor copysign$descriptor() {
        return copysign.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double copysign(double _Number, double _Sign)
     * }
     */
    public static MethodHandle copysign$handle() {
        return copysign.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double copysign(double _Number, double _Sign)
     * }
     */
    public static MemorySegment copysign$address() {
        return copysign.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double copysign(double _Number, double _Sign)
     * }
     */
    public static double copysign(double _Number, double _Sign) {
        var mh$ = copysign.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("copysign", _Number, _Sign);
            }
            return (double)mh$.invokeExact(_Number, _Sign);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _copysign {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_copysign");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double _copysign(double _Number, double _Sign)
     * }
     */
    public static FunctionDescriptor _copysign$descriptor() {
        return _copysign.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double _copysign(double _Number, double _Sign)
     * }
     */
    public static MethodHandle _copysign$handle() {
        return _copysign.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double _copysign(double _Number, double _Sign)
     * }
     */
    public static MemorySegment _copysign$address() {
        return _copysign.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double _copysign(double _Number, double _Sign)
     * }
     */
    public static double _copysign(double _Number, double _Sign) {
        var mh$ = _copysign.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_copysign", _Number, _Sign);
            }
            return (double)mh$.invokeExact(_Number, _Sign);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class erf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("erf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double erf(double _X)
     * }
     */
    public static FunctionDescriptor erf$descriptor() {
        return erf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double erf(double _X)
     * }
     */
    public static MethodHandle erf$handle() {
        return erf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double erf(double _X)
     * }
     */
    public static MemorySegment erf$address() {
        return erf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double erf(double _X)
     * }
     */
    public static double erf(double _X) {
        var mh$ = erf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("erf", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class erfc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("erfc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double erfc(double _X)
     * }
     */
    public static FunctionDescriptor erfc$descriptor() {
        return erfc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double erfc(double _X)
     * }
     */
    public static MethodHandle erfc$handle() {
        return erfc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double erfc(double _X)
     * }
     */
    public static MemorySegment erfc$address() {
        return erfc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double erfc(double _X)
     * }
     */
    public static double erfc(double _X) {
        var mh$ = erfc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("erfc", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class exp2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("exp2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double exp2(double _X)
     * }
     */
    public static FunctionDescriptor exp2$descriptor() {
        return exp2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double exp2(double _X)
     * }
     */
    public static MethodHandle exp2$handle() {
        return exp2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double exp2(double _X)
     * }
     */
    public static MemorySegment exp2$address() {
        return exp2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double exp2(double _X)
     * }
     */
    public static double exp2(double _X) {
        var mh$ = exp2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("exp2", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class expm1 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("expm1");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double expm1(double _X)
     * }
     */
    public static FunctionDescriptor expm1$descriptor() {
        return expm1.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double expm1(double _X)
     * }
     */
    public static MethodHandle expm1$handle() {
        return expm1.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double expm1(double _X)
     * }
     */
    public static MemorySegment expm1$address() {
        return expm1.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double expm1(double _X)
     * }
     */
    public static double expm1(double _X) {
        var mh$ = expm1.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("expm1", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fdim {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fdim");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double fdim(double _X, double _Y)
     * }
     */
    public static FunctionDescriptor fdim$descriptor() {
        return fdim.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double fdim(double _X, double _Y)
     * }
     */
    public static MethodHandle fdim$handle() {
        return fdim.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double fdim(double _X, double _Y)
     * }
     */
    public static MemorySegment fdim$address() {
        return fdim.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double fdim(double _X, double _Y)
     * }
     */
    public static double fdim(double _X, double _Y) {
        var mh$ = fdim.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fdim", _X, _Y);
            }
            return (double)mh$.invokeExact(_X, _Y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class floor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("floor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double floor(double _X)
     * }
     */
    public static FunctionDescriptor floor$descriptor() {
        return floor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double floor(double _X)
     * }
     */
    public static MethodHandle floor$handle() {
        return floor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double floor(double _X)
     * }
     */
    public static MemorySegment floor$address() {
        return floor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double floor(double _X)
     * }
     */
    public static double floor(double _X) {
        var mh$ = floor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("floor", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fma {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fma");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double fma(double _X, double _Y, double _Z)
     * }
     */
    public static FunctionDescriptor fma$descriptor() {
        return fma.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double fma(double _X, double _Y, double _Z)
     * }
     */
    public static MethodHandle fma$handle() {
        return fma.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double fma(double _X, double _Y, double _Z)
     * }
     */
    public static MemorySegment fma$address() {
        return fma.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double fma(double _X, double _Y, double _Z)
     * }
     */
    public static double fma(double _X, double _Y, double _Z) {
        var mh$ = fma.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fma", _X, _Y, _Z);
            }
            return (double)mh$.invokeExact(_X, _Y, _Z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fmax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fmax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double fmax(double _X, double _Y)
     * }
     */
    public static FunctionDescriptor fmax$descriptor() {
        return fmax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double fmax(double _X, double _Y)
     * }
     */
    public static MethodHandle fmax$handle() {
        return fmax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double fmax(double _X, double _Y)
     * }
     */
    public static MemorySegment fmax$address() {
        return fmax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double fmax(double _X, double _Y)
     * }
     */
    public static double fmax(double _X, double _Y) {
        var mh$ = fmax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fmax", _X, _Y);
            }
            return (double)mh$.invokeExact(_X, _Y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fmin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fmin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double fmin(double _X, double _Y)
     * }
     */
    public static FunctionDescriptor fmin$descriptor() {
        return fmin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double fmin(double _X, double _Y)
     * }
     */
    public static MethodHandle fmin$handle() {
        return fmin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double fmin(double _X, double _Y)
     * }
     */
    public static MemorySegment fmin$address() {
        return fmin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double fmin(double _X, double _Y)
     * }
     */
    public static double fmin(double _X, double _Y) {
        var mh$ = fmin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fmin", _X, _Y);
            }
            return (double)mh$.invokeExact(_X, _Y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class frexp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("frexp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double frexp(double _X, int *_Y)
     * }
     */
    public static FunctionDescriptor frexp$descriptor() {
        return frexp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double frexp(double _X, int *_Y)
     * }
     */
    public static MethodHandle frexp$handle() {
        return frexp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double frexp(double _X, int *_Y)
     * }
     */
    public static MemorySegment frexp$address() {
        return frexp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double frexp(double _X, int *_Y)
     * }
     */
    public static double frexp(double _X, MemorySegment _Y) {
        var mh$ = frexp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("frexp", _X, _Y);
            }
            return (double)mh$.invokeExact(_X, _Y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class hypot {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("hypot");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double hypot(double _X, double _Y)
     * }
     */
    public static FunctionDescriptor hypot$descriptor() {
        return hypot.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double hypot(double _X, double _Y)
     * }
     */
    public static MethodHandle hypot$handle() {
        return hypot.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double hypot(double _X, double _Y)
     * }
     */
    public static MemorySegment hypot$address() {
        return hypot.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double hypot(double _X, double _Y)
     * }
     */
    public static double hypot(double _X, double _Y) {
        var mh$ = hypot.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("hypot", _X, _Y);
            }
            return (double)mh$.invokeExact(_X, _Y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _hypot {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_hypot");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double _hypot(double _X, double _Y)
     * }
     */
    public static FunctionDescriptor _hypot$descriptor() {
        return _hypot.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double _hypot(double _X, double _Y)
     * }
     */
    public static MethodHandle _hypot$handle() {
        return _hypot.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double _hypot(double _X, double _Y)
     * }
     */
    public static MemorySegment _hypot$address() {
        return _hypot.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double _hypot(double _X, double _Y)
     * }
     */
    public static double _hypot(double _X, double _Y) {
        var mh$ = _hypot.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_hypot", _X, _Y);
            }
            return (double)mh$.invokeExact(_X, _Y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ilogb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("ilogb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ilogb(double _X)
     * }
     */
    public static FunctionDescriptor ilogb$descriptor() {
        return ilogb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ilogb(double _X)
     * }
     */
    public static MethodHandle ilogb$handle() {
        return ilogb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ilogb(double _X)
     * }
     */
    public static MemorySegment ilogb$address() {
        return ilogb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ilogb(double _X)
     * }
     */
    public static int ilogb(double _X) {
        var mh$ = ilogb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ilogb", _X);
            }
            return (int)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ldexp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("ldexp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double ldexp(double _X, int _Y)
     * }
     */
    public static FunctionDescriptor ldexp$descriptor() {
        return ldexp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double ldexp(double _X, int _Y)
     * }
     */
    public static MethodHandle ldexp$handle() {
        return ldexp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double ldexp(double _X, int _Y)
     * }
     */
    public static MemorySegment ldexp$address() {
        return ldexp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double ldexp(double _X, int _Y)
     * }
     */
    public static double ldexp(double _X, int _Y) {
        var mh$ = ldexp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ldexp", _X, _Y);
            }
            return (double)mh$.invokeExact(_X, _Y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lgamma {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("lgamma");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double lgamma(double _X)
     * }
     */
    public static FunctionDescriptor lgamma$descriptor() {
        return lgamma.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double lgamma(double _X)
     * }
     */
    public static MethodHandle lgamma$handle() {
        return lgamma.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double lgamma(double _X)
     * }
     */
    public static MemorySegment lgamma$address() {
        return lgamma.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double lgamma(double _X)
     * }
     */
    public static double lgamma(double _X) {
        var mh$ = lgamma.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lgamma", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llrint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("llrint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long llrint(double _X)
     * }
     */
    public static FunctionDescriptor llrint$descriptor() {
        return llrint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long llrint(double _X)
     * }
     */
    public static MethodHandle llrint$handle() {
        return llrint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long llrint(double _X)
     * }
     */
    public static MemorySegment llrint$address() {
        return llrint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long llrint(double _X)
     * }
     */
    public static long llrint(double _X) {
        var mh$ = llrint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llrint", _X);
            }
            return (long)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llround {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("llround");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long llround(double _X)
     * }
     */
    public static FunctionDescriptor llround$descriptor() {
        return llround.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long llround(double _X)
     * }
     */
    public static MethodHandle llround$handle() {
        return llround.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long llround(double _X)
     * }
     */
    public static MemorySegment llround$address() {
        return llround.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long llround(double _X)
     * }
     */
    public static long llround(double _X) {
        var mh$ = llround.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llround", _X);
            }
            return (long)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class log1p {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("log1p");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double log1p(double _X)
     * }
     */
    public static FunctionDescriptor log1p$descriptor() {
        return log1p.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double log1p(double _X)
     * }
     */
    public static MethodHandle log1p$handle() {
        return log1p.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double log1p(double _X)
     * }
     */
    public static MemorySegment log1p$address() {
        return log1p.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double log1p(double _X)
     * }
     */
    public static double log1p(double _X) {
        var mh$ = log1p.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("log1p", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class log2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("log2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double log2(double _X)
     * }
     */
    public static FunctionDescriptor log2$descriptor() {
        return log2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double log2(double _X)
     * }
     */
    public static MethodHandle log2$handle() {
        return log2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double log2(double _X)
     * }
     */
    public static MemorySegment log2$address() {
        return log2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double log2(double _X)
     * }
     */
    public static double log2(double _X) {
        var mh$ = log2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("log2", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class logb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("logb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double logb(double _X)
     * }
     */
    public static FunctionDescriptor logb$descriptor() {
        return logb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double logb(double _X)
     * }
     */
    public static MethodHandle logb$handle() {
        return logb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double logb(double _X)
     * }
     */
    public static MemorySegment logb$address() {
        return logb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double logb(double _X)
     * }
     */
    public static double logb(double _X) {
        var mh$ = logb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("logb", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lrint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("lrint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long lrint(double _X)
     * }
     */
    public static FunctionDescriptor lrint$descriptor() {
        return lrint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long lrint(double _X)
     * }
     */
    public static MethodHandle lrint$handle() {
        return lrint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long lrint(double _X)
     * }
     */
    public static MemorySegment lrint$address() {
        return lrint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long lrint(double _X)
     * }
     */
    public static int lrint(double _X) {
        var mh$ = lrint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lrint", _X);
            }
            return (int)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lround {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("lround");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long lround(double _X)
     * }
     */
    public static FunctionDescriptor lround$descriptor() {
        return lround.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long lround(double _X)
     * }
     */
    public static MethodHandle lround$handle() {
        return lround.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long lround(double _X)
     * }
     */
    public static MemorySegment lround$address() {
        return lround.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long lround(double _X)
     * }
     */
    public static int lround(double _X) {
        var mh$ = lround.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lround", _X);
            }
            return (int)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _matherr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_matherr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _matherr(struct _exception *_Except)
     * }
     */
    public static FunctionDescriptor _matherr$descriptor() {
        return _matherr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _matherr(struct _exception *_Except)
     * }
     */
    public static MethodHandle _matherr$handle() {
        return _matherr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _matherr(struct _exception *_Except)
     * }
     */
    public static MemorySegment _matherr$address() {
        return _matherr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _matherr(struct _exception *_Except)
     * }
     */
    public static int _matherr(MemorySegment _Except) {
        var mh$ = _matherr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_matherr", _Except);
            }
            return (int)mh$.invokeExact(_Except);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class modf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("modf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double modf(double _X, double *_Y)
     * }
     */
    public static FunctionDescriptor modf$descriptor() {
        return modf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double modf(double _X, double *_Y)
     * }
     */
    public static MethodHandle modf$handle() {
        return modf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double modf(double _X, double *_Y)
     * }
     */
    public static MemorySegment modf$address() {
        return modf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double modf(double _X, double *_Y)
     * }
     */
    public static double modf(double _X, MemorySegment _Y) {
        var mh$ = modf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("modf", _X, _Y);
            }
            return (double)mh$.invokeExact(_X, _Y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nan {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("nan");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double nan(const char *_X)
     * }
     */
    public static FunctionDescriptor nan$descriptor() {
        return nan.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double nan(const char *_X)
     * }
     */
    public static MethodHandle nan$handle() {
        return nan.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double nan(const char *_X)
     * }
     */
    public static MemorySegment nan$address() {
        return nan.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double nan(const char *_X)
     * }
     */
    public static double nan(MemorySegment _X) {
        var mh$ = nan.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nan", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nearbyint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("nearbyint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double nearbyint(double _X)
     * }
     */
    public static FunctionDescriptor nearbyint$descriptor() {
        return nearbyint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double nearbyint(double _X)
     * }
     */
    public static MethodHandle nearbyint$handle() {
        return nearbyint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double nearbyint(double _X)
     * }
     */
    public static MemorySegment nearbyint$address() {
        return nearbyint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double nearbyint(double _X)
     * }
     */
    public static double nearbyint(double _X) {
        var mh$ = nearbyint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nearbyint", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nextafter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("nextafter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double nextafter(double _X, double _Y)
     * }
     */
    public static FunctionDescriptor nextafter$descriptor() {
        return nextafter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double nextafter(double _X, double _Y)
     * }
     */
    public static MethodHandle nextafter$handle() {
        return nextafter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double nextafter(double _X, double _Y)
     * }
     */
    public static MemorySegment nextafter$address() {
        return nextafter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double nextafter(double _X, double _Y)
     * }
     */
    public static double nextafter(double _X, double _Y) {
        var mh$ = nextafter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nextafter", _X, _Y);
            }
            return (double)mh$.invokeExact(_X, _Y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nexttoward {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE,
            Python_h.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("nexttoward");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double nexttoward(double _X, long double _Y)
     * }
     */
    public static FunctionDescriptor nexttoward$descriptor() {
        return nexttoward.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double nexttoward(double _X, long double _Y)
     * }
     */
    public static MethodHandle nexttoward$handle() {
        return nexttoward.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double nexttoward(double _X, long double _Y)
     * }
     */
    public static MemorySegment nexttoward$address() {
        return nexttoward.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double nexttoward(double _X, long double _Y)
     * }
     */
    public static double nexttoward(double _X, double _Y) {
        var mh$ = nexttoward.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nexttoward", _X, _Y);
            }
            return (double)mh$.invokeExact(_X, _Y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class remainder {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("remainder");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double remainder(double _X, double _Y)
     * }
     */
    public static FunctionDescriptor remainder$descriptor() {
        return remainder.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double remainder(double _X, double _Y)
     * }
     */
    public static MethodHandle remainder$handle() {
        return remainder.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double remainder(double _X, double _Y)
     * }
     */
    public static MemorySegment remainder$address() {
        return remainder.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double remainder(double _X, double _Y)
     * }
     */
    public static double remainder(double _X, double _Y) {
        var mh$ = remainder.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("remainder", _X, _Y);
            }
            return (double)mh$.invokeExact(_X, _Y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class remquo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("remquo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double remquo(double _X, double _Y, int *_Z)
     * }
     */
    public static FunctionDescriptor remquo$descriptor() {
        return remquo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double remquo(double _X, double _Y, int *_Z)
     * }
     */
    public static MethodHandle remquo$handle() {
        return remquo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double remquo(double _X, double _Y, int *_Z)
     * }
     */
    public static MemorySegment remquo$address() {
        return remquo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double remquo(double _X, double _Y, int *_Z)
     * }
     */
    public static double remquo(double _X, double _Y, MemorySegment _Z) {
        var mh$ = remquo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("remquo", _X, _Y, _Z);
            }
            return (double)mh$.invokeExact(_X, _Y, _Z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("rint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double rint(double _X)
     * }
     */
    public static FunctionDescriptor rint$descriptor() {
        return rint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double rint(double _X)
     * }
     */
    public static MethodHandle rint$handle() {
        return rint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double rint(double _X)
     * }
     */
    public static MemorySegment rint$address() {
        return rint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double rint(double _X)
     * }
     */
    public static double rint(double _X) {
        var mh$ = rint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rint", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class round {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("round");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double round(double _X)
     * }
     */
    public static FunctionDescriptor round$descriptor() {
        return round.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double round(double _X)
     * }
     */
    public static MethodHandle round$handle() {
        return round.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double round(double _X)
     * }
     */
    public static MemorySegment round$address() {
        return round.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double round(double _X)
     * }
     */
    public static double round(double _X) {
        var mh$ = round.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("round", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class scalbln {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("scalbln");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double scalbln(double _X, long _Y)
     * }
     */
    public static FunctionDescriptor scalbln$descriptor() {
        return scalbln.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double scalbln(double _X, long _Y)
     * }
     */
    public static MethodHandle scalbln$handle() {
        return scalbln.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double scalbln(double _X, long _Y)
     * }
     */
    public static MemorySegment scalbln$address() {
        return scalbln.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double scalbln(double _X, long _Y)
     * }
     */
    public static double scalbln(double _X, int _Y) {
        var mh$ = scalbln.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("scalbln", _X, _Y);
            }
            return (double)mh$.invokeExact(_X, _Y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class scalbn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("scalbn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double scalbn(double _X, int _Y)
     * }
     */
    public static FunctionDescriptor scalbn$descriptor() {
        return scalbn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double scalbn(double _X, int _Y)
     * }
     */
    public static MethodHandle scalbn$handle() {
        return scalbn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double scalbn(double _X, int _Y)
     * }
     */
    public static MemorySegment scalbn$address() {
        return scalbn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double scalbn(double _X, int _Y)
     * }
     */
    public static double scalbn(double _X, int _Y) {
        var mh$ = scalbn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("scalbn", _X, _Y);
            }
            return (double)mh$.invokeExact(_X, _Y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tgamma {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("tgamma");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double tgamma(double _X)
     * }
     */
    public static FunctionDescriptor tgamma$descriptor() {
        return tgamma.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double tgamma(double _X)
     * }
     */
    public static MethodHandle tgamma$handle() {
        return tgamma.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double tgamma(double _X)
     * }
     */
    public static MemorySegment tgamma$address() {
        return tgamma.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double tgamma(double _X)
     * }
     */
    public static double tgamma(double _X) {
        var mh$ = tgamma.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tgamma", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class trunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("trunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double trunc(double _X)
     * }
     */
    public static FunctionDescriptor trunc$descriptor() {
        return trunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double trunc(double _X)
     * }
     */
    public static MethodHandle trunc$handle() {
        return trunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double trunc(double _X)
     * }
     */
    public static MemorySegment trunc$address() {
        return trunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double trunc(double _X)
     * }
     */
    public static double trunc(double _X) {
        var mh$ = trunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("trunc", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _j0 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_j0");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double _j0(double _X)
     * }
     */
    public static FunctionDescriptor _j0$descriptor() {
        return _j0.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double _j0(double _X)
     * }
     */
    public static MethodHandle _j0$handle() {
        return _j0.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double _j0(double _X)
     * }
     */
    public static MemorySegment _j0$address() {
        return _j0.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double _j0(double _X)
     * }
     */
    public static double _j0(double _X) {
        var mh$ = _j0.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_j0", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _j1 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_j1");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double _j1(double _X)
     * }
     */
    public static FunctionDescriptor _j1$descriptor() {
        return _j1.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double _j1(double _X)
     * }
     */
    public static MethodHandle _j1$handle() {
        return _j1.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double _j1(double _X)
     * }
     */
    public static MemorySegment _j1$address() {
        return _j1.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double _j1(double _X)
     * }
     */
    public static double _j1(double _X) {
        var mh$ = _j1.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_j1", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _jn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_INT,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_jn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double _jn(int _X, double _Y)
     * }
     */
    public static FunctionDescriptor _jn$descriptor() {
        return _jn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double _jn(int _X, double _Y)
     * }
     */
    public static MethodHandle _jn$handle() {
        return _jn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double _jn(int _X, double _Y)
     * }
     */
    public static MemorySegment _jn$address() {
        return _jn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double _jn(int _X, double _Y)
     * }
     */
    public static double _jn(int _X, double _Y) {
        var mh$ = _jn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_jn", _X, _Y);
            }
            return (double)mh$.invokeExact(_X, _Y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _y0 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_y0");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double _y0(double _X)
     * }
     */
    public static FunctionDescriptor _y0$descriptor() {
        return _y0.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double _y0(double _X)
     * }
     */
    public static MethodHandle _y0$handle() {
        return _y0.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double _y0(double _X)
     * }
     */
    public static MemorySegment _y0$address() {
        return _y0.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double _y0(double _X)
     * }
     */
    public static double _y0(double _X) {
        var mh$ = _y0.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_y0", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _y1 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_y1");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double _y1(double _X)
     * }
     */
    public static FunctionDescriptor _y1$descriptor() {
        return _y1.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double _y1(double _X)
     * }
     */
    public static MethodHandle _y1$handle() {
        return _y1.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double _y1(double _X)
     * }
     */
    public static MemorySegment _y1$address() {
        return _y1.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double _y1(double _X)
     * }
     */
    public static double _y1(double _X) {
        var mh$ = _y1.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_y1", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _yn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_INT,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_yn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double _yn(int _X, double _Y)
     * }
     */
    public static FunctionDescriptor _yn$descriptor() {
        return _yn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double _yn(int _X, double _Y)
     * }
     */
    public static MethodHandle _yn$handle() {
        return _yn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double _yn(int _X, double _Y)
     * }
     */
    public static MemorySegment _yn$address() {
        return _yn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double _yn(int _X, double _Y)
     * }
     */
    public static double _yn(int _X, double _Y) {
        var mh$ = _yn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_yn", _X, _Y);
            }
            return (double)mh$.invokeExact(_X, _Y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class acoshf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("acoshf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float acoshf(float _X)
     * }
     */
    public static FunctionDescriptor acoshf$descriptor() {
        return acoshf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float acoshf(float _X)
     * }
     */
    public static MethodHandle acoshf$handle() {
        return acoshf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float acoshf(float _X)
     * }
     */
    public static MemorySegment acoshf$address() {
        return acoshf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float acoshf(float _X)
     * }
     */
    public static float acoshf(float _X) {
        var mh$ = acoshf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("acoshf", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asinhf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("asinhf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float asinhf(float _X)
     * }
     */
    public static FunctionDescriptor asinhf$descriptor() {
        return asinhf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float asinhf(float _X)
     * }
     */
    public static MethodHandle asinhf$handle() {
        return asinhf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float asinhf(float _X)
     * }
     */
    public static MemorySegment asinhf$address() {
        return asinhf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float asinhf(float _X)
     * }
     */
    public static float asinhf(float _X) {
        var mh$ = asinhf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("asinhf", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atanhf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("atanhf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float atanhf(float _X)
     * }
     */
    public static FunctionDescriptor atanhf$descriptor() {
        return atanhf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float atanhf(float _X)
     * }
     */
    public static MethodHandle atanhf$handle() {
        return atanhf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float atanhf(float _X)
     * }
     */
    public static MemorySegment atanhf$address() {
        return atanhf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float atanhf(float _X)
     * }
     */
    public static float atanhf(float _X) {
        var mh$ = atanhf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atanhf", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cbrtf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("cbrtf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float cbrtf(float _X)
     * }
     */
    public static FunctionDescriptor cbrtf$descriptor() {
        return cbrtf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float cbrtf(float _X)
     * }
     */
    public static MethodHandle cbrtf$handle() {
        return cbrtf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float cbrtf(float _X)
     * }
     */
    public static MemorySegment cbrtf$address() {
        return cbrtf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float cbrtf(float _X)
     * }
     */
    public static float cbrtf(float _X) {
        var mh$ = cbrtf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cbrtf", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _chgsignf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_chgsignf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float _chgsignf(float _X)
     * }
     */
    public static FunctionDescriptor _chgsignf$descriptor() {
        return _chgsignf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float _chgsignf(float _X)
     * }
     */
    public static MethodHandle _chgsignf$handle() {
        return _chgsignf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float _chgsignf(float _X)
     * }
     */
    public static MemorySegment _chgsignf$address() {
        return _chgsignf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float _chgsignf(float _X)
     * }
     */
    public static float _chgsignf(float _X) {
        var mh$ = _chgsignf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_chgsignf", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class copysignf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("copysignf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float copysignf(float _Number, float _Sign)
     * }
     */
    public static FunctionDescriptor copysignf$descriptor() {
        return copysignf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float copysignf(float _Number, float _Sign)
     * }
     */
    public static MethodHandle copysignf$handle() {
        return copysignf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float copysignf(float _Number, float _Sign)
     * }
     */
    public static MemorySegment copysignf$address() {
        return copysignf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float copysignf(float _Number, float _Sign)
     * }
     */
    public static float copysignf(float _Number, float _Sign) {
        var mh$ = copysignf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("copysignf", _Number, _Sign);
            }
            return (float)mh$.invokeExact(_Number, _Sign);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _copysignf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_copysignf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float _copysignf(float _Number, float _Sign)
     * }
     */
    public static FunctionDescriptor _copysignf$descriptor() {
        return _copysignf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float _copysignf(float _Number, float _Sign)
     * }
     */
    public static MethodHandle _copysignf$handle() {
        return _copysignf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float _copysignf(float _Number, float _Sign)
     * }
     */
    public static MemorySegment _copysignf$address() {
        return _copysignf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float _copysignf(float _Number, float _Sign)
     * }
     */
    public static float _copysignf(float _Number, float _Sign) {
        var mh$ = _copysignf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_copysignf", _Number, _Sign);
            }
            return (float)mh$.invokeExact(_Number, _Sign);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class erff {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("erff");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float erff(float _X)
     * }
     */
    public static FunctionDescriptor erff$descriptor() {
        return erff.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float erff(float _X)
     * }
     */
    public static MethodHandle erff$handle() {
        return erff.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float erff(float _X)
     * }
     */
    public static MemorySegment erff$address() {
        return erff.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float erff(float _X)
     * }
     */
    public static float erff(float _X) {
        var mh$ = erff.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("erff", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class erfcf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("erfcf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float erfcf(float _X)
     * }
     */
    public static FunctionDescriptor erfcf$descriptor() {
        return erfcf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float erfcf(float _X)
     * }
     */
    public static MethodHandle erfcf$handle() {
        return erfcf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float erfcf(float _X)
     * }
     */
    public static MemorySegment erfcf$address() {
        return erfcf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float erfcf(float _X)
     * }
     */
    public static float erfcf(float _X) {
        var mh$ = erfcf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("erfcf", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class expm1f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("expm1f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float expm1f(float _X)
     * }
     */
    public static FunctionDescriptor expm1f$descriptor() {
        return expm1f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float expm1f(float _X)
     * }
     */
    public static MethodHandle expm1f$handle() {
        return expm1f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float expm1f(float _X)
     * }
     */
    public static MemorySegment expm1f$address() {
        return expm1f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float expm1f(float _X)
     * }
     */
    public static float expm1f(float _X) {
        var mh$ = expm1f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("expm1f", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class exp2f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("exp2f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float exp2f(float _X)
     * }
     */
    public static FunctionDescriptor exp2f$descriptor() {
        return exp2f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float exp2f(float _X)
     * }
     */
    public static MethodHandle exp2f$handle() {
        return exp2f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float exp2f(float _X)
     * }
     */
    public static MemorySegment exp2f$address() {
        return exp2f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float exp2f(float _X)
     * }
     */
    public static float exp2f(float _X) {
        var mh$ = exp2f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("exp2f", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fdimf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fdimf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float fdimf(float _X, float _Y)
     * }
     */
    public static FunctionDescriptor fdimf$descriptor() {
        return fdimf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float fdimf(float _X, float _Y)
     * }
     */
    public static MethodHandle fdimf$handle() {
        return fdimf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float fdimf(float _X, float _Y)
     * }
     */
    public static MemorySegment fdimf$address() {
        return fdimf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float fdimf(float _X, float _Y)
     * }
     */
    public static float fdimf(float _X, float _Y) {
        var mh$ = fdimf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fdimf", _X, _Y);
            }
            return (float)mh$.invokeExact(_X, _Y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fmaf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT,
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fmaf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float fmaf(float _X, float _Y, float _Z)
     * }
     */
    public static FunctionDescriptor fmaf$descriptor() {
        return fmaf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float fmaf(float _X, float _Y, float _Z)
     * }
     */
    public static MethodHandle fmaf$handle() {
        return fmaf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float fmaf(float _X, float _Y, float _Z)
     * }
     */
    public static MemorySegment fmaf$address() {
        return fmaf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float fmaf(float _X, float _Y, float _Z)
     * }
     */
    public static float fmaf(float _X, float _Y, float _Z) {
        var mh$ = fmaf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fmaf", _X, _Y, _Z);
            }
            return (float)mh$.invokeExact(_X, _Y, _Z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fmaxf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fmaxf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float fmaxf(float _X, float _Y)
     * }
     */
    public static FunctionDescriptor fmaxf$descriptor() {
        return fmaxf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float fmaxf(float _X, float _Y)
     * }
     */
    public static MethodHandle fmaxf$handle() {
        return fmaxf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float fmaxf(float _X, float _Y)
     * }
     */
    public static MemorySegment fmaxf$address() {
        return fmaxf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float fmaxf(float _X, float _Y)
     * }
     */
    public static float fmaxf(float _X, float _Y) {
        var mh$ = fmaxf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fmaxf", _X, _Y);
            }
            return (float)mh$.invokeExact(_X, _Y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fminf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fminf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float fminf(float _X, float _Y)
     * }
     */
    public static FunctionDescriptor fminf$descriptor() {
        return fminf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float fminf(float _X, float _Y)
     * }
     */
    public static MethodHandle fminf$handle() {
        return fminf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float fminf(float _X, float _Y)
     * }
     */
    public static MemorySegment fminf$address() {
        return fminf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float fminf(float _X, float _Y)
     * }
     */
    public static float fminf(float _X, float _Y) {
        var mh$ = fminf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fminf", _X, _Y);
            }
            return (float)mh$.invokeExact(_X, _Y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _hypotf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_hypotf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float _hypotf(float _X, float _Y)
     * }
     */
    public static FunctionDescriptor _hypotf$descriptor() {
        return _hypotf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float _hypotf(float _X, float _Y)
     * }
     */
    public static MethodHandle _hypotf$handle() {
        return _hypotf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float _hypotf(float _X, float _Y)
     * }
     */
    public static MemorySegment _hypotf$address() {
        return _hypotf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float _hypotf(float _X, float _Y)
     * }
     */
    public static float _hypotf(float _X, float _Y) {
        var mh$ = _hypotf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_hypotf", _X, _Y);
            }
            return (float)mh$.invokeExact(_X, _Y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ilogbf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("ilogbf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ilogbf(float _X)
     * }
     */
    public static FunctionDescriptor ilogbf$descriptor() {
        return ilogbf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ilogbf(float _X)
     * }
     */
    public static MethodHandle ilogbf$handle() {
        return ilogbf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ilogbf(float _X)
     * }
     */
    public static MemorySegment ilogbf$address() {
        return ilogbf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ilogbf(float _X)
     * }
     */
    public static int ilogbf(float _X) {
        var mh$ = ilogbf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ilogbf", _X);
            }
            return (int)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lgammaf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("lgammaf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float lgammaf(float _X)
     * }
     */
    public static FunctionDescriptor lgammaf$descriptor() {
        return lgammaf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float lgammaf(float _X)
     * }
     */
    public static MethodHandle lgammaf$handle() {
        return lgammaf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float lgammaf(float _X)
     * }
     */
    public static MemorySegment lgammaf$address() {
        return lgammaf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float lgammaf(float _X)
     * }
     */
    public static float lgammaf(float _X) {
        var mh$ = lgammaf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lgammaf", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llrintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("llrintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long llrintf(float _X)
     * }
     */
    public static FunctionDescriptor llrintf$descriptor() {
        return llrintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long llrintf(float _X)
     * }
     */
    public static MethodHandle llrintf$handle() {
        return llrintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long llrintf(float _X)
     * }
     */
    public static MemorySegment llrintf$address() {
        return llrintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long llrintf(float _X)
     * }
     */
    public static long llrintf(float _X) {
        var mh$ = llrintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llrintf", _X);
            }
            return (long)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llroundf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("llroundf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long llroundf(float _X)
     * }
     */
    public static FunctionDescriptor llroundf$descriptor() {
        return llroundf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long llroundf(float _X)
     * }
     */
    public static MethodHandle llroundf$handle() {
        return llroundf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long llroundf(float _X)
     * }
     */
    public static MemorySegment llroundf$address() {
        return llroundf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long llroundf(float _X)
     * }
     */
    public static long llroundf(float _X) {
        var mh$ = llroundf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llroundf", _X);
            }
            return (long)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class log1pf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("log1pf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float log1pf(float _X)
     * }
     */
    public static FunctionDescriptor log1pf$descriptor() {
        return log1pf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float log1pf(float _X)
     * }
     */
    public static MethodHandle log1pf$handle() {
        return log1pf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float log1pf(float _X)
     * }
     */
    public static MemorySegment log1pf$address() {
        return log1pf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float log1pf(float _X)
     * }
     */
    public static float log1pf(float _X) {
        var mh$ = log1pf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("log1pf", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class log2f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("log2f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float log2f(float _X)
     * }
     */
    public static FunctionDescriptor log2f$descriptor() {
        return log2f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float log2f(float _X)
     * }
     */
    public static MethodHandle log2f$handle() {
        return log2f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float log2f(float _X)
     * }
     */
    public static MemorySegment log2f$address() {
        return log2f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float log2f(float _X)
     * }
     */
    public static float log2f(float _X) {
        var mh$ = log2f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("log2f", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class logbf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("logbf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float logbf(float _X)
     * }
     */
    public static FunctionDescriptor logbf$descriptor() {
        return logbf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float logbf(float _X)
     * }
     */
    public static MethodHandle logbf$handle() {
        return logbf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float logbf(float _X)
     * }
     */
    public static MemorySegment logbf$address() {
        return logbf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float logbf(float _X)
     * }
     */
    public static float logbf(float _X) {
        var mh$ = logbf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("logbf", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lrintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("lrintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long lrintf(float _X)
     * }
     */
    public static FunctionDescriptor lrintf$descriptor() {
        return lrintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long lrintf(float _X)
     * }
     */
    public static MethodHandle lrintf$handle() {
        return lrintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long lrintf(float _X)
     * }
     */
    public static MemorySegment lrintf$address() {
        return lrintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long lrintf(float _X)
     * }
     */
    public static int lrintf(float _X) {
        var mh$ = lrintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lrintf", _X);
            }
            return (int)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lroundf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("lroundf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long lroundf(float _X)
     * }
     */
    public static FunctionDescriptor lroundf$descriptor() {
        return lroundf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long lroundf(float _X)
     * }
     */
    public static MethodHandle lroundf$handle() {
        return lroundf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long lroundf(float _X)
     * }
     */
    public static MemorySegment lroundf$address() {
        return lroundf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long lroundf(float _X)
     * }
     */
    public static int lroundf(float _X) {
        var mh$ = lroundf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lroundf", _X);
            }
            return (int)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("nanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float nanf(const char *_X)
     * }
     */
    public static FunctionDescriptor nanf$descriptor() {
        return nanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float nanf(const char *_X)
     * }
     */
    public static MethodHandle nanf$handle() {
        return nanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float nanf(const char *_X)
     * }
     */
    public static MemorySegment nanf$address() {
        return nanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float nanf(const char *_X)
     * }
     */
    public static float nanf(MemorySegment _X) {
        var mh$ = nanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nanf", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nearbyintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("nearbyintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float nearbyintf(float _X)
     * }
     */
    public static FunctionDescriptor nearbyintf$descriptor() {
        return nearbyintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float nearbyintf(float _X)
     * }
     */
    public static MethodHandle nearbyintf$handle() {
        return nearbyintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float nearbyintf(float _X)
     * }
     */
    public static MemorySegment nearbyintf$address() {
        return nearbyintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float nearbyintf(float _X)
     * }
     */
    public static float nearbyintf(float _X) {
        var mh$ = nearbyintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nearbyintf", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nextafterf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("nextafterf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float nextafterf(float _X, float _Y)
     * }
     */
    public static FunctionDescriptor nextafterf$descriptor() {
        return nextafterf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float nextafterf(float _X, float _Y)
     * }
     */
    public static MethodHandle nextafterf$handle() {
        return nextafterf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float nextafterf(float _X, float _Y)
     * }
     */
    public static MemorySegment nextafterf$address() {
        return nextafterf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float nextafterf(float _X, float _Y)
     * }
     */
    public static float nextafterf(float _X, float _Y) {
        var mh$ = nextafterf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nextafterf", _X, _Y);
            }
            return (float)mh$.invokeExact(_X, _Y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nexttowardf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT,
            Python_h.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("nexttowardf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float nexttowardf(float _X, long double _Y)
     * }
     */
    public static FunctionDescriptor nexttowardf$descriptor() {
        return nexttowardf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float nexttowardf(float _X, long double _Y)
     * }
     */
    public static MethodHandle nexttowardf$handle() {
        return nexttowardf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float nexttowardf(float _X, long double _Y)
     * }
     */
    public static MemorySegment nexttowardf$address() {
        return nexttowardf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float nexttowardf(float _X, long double _Y)
     * }
     */
    public static float nexttowardf(float _X, double _Y) {
        var mh$ = nexttowardf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nexttowardf", _X, _Y);
            }
            return (float)mh$.invokeExact(_X, _Y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class remainderf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("remainderf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float remainderf(float _X, float _Y)
     * }
     */
    public static FunctionDescriptor remainderf$descriptor() {
        return remainderf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float remainderf(float _X, float _Y)
     * }
     */
    public static MethodHandle remainderf$handle() {
        return remainderf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float remainderf(float _X, float _Y)
     * }
     */
    public static MemorySegment remainderf$address() {
        return remainderf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float remainderf(float _X, float _Y)
     * }
     */
    public static float remainderf(float _X, float _Y) {
        var mh$ = remainderf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("remainderf", _X, _Y);
            }
            return (float)mh$.invokeExact(_X, _Y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class remquof {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT,
            Python_h.C_FLOAT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("remquof");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float remquof(float _X, float _Y, int *_Z)
     * }
     */
    public static FunctionDescriptor remquof$descriptor() {
        return remquof.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float remquof(float _X, float _Y, int *_Z)
     * }
     */
    public static MethodHandle remquof$handle() {
        return remquof.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float remquof(float _X, float _Y, int *_Z)
     * }
     */
    public static MemorySegment remquof$address() {
        return remquof.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float remquof(float _X, float _Y, int *_Z)
     * }
     */
    public static float remquof(float _X, float _Y, MemorySegment _Z) {
        var mh$ = remquof.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("remquof", _X, _Y, _Z);
            }
            return (float)mh$.invokeExact(_X, _Y, _Z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("rintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float rintf(float _X)
     * }
     */
    public static FunctionDescriptor rintf$descriptor() {
        return rintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float rintf(float _X)
     * }
     */
    public static MethodHandle rintf$handle() {
        return rintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float rintf(float _X)
     * }
     */
    public static MemorySegment rintf$address() {
        return rintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float rintf(float _X)
     * }
     */
    public static float rintf(float _X) {
        var mh$ = rintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rintf", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class roundf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("roundf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float roundf(float _X)
     * }
     */
    public static FunctionDescriptor roundf$descriptor() {
        return roundf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float roundf(float _X)
     * }
     */
    public static MethodHandle roundf$handle() {
        return roundf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float roundf(float _X)
     * }
     */
    public static MemorySegment roundf$address() {
        return roundf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float roundf(float _X)
     * }
     */
    public static float roundf(float _X) {
        var mh$ = roundf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("roundf", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class scalblnf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("scalblnf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float scalblnf(float _X, long _Y)
     * }
     */
    public static FunctionDescriptor scalblnf$descriptor() {
        return scalblnf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float scalblnf(float _X, long _Y)
     * }
     */
    public static MethodHandle scalblnf$handle() {
        return scalblnf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float scalblnf(float _X, long _Y)
     * }
     */
    public static MemorySegment scalblnf$address() {
        return scalblnf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float scalblnf(float _X, long _Y)
     * }
     */
    public static float scalblnf(float _X, int _Y) {
        var mh$ = scalblnf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("scalblnf", _X, _Y);
            }
            return (float)mh$.invokeExact(_X, _Y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class scalbnf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("scalbnf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float scalbnf(float _X, int _Y)
     * }
     */
    public static FunctionDescriptor scalbnf$descriptor() {
        return scalbnf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float scalbnf(float _X, int _Y)
     * }
     */
    public static MethodHandle scalbnf$handle() {
        return scalbnf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float scalbnf(float _X, int _Y)
     * }
     */
    public static MemorySegment scalbnf$address() {
        return scalbnf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float scalbnf(float _X, int _Y)
     * }
     */
    public static float scalbnf(float _X, int _Y) {
        var mh$ = scalbnf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("scalbnf", _X, _Y);
            }
            return (float)mh$.invokeExact(_X, _Y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tgammaf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("tgammaf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float tgammaf(float _X)
     * }
     */
    public static FunctionDescriptor tgammaf$descriptor() {
        return tgammaf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float tgammaf(float _X)
     * }
     */
    public static MethodHandle tgammaf$handle() {
        return tgammaf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float tgammaf(float _X)
     * }
     */
    public static MemorySegment tgammaf$address() {
        return tgammaf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float tgammaf(float _X)
     * }
     */
    public static float tgammaf(float _X) {
        var mh$ = tgammaf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tgammaf", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class truncf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("truncf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float truncf(float _X)
     * }
     */
    public static FunctionDescriptor truncf$descriptor() {
        return truncf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float truncf(float _X)
     * }
     */
    public static MethodHandle truncf$handle() {
        return truncf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float truncf(float _X)
     * }
     */
    public static MemorySegment truncf$address() {
        return truncf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float truncf(float _X)
     * }
     */
    public static float truncf(float _X) {
        var mh$ = truncf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("truncf", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _logbf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_logbf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float _logbf(float _X)
     * }
     */
    public static FunctionDescriptor _logbf$descriptor() {
        return _logbf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float _logbf(float _X)
     * }
     */
    public static MethodHandle _logbf$handle() {
        return _logbf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float _logbf(float _X)
     * }
     */
    public static MemorySegment _logbf$address() {
        return _logbf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float _logbf(float _X)
     * }
     */
    public static float _logbf(float _X) {
        var mh$ = _logbf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_logbf", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _nextafterf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_nextafterf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float _nextafterf(float _X, float _Y)
     * }
     */
    public static FunctionDescriptor _nextafterf$descriptor() {
        return _nextafterf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float _nextafterf(float _X, float _Y)
     * }
     */
    public static MethodHandle _nextafterf$handle() {
        return _nextafterf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float _nextafterf(float _X, float _Y)
     * }
     */
    public static MemorySegment _nextafterf$address() {
        return _nextafterf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float _nextafterf(float _X, float _Y)
     * }
     */
    public static float _nextafterf(float _X, float _Y) {
        var mh$ = _nextafterf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_nextafterf", _X, _Y);
            }
            return (float)mh$.invokeExact(_X, _Y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _finitef {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_finitef");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _finitef(float _X)
     * }
     */
    public static FunctionDescriptor _finitef$descriptor() {
        return _finitef.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _finitef(float _X)
     * }
     */
    public static MethodHandle _finitef$handle() {
        return _finitef.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _finitef(float _X)
     * }
     */
    public static MemorySegment _finitef$address() {
        return _finitef.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _finitef(float _X)
     * }
     */
    public static int _finitef(float _X) {
        var mh$ = _finitef.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_finitef", _X);
            }
            return (int)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _isnanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_isnanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _isnanf(float _X)
     * }
     */
    public static FunctionDescriptor _isnanf$descriptor() {
        return _isnanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _isnanf(float _X)
     * }
     */
    public static MethodHandle _isnanf$handle() {
        return _isnanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _isnanf(float _X)
     * }
     */
    public static MemorySegment _isnanf$address() {
        return _isnanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _isnanf(float _X)
     * }
     */
    public static int _isnanf(float _X) {
        var mh$ = _isnanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_isnanf", _X);
            }
            return (int)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fpclassf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_fpclassf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _fpclassf(float _X)
     * }
     */
    public static FunctionDescriptor _fpclassf$descriptor() {
        return _fpclassf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _fpclassf(float _X)
     * }
     */
    public static MethodHandle _fpclassf$handle() {
        return _fpclassf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _fpclassf(float _X)
     * }
     */
    public static MemorySegment _fpclassf$address() {
        return _fpclassf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _fpclassf(float _X)
     * }
     */
    public static int _fpclassf(float _X) {
        var mh$ = _fpclassf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fpclassf", _X);
            }
            return (int)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _set_FMA3_enable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_set_FMA3_enable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _set_FMA3_enable(int _Flag)
     * }
     */
    public static FunctionDescriptor _set_FMA3_enable$descriptor() {
        return _set_FMA3_enable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _set_FMA3_enable(int _Flag)
     * }
     */
    public static MethodHandle _set_FMA3_enable$handle() {
        return _set_FMA3_enable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _set_FMA3_enable(int _Flag)
     * }
     */
    public static MemorySegment _set_FMA3_enable$address() {
        return _set_FMA3_enable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _set_FMA3_enable(int _Flag)
     * }
     */
    public static int _set_FMA3_enable(int _Flag) {
        var mh$ = _set_FMA3_enable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_set_FMA3_enable", _Flag);
            }
            return (int)mh$.invokeExact(_Flag);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _get_FMA3_enable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_get_FMA3_enable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _get_FMA3_enable()
     * }
     */
    public static FunctionDescriptor _get_FMA3_enable$descriptor() {
        return _get_FMA3_enable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _get_FMA3_enable()
     * }
     */
    public static MethodHandle _get_FMA3_enable$handle() {
        return _get_FMA3_enable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _get_FMA3_enable()
     * }
     */
    public static MemorySegment _get_FMA3_enable$address() {
        return _get_FMA3_enable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _get_FMA3_enable()
     * }
     */
    public static int _get_FMA3_enable() {
        var mh$ = _get_FMA3_enable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_get_FMA3_enable");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class acosf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("acosf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float acosf(float _X)
     * }
     */
    public static FunctionDescriptor acosf$descriptor() {
        return acosf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float acosf(float _X)
     * }
     */
    public static MethodHandle acosf$handle() {
        return acosf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float acosf(float _X)
     * }
     */
    public static MemorySegment acosf$address() {
        return acosf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float acosf(float _X)
     * }
     */
    public static float acosf(float _X) {
        var mh$ = acosf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("acosf", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asinf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("asinf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float asinf(float _X)
     * }
     */
    public static FunctionDescriptor asinf$descriptor() {
        return asinf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float asinf(float _X)
     * }
     */
    public static MethodHandle asinf$handle() {
        return asinf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float asinf(float _X)
     * }
     */
    public static MemorySegment asinf$address() {
        return asinf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float asinf(float _X)
     * }
     */
    public static float asinf(float _X) {
        var mh$ = asinf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("asinf", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atan2f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("atan2f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float atan2f(float _Y, float _X)
     * }
     */
    public static FunctionDescriptor atan2f$descriptor() {
        return atan2f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float atan2f(float _Y, float _X)
     * }
     */
    public static MethodHandle atan2f$handle() {
        return atan2f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float atan2f(float _Y, float _X)
     * }
     */
    public static MemorySegment atan2f$address() {
        return atan2f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float atan2f(float _Y, float _X)
     * }
     */
    public static float atan2f(float _Y, float _X) {
        var mh$ = atan2f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atan2f", _Y, _X);
            }
            return (float)mh$.invokeExact(_Y, _X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("atanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float atanf(float _X)
     * }
     */
    public static FunctionDescriptor atanf$descriptor() {
        return atanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float atanf(float _X)
     * }
     */
    public static MethodHandle atanf$handle() {
        return atanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float atanf(float _X)
     * }
     */
    public static MemorySegment atanf$address() {
        return atanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float atanf(float _X)
     * }
     */
    public static float atanf(float _X) {
        var mh$ = atanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atanf", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ceilf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("ceilf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float ceilf(float _X)
     * }
     */
    public static FunctionDescriptor ceilf$descriptor() {
        return ceilf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float ceilf(float _X)
     * }
     */
    public static MethodHandle ceilf$handle() {
        return ceilf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float ceilf(float _X)
     * }
     */
    public static MemorySegment ceilf$address() {
        return ceilf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float ceilf(float _X)
     * }
     */
    public static float ceilf(float _X) {
        var mh$ = ceilf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ceilf", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cosf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("cosf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float cosf(float _X)
     * }
     */
    public static FunctionDescriptor cosf$descriptor() {
        return cosf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float cosf(float _X)
     * }
     */
    public static MethodHandle cosf$handle() {
        return cosf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float cosf(float _X)
     * }
     */
    public static MemorySegment cosf$address() {
        return cosf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float cosf(float _X)
     * }
     */
    public static float cosf(float _X) {
        var mh$ = cosf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cosf", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class coshf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("coshf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float coshf(float _X)
     * }
     */
    public static FunctionDescriptor coshf$descriptor() {
        return coshf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float coshf(float _X)
     * }
     */
    public static MethodHandle coshf$handle() {
        return coshf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float coshf(float _X)
     * }
     */
    public static MemorySegment coshf$address() {
        return coshf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float coshf(float _X)
     * }
     */
    public static float coshf(float _X) {
        var mh$ = coshf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("coshf", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class expf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("expf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float expf(float _X)
     * }
     */
    public static FunctionDescriptor expf$descriptor() {
        return expf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float expf(float _X)
     * }
     */
    public static MethodHandle expf$handle() {
        return expf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float expf(float _X)
     * }
     */
    public static MemorySegment expf$address() {
        return expf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float expf(float _X)
     * }
     */
    public static float expf(float _X) {
        var mh$ = expf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("expf", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class floorf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("floorf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float floorf(float _X)
     * }
     */
    public static FunctionDescriptor floorf$descriptor() {
        return floorf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float floorf(float _X)
     * }
     */
    public static MethodHandle floorf$handle() {
        return floorf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float floorf(float _X)
     * }
     */
    public static MemorySegment floorf$address() {
        return floorf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float floorf(float _X)
     * }
     */
    public static float floorf(float _X) {
        var mh$ = floorf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("floorf", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fmodf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fmodf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float fmodf(float _X, float _Y)
     * }
     */
    public static FunctionDescriptor fmodf$descriptor() {
        return fmodf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float fmodf(float _X, float _Y)
     * }
     */
    public static MethodHandle fmodf$handle() {
        return fmodf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float fmodf(float _X, float _Y)
     * }
     */
    public static MemorySegment fmodf$address() {
        return fmodf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float fmodf(float _X, float _Y)
     * }
     */
    public static float fmodf(float _X, float _Y) {
        var mh$ = fmodf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fmodf", _X, _Y);
            }
            return (float)mh$.invokeExact(_X, _Y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class log10f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("log10f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float log10f(float _X)
     * }
     */
    public static FunctionDescriptor log10f$descriptor() {
        return log10f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float log10f(float _X)
     * }
     */
    public static MethodHandle log10f$handle() {
        return log10f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float log10f(float _X)
     * }
     */
    public static MemorySegment log10f$address() {
        return log10f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float log10f(float _X)
     * }
     */
    public static float log10f(float _X) {
        var mh$ = log10f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("log10f", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class logf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("logf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float logf(float _X)
     * }
     */
    public static FunctionDescriptor logf$descriptor() {
        return logf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float logf(float _X)
     * }
     */
    public static MethodHandle logf$handle() {
        return logf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float logf(float _X)
     * }
     */
    public static MemorySegment logf$address() {
        return logf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float logf(float _X)
     * }
     */
    public static float logf(float _X) {
        var mh$ = logf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("logf", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class modff {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("modff");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float modff(float _X, float *_Y)
     * }
     */
    public static FunctionDescriptor modff$descriptor() {
        return modff.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float modff(float _X, float *_Y)
     * }
     */
    public static MethodHandle modff$handle() {
        return modff.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float modff(float _X, float *_Y)
     * }
     */
    public static MemorySegment modff$address() {
        return modff.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float modff(float _X, float *_Y)
     * }
     */
    public static float modff(float _X, MemorySegment _Y) {
        var mh$ = modff.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("modff", _X, _Y);
            }
            return (float)mh$.invokeExact(_X, _Y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class powf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("powf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float powf(float _X, float _Y)
     * }
     */
    public static FunctionDescriptor powf$descriptor() {
        return powf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float powf(float _X, float _Y)
     * }
     */
    public static MethodHandle powf$handle() {
        return powf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float powf(float _X, float _Y)
     * }
     */
    public static MemorySegment powf$address() {
        return powf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float powf(float _X, float _Y)
     * }
     */
    public static float powf(float _X, float _Y) {
        var mh$ = powf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("powf", _X, _Y);
            }
            return (float)mh$.invokeExact(_X, _Y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sinf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("sinf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float sinf(float _X)
     * }
     */
    public static FunctionDescriptor sinf$descriptor() {
        return sinf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float sinf(float _X)
     * }
     */
    public static MethodHandle sinf$handle() {
        return sinf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float sinf(float _X)
     * }
     */
    public static MemorySegment sinf$address() {
        return sinf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float sinf(float _X)
     * }
     */
    public static float sinf(float _X) {
        var mh$ = sinf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sinf", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sinhf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("sinhf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float sinhf(float _X)
     * }
     */
    public static FunctionDescriptor sinhf$descriptor() {
        return sinhf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float sinhf(float _X)
     * }
     */
    public static MethodHandle sinhf$handle() {
        return sinhf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float sinhf(float _X)
     * }
     */
    public static MemorySegment sinhf$address() {
        return sinhf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float sinhf(float _X)
     * }
     */
    public static float sinhf(float _X) {
        var mh$ = sinhf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sinhf", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sqrtf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("sqrtf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float sqrtf(float _X)
     * }
     */
    public static FunctionDescriptor sqrtf$descriptor() {
        return sqrtf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float sqrtf(float _X)
     * }
     */
    public static MethodHandle sqrtf$handle() {
        return sqrtf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float sqrtf(float _X)
     * }
     */
    public static MemorySegment sqrtf$address() {
        return sqrtf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float sqrtf(float _X)
     * }
     */
    public static float sqrtf(float _X) {
        var mh$ = sqrtf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sqrtf", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("tanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float tanf(float _X)
     * }
     */
    public static FunctionDescriptor tanf$descriptor() {
        return tanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float tanf(float _X)
     * }
     */
    public static MethodHandle tanf$handle() {
        return tanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float tanf(float _X)
     * }
     */
    public static MemorySegment tanf$address() {
        return tanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float tanf(float _X)
     * }
     */
    public static float tanf(float _X) {
        var mh$ = tanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tanf", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tanhf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("tanhf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float tanhf(float _X)
     * }
     */
    public static FunctionDescriptor tanhf$descriptor() {
        return tanhf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float tanhf(float _X)
     * }
     */
    public static MethodHandle tanhf$handle() {
        return tanhf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float tanhf(float _X)
     * }
     */
    public static MemorySegment tanhf$address() {
        return tanhf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float tanhf(float _X)
     * }
     */
    public static float tanhf(float _X) {
        var mh$ = tanhf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tanhf", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class acoshl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_DOUBLE,
            Python_h.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("acoshl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double acoshl(long double _X)
     * }
     */
    public static FunctionDescriptor acoshl$descriptor() {
        return acoshl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double acoshl(long double _X)
     * }
     */
    public static MethodHandle acoshl$handle() {
        return acoshl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double acoshl(long double _X)
     * }
     */
    public static MemorySegment acoshl$address() {
        return acoshl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double acoshl(long double _X)
     * }
     */
    public static double acoshl(double _X) {
        var mh$ = acoshl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("acoshl", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asinhl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_DOUBLE,
            Python_h.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("asinhl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double asinhl(long double _X)
     * }
     */
    public static FunctionDescriptor asinhl$descriptor() {
        return asinhl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double asinhl(long double _X)
     * }
     */
    public static MethodHandle asinhl$handle() {
        return asinhl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double asinhl(long double _X)
     * }
     */
    public static MemorySegment asinhl$address() {
        return asinhl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double asinhl(long double _X)
     * }
     */
    public static double asinhl(double _X) {
        var mh$ = asinhl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("asinhl", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atanhl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_DOUBLE,
            Python_h.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("atanhl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double atanhl(long double _X)
     * }
     */
    public static FunctionDescriptor atanhl$descriptor() {
        return atanhl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double atanhl(long double _X)
     * }
     */
    public static MethodHandle atanhl$handle() {
        return atanhl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double atanhl(long double _X)
     * }
     */
    public static MemorySegment atanhl$address() {
        return atanhl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double atanhl(long double _X)
     * }
     */
    public static double atanhl(double _X) {
        var mh$ = atanhl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atanhl", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cbrtl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_DOUBLE,
            Python_h.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("cbrtl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double cbrtl(long double _X)
     * }
     */
    public static FunctionDescriptor cbrtl$descriptor() {
        return cbrtl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double cbrtl(long double _X)
     * }
     */
    public static MethodHandle cbrtl$handle() {
        return cbrtl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double cbrtl(long double _X)
     * }
     */
    public static MemorySegment cbrtl$address() {
        return cbrtl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double cbrtl(long double _X)
     * }
     */
    public static double cbrtl(double _X) {
        var mh$ = cbrtl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cbrtl", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class copysignl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_DOUBLE,
            Python_h.C_LONG_DOUBLE,
            Python_h.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("copysignl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double copysignl(long double _Number, long double _Sign)
     * }
     */
    public static FunctionDescriptor copysignl$descriptor() {
        return copysignl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double copysignl(long double _Number, long double _Sign)
     * }
     */
    public static MethodHandle copysignl$handle() {
        return copysignl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double copysignl(long double _Number, long double _Sign)
     * }
     */
    public static MemorySegment copysignl$address() {
        return copysignl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double copysignl(long double _Number, long double _Sign)
     * }
     */
    public static double copysignl(double _Number, double _Sign) {
        var mh$ = copysignl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("copysignl", _Number, _Sign);
            }
            return (double)mh$.invokeExact(_Number, _Sign);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class erfl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_DOUBLE,
            Python_h.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("erfl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double erfl(long double _X)
     * }
     */
    public static FunctionDescriptor erfl$descriptor() {
        return erfl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double erfl(long double _X)
     * }
     */
    public static MethodHandle erfl$handle() {
        return erfl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double erfl(long double _X)
     * }
     */
    public static MemorySegment erfl$address() {
        return erfl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double erfl(long double _X)
     * }
     */
    public static double erfl(double _X) {
        var mh$ = erfl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("erfl", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class erfcl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_DOUBLE,
            Python_h.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("erfcl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double erfcl(long double _X)
     * }
     */
    public static FunctionDescriptor erfcl$descriptor() {
        return erfcl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double erfcl(long double _X)
     * }
     */
    public static MethodHandle erfcl$handle() {
        return erfcl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double erfcl(long double _X)
     * }
     */
    public static MemorySegment erfcl$address() {
        return erfcl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double erfcl(long double _X)
     * }
     */
    public static double erfcl(double _X) {
        var mh$ = erfcl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("erfcl", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class exp2l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_DOUBLE,
            Python_h.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("exp2l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double exp2l(long double _X)
     * }
     */
    public static FunctionDescriptor exp2l$descriptor() {
        return exp2l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double exp2l(long double _X)
     * }
     */
    public static MethodHandle exp2l$handle() {
        return exp2l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double exp2l(long double _X)
     * }
     */
    public static MemorySegment exp2l$address() {
        return exp2l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double exp2l(long double _X)
     * }
     */
    public static double exp2l(double _X) {
        var mh$ = exp2l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("exp2l", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class expm1l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_DOUBLE,
            Python_h.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("expm1l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double expm1l(long double _X)
     * }
     */
    public static FunctionDescriptor expm1l$descriptor() {
        return expm1l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double expm1l(long double _X)
     * }
     */
    public static MethodHandle expm1l$handle() {
        return expm1l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double expm1l(long double _X)
     * }
     */
    public static MemorySegment expm1l$address() {
        return expm1l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double expm1l(long double _X)
     * }
     */
    public static double expm1l(double _X) {
        var mh$ = expm1l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("expm1l", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fdiml {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_DOUBLE,
            Python_h.C_LONG_DOUBLE,
            Python_h.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fdiml");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double fdiml(long double _X, long double _Y)
     * }
     */
    public static FunctionDescriptor fdiml$descriptor() {
        return fdiml.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double fdiml(long double _X, long double _Y)
     * }
     */
    public static MethodHandle fdiml$handle() {
        return fdiml.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double fdiml(long double _X, long double _Y)
     * }
     */
    public static MemorySegment fdiml$address() {
        return fdiml.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double fdiml(long double _X, long double _Y)
     * }
     */
    public static double fdiml(double _X, double _Y) {
        var mh$ = fdiml.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fdiml", _X, _Y);
            }
            return (double)mh$.invokeExact(_X, _Y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fmal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_DOUBLE,
            Python_h.C_LONG_DOUBLE,
            Python_h.C_LONG_DOUBLE,
            Python_h.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fmal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double fmal(long double _X, long double _Y, long double _Z)
     * }
     */
    public static FunctionDescriptor fmal$descriptor() {
        return fmal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double fmal(long double _X, long double _Y, long double _Z)
     * }
     */
    public static MethodHandle fmal$handle() {
        return fmal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double fmal(long double _X, long double _Y, long double _Z)
     * }
     */
    public static MemorySegment fmal$address() {
        return fmal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double fmal(long double _X, long double _Y, long double _Z)
     * }
     */
    public static double fmal(double _X, double _Y, double _Z) {
        var mh$ = fmal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fmal", _X, _Y, _Z);
            }
            return (double)mh$.invokeExact(_X, _Y, _Z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fmaxl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_DOUBLE,
            Python_h.C_LONG_DOUBLE,
            Python_h.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fmaxl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double fmaxl(long double _X, long double _Y)
     * }
     */
    public static FunctionDescriptor fmaxl$descriptor() {
        return fmaxl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double fmaxl(long double _X, long double _Y)
     * }
     */
    public static MethodHandle fmaxl$handle() {
        return fmaxl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double fmaxl(long double _X, long double _Y)
     * }
     */
    public static MemorySegment fmaxl$address() {
        return fmaxl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double fmaxl(long double _X, long double _Y)
     * }
     */
    public static double fmaxl(double _X, double _Y) {
        var mh$ = fmaxl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fmaxl", _X, _Y);
            }
            return (double)mh$.invokeExact(_X, _Y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fminl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_DOUBLE,
            Python_h.C_LONG_DOUBLE,
            Python_h.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fminl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double fminl(long double _X, long double _Y)
     * }
     */
    public static FunctionDescriptor fminl$descriptor() {
        return fminl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double fminl(long double _X, long double _Y)
     * }
     */
    public static MethodHandle fminl$handle() {
        return fminl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double fminl(long double _X, long double _Y)
     * }
     */
    public static MemorySegment fminl$address() {
        return fminl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double fminl(long double _X, long double _Y)
     * }
     */
    public static double fminl(double _X, double _Y) {
        var mh$ = fminl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fminl", _X, _Y);
            }
            return (double)mh$.invokeExact(_X, _Y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ilogbl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("ilogbl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ilogbl(long double _X)
     * }
     */
    public static FunctionDescriptor ilogbl$descriptor() {
        return ilogbl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ilogbl(long double _X)
     * }
     */
    public static MethodHandle ilogbl$handle() {
        return ilogbl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ilogbl(long double _X)
     * }
     */
    public static MemorySegment ilogbl$address() {
        return ilogbl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ilogbl(long double _X)
     * }
     */
    public static int ilogbl(double _X) {
        var mh$ = ilogbl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ilogbl", _X);
            }
            return (int)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lgammal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_DOUBLE,
            Python_h.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("lgammal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double lgammal(long double _X)
     * }
     */
    public static FunctionDescriptor lgammal$descriptor() {
        return lgammal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double lgammal(long double _X)
     * }
     */
    public static MethodHandle lgammal$handle() {
        return lgammal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double lgammal(long double _X)
     * }
     */
    public static MemorySegment lgammal$address() {
        return lgammal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double lgammal(long double _X)
     * }
     */
    public static double lgammal(double _X) {
        var mh$ = lgammal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lgammal", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llrintl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("llrintl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long llrintl(long double _X)
     * }
     */
    public static FunctionDescriptor llrintl$descriptor() {
        return llrintl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long llrintl(long double _X)
     * }
     */
    public static MethodHandle llrintl$handle() {
        return llrintl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long llrintl(long double _X)
     * }
     */
    public static MemorySegment llrintl$address() {
        return llrintl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long llrintl(long double _X)
     * }
     */
    public static long llrintl(double _X) {
        var mh$ = llrintl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llrintl", _X);
            }
            return (long)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llroundl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("llroundl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long llroundl(long double _X)
     * }
     */
    public static FunctionDescriptor llroundl$descriptor() {
        return llroundl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long llroundl(long double _X)
     * }
     */
    public static MethodHandle llroundl$handle() {
        return llroundl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long llroundl(long double _X)
     * }
     */
    public static MemorySegment llroundl$address() {
        return llroundl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long llroundl(long double _X)
     * }
     */
    public static long llroundl(double _X) {
        var mh$ = llroundl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llroundl", _X);
            }
            return (long)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class log1pl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_DOUBLE,
            Python_h.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("log1pl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double log1pl(long double _X)
     * }
     */
    public static FunctionDescriptor log1pl$descriptor() {
        return log1pl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double log1pl(long double _X)
     * }
     */
    public static MethodHandle log1pl$handle() {
        return log1pl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double log1pl(long double _X)
     * }
     */
    public static MemorySegment log1pl$address() {
        return log1pl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double log1pl(long double _X)
     * }
     */
    public static double log1pl(double _X) {
        var mh$ = log1pl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("log1pl", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class log2l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_DOUBLE,
            Python_h.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("log2l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double log2l(long double _X)
     * }
     */
    public static FunctionDescriptor log2l$descriptor() {
        return log2l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double log2l(long double _X)
     * }
     */
    public static MethodHandle log2l$handle() {
        return log2l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double log2l(long double _X)
     * }
     */
    public static MemorySegment log2l$address() {
        return log2l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double log2l(long double _X)
     * }
     */
    public static double log2l(double _X) {
        var mh$ = log2l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("log2l", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class logbl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_DOUBLE,
            Python_h.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("logbl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double logbl(long double _X)
     * }
     */
    public static FunctionDescriptor logbl$descriptor() {
        return logbl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double logbl(long double _X)
     * }
     */
    public static MethodHandle logbl$handle() {
        return logbl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double logbl(long double _X)
     * }
     */
    public static MemorySegment logbl$address() {
        return logbl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double logbl(long double _X)
     * }
     */
    public static double logbl(double _X) {
        var mh$ = logbl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("logbl", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lrintl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("lrintl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long lrintl(long double _X)
     * }
     */
    public static FunctionDescriptor lrintl$descriptor() {
        return lrintl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long lrintl(long double _X)
     * }
     */
    public static MethodHandle lrintl$handle() {
        return lrintl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long lrintl(long double _X)
     * }
     */
    public static MemorySegment lrintl$address() {
        return lrintl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long lrintl(long double _X)
     * }
     */
    public static int lrintl(double _X) {
        var mh$ = lrintl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lrintl", _X);
            }
            return (int)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lroundl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("lroundl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long lroundl(long double _X)
     * }
     */
    public static FunctionDescriptor lroundl$descriptor() {
        return lroundl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long lroundl(long double _X)
     * }
     */
    public static MethodHandle lroundl$handle() {
        return lroundl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long lroundl(long double _X)
     * }
     */
    public static MemorySegment lroundl$address() {
        return lroundl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long lroundl(long double _X)
     * }
     */
    public static int lroundl(double _X) {
        var mh$ = lroundl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lroundl", _X);
            }
            return (int)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nanl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_DOUBLE,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("nanl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double nanl(const char *_X)
     * }
     */
    public static FunctionDescriptor nanl$descriptor() {
        return nanl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double nanl(const char *_X)
     * }
     */
    public static MethodHandle nanl$handle() {
        return nanl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double nanl(const char *_X)
     * }
     */
    public static MemorySegment nanl$address() {
        return nanl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double nanl(const char *_X)
     * }
     */
    public static double nanl(MemorySegment _X) {
        var mh$ = nanl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nanl", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nearbyintl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_DOUBLE,
            Python_h.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("nearbyintl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double nearbyintl(long double _X)
     * }
     */
    public static FunctionDescriptor nearbyintl$descriptor() {
        return nearbyintl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double nearbyintl(long double _X)
     * }
     */
    public static MethodHandle nearbyintl$handle() {
        return nearbyintl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double nearbyintl(long double _X)
     * }
     */
    public static MemorySegment nearbyintl$address() {
        return nearbyintl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double nearbyintl(long double _X)
     * }
     */
    public static double nearbyintl(double _X) {
        var mh$ = nearbyintl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nearbyintl", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nextafterl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_DOUBLE,
            Python_h.C_LONG_DOUBLE,
            Python_h.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("nextafterl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double nextafterl(long double _X, long double _Y)
     * }
     */
    public static FunctionDescriptor nextafterl$descriptor() {
        return nextafterl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double nextafterl(long double _X, long double _Y)
     * }
     */
    public static MethodHandle nextafterl$handle() {
        return nextafterl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double nextafterl(long double _X, long double _Y)
     * }
     */
    public static MemorySegment nextafterl$address() {
        return nextafterl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double nextafterl(long double _X, long double _Y)
     * }
     */
    public static double nextafterl(double _X, double _Y) {
        var mh$ = nextafterl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nextafterl", _X, _Y);
            }
            return (double)mh$.invokeExact(_X, _Y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nexttowardl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_DOUBLE,
            Python_h.C_LONG_DOUBLE,
            Python_h.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("nexttowardl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double nexttowardl(long double _X, long double _Y)
     * }
     */
    public static FunctionDescriptor nexttowardl$descriptor() {
        return nexttowardl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double nexttowardl(long double _X, long double _Y)
     * }
     */
    public static MethodHandle nexttowardl$handle() {
        return nexttowardl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double nexttowardl(long double _X, long double _Y)
     * }
     */
    public static MemorySegment nexttowardl$address() {
        return nexttowardl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double nexttowardl(long double _X, long double _Y)
     * }
     */
    public static double nexttowardl(double _X, double _Y) {
        var mh$ = nexttowardl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nexttowardl", _X, _Y);
            }
            return (double)mh$.invokeExact(_X, _Y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class remainderl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_DOUBLE,
            Python_h.C_LONG_DOUBLE,
            Python_h.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("remainderl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double remainderl(long double _X, long double _Y)
     * }
     */
    public static FunctionDescriptor remainderl$descriptor() {
        return remainderl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double remainderl(long double _X, long double _Y)
     * }
     */
    public static MethodHandle remainderl$handle() {
        return remainderl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double remainderl(long double _X, long double _Y)
     * }
     */
    public static MemorySegment remainderl$address() {
        return remainderl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double remainderl(long double _X, long double _Y)
     * }
     */
    public static double remainderl(double _X, double _Y) {
        var mh$ = remainderl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("remainderl", _X, _Y);
            }
            return (double)mh$.invokeExact(_X, _Y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class remquol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_DOUBLE,
            Python_h.C_LONG_DOUBLE,
            Python_h.C_LONG_DOUBLE,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("remquol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double remquol(long double _X, long double _Y, int *_Z)
     * }
     */
    public static FunctionDescriptor remquol$descriptor() {
        return remquol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double remquol(long double _X, long double _Y, int *_Z)
     * }
     */
    public static MethodHandle remquol$handle() {
        return remquol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double remquol(long double _X, long double _Y, int *_Z)
     * }
     */
    public static MemorySegment remquol$address() {
        return remquol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double remquol(long double _X, long double _Y, int *_Z)
     * }
     */
    public static double remquol(double _X, double _Y, MemorySegment _Z) {
        var mh$ = remquol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("remquol", _X, _Y, _Z);
            }
            return (double)mh$.invokeExact(_X, _Y, _Z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rintl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_DOUBLE,
            Python_h.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("rintl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double rintl(long double _X)
     * }
     */
    public static FunctionDescriptor rintl$descriptor() {
        return rintl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double rintl(long double _X)
     * }
     */
    public static MethodHandle rintl$handle() {
        return rintl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double rintl(long double _X)
     * }
     */
    public static MemorySegment rintl$address() {
        return rintl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double rintl(long double _X)
     * }
     */
    public static double rintl(double _X) {
        var mh$ = rintl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rintl", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class roundl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_DOUBLE,
            Python_h.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("roundl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double roundl(long double _X)
     * }
     */
    public static FunctionDescriptor roundl$descriptor() {
        return roundl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double roundl(long double _X)
     * }
     */
    public static MethodHandle roundl$handle() {
        return roundl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double roundl(long double _X)
     * }
     */
    public static MemorySegment roundl$address() {
        return roundl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double roundl(long double _X)
     * }
     */
    public static double roundl(double _X) {
        var mh$ = roundl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("roundl", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class scalblnl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_DOUBLE,
            Python_h.C_LONG_DOUBLE,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("scalblnl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double scalblnl(long double _X, long _Y)
     * }
     */
    public static FunctionDescriptor scalblnl$descriptor() {
        return scalblnl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double scalblnl(long double _X, long _Y)
     * }
     */
    public static MethodHandle scalblnl$handle() {
        return scalblnl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double scalblnl(long double _X, long _Y)
     * }
     */
    public static MemorySegment scalblnl$address() {
        return scalblnl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double scalblnl(long double _X, long _Y)
     * }
     */
    public static double scalblnl(double _X, int _Y) {
        var mh$ = scalblnl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("scalblnl", _X, _Y);
            }
            return (double)mh$.invokeExact(_X, _Y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class scalbnl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_DOUBLE,
            Python_h.C_LONG_DOUBLE,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("scalbnl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double scalbnl(long double _X, int _Y)
     * }
     */
    public static FunctionDescriptor scalbnl$descriptor() {
        return scalbnl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double scalbnl(long double _X, int _Y)
     * }
     */
    public static MethodHandle scalbnl$handle() {
        return scalbnl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double scalbnl(long double _X, int _Y)
     * }
     */
    public static MemorySegment scalbnl$address() {
        return scalbnl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double scalbnl(long double _X, int _Y)
     * }
     */
    public static double scalbnl(double _X, int _Y) {
        var mh$ = scalbnl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("scalbnl", _X, _Y);
            }
            return (double)mh$.invokeExact(_X, _Y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tgammal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_DOUBLE,
            Python_h.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("tgammal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double tgammal(long double _X)
     * }
     */
    public static FunctionDescriptor tgammal$descriptor() {
        return tgammal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double tgammal(long double _X)
     * }
     */
    public static MethodHandle tgammal$handle() {
        return tgammal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double tgammal(long double _X)
     * }
     */
    public static MemorySegment tgammal$address() {
        return tgammal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double tgammal(long double _X)
     * }
     */
    public static double tgammal(double _X) {
        var mh$ = tgammal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tgammal", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class truncl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_DOUBLE,
            Python_h.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("truncl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double truncl(long double _X)
     * }
     */
    public static FunctionDescriptor truncl$descriptor() {
        return truncl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double truncl(long double _X)
     * }
     */
    public static MethodHandle truncl$handle() {
        return truncl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double truncl(long double _X)
     * }
     */
    public static MemorySegment truncl$address() {
        return truncl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double truncl(long double _X)
     * }
     */
    public static double truncl(double _X) {
        var mh$ = truncl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("truncl", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class HUGE$constants {
        public static final OfDouble LAYOUT = Python_h.C_DOUBLE;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("HUGE").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern double HUGE
     * }
     */
    public static OfDouble HUGE$layout() {
        return HUGE$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern double HUGE
     * }
     */
    public static MemorySegment HUGE$segment() {
        return HUGE$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern double HUGE
     * }
     */
    public static double HUGE() {
        return HUGE$constants.SEGMENT.get(HUGE$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern double HUGE
     * }
     */
    public static void HUGE(double varValue) {
        HUGE$constants.SEGMENT.set(HUGE$constants.LAYOUT, 0L, varValue);
    }

    private static class j0 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("j0");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double j0(double _X)
     * }
     */
    public static FunctionDescriptor j0$descriptor() {
        return j0.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double j0(double _X)
     * }
     */
    public static MethodHandle j0$handle() {
        return j0.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double j0(double _X)
     * }
     */
    public static MemorySegment j0$address() {
        return j0.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double j0(double _X)
     * }
     */
    public static double j0(double _X) {
        var mh$ = j0.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("j0", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class j1 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("j1");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double j1(double _X)
     * }
     */
    public static FunctionDescriptor j1$descriptor() {
        return j1.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double j1(double _X)
     * }
     */
    public static MethodHandle j1$handle() {
        return j1.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double j1(double _X)
     * }
     */
    public static MemorySegment j1$address() {
        return j1.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double j1(double _X)
     * }
     */
    public static double j1(double _X) {
        var mh$ = j1.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("j1", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class jn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_INT,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("jn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double jn(int _X, double _Y)
     * }
     */
    public static FunctionDescriptor jn$descriptor() {
        return jn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double jn(int _X, double _Y)
     * }
     */
    public static MethodHandle jn$handle() {
        return jn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double jn(int _X, double _Y)
     * }
     */
    public static MemorySegment jn$address() {
        return jn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double jn(int _X, double _Y)
     * }
     */
    public static double jn(int _X, double _Y) {
        var mh$ = jn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("jn", _X, _Y);
            }
            return (double)mh$.invokeExact(_X, _Y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class y0 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("y0");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double y0(double _X)
     * }
     */
    public static FunctionDescriptor y0$descriptor() {
        return y0.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double y0(double _X)
     * }
     */
    public static MethodHandle y0$handle() {
        return y0.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double y0(double _X)
     * }
     */
    public static MemorySegment y0$address() {
        return y0.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double y0(double _X)
     * }
     */
    public static double y0(double _X) {
        var mh$ = y0.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("y0", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class y1 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("y1");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double y1(double _X)
     * }
     */
    public static FunctionDescriptor y1$descriptor() {
        return y1.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double y1(double _X)
     * }
     */
    public static MethodHandle y1$handle() {
        return y1.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double y1(double _X)
     * }
     */
    public static MemorySegment y1$address() {
        return y1.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double y1(double _X)
     * }
     */
    public static double y1(double _X) {
        var mh$ = y1.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("y1", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class yn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_INT,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("yn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double yn(int _X, double _Y)
     * }
     */
    public static FunctionDescriptor yn$descriptor() {
        return yn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double yn(int _X, double _Y)
     * }
     */
    public static MethodHandle yn$handle() {
        return yn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double yn(int _X, double _Y)
     * }
     */
    public static MemorySegment yn$address() {
        return yn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double yn(int _X, double _Y)
     * }
     */
    public static double yn(int _X, double _Y) {
        var mh$ = yn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("yn", _X, _Y);
            }
            return (double)mh$.invokeExact(_X, _Y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef long clock_t
     * }
     */
    public static final OfInt clock_t = Python_h.C_LONG;

    private static class __daylight {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("__daylight");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int *__daylight()
     * }
     */
    public static FunctionDescriptor __daylight$descriptor() {
        return __daylight.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int *__daylight()
     * }
     */
    public static MethodHandle __daylight$handle() {
        return __daylight.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int *__daylight()
     * }
     */
    public static MemorySegment __daylight$address() {
        return __daylight.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int *__daylight()
     * }
     */
    public static MemorySegment __daylight() {
        var mh$ = __daylight.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__daylight");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __dstbias {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("__dstbias");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long *__dstbias()
     * }
     */
    public static FunctionDescriptor __dstbias$descriptor() {
        return __dstbias.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long *__dstbias()
     * }
     */
    public static MethodHandle __dstbias$handle() {
        return __dstbias.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long *__dstbias()
     * }
     */
    public static MemorySegment __dstbias$address() {
        return __dstbias.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long *__dstbias()
     * }
     */
    public static MemorySegment __dstbias() {
        var mh$ = __dstbias.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__dstbias");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __timezone {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("__timezone");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long *__timezone()
     * }
     */
    public static FunctionDescriptor __timezone$descriptor() {
        return __timezone.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long *__timezone()
     * }
     */
    public static MethodHandle __timezone$handle() {
        return __timezone.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long *__timezone()
     * }
     */
    public static MemorySegment __timezone$address() {
        return __timezone.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long *__timezone()
     * }
     */
    public static MemorySegment __timezone() {
        var mh$ = __timezone.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__timezone");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __tzname {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("__tzname");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char **__tzname()
     * }
     */
    public static FunctionDescriptor __tzname$descriptor() {
        return __tzname.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char **__tzname()
     * }
     */
    public static MethodHandle __tzname$handle() {
        return __tzname.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char **__tzname()
     * }
     */
    public static MemorySegment __tzname$address() {
        return __tzname.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char **__tzname()
     * }
     */
    public static MemorySegment __tzname() {
        var mh$ = __tzname.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__tzname");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _get_daylight {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_get_daylight");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _get_daylight(int *_Daylight)
     * }
     */
    public static FunctionDescriptor _get_daylight$descriptor() {
        return _get_daylight.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _get_daylight(int *_Daylight)
     * }
     */
    public static MethodHandle _get_daylight$handle() {
        return _get_daylight.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _get_daylight(int *_Daylight)
     * }
     */
    public static MemorySegment _get_daylight$address() {
        return _get_daylight.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _get_daylight(int *_Daylight)
     * }
     */
    public static int _get_daylight(MemorySegment _Daylight) {
        var mh$ = _get_daylight.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_get_daylight", _Daylight);
            }
            return (int)mh$.invokeExact(_Daylight);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _get_dstbias {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_get_dstbias");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _get_dstbias(long *_DaylightSavingsBias)
     * }
     */
    public static FunctionDescriptor _get_dstbias$descriptor() {
        return _get_dstbias.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _get_dstbias(long *_DaylightSavingsBias)
     * }
     */
    public static MethodHandle _get_dstbias$handle() {
        return _get_dstbias.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _get_dstbias(long *_DaylightSavingsBias)
     * }
     */
    public static MemorySegment _get_dstbias$address() {
        return _get_dstbias.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _get_dstbias(long *_DaylightSavingsBias)
     * }
     */
    public static int _get_dstbias(MemorySegment _DaylightSavingsBias) {
        var mh$ = _get_dstbias.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_get_dstbias", _DaylightSavingsBias);
            }
            return (int)mh$.invokeExact(_DaylightSavingsBias);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _get_timezone {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_get_timezone");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _get_timezone(long *_TimeZone)
     * }
     */
    public static FunctionDescriptor _get_timezone$descriptor() {
        return _get_timezone.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _get_timezone(long *_TimeZone)
     * }
     */
    public static MethodHandle _get_timezone$handle() {
        return _get_timezone.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _get_timezone(long *_TimeZone)
     * }
     */
    public static MemorySegment _get_timezone$address() {
        return _get_timezone.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _get_timezone(long *_TimeZone)
     * }
     */
    public static int _get_timezone(MemorySegment _TimeZone) {
        var mh$ = _get_timezone.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_get_timezone", _TimeZone);
            }
            return (int)mh$.invokeExact(_TimeZone);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _get_tzname {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_get_tzname");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _get_tzname(size_t *_ReturnValue, char *_Buffer, size_t _SizeInBytes, int _Index)
     * }
     */
    public static FunctionDescriptor _get_tzname$descriptor() {
        return _get_tzname.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _get_tzname(size_t *_ReturnValue, char *_Buffer, size_t _SizeInBytes, int _Index)
     * }
     */
    public static MethodHandle _get_tzname$handle() {
        return _get_tzname.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _get_tzname(size_t *_ReturnValue, char *_Buffer, size_t _SizeInBytes, int _Index)
     * }
     */
    public static MemorySegment _get_tzname$address() {
        return _get_tzname.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _get_tzname(size_t *_ReturnValue, char *_Buffer, size_t _SizeInBytes, int _Index)
     * }
     */
    public static int _get_tzname(MemorySegment _ReturnValue, MemorySegment _Buffer, long _SizeInBytes, int _Index) {
        var mh$ = _get_tzname.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_get_tzname", _ReturnValue, _Buffer, _SizeInBytes, _Index);
            }
            return (int)mh$.invokeExact(_ReturnValue, _Buffer, _SizeInBytes, _Index);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asctime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("asctime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *asctime(const struct tm *_Tm)
     * }
     */
    public static FunctionDescriptor asctime$descriptor() {
        return asctime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *asctime(const struct tm *_Tm)
     * }
     */
    public static MethodHandle asctime$handle() {
        return asctime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *asctime(const struct tm *_Tm)
     * }
     */
    public static MemorySegment asctime$address() {
        return asctime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *asctime(const struct tm *_Tm)
     * }
     */
    public static MemorySegment asctime(MemorySegment _Tm) {
        var mh$ = asctime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("asctime", _Tm);
            }
            return (MemorySegment)mh$.invokeExact(_Tm);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asctime_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("asctime_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t asctime_s(char *_Buffer, size_t _SizeInBytes, const struct tm *_Tm)
     * }
     */
    public static FunctionDescriptor asctime_s$descriptor() {
        return asctime_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t asctime_s(char *_Buffer, size_t _SizeInBytes, const struct tm *_Tm)
     * }
     */
    public static MethodHandle asctime_s$handle() {
        return asctime_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t asctime_s(char *_Buffer, size_t _SizeInBytes, const struct tm *_Tm)
     * }
     */
    public static MemorySegment asctime_s$address() {
        return asctime_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t asctime_s(char *_Buffer, size_t _SizeInBytes, const struct tm *_Tm)
     * }
     */
    public static int asctime_s(MemorySegment _Buffer, long _SizeInBytes, MemorySegment _Tm) {
        var mh$ = asctime_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("asctime_s", _Buffer, _SizeInBytes, _Tm);
            }
            return (int)mh$.invokeExact(_Buffer, _SizeInBytes, _Tm);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("clock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * clock_t clock()
     * }
     */
    public static FunctionDescriptor clock$descriptor() {
        return clock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * clock_t clock()
     * }
     */
    public static MethodHandle clock$handle() {
        return clock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * clock_t clock()
     * }
     */
    public static MemorySegment clock$address() {
        return clock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * clock_t clock()
     * }
     */
    public static int clock() {
        var mh$ = clock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clock");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ctime32 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_ctime32");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *_ctime32(const __time32_t *_Time)
     * }
     */
    public static FunctionDescriptor _ctime32$descriptor() {
        return _ctime32.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *_ctime32(const __time32_t *_Time)
     * }
     */
    public static MethodHandle _ctime32$handle() {
        return _ctime32.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *_ctime32(const __time32_t *_Time)
     * }
     */
    public static MemorySegment _ctime32$address() {
        return _ctime32.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *_ctime32(const __time32_t *_Time)
     * }
     */
    public static MemorySegment _ctime32(MemorySegment _Time) {
        var mh$ = _ctime32.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ctime32", _Time);
            }
            return (MemorySegment)mh$.invokeExact(_Time);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ctime32_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_ctime32_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _ctime32_s(char *_Buffer, size_t _SizeInBytes, const __time32_t *_Time)
     * }
     */
    public static FunctionDescriptor _ctime32_s$descriptor() {
        return _ctime32_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _ctime32_s(char *_Buffer, size_t _SizeInBytes, const __time32_t *_Time)
     * }
     */
    public static MethodHandle _ctime32_s$handle() {
        return _ctime32_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _ctime32_s(char *_Buffer, size_t _SizeInBytes, const __time32_t *_Time)
     * }
     */
    public static MemorySegment _ctime32_s$address() {
        return _ctime32_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _ctime32_s(char *_Buffer, size_t _SizeInBytes, const __time32_t *_Time)
     * }
     */
    public static int _ctime32_s(MemorySegment _Buffer, long _SizeInBytes, MemorySegment _Time) {
        var mh$ = _ctime32_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ctime32_s", _Buffer, _SizeInBytes, _Time);
            }
            return (int)mh$.invokeExact(_Buffer, _SizeInBytes, _Time);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ctime64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_ctime64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *_ctime64(const __time64_t *_Time)
     * }
     */
    public static FunctionDescriptor _ctime64$descriptor() {
        return _ctime64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *_ctime64(const __time64_t *_Time)
     * }
     */
    public static MethodHandle _ctime64$handle() {
        return _ctime64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *_ctime64(const __time64_t *_Time)
     * }
     */
    public static MemorySegment _ctime64$address() {
        return _ctime64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *_ctime64(const __time64_t *_Time)
     * }
     */
    public static MemorySegment _ctime64(MemorySegment _Time) {
        var mh$ = _ctime64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ctime64", _Time);
            }
            return (MemorySegment)mh$.invokeExact(_Time);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ctime64_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_ctime64_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _ctime64_s(char *_Buffer, size_t _SizeInBytes, const __time64_t *_Time)
     * }
     */
    public static FunctionDescriptor _ctime64_s$descriptor() {
        return _ctime64_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _ctime64_s(char *_Buffer, size_t _SizeInBytes, const __time64_t *_Time)
     * }
     */
    public static MethodHandle _ctime64_s$handle() {
        return _ctime64_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _ctime64_s(char *_Buffer, size_t _SizeInBytes, const __time64_t *_Time)
     * }
     */
    public static MemorySegment _ctime64_s$address() {
        return _ctime64_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _ctime64_s(char *_Buffer, size_t _SizeInBytes, const __time64_t *_Time)
     * }
     */
    public static int _ctime64_s(MemorySegment _Buffer, long _SizeInBytes, MemorySegment _Time) {
        var mh$ = _ctime64_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ctime64_s", _Buffer, _SizeInBytes, _Time);
            }
            return (int)mh$.invokeExact(_Buffer, _SizeInBytes, _Time);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _difftime32 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_LONG,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_difftime32");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double _difftime32(__time32_t _Time1, __time32_t _Time2)
     * }
     */
    public static FunctionDescriptor _difftime32$descriptor() {
        return _difftime32.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double _difftime32(__time32_t _Time1, __time32_t _Time2)
     * }
     */
    public static MethodHandle _difftime32$handle() {
        return _difftime32.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double _difftime32(__time32_t _Time1, __time32_t _Time2)
     * }
     */
    public static MemorySegment _difftime32$address() {
        return _difftime32.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double _difftime32(__time32_t _Time1, __time32_t _Time2)
     * }
     */
    public static double _difftime32(int _Time1, int _Time2) {
        var mh$ = _difftime32.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_difftime32", _Time1, _Time2);
            }
            return (double)mh$.invokeExact(_Time1, _Time2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _difftime64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_LONG_LONG,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_difftime64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double _difftime64(__time64_t _Time1, __time64_t _Time2)
     * }
     */
    public static FunctionDescriptor _difftime64$descriptor() {
        return _difftime64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double _difftime64(__time64_t _Time1, __time64_t _Time2)
     * }
     */
    public static MethodHandle _difftime64$handle() {
        return _difftime64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double _difftime64(__time64_t _Time1, __time64_t _Time2)
     * }
     */
    public static MemorySegment _difftime64$address() {
        return _difftime64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double _difftime64(__time64_t _Time1, __time64_t _Time2)
     * }
     */
    public static double _difftime64(long _Time1, long _Time2) {
        var mh$ = _difftime64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_difftime64", _Time1, _Time2);
            }
            return (double)mh$.invokeExact(_Time1, _Time2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _gmtime32 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_gmtime32");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct tm *_gmtime32(const __time32_t *_Time)
     * }
     */
    public static FunctionDescriptor _gmtime32$descriptor() {
        return _gmtime32.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct tm *_gmtime32(const __time32_t *_Time)
     * }
     */
    public static MethodHandle _gmtime32$handle() {
        return _gmtime32.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct tm *_gmtime32(const __time32_t *_Time)
     * }
     */
    public static MemorySegment _gmtime32$address() {
        return _gmtime32.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct tm *_gmtime32(const __time32_t *_Time)
     * }
     */
    public static MemorySegment _gmtime32(MemorySegment _Time) {
        var mh$ = _gmtime32.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_gmtime32", _Time);
            }
            return (MemorySegment)mh$.invokeExact(_Time);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _gmtime32_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_gmtime32_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _gmtime32_s(struct tm *_Tm, const __time32_t *_Time)
     * }
     */
    public static FunctionDescriptor _gmtime32_s$descriptor() {
        return _gmtime32_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _gmtime32_s(struct tm *_Tm, const __time32_t *_Time)
     * }
     */
    public static MethodHandle _gmtime32_s$handle() {
        return _gmtime32_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _gmtime32_s(struct tm *_Tm, const __time32_t *_Time)
     * }
     */
    public static MemorySegment _gmtime32_s$address() {
        return _gmtime32_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _gmtime32_s(struct tm *_Tm, const __time32_t *_Time)
     * }
     */
    public static int _gmtime32_s(MemorySegment _Tm, MemorySegment _Time) {
        var mh$ = _gmtime32_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_gmtime32_s", _Tm, _Time);
            }
            return (int)mh$.invokeExact(_Tm, _Time);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _gmtime64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_gmtime64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct tm *_gmtime64(const __time64_t *_Time)
     * }
     */
    public static FunctionDescriptor _gmtime64$descriptor() {
        return _gmtime64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct tm *_gmtime64(const __time64_t *_Time)
     * }
     */
    public static MethodHandle _gmtime64$handle() {
        return _gmtime64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct tm *_gmtime64(const __time64_t *_Time)
     * }
     */
    public static MemorySegment _gmtime64$address() {
        return _gmtime64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct tm *_gmtime64(const __time64_t *_Time)
     * }
     */
    public static MemorySegment _gmtime64(MemorySegment _Time) {
        var mh$ = _gmtime64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_gmtime64", _Time);
            }
            return (MemorySegment)mh$.invokeExact(_Time);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _gmtime64_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_gmtime64_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _gmtime64_s(struct tm *_Tm, const __time64_t *_Time)
     * }
     */
    public static FunctionDescriptor _gmtime64_s$descriptor() {
        return _gmtime64_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _gmtime64_s(struct tm *_Tm, const __time64_t *_Time)
     * }
     */
    public static MethodHandle _gmtime64_s$handle() {
        return _gmtime64_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _gmtime64_s(struct tm *_Tm, const __time64_t *_Time)
     * }
     */
    public static MemorySegment _gmtime64_s$address() {
        return _gmtime64_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _gmtime64_s(struct tm *_Tm, const __time64_t *_Time)
     * }
     */
    public static int _gmtime64_s(MemorySegment _Tm, MemorySegment _Time) {
        var mh$ = _gmtime64_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_gmtime64_s", _Tm, _Time);
            }
            return (int)mh$.invokeExact(_Tm, _Time);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _localtime32 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_localtime32");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct tm *_localtime32(const __time32_t *_Time)
     * }
     */
    public static FunctionDescriptor _localtime32$descriptor() {
        return _localtime32.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct tm *_localtime32(const __time32_t *_Time)
     * }
     */
    public static MethodHandle _localtime32$handle() {
        return _localtime32.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct tm *_localtime32(const __time32_t *_Time)
     * }
     */
    public static MemorySegment _localtime32$address() {
        return _localtime32.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct tm *_localtime32(const __time32_t *_Time)
     * }
     */
    public static MemorySegment _localtime32(MemorySegment _Time) {
        var mh$ = _localtime32.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_localtime32", _Time);
            }
            return (MemorySegment)mh$.invokeExact(_Time);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _localtime32_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_localtime32_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _localtime32_s(struct tm *_Tm, const __time32_t *_Time)
     * }
     */
    public static FunctionDescriptor _localtime32_s$descriptor() {
        return _localtime32_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _localtime32_s(struct tm *_Tm, const __time32_t *_Time)
     * }
     */
    public static MethodHandle _localtime32_s$handle() {
        return _localtime32_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _localtime32_s(struct tm *_Tm, const __time32_t *_Time)
     * }
     */
    public static MemorySegment _localtime32_s$address() {
        return _localtime32_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _localtime32_s(struct tm *_Tm, const __time32_t *_Time)
     * }
     */
    public static int _localtime32_s(MemorySegment _Tm, MemorySegment _Time) {
        var mh$ = _localtime32_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_localtime32_s", _Tm, _Time);
            }
            return (int)mh$.invokeExact(_Tm, _Time);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _localtime64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_localtime64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct tm *_localtime64(const __time64_t *_Time)
     * }
     */
    public static FunctionDescriptor _localtime64$descriptor() {
        return _localtime64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct tm *_localtime64(const __time64_t *_Time)
     * }
     */
    public static MethodHandle _localtime64$handle() {
        return _localtime64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct tm *_localtime64(const __time64_t *_Time)
     * }
     */
    public static MemorySegment _localtime64$address() {
        return _localtime64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct tm *_localtime64(const __time64_t *_Time)
     * }
     */
    public static MemorySegment _localtime64(MemorySegment _Time) {
        var mh$ = _localtime64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_localtime64", _Time);
            }
            return (MemorySegment)mh$.invokeExact(_Time);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _localtime64_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_localtime64_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _localtime64_s(struct tm *_Tm, const __time64_t *_Time)
     * }
     */
    public static FunctionDescriptor _localtime64_s$descriptor() {
        return _localtime64_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _localtime64_s(struct tm *_Tm, const __time64_t *_Time)
     * }
     */
    public static MethodHandle _localtime64_s$handle() {
        return _localtime64_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _localtime64_s(struct tm *_Tm, const __time64_t *_Time)
     * }
     */
    public static MemorySegment _localtime64_s$address() {
        return _localtime64_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _localtime64_s(struct tm *_Tm, const __time64_t *_Time)
     * }
     */
    public static int _localtime64_s(MemorySegment _Tm, MemorySegment _Time) {
        var mh$ = _localtime64_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_localtime64_s", _Tm, _Time);
            }
            return (int)mh$.invokeExact(_Tm, _Time);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _mkgmtime32 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_mkgmtime32");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * __time32_t _mkgmtime32(struct tm *_Tm)
     * }
     */
    public static FunctionDescriptor _mkgmtime32$descriptor() {
        return _mkgmtime32.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * __time32_t _mkgmtime32(struct tm *_Tm)
     * }
     */
    public static MethodHandle _mkgmtime32$handle() {
        return _mkgmtime32.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * __time32_t _mkgmtime32(struct tm *_Tm)
     * }
     */
    public static MemorySegment _mkgmtime32$address() {
        return _mkgmtime32.ADDR;
    }

    /**
     * {@snippet lang=c :
     * __time32_t _mkgmtime32(struct tm *_Tm)
     * }
     */
    public static int _mkgmtime32(MemorySegment _Tm) {
        var mh$ = _mkgmtime32.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_mkgmtime32", _Tm);
            }
            return (int)mh$.invokeExact(_Tm);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _mkgmtime64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_mkgmtime64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * __time64_t _mkgmtime64(struct tm *_Tm)
     * }
     */
    public static FunctionDescriptor _mkgmtime64$descriptor() {
        return _mkgmtime64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * __time64_t _mkgmtime64(struct tm *_Tm)
     * }
     */
    public static MethodHandle _mkgmtime64$handle() {
        return _mkgmtime64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * __time64_t _mkgmtime64(struct tm *_Tm)
     * }
     */
    public static MemorySegment _mkgmtime64$address() {
        return _mkgmtime64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * __time64_t _mkgmtime64(struct tm *_Tm)
     * }
     */
    public static long _mkgmtime64(MemorySegment _Tm) {
        var mh$ = _mkgmtime64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_mkgmtime64", _Tm);
            }
            return (long)mh$.invokeExact(_Tm);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _mktime32 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_mktime32");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * __time32_t _mktime32(struct tm *_Tm)
     * }
     */
    public static FunctionDescriptor _mktime32$descriptor() {
        return _mktime32.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * __time32_t _mktime32(struct tm *_Tm)
     * }
     */
    public static MethodHandle _mktime32$handle() {
        return _mktime32.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * __time32_t _mktime32(struct tm *_Tm)
     * }
     */
    public static MemorySegment _mktime32$address() {
        return _mktime32.ADDR;
    }

    /**
     * {@snippet lang=c :
     * __time32_t _mktime32(struct tm *_Tm)
     * }
     */
    public static int _mktime32(MemorySegment _Tm) {
        var mh$ = _mktime32.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_mktime32", _Tm);
            }
            return (int)mh$.invokeExact(_Tm);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _mktime64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_mktime64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * __time64_t _mktime64(struct tm *_Tm)
     * }
     */
    public static FunctionDescriptor _mktime64$descriptor() {
        return _mktime64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * __time64_t _mktime64(struct tm *_Tm)
     * }
     */
    public static MethodHandle _mktime64$handle() {
        return _mktime64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * __time64_t _mktime64(struct tm *_Tm)
     * }
     */
    public static MemorySegment _mktime64$address() {
        return _mktime64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * __time64_t _mktime64(struct tm *_Tm)
     * }
     */
    public static long _mktime64(MemorySegment _Tm) {
        var mh$ = _mktime64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_mktime64", _Tm);
            }
            return (long)mh$.invokeExact(_Tm);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strftime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("strftime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t strftime(char *_Buffer, size_t _SizeInBytes, const char *_Format, const struct tm *_Tm)
     * }
     */
    public static FunctionDescriptor strftime$descriptor() {
        return strftime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t strftime(char *_Buffer, size_t _SizeInBytes, const char *_Format, const struct tm *_Tm)
     * }
     */
    public static MethodHandle strftime$handle() {
        return strftime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t strftime(char *_Buffer, size_t _SizeInBytes, const char *_Format, const struct tm *_Tm)
     * }
     */
    public static MemorySegment strftime$address() {
        return strftime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t strftime(char *_Buffer, size_t _SizeInBytes, const char *_Format, const struct tm *_Tm)
     * }
     */
    public static long strftime(MemorySegment _Buffer, long _SizeInBytes, MemorySegment _Format, MemorySegment _Tm) {
        var mh$ = strftime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strftime", _Buffer, _SizeInBytes, _Format, _Tm);
            }
            return (long)mh$.invokeExact(_Buffer, _SizeInBytes, _Format, _Tm);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strftime_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_strftime_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t _strftime_l(char *_Buffer, size_t _MaxSize, const char *_Format, const struct tm *_Tm, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _strftime_l$descriptor() {
        return _strftime_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t _strftime_l(char *_Buffer, size_t _MaxSize, const char *_Format, const struct tm *_Tm, _locale_t _Locale)
     * }
     */
    public static MethodHandle _strftime_l$handle() {
        return _strftime_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t _strftime_l(char *_Buffer, size_t _MaxSize, const char *_Format, const struct tm *_Tm, _locale_t _Locale)
     * }
     */
    public static MemorySegment _strftime_l$address() {
        return _strftime_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t _strftime_l(char *_Buffer, size_t _MaxSize, const char *_Format, const struct tm *_Tm, _locale_t _Locale)
     * }
     */
    public static long _strftime_l(MemorySegment _Buffer, long _MaxSize, MemorySegment _Format, MemorySegment _Tm, MemorySegment _Locale) {
        var mh$ = _strftime_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strftime_l", _Buffer, _MaxSize, _Format, _Tm, _Locale);
            }
            return (long)mh$.invokeExact(_Buffer, _MaxSize, _Format, _Tm, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strdate_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_strdate_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _strdate_s(char *_Buffer, size_t _SizeInBytes)
     * }
     */
    public static FunctionDescriptor _strdate_s$descriptor() {
        return _strdate_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _strdate_s(char *_Buffer, size_t _SizeInBytes)
     * }
     */
    public static MethodHandle _strdate_s$handle() {
        return _strdate_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _strdate_s(char *_Buffer, size_t _SizeInBytes)
     * }
     */
    public static MemorySegment _strdate_s$address() {
        return _strdate_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _strdate_s(char *_Buffer, size_t _SizeInBytes)
     * }
     */
    public static int _strdate_s(MemorySegment _Buffer, long _SizeInBytes) {
        var mh$ = _strdate_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strdate_s", _Buffer, _SizeInBytes);
            }
            return (int)mh$.invokeExact(_Buffer, _SizeInBytes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strdate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_strdate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *_strdate(char *_Buffer)
     * }
     */
    public static FunctionDescriptor _strdate$descriptor() {
        return _strdate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *_strdate(char *_Buffer)
     * }
     */
    public static MethodHandle _strdate$handle() {
        return _strdate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *_strdate(char *_Buffer)
     * }
     */
    public static MemorySegment _strdate$address() {
        return _strdate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *_strdate(char *_Buffer)
     * }
     */
    public static MemorySegment _strdate(MemorySegment _Buffer) {
        var mh$ = _strdate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strdate", _Buffer);
            }
            return (MemorySegment)mh$.invokeExact(_Buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strtime_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_strtime_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _strtime_s(char *_Buffer, size_t _SizeInBytes)
     * }
     */
    public static FunctionDescriptor _strtime_s$descriptor() {
        return _strtime_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _strtime_s(char *_Buffer, size_t _SizeInBytes)
     * }
     */
    public static MethodHandle _strtime_s$handle() {
        return _strtime_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _strtime_s(char *_Buffer, size_t _SizeInBytes)
     * }
     */
    public static MemorySegment _strtime_s$address() {
        return _strtime_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _strtime_s(char *_Buffer, size_t _SizeInBytes)
     * }
     */
    public static int _strtime_s(MemorySegment _Buffer, long _SizeInBytes) {
        var mh$ = _strtime_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strtime_s", _Buffer, _SizeInBytes);
            }
            return (int)mh$.invokeExact(_Buffer, _SizeInBytes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strtime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_strtime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *_strtime(char *_Buffer)
     * }
     */
    public static FunctionDescriptor _strtime$descriptor() {
        return _strtime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *_strtime(char *_Buffer)
     * }
     */
    public static MethodHandle _strtime$handle() {
        return _strtime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *_strtime(char *_Buffer)
     * }
     */
    public static MemorySegment _strtime$address() {
        return _strtime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *_strtime(char *_Buffer)
     * }
     */
    public static MemorySegment _strtime(MemorySegment _Buffer) {
        var mh$ = _strtime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strtime", _Buffer);
            }
            return (MemorySegment)mh$.invokeExact(_Buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _time32 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_time32");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * __time32_t _time32(__time32_t *_Time)
     * }
     */
    public static FunctionDescriptor _time32$descriptor() {
        return _time32.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * __time32_t _time32(__time32_t *_Time)
     * }
     */
    public static MethodHandle _time32$handle() {
        return _time32.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * __time32_t _time32(__time32_t *_Time)
     * }
     */
    public static MemorySegment _time32$address() {
        return _time32.ADDR;
    }

    /**
     * {@snippet lang=c :
     * __time32_t _time32(__time32_t *_Time)
     * }
     */
    public static int _time32(MemorySegment _Time) {
        var mh$ = _time32.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_time32", _Time);
            }
            return (int)mh$.invokeExact(_Time);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _time64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_time64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * __time64_t _time64(__time64_t *_Time)
     * }
     */
    public static FunctionDescriptor _time64$descriptor() {
        return _time64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * __time64_t _time64(__time64_t *_Time)
     * }
     */
    public static MethodHandle _time64$handle() {
        return _time64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * __time64_t _time64(__time64_t *_Time)
     * }
     */
    public static MemorySegment _time64$address() {
        return _time64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * __time64_t _time64(__time64_t *_Time)
     * }
     */
    public static long _time64(MemorySegment _Time) {
        var mh$ = _time64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_time64", _Time);
            }
            return (long)mh$.invokeExact(_Time);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _timespec32_get {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_timespec32_get");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _timespec32_get(struct _timespec32 *_Ts, int _Base)
     * }
     */
    public static FunctionDescriptor _timespec32_get$descriptor() {
        return _timespec32_get.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _timespec32_get(struct _timespec32 *_Ts, int _Base)
     * }
     */
    public static MethodHandle _timespec32_get$handle() {
        return _timespec32_get.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _timespec32_get(struct _timespec32 *_Ts, int _Base)
     * }
     */
    public static MemorySegment _timespec32_get$address() {
        return _timespec32_get.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _timespec32_get(struct _timespec32 *_Ts, int _Base)
     * }
     */
    public static int _timespec32_get(MemorySegment _Ts, int _Base) {
        var mh$ = _timespec32_get.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_timespec32_get", _Ts, _Base);
            }
            return (int)mh$.invokeExact(_Ts, _Base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _timespec64_get {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_timespec64_get");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _timespec64_get(struct _timespec64 *_Ts, int _Base)
     * }
     */
    public static FunctionDescriptor _timespec64_get$descriptor() {
        return _timespec64_get.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _timespec64_get(struct _timespec64 *_Ts, int _Base)
     * }
     */
    public static MethodHandle _timespec64_get$handle() {
        return _timespec64_get.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _timespec64_get(struct _timespec64 *_Ts, int _Base)
     * }
     */
    public static MemorySegment _timespec64_get$address() {
        return _timespec64_get.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _timespec64_get(struct _timespec64 *_Ts, int _Base)
     * }
     */
    public static int _timespec64_get(MemorySegment _Ts, int _Base) {
        var mh$ = _timespec64_get.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_timespec64_get", _Ts, _Base);
            }
            return (int)mh$.invokeExact(_Ts, _Base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _tzset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_tzset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _tzset()
     * }
     */
    public static FunctionDescriptor _tzset$descriptor() {
        return _tzset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _tzset()
     * }
     */
    public static MethodHandle _tzset$handle() {
        return _tzset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _tzset()
     * }
     */
    public static MemorySegment _tzset$address() {
        return _tzset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _tzset()
     * }
     */
    public static void _tzset() {
        var mh$ = _tzset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_tzset");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _getsystime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_getsystime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int _getsystime(struct tm *_Tm)
     * }
     */
    public static FunctionDescriptor _getsystime$descriptor() {
        return _getsystime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int _getsystime(struct tm *_Tm)
     * }
     */
    public static MethodHandle _getsystime$handle() {
        return _getsystime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int _getsystime(struct tm *_Tm)
     * }
     */
    public static MemorySegment _getsystime$address() {
        return _getsystime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int _getsystime(struct tm *_Tm)
     * }
     */
    public static int _getsystime(MemorySegment _Tm) {
        var mh$ = _getsystime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_getsystime", _Tm);
            }
            return (int)mh$.invokeExact(_Tm);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _setsystime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_setsystime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int _setsystime(struct tm *_Tm, unsigned int _Milliseconds)
     * }
     */
    public static FunctionDescriptor _setsystime$descriptor() {
        return _setsystime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int _setsystime(struct tm *_Tm, unsigned int _Milliseconds)
     * }
     */
    public static MethodHandle _setsystime$handle() {
        return _setsystime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int _setsystime(struct tm *_Tm, unsigned int _Milliseconds)
     * }
     */
    public static MemorySegment _setsystime$address() {
        return _setsystime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int _setsystime(struct tm *_Tm, unsigned int _Milliseconds)
     * }
     */
    public static int _setsystime(MemorySegment _Tm, int _Milliseconds) {
        var mh$ = _setsystime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_setsystime", _Tm, _Milliseconds);
            }
            return (int)mh$.invokeExact(_Tm, _Milliseconds);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tzset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("tzset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void tzset()
     * }
     */
    public static FunctionDescriptor tzset$descriptor() {
        return tzset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void tzset()
     * }
     */
    public static MethodHandle tzset$handle() {
        return tzset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void tzset()
     * }
     */
    public static MemorySegment tzset$address() {
        return tzset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void tzset()
     * }
     */
    public static void tzset() {
        var mh$ = tzset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tzset");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyMem_Malloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyMem_Malloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *PyMem_Malloc(size_t size)
     * }
     */
    public static FunctionDescriptor PyMem_Malloc$descriptor() {
        return PyMem_Malloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *PyMem_Malloc(size_t size)
     * }
     */
    public static MethodHandle PyMem_Malloc$handle() {
        return PyMem_Malloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *PyMem_Malloc(size_t size)
     * }
     */
    public static MemorySegment PyMem_Malloc$address() {
        return PyMem_Malloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *PyMem_Malloc(size_t size)
     * }
     */
    public static MemorySegment PyMem_Malloc(long size) {
        var mh$ = PyMem_Malloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyMem_Malloc", size);
            }
            return (MemorySegment)mh$.invokeExact(size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyMem_Calloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyMem_Calloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *PyMem_Calloc(size_t nelem, size_t elsize)
     * }
     */
    public static FunctionDescriptor PyMem_Calloc$descriptor() {
        return PyMem_Calloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *PyMem_Calloc(size_t nelem, size_t elsize)
     * }
     */
    public static MethodHandle PyMem_Calloc$handle() {
        return PyMem_Calloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *PyMem_Calloc(size_t nelem, size_t elsize)
     * }
     */
    public static MemorySegment PyMem_Calloc$address() {
        return PyMem_Calloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *PyMem_Calloc(size_t nelem, size_t elsize)
     * }
     */
    public static MemorySegment PyMem_Calloc(long nelem, long elsize) {
        var mh$ = PyMem_Calloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyMem_Calloc", nelem, elsize);
            }
            return (MemorySegment)mh$.invokeExact(nelem, elsize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyMem_Realloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyMem_Realloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *PyMem_Realloc(void *ptr, size_t new_size)
     * }
     */
    public static FunctionDescriptor PyMem_Realloc$descriptor() {
        return PyMem_Realloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *PyMem_Realloc(void *ptr, size_t new_size)
     * }
     */
    public static MethodHandle PyMem_Realloc$handle() {
        return PyMem_Realloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *PyMem_Realloc(void *ptr, size_t new_size)
     * }
     */
    public static MemorySegment PyMem_Realloc$address() {
        return PyMem_Realloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *PyMem_Realloc(void *ptr, size_t new_size)
     * }
     */
    public static MemorySegment PyMem_Realloc(MemorySegment ptr, long new_size) {
        var mh$ = PyMem_Realloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyMem_Realloc", ptr, new_size);
            }
            return (MemorySegment)mh$.invokeExact(ptr, new_size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyMem_Free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyMem_Free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyMem_Free(void *ptr)
     * }
     */
    public static FunctionDescriptor PyMem_Free$descriptor() {
        return PyMem_Free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyMem_Free(void *ptr)
     * }
     */
    public static MethodHandle PyMem_Free$handle() {
        return PyMem_Free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyMem_Free(void *ptr)
     * }
     */
    public static MemorySegment PyMem_Free$address() {
        return PyMem_Free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyMem_Free(void *ptr)
     * }
     */
    public static void PyMem_Free(MemorySegment ptr) {
        var mh$ = PyMem_Free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyMem_Free", ptr);
            }
            mh$.invokeExact(ptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_CheckBuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_CheckBuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyObject_CheckBuffer(PyObject *obj)
     * }
     */
    public static FunctionDescriptor PyObject_CheckBuffer$descriptor() {
        return PyObject_CheckBuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyObject_CheckBuffer(PyObject *obj)
     * }
     */
    public static MethodHandle PyObject_CheckBuffer$handle() {
        return PyObject_CheckBuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyObject_CheckBuffer(PyObject *obj)
     * }
     */
    public static MemorySegment PyObject_CheckBuffer$address() {
        return PyObject_CheckBuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyObject_CheckBuffer(PyObject *obj)
     * }
     */
    public static int PyObject_CheckBuffer(MemorySegment obj) {
        var mh$ = PyObject_CheckBuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_CheckBuffer", obj);
            }
            return (int)mh$.invokeExact(obj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_GetBuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_GetBuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyObject_GetBuffer(PyObject *obj, Py_buffer *view, int flags)
     * }
     */
    public static FunctionDescriptor PyObject_GetBuffer$descriptor() {
        return PyObject_GetBuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyObject_GetBuffer(PyObject *obj, Py_buffer *view, int flags)
     * }
     */
    public static MethodHandle PyObject_GetBuffer$handle() {
        return PyObject_GetBuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyObject_GetBuffer(PyObject *obj, Py_buffer *view, int flags)
     * }
     */
    public static MemorySegment PyObject_GetBuffer$address() {
        return PyObject_GetBuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyObject_GetBuffer(PyObject *obj, Py_buffer *view, int flags)
     * }
     */
    public static int PyObject_GetBuffer(MemorySegment obj, MemorySegment view, int flags) {
        var mh$ = PyObject_GetBuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_GetBuffer", obj, view, flags);
            }
            return (int)mh$.invokeExact(obj, view, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyBuffer_GetPointer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyBuffer_GetPointer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *PyBuffer_GetPointer(const Py_buffer *view, const Py_ssize_t *indices)
     * }
     */
    public static FunctionDescriptor PyBuffer_GetPointer$descriptor() {
        return PyBuffer_GetPointer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *PyBuffer_GetPointer(const Py_buffer *view, const Py_ssize_t *indices)
     * }
     */
    public static MethodHandle PyBuffer_GetPointer$handle() {
        return PyBuffer_GetPointer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *PyBuffer_GetPointer(const Py_buffer *view, const Py_ssize_t *indices)
     * }
     */
    public static MemorySegment PyBuffer_GetPointer$address() {
        return PyBuffer_GetPointer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *PyBuffer_GetPointer(const Py_buffer *view, const Py_ssize_t *indices)
     * }
     */
    public static MemorySegment PyBuffer_GetPointer(MemorySegment view, MemorySegment indices) {
        var mh$ = PyBuffer_GetPointer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyBuffer_GetPointer", view, indices);
            }
            return (MemorySegment)mh$.invokeExact(view, indices);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyBuffer_SizeFromFormat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyBuffer_SizeFromFormat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_ssize_t PyBuffer_SizeFromFormat(const char *format)
     * }
     */
    public static FunctionDescriptor PyBuffer_SizeFromFormat$descriptor() {
        return PyBuffer_SizeFromFormat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_ssize_t PyBuffer_SizeFromFormat(const char *format)
     * }
     */
    public static MethodHandle PyBuffer_SizeFromFormat$handle() {
        return PyBuffer_SizeFromFormat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_ssize_t PyBuffer_SizeFromFormat(const char *format)
     * }
     */
    public static MemorySegment PyBuffer_SizeFromFormat$address() {
        return PyBuffer_SizeFromFormat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_ssize_t PyBuffer_SizeFromFormat(const char *format)
     * }
     */
    public static long PyBuffer_SizeFromFormat(MemorySegment format) {
        var mh$ = PyBuffer_SizeFromFormat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyBuffer_SizeFromFormat", format);
            }
            return (long)mh$.invokeExact(format);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyBuffer_ToContiguous {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_CHAR
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyBuffer_ToContiguous");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyBuffer_ToContiguous(void *buf, const Py_buffer *view, Py_ssize_t len, char order)
     * }
     */
    public static FunctionDescriptor PyBuffer_ToContiguous$descriptor() {
        return PyBuffer_ToContiguous.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyBuffer_ToContiguous(void *buf, const Py_buffer *view, Py_ssize_t len, char order)
     * }
     */
    public static MethodHandle PyBuffer_ToContiguous$handle() {
        return PyBuffer_ToContiguous.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyBuffer_ToContiguous(void *buf, const Py_buffer *view, Py_ssize_t len, char order)
     * }
     */
    public static MemorySegment PyBuffer_ToContiguous$address() {
        return PyBuffer_ToContiguous.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyBuffer_ToContiguous(void *buf, const Py_buffer *view, Py_ssize_t len, char order)
     * }
     */
    public static int PyBuffer_ToContiguous(MemorySegment buf, MemorySegment view, long len, byte order) {
        var mh$ = PyBuffer_ToContiguous.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyBuffer_ToContiguous", buf, view, len, order);
            }
            return (int)mh$.invokeExact(buf, view, len, order);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyBuffer_FromContiguous {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_CHAR
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyBuffer_FromContiguous");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyBuffer_FromContiguous(const Py_buffer *view, const void *buf, Py_ssize_t len, char order)
     * }
     */
    public static FunctionDescriptor PyBuffer_FromContiguous$descriptor() {
        return PyBuffer_FromContiguous.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyBuffer_FromContiguous(const Py_buffer *view, const void *buf, Py_ssize_t len, char order)
     * }
     */
    public static MethodHandle PyBuffer_FromContiguous$handle() {
        return PyBuffer_FromContiguous.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyBuffer_FromContiguous(const Py_buffer *view, const void *buf, Py_ssize_t len, char order)
     * }
     */
    public static MemorySegment PyBuffer_FromContiguous$address() {
        return PyBuffer_FromContiguous.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyBuffer_FromContiguous(const Py_buffer *view, const void *buf, Py_ssize_t len, char order)
     * }
     */
    public static int PyBuffer_FromContiguous(MemorySegment view, MemorySegment buf, long len, byte order) {
        var mh$ = PyBuffer_FromContiguous.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyBuffer_FromContiguous", view, buf, len, order);
            }
            return (int)mh$.invokeExact(view, buf, len, order);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_CopyData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_CopyData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyObject_CopyData(PyObject *dest, PyObject *src)
     * }
     */
    public static FunctionDescriptor PyObject_CopyData$descriptor() {
        return PyObject_CopyData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyObject_CopyData(PyObject *dest, PyObject *src)
     * }
     */
    public static MethodHandle PyObject_CopyData$handle() {
        return PyObject_CopyData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyObject_CopyData(PyObject *dest, PyObject *src)
     * }
     */
    public static MemorySegment PyObject_CopyData$address() {
        return PyObject_CopyData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyObject_CopyData(PyObject *dest, PyObject *src)
     * }
     */
    public static int PyObject_CopyData(MemorySegment dest, MemorySegment src) {
        var mh$ = PyObject_CopyData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_CopyData", dest, src);
            }
            return (int)mh$.invokeExact(dest, src);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyBuffer_IsContiguous {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_CHAR
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyBuffer_IsContiguous");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyBuffer_IsContiguous(const Py_buffer *view, char fort)
     * }
     */
    public static FunctionDescriptor PyBuffer_IsContiguous$descriptor() {
        return PyBuffer_IsContiguous.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyBuffer_IsContiguous(const Py_buffer *view, char fort)
     * }
     */
    public static MethodHandle PyBuffer_IsContiguous$handle() {
        return PyBuffer_IsContiguous.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyBuffer_IsContiguous(const Py_buffer *view, char fort)
     * }
     */
    public static MemorySegment PyBuffer_IsContiguous$address() {
        return PyBuffer_IsContiguous.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyBuffer_IsContiguous(const Py_buffer *view, char fort)
     * }
     */
    public static int PyBuffer_IsContiguous(MemorySegment view, byte fort) {
        var mh$ = PyBuffer_IsContiguous.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyBuffer_IsContiguous", view, fort);
            }
            return (int)mh$.invokeExact(view, fort);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyBuffer_FillContiguousStrides {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_CHAR
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyBuffer_FillContiguousStrides");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyBuffer_FillContiguousStrides(int ndims, Py_ssize_t *shape, Py_ssize_t *strides, int itemsize, char fort)
     * }
     */
    public static FunctionDescriptor PyBuffer_FillContiguousStrides$descriptor() {
        return PyBuffer_FillContiguousStrides.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyBuffer_FillContiguousStrides(int ndims, Py_ssize_t *shape, Py_ssize_t *strides, int itemsize, char fort)
     * }
     */
    public static MethodHandle PyBuffer_FillContiguousStrides$handle() {
        return PyBuffer_FillContiguousStrides.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyBuffer_FillContiguousStrides(int ndims, Py_ssize_t *shape, Py_ssize_t *strides, int itemsize, char fort)
     * }
     */
    public static MemorySegment PyBuffer_FillContiguousStrides$address() {
        return PyBuffer_FillContiguousStrides.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyBuffer_FillContiguousStrides(int ndims, Py_ssize_t *shape, Py_ssize_t *strides, int itemsize, char fort)
     * }
     */
    public static void PyBuffer_FillContiguousStrides(int ndims, MemorySegment shape, MemorySegment strides, int itemsize, byte fort) {
        var mh$ = PyBuffer_FillContiguousStrides.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyBuffer_FillContiguousStrides", ndims, shape, strides, itemsize, fort);
            }
            mh$.invokeExact(ndims, shape, strides, itemsize, fort);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyBuffer_FillInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyBuffer_FillInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyBuffer_FillInfo(Py_buffer *view, PyObject *o, void *buf, Py_ssize_t len, int readonly, int flags)
     * }
     */
    public static FunctionDescriptor PyBuffer_FillInfo$descriptor() {
        return PyBuffer_FillInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyBuffer_FillInfo(Py_buffer *view, PyObject *o, void *buf, Py_ssize_t len, int readonly, int flags)
     * }
     */
    public static MethodHandle PyBuffer_FillInfo$handle() {
        return PyBuffer_FillInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyBuffer_FillInfo(Py_buffer *view, PyObject *o, void *buf, Py_ssize_t len, int readonly, int flags)
     * }
     */
    public static MemorySegment PyBuffer_FillInfo$address() {
        return PyBuffer_FillInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyBuffer_FillInfo(Py_buffer *view, PyObject *o, void *buf, Py_ssize_t len, int readonly, int flags)
     * }
     */
    public static int PyBuffer_FillInfo(MemorySegment view, MemorySegment o, MemorySegment buf, long len, int readonly, int flags) {
        var mh$ = PyBuffer_FillInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyBuffer_FillInfo", view, o, buf, len, readonly, flags);
            }
            return (int)mh$.invokeExact(view, o, buf, len, readonly, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyBuffer_Release {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyBuffer_Release");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyBuffer_Release(Py_buffer *view)
     * }
     */
    public static FunctionDescriptor PyBuffer_Release$descriptor() {
        return PyBuffer_Release.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyBuffer_Release(Py_buffer *view)
     * }
     */
    public static MethodHandle PyBuffer_Release$handle() {
        return PyBuffer_Release.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyBuffer_Release(Py_buffer *view)
     * }
     */
    public static MemorySegment PyBuffer_Release$address() {
        return PyBuffer_Release.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyBuffer_Release(Py_buffer *view)
     * }
     */
    public static void PyBuffer_Release(MemorySegment view) {
        var mh$ = PyBuffer_Release.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyBuffer_Release", view);
            }
            mh$.invokeExact(view);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_Is {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_Is");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int Py_Is(PyObject *x, PyObject *y)
     * }
     */
    public static FunctionDescriptor Py_Is$descriptor() {
        return Py_Is.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int Py_Is(PyObject *x, PyObject *y)
     * }
     */
    public static MethodHandle Py_Is$handle() {
        return Py_Is.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int Py_Is(PyObject *x, PyObject *y)
     * }
     */
    public static MemorySegment Py_Is$address() {
        return Py_Is.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int Py_Is(PyObject *x, PyObject *y)
     * }
     */
    public static int Py_Is(MemorySegment x, MemorySegment y) {
        var mh$ = Py_Is.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_Is", x, y);
            }
            return (int)mh$.invokeExact(x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyLong_Type$constants {
        public static final GroupLayout LAYOUT = _object.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyLong_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyLong_Type
     * }
     */
    public static GroupLayout PyLong_Type$layout() {
        return PyLong_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyLong_Type
     * }
     */
    public static MemorySegment PyLong_Type() {
        return PyLong_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyLong_Type
     * }
     */
    public static void PyLong_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyLong_Type$constants.SEGMENT, 0L, PyLong_Type$constants.LAYOUT.byteSize());
    }

    private static class PyBool_Type$constants {
        public static final GroupLayout LAYOUT = _object.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyBool_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyBool_Type
     * }
     */
    public static GroupLayout PyBool_Type$layout() {
        return PyBool_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyBool_Type
     * }
     */
    public static MemorySegment PyBool_Type() {
        return PyBool_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyBool_Type
     * }
     */
    public static void PyBool_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyBool_Type$constants.SEGMENT, 0L, PyBool_Type$constants.LAYOUT.byteSize());
    }

    private static class PyType_FromSpec {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyType_FromSpec");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyType_FromSpec(PyType_Spec *)
     * }
     */
    public static FunctionDescriptor PyType_FromSpec$descriptor() {
        return PyType_FromSpec.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyType_FromSpec(PyType_Spec *)
     * }
     */
    public static MethodHandle PyType_FromSpec$handle() {
        return PyType_FromSpec.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyType_FromSpec(PyType_Spec *)
     * }
     */
    public static MemorySegment PyType_FromSpec$address() {
        return PyType_FromSpec.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyType_FromSpec(PyType_Spec *)
     * }
     */
    public static MemorySegment PyType_FromSpec(MemorySegment x0) {
        var mh$ = PyType_FromSpec.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyType_FromSpec", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyType_FromSpecWithBases {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyType_FromSpecWithBases");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyType_FromSpecWithBases(PyType_Spec *, PyObject *)
     * }
     */
    public static FunctionDescriptor PyType_FromSpecWithBases$descriptor() {
        return PyType_FromSpecWithBases.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyType_FromSpecWithBases(PyType_Spec *, PyObject *)
     * }
     */
    public static MethodHandle PyType_FromSpecWithBases$handle() {
        return PyType_FromSpecWithBases.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyType_FromSpecWithBases(PyType_Spec *, PyObject *)
     * }
     */
    public static MemorySegment PyType_FromSpecWithBases$address() {
        return PyType_FromSpecWithBases.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyType_FromSpecWithBases(PyType_Spec *, PyObject *)
     * }
     */
    public static MemorySegment PyType_FromSpecWithBases(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyType_FromSpecWithBases.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyType_FromSpecWithBases", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyType_GetSlot {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyType_GetSlot");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *PyType_GetSlot(PyTypeObject *, int)
     * }
     */
    public static FunctionDescriptor PyType_GetSlot$descriptor() {
        return PyType_GetSlot.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *PyType_GetSlot(PyTypeObject *, int)
     * }
     */
    public static MethodHandle PyType_GetSlot$handle() {
        return PyType_GetSlot.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *PyType_GetSlot(PyTypeObject *, int)
     * }
     */
    public static MemorySegment PyType_GetSlot$address() {
        return PyType_GetSlot.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *PyType_GetSlot(PyTypeObject *, int)
     * }
     */
    public static MemorySegment PyType_GetSlot(MemorySegment x0, int x1) {
        var mh$ = PyType_GetSlot.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyType_GetSlot", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyType_FromModuleAndSpec {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyType_FromModuleAndSpec");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyType_FromModuleAndSpec(PyObject *, PyType_Spec *, PyObject *)
     * }
     */
    public static FunctionDescriptor PyType_FromModuleAndSpec$descriptor() {
        return PyType_FromModuleAndSpec.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyType_FromModuleAndSpec(PyObject *, PyType_Spec *, PyObject *)
     * }
     */
    public static MethodHandle PyType_FromModuleAndSpec$handle() {
        return PyType_FromModuleAndSpec.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyType_FromModuleAndSpec(PyObject *, PyType_Spec *, PyObject *)
     * }
     */
    public static MemorySegment PyType_FromModuleAndSpec$address() {
        return PyType_FromModuleAndSpec.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyType_FromModuleAndSpec(PyObject *, PyType_Spec *, PyObject *)
     * }
     */
    public static MemorySegment PyType_FromModuleAndSpec(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = PyType_FromModuleAndSpec.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyType_FromModuleAndSpec", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyType_GetModule {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyType_GetModule");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyType_GetModule(PyTypeObject *)
     * }
     */
    public static FunctionDescriptor PyType_GetModule$descriptor() {
        return PyType_GetModule.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyType_GetModule(PyTypeObject *)
     * }
     */
    public static MethodHandle PyType_GetModule$handle() {
        return PyType_GetModule.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyType_GetModule(PyTypeObject *)
     * }
     */
    public static MemorySegment PyType_GetModule$address() {
        return PyType_GetModule.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyType_GetModule(PyTypeObject *)
     * }
     */
    public static MemorySegment PyType_GetModule(MemorySegment x0) {
        var mh$ = PyType_GetModule.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyType_GetModule", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyType_GetModuleState {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyType_GetModuleState");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *PyType_GetModuleState(PyTypeObject *)
     * }
     */
    public static FunctionDescriptor PyType_GetModuleState$descriptor() {
        return PyType_GetModuleState.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *PyType_GetModuleState(PyTypeObject *)
     * }
     */
    public static MethodHandle PyType_GetModuleState$handle() {
        return PyType_GetModuleState.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *PyType_GetModuleState(PyTypeObject *)
     * }
     */
    public static MemorySegment PyType_GetModuleState$address() {
        return PyType_GetModuleState.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *PyType_GetModuleState(PyTypeObject *)
     * }
     */
    public static MemorySegment PyType_GetModuleState(MemorySegment x0) {
        var mh$ = PyType_GetModuleState.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyType_GetModuleState", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyType_GetName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyType_GetName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyType_GetName(PyTypeObject *)
     * }
     */
    public static FunctionDescriptor PyType_GetName$descriptor() {
        return PyType_GetName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyType_GetName(PyTypeObject *)
     * }
     */
    public static MethodHandle PyType_GetName$handle() {
        return PyType_GetName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyType_GetName(PyTypeObject *)
     * }
     */
    public static MemorySegment PyType_GetName$address() {
        return PyType_GetName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyType_GetName(PyTypeObject *)
     * }
     */
    public static MemorySegment PyType_GetName(MemorySegment x0) {
        var mh$ = PyType_GetName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyType_GetName", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyType_GetQualName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyType_GetQualName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyType_GetQualName(PyTypeObject *)
     * }
     */
    public static FunctionDescriptor PyType_GetQualName$descriptor() {
        return PyType_GetQualName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyType_GetQualName(PyTypeObject *)
     * }
     */
    public static MethodHandle PyType_GetQualName$handle() {
        return PyType_GetQualName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyType_GetQualName(PyTypeObject *)
     * }
     */
    public static MemorySegment PyType_GetQualName$address() {
        return PyType_GetQualName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyType_GetQualName(PyTypeObject *)
     * }
     */
    public static MemorySegment PyType_GetQualName(MemorySegment x0) {
        var mh$ = PyType_GetQualName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyType_GetQualName", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyType_FromMetaclass {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyType_FromMetaclass");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyType_FromMetaclass(PyTypeObject *, PyObject *, PyType_Spec *, PyObject *)
     * }
     */
    public static FunctionDescriptor PyType_FromMetaclass$descriptor() {
        return PyType_FromMetaclass.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyType_FromMetaclass(PyTypeObject *, PyObject *, PyType_Spec *, PyObject *)
     * }
     */
    public static MethodHandle PyType_FromMetaclass$handle() {
        return PyType_FromMetaclass.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyType_FromMetaclass(PyTypeObject *, PyObject *, PyType_Spec *, PyObject *)
     * }
     */
    public static MemorySegment PyType_FromMetaclass$address() {
        return PyType_FromMetaclass.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyType_FromMetaclass(PyTypeObject *, PyObject *, PyType_Spec *, PyObject *)
     * }
     */
    public static MemorySegment PyType_FromMetaclass(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = PyType_FromMetaclass.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyType_FromMetaclass", x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_GetTypeData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_GetTypeData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *PyObject_GetTypeData(PyObject *obj, PyTypeObject *cls)
     * }
     */
    public static FunctionDescriptor PyObject_GetTypeData$descriptor() {
        return PyObject_GetTypeData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *PyObject_GetTypeData(PyObject *obj, PyTypeObject *cls)
     * }
     */
    public static MethodHandle PyObject_GetTypeData$handle() {
        return PyObject_GetTypeData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *PyObject_GetTypeData(PyObject *obj, PyTypeObject *cls)
     * }
     */
    public static MemorySegment PyObject_GetTypeData$address() {
        return PyObject_GetTypeData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *PyObject_GetTypeData(PyObject *obj, PyTypeObject *cls)
     * }
     */
    public static MemorySegment PyObject_GetTypeData(MemorySegment obj, MemorySegment cls) {
        var mh$ = PyObject_GetTypeData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_GetTypeData", obj, cls);
            }
            return (MemorySegment)mh$.invokeExact(obj, cls);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyType_GetTypeDataSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyType_GetTypeDataSize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_ssize_t PyType_GetTypeDataSize(PyTypeObject *cls)
     * }
     */
    public static FunctionDescriptor PyType_GetTypeDataSize$descriptor() {
        return PyType_GetTypeDataSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_ssize_t PyType_GetTypeDataSize(PyTypeObject *cls)
     * }
     */
    public static MethodHandle PyType_GetTypeDataSize$handle() {
        return PyType_GetTypeDataSize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_ssize_t PyType_GetTypeDataSize(PyTypeObject *cls)
     * }
     */
    public static MemorySegment PyType_GetTypeDataSize$address() {
        return PyType_GetTypeDataSize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_ssize_t PyType_GetTypeDataSize(PyTypeObject *cls)
     * }
     */
    public static long PyType_GetTypeDataSize(MemorySegment cls) {
        var mh$ = PyType_GetTypeDataSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyType_GetTypeDataSize", cls);
            }
            return (long)mh$.invokeExact(cls);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyType_IsSubtype {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyType_IsSubtype");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyType_IsSubtype(PyTypeObject *, PyTypeObject *)
     * }
     */
    public static FunctionDescriptor PyType_IsSubtype$descriptor() {
        return PyType_IsSubtype.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyType_IsSubtype(PyTypeObject *, PyTypeObject *)
     * }
     */
    public static MethodHandle PyType_IsSubtype$handle() {
        return PyType_IsSubtype.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyType_IsSubtype(PyTypeObject *, PyTypeObject *)
     * }
     */
    public static MemorySegment PyType_IsSubtype$address() {
        return PyType_IsSubtype.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyType_IsSubtype(PyTypeObject *, PyTypeObject *)
     * }
     */
    public static int PyType_IsSubtype(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyType_IsSubtype.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyType_IsSubtype", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyType_Type$constants {
        public static final GroupLayout LAYOUT = _object.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyType_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyType_Type
     * }
     */
    public static GroupLayout PyType_Type$layout() {
        return PyType_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyType_Type
     * }
     */
    public static MemorySegment PyType_Type() {
        return PyType_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyType_Type
     * }
     */
    public static void PyType_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyType_Type$constants.SEGMENT, 0L, PyType_Type$constants.LAYOUT.byteSize());
    }

    private static class PyBaseObject_Type$constants {
        public static final GroupLayout LAYOUT = _object.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyBaseObject_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyBaseObject_Type
     * }
     */
    public static GroupLayout PyBaseObject_Type$layout() {
        return PyBaseObject_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyBaseObject_Type
     * }
     */
    public static MemorySegment PyBaseObject_Type() {
        return PyBaseObject_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyBaseObject_Type
     * }
     */
    public static void PyBaseObject_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyBaseObject_Type$constants.SEGMENT, 0L, PyBaseObject_Type$constants.LAYOUT.byteSize());
    }

    private static class PySuper_Type$constants {
        public static final GroupLayout LAYOUT = _object.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PySuper_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PySuper_Type
     * }
     */
    public static GroupLayout PySuper_Type$layout() {
        return PySuper_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PySuper_Type
     * }
     */
    public static MemorySegment PySuper_Type() {
        return PySuper_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PySuper_Type
     * }
     */
    public static void PySuper_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PySuper_Type$constants.SEGMENT, 0L, PySuper_Type$constants.LAYOUT.byteSize());
    }

    private static class PyType_GetFlags {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyType_GetFlags");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long PyType_GetFlags(PyTypeObject *)
     * }
     */
    public static FunctionDescriptor PyType_GetFlags$descriptor() {
        return PyType_GetFlags.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long PyType_GetFlags(PyTypeObject *)
     * }
     */
    public static MethodHandle PyType_GetFlags$handle() {
        return PyType_GetFlags.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long PyType_GetFlags(PyTypeObject *)
     * }
     */
    public static MemorySegment PyType_GetFlags$address() {
        return PyType_GetFlags.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long PyType_GetFlags(PyTypeObject *)
     * }
     */
    public static int PyType_GetFlags(MemorySegment x0) {
        var mh$ = PyType_GetFlags.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyType_GetFlags", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyType_Ready {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyType_Ready");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyType_Ready(PyTypeObject *)
     * }
     */
    public static FunctionDescriptor PyType_Ready$descriptor() {
        return PyType_Ready.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyType_Ready(PyTypeObject *)
     * }
     */
    public static MethodHandle PyType_Ready$handle() {
        return PyType_Ready.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyType_Ready(PyTypeObject *)
     * }
     */
    public static MemorySegment PyType_Ready$address() {
        return PyType_Ready.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyType_Ready(PyTypeObject *)
     * }
     */
    public static int PyType_Ready(MemorySegment x0) {
        var mh$ = PyType_Ready.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyType_Ready", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyType_GenericAlloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyType_GenericAlloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyType_GenericAlloc(PyTypeObject *, Py_ssize_t)
     * }
     */
    public static FunctionDescriptor PyType_GenericAlloc$descriptor() {
        return PyType_GenericAlloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyType_GenericAlloc(PyTypeObject *, Py_ssize_t)
     * }
     */
    public static MethodHandle PyType_GenericAlloc$handle() {
        return PyType_GenericAlloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyType_GenericAlloc(PyTypeObject *, Py_ssize_t)
     * }
     */
    public static MemorySegment PyType_GenericAlloc$address() {
        return PyType_GenericAlloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyType_GenericAlloc(PyTypeObject *, Py_ssize_t)
     * }
     */
    public static MemorySegment PyType_GenericAlloc(MemorySegment x0, long x1) {
        var mh$ = PyType_GenericAlloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyType_GenericAlloc", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyType_GenericNew {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyType_GenericNew");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyType_GenericNew(PyTypeObject *, PyObject *, PyObject *)
     * }
     */
    public static FunctionDescriptor PyType_GenericNew$descriptor() {
        return PyType_GenericNew.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyType_GenericNew(PyTypeObject *, PyObject *, PyObject *)
     * }
     */
    public static MethodHandle PyType_GenericNew$handle() {
        return PyType_GenericNew.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyType_GenericNew(PyTypeObject *, PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyType_GenericNew$address() {
        return PyType_GenericNew.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyType_GenericNew(PyTypeObject *, PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyType_GenericNew(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = PyType_GenericNew.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyType_GenericNew", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyType_ClearCache {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyType_ClearCache");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int PyType_ClearCache()
     * }
     */
    public static FunctionDescriptor PyType_ClearCache$descriptor() {
        return PyType_ClearCache.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int PyType_ClearCache()
     * }
     */
    public static MethodHandle PyType_ClearCache$handle() {
        return PyType_ClearCache.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int PyType_ClearCache()
     * }
     */
    public static MemorySegment PyType_ClearCache$address() {
        return PyType_ClearCache.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int PyType_ClearCache()
     * }
     */
    public static int PyType_ClearCache() {
        var mh$ = PyType_ClearCache.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyType_ClearCache");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyType_Modified {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyType_Modified");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyType_Modified(PyTypeObject *)
     * }
     */
    public static FunctionDescriptor PyType_Modified$descriptor() {
        return PyType_Modified.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyType_Modified(PyTypeObject *)
     * }
     */
    public static MethodHandle PyType_Modified$handle() {
        return PyType_Modified.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyType_Modified(PyTypeObject *)
     * }
     */
    public static MemorySegment PyType_Modified$address() {
        return PyType_Modified.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyType_Modified(PyTypeObject *)
     * }
     */
    public static void PyType_Modified(MemorySegment x0) {
        var mh$ = PyType_Modified.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyType_Modified", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_Repr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_Repr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyObject_Repr(PyObject *)
     * }
     */
    public static FunctionDescriptor PyObject_Repr$descriptor() {
        return PyObject_Repr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyObject_Repr(PyObject *)
     * }
     */
    public static MethodHandle PyObject_Repr$handle() {
        return PyObject_Repr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyObject_Repr(PyObject *)
     * }
     */
    public static MemorySegment PyObject_Repr$address() {
        return PyObject_Repr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyObject_Repr(PyObject *)
     * }
     */
    public static MemorySegment PyObject_Repr(MemorySegment x0) {
        var mh$ = PyObject_Repr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_Repr", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_Str {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_Str");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyObject_Str(PyObject *)
     * }
     */
    public static FunctionDescriptor PyObject_Str$descriptor() {
        return PyObject_Str.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyObject_Str(PyObject *)
     * }
     */
    public static MethodHandle PyObject_Str$handle() {
        return PyObject_Str.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyObject_Str(PyObject *)
     * }
     */
    public static MemorySegment PyObject_Str$address() {
        return PyObject_Str.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyObject_Str(PyObject *)
     * }
     */
    public static MemorySegment PyObject_Str(MemorySegment x0) {
        var mh$ = PyObject_Str.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_Str", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_ASCII {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_ASCII");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyObject_ASCII(PyObject *)
     * }
     */
    public static FunctionDescriptor PyObject_ASCII$descriptor() {
        return PyObject_ASCII.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyObject_ASCII(PyObject *)
     * }
     */
    public static MethodHandle PyObject_ASCII$handle() {
        return PyObject_ASCII.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyObject_ASCII(PyObject *)
     * }
     */
    public static MemorySegment PyObject_ASCII$address() {
        return PyObject_ASCII.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyObject_ASCII(PyObject *)
     * }
     */
    public static MemorySegment PyObject_ASCII(MemorySegment x0) {
        var mh$ = PyObject_ASCII.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_ASCII", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_Bytes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_Bytes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyObject_Bytes(PyObject *)
     * }
     */
    public static FunctionDescriptor PyObject_Bytes$descriptor() {
        return PyObject_Bytes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyObject_Bytes(PyObject *)
     * }
     */
    public static MethodHandle PyObject_Bytes$handle() {
        return PyObject_Bytes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyObject_Bytes(PyObject *)
     * }
     */
    public static MemorySegment PyObject_Bytes$address() {
        return PyObject_Bytes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyObject_Bytes(PyObject *)
     * }
     */
    public static MemorySegment PyObject_Bytes(MemorySegment x0) {
        var mh$ = PyObject_Bytes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_Bytes", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_RichCompare {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_RichCompare");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyObject_RichCompare(PyObject *, PyObject *, int)
     * }
     */
    public static FunctionDescriptor PyObject_RichCompare$descriptor() {
        return PyObject_RichCompare.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyObject_RichCompare(PyObject *, PyObject *, int)
     * }
     */
    public static MethodHandle PyObject_RichCompare$handle() {
        return PyObject_RichCompare.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyObject_RichCompare(PyObject *, PyObject *, int)
     * }
     */
    public static MemorySegment PyObject_RichCompare$address() {
        return PyObject_RichCompare.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyObject_RichCompare(PyObject *, PyObject *, int)
     * }
     */
    public static MemorySegment PyObject_RichCompare(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = PyObject_RichCompare.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_RichCompare", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_RichCompareBool {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_RichCompareBool");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyObject_RichCompareBool(PyObject *, PyObject *, int)
     * }
     */
    public static FunctionDescriptor PyObject_RichCompareBool$descriptor() {
        return PyObject_RichCompareBool.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyObject_RichCompareBool(PyObject *, PyObject *, int)
     * }
     */
    public static MethodHandle PyObject_RichCompareBool$handle() {
        return PyObject_RichCompareBool.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyObject_RichCompareBool(PyObject *, PyObject *, int)
     * }
     */
    public static MemorySegment PyObject_RichCompareBool$address() {
        return PyObject_RichCompareBool.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyObject_RichCompareBool(PyObject *, PyObject *, int)
     * }
     */
    public static int PyObject_RichCompareBool(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = PyObject_RichCompareBool.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_RichCompareBool", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_GetAttrString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_GetAttrString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyObject_GetAttrString(PyObject *, const char *)
     * }
     */
    public static FunctionDescriptor PyObject_GetAttrString$descriptor() {
        return PyObject_GetAttrString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyObject_GetAttrString(PyObject *, const char *)
     * }
     */
    public static MethodHandle PyObject_GetAttrString$handle() {
        return PyObject_GetAttrString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyObject_GetAttrString(PyObject *, const char *)
     * }
     */
    public static MemorySegment PyObject_GetAttrString$address() {
        return PyObject_GetAttrString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyObject_GetAttrString(PyObject *, const char *)
     * }
     */
    public static MemorySegment PyObject_GetAttrString(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyObject_GetAttrString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_GetAttrString", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_SetAttrString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_SetAttrString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyObject_SetAttrString(PyObject *, const char *, PyObject *)
     * }
     */
    public static FunctionDescriptor PyObject_SetAttrString$descriptor() {
        return PyObject_SetAttrString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyObject_SetAttrString(PyObject *, const char *, PyObject *)
     * }
     */
    public static MethodHandle PyObject_SetAttrString$handle() {
        return PyObject_SetAttrString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyObject_SetAttrString(PyObject *, const char *, PyObject *)
     * }
     */
    public static MemorySegment PyObject_SetAttrString$address() {
        return PyObject_SetAttrString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyObject_SetAttrString(PyObject *, const char *, PyObject *)
     * }
     */
    public static int PyObject_SetAttrString(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = PyObject_SetAttrString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_SetAttrString", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_HasAttrString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_HasAttrString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyObject_HasAttrString(PyObject *, const char *)
     * }
     */
    public static FunctionDescriptor PyObject_HasAttrString$descriptor() {
        return PyObject_HasAttrString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyObject_HasAttrString(PyObject *, const char *)
     * }
     */
    public static MethodHandle PyObject_HasAttrString$handle() {
        return PyObject_HasAttrString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyObject_HasAttrString(PyObject *, const char *)
     * }
     */
    public static MemorySegment PyObject_HasAttrString$address() {
        return PyObject_HasAttrString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyObject_HasAttrString(PyObject *, const char *)
     * }
     */
    public static int PyObject_HasAttrString(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyObject_HasAttrString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_HasAttrString", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_GetAttr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_GetAttr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyObject_GetAttr(PyObject *, PyObject *)
     * }
     */
    public static FunctionDescriptor PyObject_GetAttr$descriptor() {
        return PyObject_GetAttr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyObject_GetAttr(PyObject *, PyObject *)
     * }
     */
    public static MethodHandle PyObject_GetAttr$handle() {
        return PyObject_GetAttr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyObject_GetAttr(PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyObject_GetAttr$address() {
        return PyObject_GetAttr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyObject_GetAttr(PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyObject_GetAttr(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyObject_GetAttr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_GetAttr", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_SetAttr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_SetAttr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyObject_SetAttr(PyObject *, PyObject *, PyObject *)
     * }
     */
    public static FunctionDescriptor PyObject_SetAttr$descriptor() {
        return PyObject_SetAttr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyObject_SetAttr(PyObject *, PyObject *, PyObject *)
     * }
     */
    public static MethodHandle PyObject_SetAttr$handle() {
        return PyObject_SetAttr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyObject_SetAttr(PyObject *, PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyObject_SetAttr$address() {
        return PyObject_SetAttr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyObject_SetAttr(PyObject *, PyObject *, PyObject *)
     * }
     */
    public static int PyObject_SetAttr(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = PyObject_SetAttr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_SetAttr", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_HasAttr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_HasAttr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyObject_HasAttr(PyObject *, PyObject *)
     * }
     */
    public static FunctionDescriptor PyObject_HasAttr$descriptor() {
        return PyObject_HasAttr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyObject_HasAttr(PyObject *, PyObject *)
     * }
     */
    public static MethodHandle PyObject_HasAttr$handle() {
        return PyObject_HasAttr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyObject_HasAttr(PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyObject_HasAttr$address() {
        return PyObject_HasAttr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyObject_HasAttr(PyObject *, PyObject *)
     * }
     */
    public static int PyObject_HasAttr(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyObject_HasAttr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_HasAttr", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_SelfIter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_SelfIter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyObject_SelfIter(PyObject *)
     * }
     */
    public static FunctionDescriptor PyObject_SelfIter$descriptor() {
        return PyObject_SelfIter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyObject_SelfIter(PyObject *)
     * }
     */
    public static MethodHandle PyObject_SelfIter$handle() {
        return PyObject_SelfIter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyObject_SelfIter(PyObject *)
     * }
     */
    public static MemorySegment PyObject_SelfIter$address() {
        return PyObject_SelfIter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyObject_SelfIter(PyObject *)
     * }
     */
    public static MemorySegment PyObject_SelfIter(MemorySegment x0) {
        var mh$ = PyObject_SelfIter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_SelfIter", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_GenericGetAttr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_GenericGetAttr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyObject_GenericGetAttr(PyObject *, PyObject *)
     * }
     */
    public static FunctionDescriptor PyObject_GenericGetAttr$descriptor() {
        return PyObject_GenericGetAttr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyObject_GenericGetAttr(PyObject *, PyObject *)
     * }
     */
    public static MethodHandle PyObject_GenericGetAttr$handle() {
        return PyObject_GenericGetAttr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyObject_GenericGetAttr(PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyObject_GenericGetAttr$address() {
        return PyObject_GenericGetAttr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyObject_GenericGetAttr(PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyObject_GenericGetAttr(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyObject_GenericGetAttr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_GenericGetAttr", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_GenericSetAttr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_GenericSetAttr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyObject_GenericSetAttr(PyObject *, PyObject *, PyObject *)
     * }
     */
    public static FunctionDescriptor PyObject_GenericSetAttr$descriptor() {
        return PyObject_GenericSetAttr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyObject_GenericSetAttr(PyObject *, PyObject *, PyObject *)
     * }
     */
    public static MethodHandle PyObject_GenericSetAttr$handle() {
        return PyObject_GenericSetAttr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyObject_GenericSetAttr(PyObject *, PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyObject_GenericSetAttr$address() {
        return PyObject_GenericSetAttr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyObject_GenericSetAttr(PyObject *, PyObject *, PyObject *)
     * }
     */
    public static int PyObject_GenericSetAttr(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = PyObject_GenericSetAttr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_GenericSetAttr", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_GenericSetDict {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_GenericSetDict");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyObject_GenericSetDict(PyObject *, PyObject *, void *)
     * }
     */
    public static FunctionDescriptor PyObject_GenericSetDict$descriptor() {
        return PyObject_GenericSetDict.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyObject_GenericSetDict(PyObject *, PyObject *, void *)
     * }
     */
    public static MethodHandle PyObject_GenericSetDict$handle() {
        return PyObject_GenericSetDict.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyObject_GenericSetDict(PyObject *, PyObject *, void *)
     * }
     */
    public static MemorySegment PyObject_GenericSetDict$address() {
        return PyObject_GenericSetDict.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyObject_GenericSetDict(PyObject *, PyObject *, void *)
     * }
     */
    public static int PyObject_GenericSetDict(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = PyObject_GenericSetDict.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_GenericSetDict", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_Hash {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_Hash");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_hash_t PyObject_Hash(PyObject *)
     * }
     */
    public static FunctionDescriptor PyObject_Hash$descriptor() {
        return PyObject_Hash.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_hash_t PyObject_Hash(PyObject *)
     * }
     */
    public static MethodHandle PyObject_Hash$handle() {
        return PyObject_Hash.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_hash_t PyObject_Hash(PyObject *)
     * }
     */
    public static MemorySegment PyObject_Hash$address() {
        return PyObject_Hash.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_hash_t PyObject_Hash(PyObject *)
     * }
     */
    public static long PyObject_Hash(MemorySegment x0) {
        var mh$ = PyObject_Hash.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_Hash", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_HashNotImplemented {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_HashNotImplemented");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_hash_t PyObject_HashNotImplemented(PyObject *)
     * }
     */
    public static FunctionDescriptor PyObject_HashNotImplemented$descriptor() {
        return PyObject_HashNotImplemented.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_hash_t PyObject_HashNotImplemented(PyObject *)
     * }
     */
    public static MethodHandle PyObject_HashNotImplemented$handle() {
        return PyObject_HashNotImplemented.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_hash_t PyObject_HashNotImplemented(PyObject *)
     * }
     */
    public static MemorySegment PyObject_HashNotImplemented$address() {
        return PyObject_HashNotImplemented.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_hash_t PyObject_HashNotImplemented(PyObject *)
     * }
     */
    public static long PyObject_HashNotImplemented(MemorySegment x0) {
        var mh$ = PyObject_HashNotImplemented.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_HashNotImplemented", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_IsTrue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_IsTrue");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyObject_IsTrue(PyObject *)
     * }
     */
    public static FunctionDescriptor PyObject_IsTrue$descriptor() {
        return PyObject_IsTrue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyObject_IsTrue(PyObject *)
     * }
     */
    public static MethodHandle PyObject_IsTrue$handle() {
        return PyObject_IsTrue.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyObject_IsTrue(PyObject *)
     * }
     */
    public static MemorySegment PyObject_IsTrue$address() {
        return PyObject_IsTrue.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyObject_IsTrue(PyObject *)
     * }
     */
    public static int PyObject_IsTrue(MemorySegment x0) {
        var mh$ = PyObject_IsTrue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_IsTrue", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_Not {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_Not");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyObject_Not(PyObject *)
     * }
     */
    public static FunctionDescriptor PyObject_Not$descriptor() {
        return PyObject_Not.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyObject_Not(PyObject *)
     * }
     */
    public static MethodHandle PyObject_Not$handle() {
        return PyObject_Not.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyObject_Not(PyObject *)
     * }
     */
    public static MemorySegment PyObject_Not$address() {
        return PyObject_Not.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyObject_Not(PyObject *)
     * }
     */
    public static int PyObject_Not(MemorySegment x0) {
        var mh$ = PyObject_Not.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_Not", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCallable_Check {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCallable_Check");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyCallable_Check(PyObject *)
     * }
     */
    public static FunctionDescriptor PyCallable_Check$descriptor() {
        return PyCallable_Check.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyCallable_Check(PyObject *)
     * }
     */
    public static MethodHandle PyCallable_Check$handle() {
        return PyCallable_Check.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyCallable_Check(PyObject *)
     * }
     */
    public static MemorySegment PyCallable_Check$address() {
        return PyCallable_Check.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyCallable_Check(PyObject *)
     * }
     */
    public static int PyCallable_Check(MemorySegment x0) {
        var mh$ = PyCallable_Check.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCallable_Check", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_ClearWeakRefs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_ClearWeakRefs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyObject_ClearWeakRefs(PyObject *)
     * }
     */
    public static FunctionDescriptor PyObject_ClearWeakRefs$descriptor() {
        return PyObject_ClearWeakRefs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyObject_ClearWeakRefs(PyObject *)
     * }
     */
    public static MethodHandle PyObject_ClearWeakRefs$handle() {
        return PyObject_ClearWeakRefs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyObject_ClearWeakRefs(PyObject *)
     * }
     */
    public static MemorySegment PyObject_ClearWeakRefs$address() {
        return PyObject_ClearWeakRefs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyObject_ClearWeakRefs(PyObject *)
     * }
     */
    public static void PyObject_ClearWeakRefs(MemorySegment x0) {
        var mh$ = PyObject_ClearWeakRefs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_ClearWeakRefs", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_Dir {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_Dir");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyObject_Dir(PyObject *)
     * }
     */
    public static FunctionDescriptor PyObject_Dir$descriptor() {
        return PyObject_Dir.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyObject_Dir(PyObject *)
     * }
     */
    public static MethodHandle PyObject_Dir$handle() {
        return PyObject_Dir.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyObject_Dir(PyObject *)
     * }
     */
    public static MemorySegment PyObject_Dir$address() {
        return PyObject_Dir.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyObject_Dir(PyObject *)
     * }
     */
    public static MemorySegment PyObject_Dir(MemorySegment x0) {
        var mh$ = PyObject_Dir.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_Dir", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_ReprEnter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_ReprEnter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int Py_ReprEnter(PyObject *)
     * }
     */
    public static FunctionDescriptor Py_ReprEnter$descriptor() {
        return Py_ReprEnter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int Py_ReprEnter(PyObject *)
     * }
     */
    public static MethodHandle Py_ReprEnter$handle() {
        return Py_ReprEnter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int Py_ReprEnter(PyObject *)
     * }
     */
    public static MemorySegment Py_ReprEnter$address() {
        return Py_ReprEnter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int Py_ReprEnter(PyObject *)
     * }
     */
    public static int Py_ReprEnter(MemorySegment x0) {
        var mh$ = Py_ReprEnter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_ReprEnter", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_ReprLeave {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_ReprLeave");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void Py_ReprLeave(PyObject *)
     * }
     */
    public static FunctionDescriptor Py_ReprLeave$descriptor() {
        return Py_ReprLeave.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void Py_ReprLeave(PyObject *)
     * }
     */
    public static MethodHandle Py_ReprLeave$handle() {
        return Py_ReprLeave.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void Py_ReprLeave(PyObject *)
     * }
     */
    public static MemorySegment Py_ReprLeave$address() {
        return Py_ReprLeave.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void Py_ReprLeave(PyObject *)
     * }
     */
    public static void Py_ReprLeave(MemorySegment x0) {
        var mh$ = Py_ReprLeave.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_ReprLeave", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _Py_Dealloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_Py_Dealloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _Py_Dealloc(PyObject *)
     * }
     */
    public static FunctionDescriptor _Py_Dealloc$descriptor() {
        return _Py_Dealloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _Py_Dealloc(PyObject *)
     * }
     */
    public static MethodHandle _Py_Dealloc$handle() {
        return _Py_Dealloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _Py_Dealloc(PyObject *)
     * }
     */
    public static MemorySegment _Py_Dealloc$address() {
        return _Py_Dealloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _Py_Dealloc(PyObject *)
     * }
     */
    public static void _Py_Dealloc(MemorySegment x0) {
        var mh$ = _Py_Dealloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_Py_Dealloc", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_IncRef {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_IncRef");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void Py_IncRef(PyObject *)
     * }
     */
    public static FunctionDescriptor Py_IncRef$descriptor() {
        return Py_IncRef.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void Py_IncRef(PyObject *)
     * }
     */
    public static MethodHandle Py_IncRef$handle() {
        return Py_IncRef.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void Py_IncRef(PyObject *)
     * }
     */
    public static MemorySegment Py_IncRef$address() {
        return Py_IncRef.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void Py_IncRef(PyObject *)
     * }
     */
    public static void Py_IncRef(MemorySegment x0) {
        var mh$ = Py_IncRef.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_IncRef", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_DecRef {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_DecRef");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void Py_DecRef(PyObject *)
     * }
     */
    public static FunctionDescriptor Py_DecRef$descriptor() {
        return Py_DecRef.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void Py_DecRef(PyObject *)
     * }
     */
    public static MethodHandle Py_DecRef$handle() {
        return Py_DecRef.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void Py_DecRef(PyObject *)
     * }
     */
    public static MemorySegment Py_DecRef$address() {
        return Py_DecRef.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void Py_DecRef(PyObject *)
     * }
     */
    public static void Py_DecRef(MemorySegment x0) {
        var mh$ = Py_DecRef.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_DecRef", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _Py_IncRef {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_Py_IncRef");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _Py_IncRef(PyObject *)
     * }
     */
    public static FunctionDescriptor _Py_IncRef$descriptor() {
        return _Py_IncRef.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _Py_IncRef(PyObject *)
     * }
     */
    public static MethodHandle _Py_IncRef$handle() {
        return _Py_IncRef.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _Py_IncRef(PyObject *)
     * }
     */
    public static MemorySegment _Py_IncRef$address() {
        return _Py_IncRef.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _Py_IncRef(PyObject *)
     * }
     */
    public static void _Py_IncRef(MemorySegment x0) {
        var mh$ = _Py_IncRef.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_Py_IncRef", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _Py_DecRef {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_Py_DecRef");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _Py_DecRef(PyObject *)
     * }
     */
    public static FunctionDescriptor _Py_DecRef$descriptor() {
        return _Py_DecRef.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _Py_DecRef(PyObject *)
     * }
     */
    public static MethodHandle _Py_DecRef$handle() {
        return _Py_DecRef.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _Py_DecRef(PyObject *)
     * }
     */
    public static MemorySegment _Py_DecRef$address() {
        return _Py_DecRef.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _Py_DecRef(PyObject *)
     * }
     */
    public static void _Py_DecRef(MemorySegment x0) {
        var mh$ = _Py_DecRef.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_Py_DecRef", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_NewRef {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_NewRef");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *Py_NewRef(PyObject *obj)
     * }
     */
    public static FunctionDescriptor Py_NewRef$descriptor() {
        return Py_NewRef.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *Py_NewRef(PyObject *obj)
     * }
     */
    public static MethodHandle Py_NewRef$handle() {
        return Py_NewRef.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *Py_NewRef(PyObject *obj)
     * }
     */
    public static MemorySegment Py_NewRef$address() {
        return Py_NewRef.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *Py_NewRef(PyObject *obj)
     * }
     */
    public static MemorySegment Py_NewRef(MemorySegment obj) {
        var mh$ = Py_NewRef.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_NewRef", obj);
            }
            return (MemorySegment)mh$.invokeExact(obj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_XNewRef {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_XNewRef");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *Py_XNewRef(PyObject *obj)
     * }
     */
    public static FunctionDescriptor Py_XNewRef$descriptor() {
        return Py_XNewRef.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *Py_XNewRef(PyObject *obj)
     * }
     */
    public static MethodHandle Py_XNewRef$handle() {
        return Py_XNewRef.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *Py_XNewRef(PyObject *obj)
     * }
     */
    public static MemorySegment Py_XNewRef$address() {
        return Py_XNewRef.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *Py_XNewRef(PyObject *obj)
     * }
     */
    public static MemorySegment Py_XNewRef(MemorySegment obj) {
        var mh$ = Py_XNewRef.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_XNewRef", obj);
            }
            return (MemorySegment)mh$.invokeExact(obj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _Py_NoneStruct$constants {
        public static final GroupLayout LAYOUT = _object.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("_Py_NoneStruct").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject _Py_NoneStruct
     * }
     */
    public static GroupLayout _Py_NoneStruct$layout() {
        return _Py_NoneStruct$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject _Py_NoneStruct
     * }
     */
    public static MemorySegment _Py_NoneStruct() {
        return _Py_NoneStruct$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject _Py_NoneStruct
     * }
     */
    public static void _Py_NoneStruct(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, _Py_NoneStruct$constants.SEGMENT, 0L, _Py_NoneStruct$constants.LAYOUT.byteSize());
    }

    private static class Py_IsNone {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_IsNone");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int Py_IsNone(PyObject *x)
     * }
     */
    public static FunctionDescriptor Py_IsNone$descriptor() {
        return Py_IsNone.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int Py_IsNone(PyObject *x)
     * }
     */
    public static MethodHandle Py_IsNone$handle() {
        return Py_IsNone.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int Py_IsNone(PyObject *x)
     * }
     */
    public static MemorySegment Py_IsNone$address() {
        return Py_IsNone.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int Py_IsNone(PyObject *x)
     * }
     */
    public static int Py_IsNone(MemorySegment x) {
        var mh$ = Py_IsNone.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_IsNone", x);
            }
            return (int)mh$.invokeExact(x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _Py_NotImplementedStruct$constants {
        public static final GroupLayout LAYOUT = _object.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("_Py_NotImplementedStruct").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject _Py_NotImplementedStruct
     * }
     */
    public static GroupLayout _Py_NotImplementedStruct$layout() {
        return _Py_NotImplementedStruct$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject _Py_NotImplementedStruct
     * }
     */
    public static MemorySegment _Py_NotImplementedStruct() {
        return _Py_NotImplementedStruct$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject _Py_NotImplementedStruct
     * }
     */
    public static void _Py_NotImplementedStruct(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, _Py_NotImplementedStruct$constants.SEGMENT, 0L, _Py_NotImplementedStruct$constants.LAYOUT.byteSize());
    }
    private static final int PYGEN_RETURN = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PYGEN_RETURN = 0
     * }
     */
    public static int PYGEN_RETURN() {
        return PYGEN_RETURN;
    }
    private static final int PYGEN_ERROR = (int)-1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PYGEN_ERROR = -1
     * }
     */
    public static int PYGEN_ERROR() {
        return PYGEN_ERROR;
    }
    private static final int PYGEN_NEXT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PYGEN_NEXT = 1
     * }
     */
    public static int PYGEN_NEXT() {
        return PYGEN_NEXT;
    }

    private static class PyObject_Malloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_Malloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *PyObject_Malloc(size_t size)
     * }
     */
    public static FunctionDescriptor PyObject_Malloc$descriptor() {
        return PyObject_Malloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *PyObject_Malloc(size_t size)
     * }
     */
    public static MethodHandle PyObject_Malloc$handle() {
        return PyObject_Malloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *PyObject_Malloc(size_t size)
     * }
     */
    public static MemorySegment PyObject_Malloc$address() {
        return PyObject_Malloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *PyObject_Malloc(size_t size)
     * }
     */
    public static MemorySegment PyObject_Malloc(long size) {
        var mh$ = PyObject_Malloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_Malloc", size);
            }
            return (MemorySegment)mh$.invokeExact(size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_Calloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_Calloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *PyObject_Calloc(size_t nelem, size_t elsize)
     * }
     */
    public static FunctionDescriptor PyObject_Calloc$descriptor() {
        return PyObject_Calloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *PyObject_Calloc(size_t nelem, size_t elsize)
     * }
     */
    public static MethodHandle PyObject_Calloc$handle() {
        return PyObject_Calloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *PyObject_Calloc(size_t nelem, size_t elsize)
     * }
     */
    public static MemorySegment PyObject_Calloc$address() {
        return PyObject_Calloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *PyObject_Calloc(size_t nelem, size_t elsize)
     * }
     */
    public static MemorySegment PyObject_Calloc(long nelem, long elsize) {
        var mh$ = PyObject_Calloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_Calloc", nelem, elsize);
            }
            return (MemorySegment)mh$.invokeExact(nelem, elsize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_Realloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_Realloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *PyObject_Realloc(void *ptr, size_t new_size)
     * }
     */
    public static FunctionDescriptor PyObject_Realloc$descriptor() {
        return PyObject_Realloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *PyObject_Realloc(void *ptr, size_t new_size)
     * }
     */
    public static MethodHandle PyObject_Realloc$handle() {
        return PyObject_Realloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *PyObject_Realloc(void *ptr, size_t new_size)
     * }
     */
    public static MemorySegment PyObject_Realloc$address() {
        return PyObject_Realloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *PyObject_Realloc(void *ptr, size_t new_size)
     * }
     */
    public static MemorySegment PyObject_Realloc(MemorySegment ptr, long new_size) {
        var mh$ = PyObject_Realloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_Realloc", ptr, new_size);
            }
            return (MemorySegment)mh$.invokeExact(ptr, new_size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_Free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_Free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyObject_Free(void *ptr)
     * }
     */
    public static FunctionDescriptor PyObject_Free$descriptor() {
        return PyObject_Free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyObject_Free(void *ptr)
     * }
     */
    public static MethodHandle PyObject_Free$handle() {
        return PyObject_Free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyObject_Free(void *ptr)
     * }
     */
    public static MemorySegment PyObject_Free$address() {
        return PyObject_Free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyObject_Free(void *ptr)
     * }
     */
    public static void PyObject_Free(MemorySegment ptr) {
        var mh$ = PyObject_Free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_Free", ptr);
            }
            mh$.invokeExact(ptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_Init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_Init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyObject_Init(PyObject *, PyTypeObject *)
     * }
     */
    public static FunctionDescriptor PyObject_Init$descriptor() {
        return PyObject_Init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyObject_Init(PyObject *, PyTypeObject *)
     * }
     */
    public static MethodHandle PyObject_Init$handle() {
        return PyObject_Init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyObject_Init(PyObject *, PyTypeObject *)
     * }
     */
    public static MemorySegment PyObject_Init$address() {
        return PyObject_Init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyObject_Init(PyObject *, PyTypeObject *)
     * }
     */
    public static MemorySegment PyObject_Init(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyObject_Init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_Init", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_InitVar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_InitVar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyVarObject *PyObject_InitVar(PyVarObject *, PyTypeObject *, Py_ssize_t)
     * }
     */
    public static FunctionDescriptor PyObject_InitVar$descriptor() {
        return PyObject_InitVar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyVarObject *PyObject_InitVar(PyVarObject *, PyTypeObject *, Py_ssize_t)
     * }
     */
    public static MethodHandle PyObject_InitVar$handle() {
        return PyObject_InitVar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyVarObject *PyObject_InitVar(PyVarObject *, PyTypeObject *, Py_ssize_t)
     * }
     */
    public static MemorySegment PyObject_InitVar$address() {
        return PyObject_InitVar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyVarObject *PyObject_InitVar(PyVarObject *, PyTypeObject *, Py_ssize_t)
     * }
     */
    public static MemorySegment PyObject_InitVar(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = PyObject_InitVar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_InitVar", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyObject_New {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyObject_New");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *_PyObject_New(PyTypeObject *)
     * }
     */
    public static FunctionDescriptor _PyObject_New$descriptor() {
        return _PyObject_New.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *_PyObject_New(PyTypeObject *)
     * }
     */
    public static MethodHandle _PyObject_New$handle() {
        return _PyObject_New.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *_PyObject_New(PyTypeObject *)
     * }
     */
    public static MemorySegment _PyObject_New$address() {
        return _PyObject_New.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *_PyObject_New(PyTypeObject *)
     * }
     */
    public static MemorySegment _PyObject_New(MemorySegment x0) {
        var mh$ = _PyObject_New.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyObject_New", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyObject_NewVar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyObject_NewVar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyVarObject *_PyObject_NewVar(PyTypeObject *, Py_ssize_t)
     * }
     */
    public static FunctionDescriptor _PyObject_NewVar$descriptor() {
        return _PyObject_NewVar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyVarObject *_PyObject_NewVar(PyTypeObject *, Py_ssize_t)
     * }
     */
    public static MethodHandle _PyObject_NewVar$handle() {
        return _PyObject_NewVar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyVarObject *_PyObject_NewVar(PyTypeObject *, Py_ssize_t)
     * }
     */
    public static MemorySegment _PyObject_NewVar$address() {
        return _PyObject_NewVar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyVarObject *_PyObject_NewVar(PyTypeObject *, Py_ssize_t)
     * }
     */
    public static MemorySegment _PyObject_NewVar(MemorySegment x0, long x1) {
        var mh$ = _PyObject_NewVar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyObject_NewVar", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyGC_Collect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyGC_Collect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_ssize_t PyGC_Collect()
     * }
     */
    public static FunctionDescriptor PyGC_Collect$descriptor() {
        return PyGC_Collect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_ssize_t PyGC_Collect()
     * }
     */
    public static MethodHandle PyGC_Collect$handle() {
        return PyGC_Collect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_ssize_t PyGC_Collect()
     * }
     */
    public static MemorySegment PyGC_Collect$address() {
        return PyGC_Collect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_ssize_t PyGC_Collect()
     * }
     */
    public static long PyGC_Collect() {
        var mh$ = PyGC_Collect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyGC_Collect");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyGC_Enable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyGC_Enable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyGC_Enable()
     * }
     */
    public static FunctionDescriptor PyGC_Enable$descriptor() {
        return PyGC_Enable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyGC_Enable()
     * }
     */
    public static MethodHandle PyGC_Enable$handle() {
        return PyGC_Enable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyGC_Enable()
     * }
     */
    public static MemorySegment PyGC_Enable$address() {
        return PyGC_Enable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyGC_Enable()
     * }
     */
    public static int PyGC_Enable() {
        var mh$ = PyGC_Enable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyGC_Enable");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyGC_Disable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyGC_Disable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyGC_Disable()
     * }
     */
    public static FunctionDescriptor PyGC_Disable$descriptor() {
        return PyGC_Disable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyGC_Disable()
     * }
     */
    public static MethodHandle PyGC_Disable$handle() {
        return PyGC_Disable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyGC_Disable()
     * }
     */
    public static MemorySegment PyGC_Disable$address() {
        return PyGC_Disable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyGC_Disable()
     * }
     */
    public static int PyGC_Disable() {
        var mh$ = PyGC_Disable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyGC_Disable");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyGC_IsEnabled {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyGC_IsEnabled");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyGC_IsEnabled()
     * }
     */
    public static FunctionDescriptor PyGC_IsEnabled$descriptor() {
        return PyGC_IsEnabled.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyGC_IsEnabled()
     * }
     */
    public static MethodHandle PyGC_IsEnabled$handle() {
        return PyGC_IsEnabled.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyGC_IsEnabled()
     * }
     */
    public static MemorySegment PyGC_IsEnabled$address() {
        return PyGC_IsEnabled.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyGC_IsEnabled()
     * }
     */
    public static int PyGC_IsEnabled() {
        var mh$ = PyGC_IsEnabled.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyGC_IsEnabled");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyObject_GC_Resize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyObject_GC_Resize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyVarObject *_PyObject_GC_Resize(PyVarObject *, Py_ssize_t)
     * }
     */
    public static FunctionDescriptor _PyObject_GC_Resize$descriptor() {
        return _PyObject_GC_Resize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyVarObject *_PyObject_GC_Resize(PyVarObject *, Py_ssize_t)
     * }
     */
    public static MethodHandle _PyObject_GC_Resize$handle() {
        return _PyObject_GC_Resize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyVarObject *_PyObject_GC_Resize(PyVarObject *, Py_ssize_t)
     * }
     */
    public static MemorySegment _PyObject_GC_Resize$address() {
        return _PyObject_GC_Resize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyVarObject *_PyObject_GC_Resize(PyVarObject *, Py_ssize_t)
     * }
     */
    public static MemorySegment _PyObject_GC_Resize(MemorySegment x0, long x1) {
        var mh$ = _PyObject_GC_Resize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyObject_GC_Resize", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyObject_GC_New {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyObject_GC_New");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *_PyObject_GC_New(PyTypeObject *)
     * }
     */
    public static FunctionDescriptor _PyObject_GC_New$descriptor() {
        return _PyObject_GC_New.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *_PyObject_GC_New(PyTypeObject *)
     * }
     */
    public static MethodHandle _PyObject_GC_New$handle() {
        return _PyObject_GC_New.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *_PyObject_GC_New(PyTypeObject *)
     * }
     */
    public static MemorySegment _PyObject_GC_New$address() {
        return _PyObject_GC_New.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *_PyObject_GC_New(PyTypeObject *)
     * }
     */
    public static MemorySegment _PyObject_GC_New(MemorySegment x0) {
        var mh$ = _PyObject_GC_New.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyObject_GC_New", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyObject_GC_NewVar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyObject_GC_NewVar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyVarObject *_PyObject_GC_NewVar(PyTypeObject *, Py_ssize_t)
     * }
     */
    public static FunctionDescriptor _PyObject_GC_NewVar$descriptor() {
        return _PyObject_GC_NewVar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyVarObject *_PyObject_GC_NewVar(PyTypeObject *, Py_ssize_t)
     * }
     */
    public static MethodHandle _PyObject_GC_NewVar$handle() {
        return _PyObject_GC_NewVar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyVarObject *_PyObject_GC_NewVar(PyTypeObject *, Py_ssize_t)
     * }
     */
    public static MemorySegment _PyObject_GC_NewVar$address() {
        return _PyObject_GC_NewVar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyVarObject *_PyObject_GC_NewVar(PyTypeObject *, Py_ssize_t)
     * }
     */
    public static MemorySegment _PyObject_GC_NewVar(MemorySegment x0, long x1) {
        var mh$ = _PyObject_GC_NewVar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyObject_GC_NewVar", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_GC_Track {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_GC_Track");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyObject_GC_Track(void *)
     * }
     */
    public static FunctionDescriptor PyObject_GC_Track$descriptor() {
        return PyObject_GC_Track.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyObject_GC_Track(void *)
     * }
     */
    public static MethodHandle PyObject_GC_Track$handle() {
        return PyObject_GC_Track.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyObject_GC_Track(void *)
     * }
     */
    public static MemorySegment PyObject_GC_Track$address() {
        return PyObject_GC_Track.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyObject_GC_Track(void *)
     * }
     */
    public static void PyObject_GC_Track(MemorySegment x0) {
        var mh$ = PyObject_GC_Track.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_GC_Track", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_GC_UnTrack {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_GC_UnTrack");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyObject_GC_UnTrack(void *)
     * }
     */
    public static FunctionDescriptor PyObject_GC_UnTrack$descriptor() {
        return PyObject_GC_UnTrack.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyObject_GC_UnTrack(void *)
     * }
     */
    public static MethodHandle PyObject_GC_UnTrack$handle() {
        return PyObject_GC_UnTrack.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyObject_GC_UnTrack(void *)
     * }
     */
    public static MemorySegment PyObject_GC_UnTrack$address() {
        return PyObject_GC_UnTrack.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyObject_GC_UnTrack(void *)
     * }
     */
    public static void PyObject_GC_UnTrack(MemorySegment x0) {
        var mh$ = PyObject_GC_UnTrack.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_GC_UnTrack", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_GC_Del {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_GC_Del");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyObject_GC_Del(void *)
     * }
     */
    public static FunctionDescriptor PyObject_GC_Del$descriptor() {
        return PyObject_GC_Del.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyObject_GC_Del(void *)
     * }
     */
    public static MethodHandle PyObject_GC_Del$handle() {
        return PyObject_GC_Del.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyObject_GC_Del(void *)
     * }
     */
    public static MemorySegment PyObject_GC_Del$address() {
        return PyObject_GC_Del.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyObject_GC_Del(void *)
     * }
     */
    public static void PyObject_GC_Del(MemorySegment x0) {
        var mh$ = PyObject_GC_Del.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_GC_Del", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_GC_IsTracked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_GC_IsTracked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyObject_GC_IsTracked(PyObject *)
     * }
     */
    public static FunctionDescriptor PyObject_GC_IsTracked$descriptor() {
        return PyObject_GC_IsTracked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyObject_GC_IsTracked(PyObject *)
     * }
     */
    public static MethodHandle PyObject_GC_IsTracked$handle() {
        return PyObject_GC_IsTracked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyObject_GC_IsTracked(PyObject *)
     * }
     */
    public static MemorySegment PyObject_GC_IsTracked$address() {
        return PyObject_GC_IsTracked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyObject_GC_IsTracked(PyObject *)
     * }
     */
    public static int PyObject_GC_IsTracked(MemorySegment x0) {
        var mh$ = PyObject_GC_IsTracked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_GC_IsTracked", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_GC_IsFinalized {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_GC_IsFinalized");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyObject_GC_IsFinalized(PyObject *)
     * }
     */
    public static FunctionDescriptor PyObject_GC_IsFinalized$descriptor() {
        return PyObject_GC_IsFinalized.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyObject_GC_IsFinalized(PyObject *)
     * }
     */
    public static MethodHandle PyObject_GC_IsFinalized$handle() {
        return PyObject_GC_IsFinalized.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyObject_GC_IsFinalized(PyObject *)
     * }
     */
    public static MemorySegment PyObject_GC_IsFinalized$address() {
        return PyObject_GC_IsFinalized.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyObject_GC_IsFinalized(PyObject *)
     * }
     */
    public static int PyObject_GC_IsFinalized(MemorySegment x0) {
        var mh$ = PyObject_GC_IsFinalized.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_GC_IsFinalized", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyByteArray_Type$constants {
        public static final GroupLayout LAYOUT = _object.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyByteArray_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyByteArray_Type
     * }
     */
    public static GroupLayout PyByteArray_Type$layout() {
        return PyByteArray_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyByteArray_Type
     * }
     */
    public static MemorySegment PyByteArray_Type() {
        return PyByteArray_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyByteArray_Type
     * }
     */
    public static void PyByteArray_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyByteArray_Type$constants.SEGMENT, 0L, PyByteArray_Type$constants.LAYOUT.byteSize());
    }

    private static class PyByteArrayIter_Type$constants {
        public static final GroupLayout LAYOUT = _object.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyByteArrayIter_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyByteArrayIter_Type
     * }
     */
    public static GroupLayout PyByteArrayIter_Type$layout() {
        return PyByteArrayIter_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyByteArrayIter_Type
     * }
     */
    public static MemorySegment PyByteArrayIter_Type() {
        return PyByteArrayIter_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyByteArrayIter_Type
     * }
     */
    public static void PyByteArrayIter_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyByteArrayIter_Type$constants.SEGMENT, 0L, PyByteArrayIter_Type$constants.LAYOUT.byteSize());
    }

    private static class PyByteArray_FromObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyByteArray_FromObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyByteArray_FromObject(PyObject *)
     * }
     */
    public static FunctionDescriptor PyByteArray_FromObject$descriptor() {
        return PyByteArray_FromObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyByteArray_FromObject(PyObject *)
     * }
     */
    public static MethodHandle PyByteArray_FromObject$handle() {
        return PyByteArray_FromObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyByteArray_FromObject(PyObject *)
     * }
     */
    public static MemorySegment PyByteArray_FromObject$address() {
        return PyByteArray_FromObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyByteArray_FromObject(PyObject *)
     * }
     */
    public static MemorySegment PyByteArray_FromObject(MemorySegment x0) {
        var mh$ = PyByteArray_FromObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyByteArray_FromObject", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyByteArray_Concat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyByteArray_Concat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyByteArray_Concat(PyObject *, PyObject *)
     * }
     */
    public static FunctionDescriptor PyByteArray_Concat$descriptor() {
        return PyByteArray_Concat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyByteArray_Concat(PyObject *, PyObject *)
     * }
     */
    public static MethodHandle PyByteArray_Concat$handle() {
        return PyByteArray_Concat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyByteArray_Concat(PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyByteArray_Concat$address() {
        return PyByteArray_Concat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyByteArray_Concat(PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyByteArray_Concat(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyByteArray_Concat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyByteArray_Concat", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyByteArray_FromStringAndSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyByteArray_FromStringAndSize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyByteArray_FromStringAndSize(const char *, Py_ssize_t)
     * }
     */
    public static FunctionDescriptor PyByteArray_FromStringAndSize$descriptor() {
        return PyByteArray_FromStringAndSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyByteArray_FromStringAndSize(const char *, Py_ssize_t)
     * }
     */
    public static MethodHandle PyByteArray_FromStringAndSize$handle() {
        return PyByteArray_FromStringAndSize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyByteArray_FromStringAndSize(const char *, Py_ssize_t)
     * }
     */
    public static MemorySegment PyByteArray_FromStringAndSize$address() {
        return PyByteArray_FromStringAndSize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyByteArray_FromStringAndSize(const char *, Py_ssize_t)
     * }
     */
    public static MemorySegment PyByteArray_FromStringAndSize(MemorySegment x0, long x1) {
        var mh$ = PyByteArray_FromStringAndSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyByteArray_FromStringAndSize", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyByteArray_Size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyByteArray_Size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_ssize_t PyByteArray_Size(PyObject *)
     * }
     */
    public static FunctionDescriptor PyByteArray_Size$descriptor() {
        return PyByteArray_Size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_ssize_t PyByteArray_Size(PyObject *)
     * }
     */
    public static MethodHandle PyByteArray_Size$handle() {
        return PyByteArray_Size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_ssize_t PyByteArray_Size(PyObject *)
     * }
     */
    public static MemorySegment PyByteArray_Size$address() {
        return PyByteArray_Size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_ssize_t PyByteArray_Size(PyObject *)
     * }
     */
    public static long PyByteArray_Size(MemorySegment x0) {
        var mh$ = PyByteArray_Size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyByteArray_Size", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyByteArray_AsString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyByteArray_AsString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *PyByteArray_AsString(PyObject *)
     * }
     */
    public static FunctionDescriptor PyByteArray_AsString$descriptor() {
        return PyByteArray_AsString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *PyByteArray_AsString(PyObject *)
     * }
     */
    public static MethodHandle PyByteArray_AsString$handle() {
        return PyByteArray_AsString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *PyByteArray_AsString(PyObject *)
     * }
     */
    public static MemorySegment PyByteArray_AsString$address() {
        return PyByteArray_AsString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *PyByteArray_AsString(PyObject *)
     * }
     */
    public static MemorySegment PyByteArray_AsString(MemorySegment x0) {
        var mh$ = PyByteArray_AsString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyByteArray_AsString", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyByteArray_Resize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyByteArray_Resize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyByteArray_Resize(PyObject *, Py_ssize_t)
     * }
     */
    public static FunctionDescriptor PyByteArray_Resize$descriptor() {
        return PyByteArray_Resize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyByteArray_Resize(PyObject *, Py_ssize_t)
     * }
     */
    public static MethodHandle PyByteArray_Resize$handle() {
        return PyByteArray_Resize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyByteArray_Resize(PyObject *, Py_ssize_t)
     * }
     */
    public static MemorySegment PyByteArray_Resize$address() {
        return PyByteArray_Resize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyByteArray_Resize(PyObject *, Py_ssize_t)
     * }
     */
    public static int PyByteArray_Resize(MemorySegment x0, long x1) {
        var mh$ = PyByteArray_Resize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyByteArray_Resize", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef __builtin_va_list __gnuc_va_list
     * }
     */
    public static final AddressLayout __gnuc_va_list = Python_h.C_POINTER;

    private static class PyBytes_Type$constants {
        public static final GroupLayout LAYOUT = _object.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyBytes_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyBytes_Type
     * }
     */
    public static GroupLayout PyBytes_Type$layout() {
        return PyBytes_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyBytes_Type
     * }
     */
    public static MemorySegment PyBytes_Type() {
        return PyBytes_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyBytes_Type
     * }
     */
    public static void PyBytes_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyBytes_Type$constants.SEGMENT, 0L, PyBytes_Type$constants.LAYOUT.byteSize());
    }

    private static class PyBytesIter_Type$constants {
        public static final GroupLayout LAYOUT = _object.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyBytesIter_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyBytesIter_Type
     * }
     */
    public static GroupLayout PyBytesIter_Type$layout() {
        return PyBytesIter_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyBytesIter_Type
     * }
     */
    public static MemorySegment PyBytesIter_Type() {
        return PyBytesIter_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyBytesIter_Type
     * }
     */
    public static void PyBytesIter_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyBytesIter_Type$constants.SEGMENT, 0L, PyBytesIter_Type$constants.LAYOUT.byteSize());
    }

    private static class PyBytes_FromStringAndSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyBytes_FromStringAndSize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyBytes_FromStringAndSize(const char *, Py_ssize_t)
     * }
     */
    public static FunctionDescriptor PyBytes_FromStringAndSize$descriptor() {
        return PyBytes_FromStringAndSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyBytes_FromStringAndSize(const char *, Py_ssize_t)
     * }
     */
    public static MethodHandle PyBytes_FromStringAndSize$handle() {
        return PyBytes_FromStringAndSize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyBytes_FromStringAndSize(const char *, Py_ssize_t)
     * }
     */
    public static MemorySegment PyBytes_FromStringAndSize$address() {
        return PyBytes_FromStringAndSize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyBytes_FromStringAndSize(const char *, Py_ssize_t)
     * }
     */
    public static MemorySegment PyBytes_FromStringAndSize(MemorySegment x0, long x1) {
        var mh$ = PyBytes_FromStringAndSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyBytes_FromStringAndSize", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyBytes_FromString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyBytes_FromString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyBytes_FromString(const char *)
     * }
     */
    public static FunctionDescriptor PyBytes_FromString$descriptor() {
        return PyBytes_FromString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyBytes_FromString(const char *)
     * }
     */
    public static MethodHandle PyBytes_FromString$handle() {
        return PyBytes_FromString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyBytes_FromString(const char *)
     * }
     */
    public static MemorySegment PyBytes_FromString$address() {
        return PyBytes_FromString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyBytes_FromString(const char *)
     * }
     */
    public static MemorySegment PyBytes_FromString(MemorySegment x0) {
        var mh$ = PyBytes_FromString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyBytes_FromString", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyBytes_FromObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyBytes_FromObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyBytes_FromObject(PyObject *)
     * }
     */
    public static FunctionDescriptor PyBytes_FromObject$descriptor() {
        return PyBytes_FromObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyBytes_FromObject(PyObject *)
     * }
     */
    public static MethodHandle PyBytes_FromObject$handle() {
        return PyBytes_FromObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyBytes_FromObject(PyObject *)
     * }
     */
    public static MemorySegment PyBytes_FromObject$address() {
        return PyBytes_FromObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyBytes_FromObject(PyObject *)
     * }
     */
    public static MemorySegment PyBytes_FromObject(MemorySegment x0) {
        var mh$ = PyBytes_FromObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyBytes_FromObject", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyBytes_FromFormatV {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyBytes_FromFormatV");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyBytes_FromFormatV(const char *, va_list)
     * }
     */
    public static FunctionDescriptor PyBytes_FromFormatV$descriptor() {
        return PyBytes_FromFormatV.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyBytes_FromFormatV(const char *, va_list)
     * }
     */
    public static MethodHandle PyBytes_FromFormatV$handle() {
        return PyBytes_FromFormatV.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyBytes_FromFormatV(const char *, va_list)
     * }
     */
    public static MemorySegment PyBytes_FromFormatV$address() {
        return PyBytes_FromFormatV.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyBytes_FromFormatV(const char *, va_list)
     * }
     */
    public static MemorySegment PyBytes_FromFormatV(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyBytes_FromFormatV.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyBytes_FromFormatV", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * PyObject *PyBytes_FromFormat(const char *, ...)
     * }
     */
    public static class PyBytes_FromFormat {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_POINTER,
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("PyBytes_FromFormat");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private PyBytes_FromFormat(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * PyObject *PyBytes_FromFormat(const char *, ...)
         * }
         */
        public static PyBytes_FromFormat makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new PyBytes_FromFormat(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public MemorySegment apply(MemorySegment x0, Object... x1) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("PyBytes_FromFormat", x0, x1);
                }
                return (MemorySegment)spreader.invokeExact(x0, x1);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class PyBytes_Size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyBytes_Size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_ssize_t PyBytes_Size(PyObject *)
     * }
     */
    public static FunctionDescriptor PyBytes_Size$descriptor() {
        return PyBytes_Size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_ssize_t PyBytes_Size(PyObject *)
     * }
     */
    public static MethodHandle PyBytes_Size$handle() {
        return PyBytes_Size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_ssize_t PyBytes_Size(PyObject *)
     * }
     */
    public static MemorySegment PyBytes_Size$address() {
        return PyBytes_Size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_ssize_t PyBytes_Size(PyObject *)
     * }
     */
    public static long PyBytes_Size(MemorySegment x0) {
        var mh$ = PyBytes_Size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyBytes_Size", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyBytes_AsString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyBytes_AsString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *PyBytes_AsString(PyObject *)
     * }
     */
    public static FunctionDescriptor PyBytes_AsString$descriptor() {
        return PyBytes_AsString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *PyBytes_AsString(PyObject *)
     * }
     */
    public static MethodHandle PyBytes_AsString$handle() {
        return PyBytes_AsString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *PyBytes_AsString(PyObject *)
     * }
     */
    public static MemorySegment PyBytes_AsString$address() {
        return PyBytes_AsString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *PyBytes_AsString(PyObject *)
     * }
     */
    public static MemorySegment PyBytes_AsString(MemorySegment x0) {
        var mh$ = PyBytes_AsString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyBytes_AsString", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyBytes_Repr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyBytes_Repr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyBytes_Repr(PyObject *, int)
     * }
     */
    public static FunctionDescriptor PyBytes_Repr$descriptor() {
        return PyBytes_Repr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyBytes_Repr(PyObject *, int)
     * }
     */
    public static MethodHandle PyBytes_Repr$handle() {
        return PyBytes_Repr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyBytes_Repr(PyObject *, int)
     * }
     */
    public static MemorySegment PyBytes_Repr$address() {
        return PyBytes_Repr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyBytes_Repr(PyObject *, int)
     * }
     */
    public static MemorySegment PyBytes_Repr(MemorySegment x0, int x1) {
        var mh$ = PyBytes_Repr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyBytes_Repr", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyBytes_Concat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyBytes_Concat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyBytes_Concat(PyObject **, PyObject *)
     * }
     */
    public static FunctionDescriptor PyBytes_Concat$descriptor() {
        return PyBytes_Concat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyBytes_Concat(PyObject **, PyObject *)
     * }
     */
    public static MethodHandle PyBytes_Concat$handle() {
        return PyBytes_Concat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyBytes_Concat(PyObject **, PyObject *)
     * }
     */
    public static MemorySegment PyBytes_Concat$address() {
        return PyBytes_Concat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyBytes_Concat(PyObject **, PyObject *)
     * }
     */
    public static void PyBytes_Concat(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyBytes_Concat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyBytes_Concat", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyBytes_ConcatAndDel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyBytes_ConcatAndDel");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyBytes_ConcatAndDel(PyObject **, PyObject *)
     * }
     */
    public static FunctionDescriptor PyBytes_ConcatAndDel$descriptor() {
        return PyBytes_ConcatAndDel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyBytes_ConcatAndDel(PyObject **, PyObject *)
     * }
     */
    public static MethodHandle PyBytes_ConcatAndDel$handle() {
        return PyBytes_ConcatAndDel.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyBytes_ConcatAndDel(PyObject **, PyObject *)
     * }
     */
    public static MemorySegment PyBytes_ConcatAndDel$address() {
        return PyBytes_ConcatAndDel.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyBytes_ConcatAndDel(PyObject **, PyObject *)
     * }
     */
    public static void PyBytes_ConcatAndDel(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyBytes_ConcatAndDel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyBytes_ConcatAndDel", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyBytes_DecodeEscape {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyBytes_DecodeEscape");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyBytes_DecodeEscape(const char *, Py_ssize_t, const char *, Py_ssize_t, const char *)
     * }
     */
    public static FunctionDescriptor PyBytes_DecodeEscape$descriptor() {
        return PyBytes_DecodeEscape.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyBytes_DecodeEscape(const char *, Py_ssize_t, const char *, Py_ssize_t, const char *)
     * }
     */
    public static MethodHandle PyBytes_DecodeEscape$handle() {
        return PyBytes_DecodeEscape.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyBytes_DecodeEscape(const char *, Py_ssize_t, const char *, Py_ssize_t, const char *)
     * }
     */
    public static MemorySegment PyBytes_DecodeEscape$address() {
        return PyBytes_DecodeEscape.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyBytes_DecodeEscape(const char *, Py_ssize_t, const char *, Py_ssize_t, const char *)
     * }
     */
    public static MemorySegment PyBytes_DecodeEscape(MemorySegment x0, long x1, MemorySegment x2, long x3, MemorySegment x4) {
        var mh$ = PyBytes_DecodeEscape.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyBytes_DecodeEscape", x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyBytes_AsStringAndSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyBytes_AsStringAndSize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyBytes_AsStringAndSize(PyObject *obj, char **s, Py_ssize_t *len)
     * }
     */
    public static FunctionDescriptor PyBytes_AsStringAndSize$descriptor() {
        return PyBytes_AsStringAndSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyBytes_AsStringAndSize(PyObject *obj, char **s, Py_ssize_t *len)
     * }
     */
    public static MethodHandle PyBytes_AsStringAndSize$handle() {
        return PyBytes_AsStringAndSize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyBytes_AsStringAndSize(PyObject *obj, char **s, Py_ssize_t *len)
     * }
     */
    public static MemorySegment PyBytes_AsStringAndSize$address() {
        return PyBytes_AsStringAndSize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyBytes_AsStringAndSize(PyObject *obj, char **s, Py_ssize_t *len)
     * }
     */
    public static int PyBytes_AsStringAndSize(MemorySegment obj, MemorySegment s, MemorySegment len) {
        var mh$ = PyBytes_AsStringAndSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyBytes_AsStringAndSize", obj, s, len);
            }
            return (int)mh$.invokeExact(obj, s, len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _isctype {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_isctype");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _isctype(int _C, int _Type)
     * }
     */
    public static FunctionDescriptor _isctype$descriptor() {
        return _isctype.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _isctype(int _C, int _Type)
     * }
     */
    public static MethodHandle _isctype$handle() {
        return _isctype.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _isctype(int _C, int _Type)
     * }
     */
    public static MemorySegment _isctype$address() {
        return _isctype.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _isctype(int _C, int _Type)
     * }
     */
    public static int _isctype(int _C, int _Type) {
        var mh$ = _isctype.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_isctype", _C, _Type);
            }
            return (int)mh$.invokeExact(_C, _Type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _isctype_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_isctype_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _isctype_l(int _C, int _Type, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _isctype_l$descriptor() {
        return _isctype_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _isctype_l(int _C, int _Type, _locale_t _Locale)
     * }
     */
    public static MethodHandle _isctype_l$handle() {
        return _isctype_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _isctype_l(int _C, int _Type, _locale_t _Locale)
     * }
     */
    public static MemorySegment _isctype_l$address() {
        return _isctype_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _isctype_l(int _C, int _Type, _locale_t _Locale)
     * }
     */
    public static int _isctype_l(int _C, int _Type, MemorySegment _Locale) {
        var mh$ = _isctype_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_isctype_l", _C, _Type, _Locale);
            }
            return (int)mh$.invokeExact(_C, _Type, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class isalpha {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("isalpha");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int isalpha(int _C)
     * }
     */
    public static FunctionDescriptor isalpha$descriptor() {
        return isalpha.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int isalpha(int _C)
     * }
     */
    public static MethodHandle isalpha$handle() {
        return isalpha.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int isalpha(int _C)
     * }
     */
    public static MemorySegment isalpha$address() {
        return isalpha.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int isalpha(int _C)
     * }
     */
    public static int isalpha(int _C) {
        var mh$ = isalpha.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("isalpha", _C);
            }
            return (int)mh$.invokeExact(_C);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _isalpha_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_isalpha_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _isalpha_l(int _C, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _isalpha_l$descriptor() {
        return _isalpha_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _isalpha_l(int _C, _locale_t _Locale)
     * }
     */
    public static MethodHandle _isalpha_l$handle() {
        return _isalpha_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _isalpha_l(int _C, _locale_t _Locale)
     * }
     */
    public static MemorySegment _isalpha_l$address() {
        return _isalpha_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _isalpha_l(int _C, _locale_t _Locale)
     * }
     */
    public static int _isalpha_l(int _C, MemorySegment _Locale) {
        var mh$ = _isalpha_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_isalpha_l", _C, _Locale);
            }
            return (int)mh$.invokeExact(_C, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class isupper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("isupper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int isupper(int _C)
     * }
     */
    public static FunctionDescriptor isupper$descriptor() {
        return isupper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int isupper(int _C)
     * }
     */
    public static MethodHandle isupper$handle() {
        return isupper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int isupper(int _C)
     * }
     */
    public static MemorySegment isupper$address() {
        return isupper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int isupper(int _C)
     * }
     */
    public static int isupper(int _C) {
        var mh$ = isupper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("isupper", _C);
            }
            return (int)mh$.invokeExact(_C);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _isupper_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_isupper_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _isupper_l(int _C, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _isupper_l$descriptor() {
        return _isupper_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _isupper_l(int _C, _locale_t _Locale)
     * }
     */
    public static MethodHandle _isupper_l$handle() {
        return _isupper_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _isupper_l(int _C, _locale_t _Locale)
     * }
     */
    public static MemorySegment _isupper_l$address() {
        return _isupper_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _isupper_l(int _C, _locale_t _Locale)
     * }
     */
    public static int _isupper_l(int _C, MemorySegment _Locale) {
        var mh$ = _isupper_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_isupper_l", _C, _Locale);
            }
            return (int)mh$.invokeExact(_C, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class islower {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("islower");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int islower(int _C)
     * }
     */
    public static FunctionDescriptor islower$descriptor() {
        return islower.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int islower(int _C)
     * }
     */
    public static MethodHandle islower$handle() {
        return islower.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int islower(int _C)
     * }
     */
    public static MemorySegment islower$address() {
        return islower.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int islower(int _C)
     * }
     */
    public static int islower(int _C) {
        var mh$ = islower.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("islower", _C);
            }
            return (int)mh$.invokeExact(_C);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _islower_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_islower_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _islower_l(int _C, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _islower_l$descriptor() {
        return _islower_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _islower_l(int _C, _locale_t _Locale)
     * }
     */
    public static MethodHandle _islower_l$handle() {
        return _islower_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _islower_l(int _C, _locale_t _Locale)
     * }
     */
    public static MemorySegment _islower_l$address() {
        return _islower_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _islower_l(int _C, _locale_t _Locale)
     * }
     */
    public static int _islower_l(int _C, MemorySegment _Locale) {
        var mh$ = _islower_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_islower_l", _C, _Locale);
            }
            return (int)mh$.invokeExact(_C, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class isdigit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("isdigit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int isdigit(int _C)
     * }
     */
    public static FunctionDescriptor isdigit$descriptor() {
        return isdigit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int isdigit(int _C)
     * }
     */
    public static MethodHandle isdigit$handle() {
        return isdigit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int isdigit(int _C)
     * }
     */
    public static MemorySegment isdigit$address() {
        return isdigit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int isdigit(int _C)
     * }
     */
    public static int isdigit(int _C) {
        var mh$ = isdigit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("isdigit", _C);
            }
            return (int)mh$.invokeExact(_C);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _isdigit_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_isdigit_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _isdigit_l(int _C, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _isdigit_l$descriptor() {
        return _isdigit_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _isdigit_l(int _C, _locale_t _Locale)
     * }
     */
    public static MethodHandle _isdigit_l$handle() {
        return _isdigit_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _isdigit_l(int _C, _locale_t _Locale)
     * }
     */
    public static MemorySegment _isdigit_l$address() {
        return _isdigit_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _isdigit_l(int _C, _locale_t _Locale)
     * }
     */
    public static int _isdigit_l(int _C, MemorySegment _Locale) {
        var mh$ = _isdigit_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_isdigit_l", _C, _Locale);
            }
            return (int)mh$.invokeExact(_C, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class isxdigit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("isxdigit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int isxdigit(int _C)
     * }
     */
    public static FunctionDescriptor isxdigit$descriptor() {
        return isxdigit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int isxdigit(int _C)
     * }
     */
    public static MethodHandle isxdigit$handle() {
        return isxdigit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int isxdigit(int _C)
     * }
     */
    public static MemorySegment isxdigit$address() {
        return isxdigit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int isxdigit(int _C)
     * }
     */
    public static int isxdigit(int _C) {
        var mh$ = isxdigit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("isxdigit", _C);
            }
            return (int)mh$.invokeExact(_C);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _isxdigit_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_isxdigit_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _isxdigit_l(int _C, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _isxdigit_l$descriptor() {
        return _isxdigit_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _isxdigit_l(int _C, _locale_t _Locale)
     * }
     */
    public static MethodHandle _isxdigit_l$handle() {
        return _isxdigit_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _isxdigit_l(int _C, _locale_t _Locale)
     * }
     */
    public static MemorySegment _isxdigit_l$address() {
        return _isxdigit_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _isxdigit_l(int _C, _locale_t _Locale)
     * }
     */
    public static int _isxdigit_l(int _C, MemorySegment _Locale) {
        var mh$ = _isxdigit_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_isxdigit_l", _C, _Locale);
            }
            return (int)mh$.invokeExact(_C, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class isspace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("isspace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int isspace(int _C)
     * }
     */
    public static FunctionDescriptor isspace$descriptor() {
        return isspace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int isspace(int _C)
     * }
     */
    public static MethodHandle isspace$handle() {
        return isspace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int isspace(int _C)
     * }
     */
    public static MemorySegment isspace$address() {
        return isspace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int isspace(int _C)
     * }
     */
    public static int isspace(int _C) {
        var mh$ = isspace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("isspace", _C);
            }
            return (int)mh$.invokeExact(_C);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _isspace_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_isspace_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _isspace_l(int _C, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _isspace_l$descriptor() {
        return _isspace_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _isspace_l(int _C, _locale_t _Locale)
     * }
     */
    public static MethodHandle _isspace_l$handle() {
        return _isspace_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _isspace_l(int _C, _locale_t _Locale)
     * }
     */
    public static MemorySegment _isspace_l$address() {
        return _isspace_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _isspace_l(int _C, _locale_t _Locale)
     * }
     */
    public static int _isspace_l(int _C, MemorySegment _Locale) {
        var mh$ = _isspace_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_isspace_l", _C, _Locale);
            }
            return (int)mh$.invokeExact(_C, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ispunct {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("ispunct");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ispunct(int _C)
     * }
     */
    public static FunctionDescriptor ispunct$descriptor() {
        return ispunct.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ispunct(int _C)
     * }
     */
    public static MethodHandle ispunct$handle() {
        return ispunct.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ispunct(int _C)
     * }
     */
    public static MemorySegment ispunct$address() {
        return ispunct.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ispunct(int _C)
     * }
     */
    public static int ispunct(int _C) {
        var mh$ = ispunct.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ispunct", _C);
            }
            return (int)mh$.invokeExact(_C);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ispunct_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_ispunct_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _ispunct_l(int _C, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _ispunct_l$descriptor() {
        return _ispunct_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _ispunct_l(int _C, _locale_t _Locale)
     * }
     */
    public static MethodHandle _ispunct_l$handle() {
        return _ispunct_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _ispunct_l(int _C, _locale_t _Locale)
     * }
     */
    public static MemorySegment _ispunct_l$address() {
        return _ispunct_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _ispunct_l(int _C, _locale_t _Locale)
     * }
     */
    public static int _ispunct_l(int _C, MemorySegment _Locale) {
        var mh$ = _ispunct_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ispunct_l", _C, _Locale);
            }
            return (int)mh$.invokeExact(_C, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class isblank {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("isblank");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int isblank(int _C)
     * }
     */
    public static FunctionDescriptor isblank$descriptor() {
        return isblank.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int isblank(int _C)
     * }
     */
    public static MethodHandle isblank$handle() {
        return isblank.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int isblank(int _C)
     * }
     */
    public static MemorySegment isblank$address() {
        return isblank.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int isblank(int _C)
     * }
     */
    public static int isblank(int _C) {
        var mh$ = isblank.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("isblank", _C);
            }
            return (int)mh$.invokeExact(_C);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _isblank_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_isblank_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _isblank_l(int _C, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _isblank_l$descriptor() {
        return _isblank_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _isblank_l(int _C, _locale_t _Locale)
     * }
     */
    public static MethodHandle _isblank_l$handle() {
        return _isblank_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _isblank_l(int _C, _locale_t _Locale)
     * }
     */
    public static MemorySegment _isblank_l$address() {
        return _isblank_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _isblank_l(int _C, _locale_t _Locale)
     * }
     */
    public static int _isblank_l(int _C, MemorySegment _Locale) {
        var mh$ = _isblank_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_isblank_l", _C, _Locale);
            }
            return (int)mh$.invokeExact(_C, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class isalnum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("isalnum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int isalnum(int _C)
     * }
     */
    public static FunctionDescriptor isalnum$descriptor() {
        return isalnum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int isalnum(int _C)
     * }
     */
    public static MethodHandle isalnum$handle() {
        return isalnum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int isalnum(int _C)
     * }
     */
    public static MemorySegment isalnum$address() {
        return isalnum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int isalnum(int _C)
     * }
     */
    public static int isalnum(int _C) {
        var mh$ = isalnum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("isalnum", _C);
            }
            return (int)mh$.invokeExact(_C);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _isalnum_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_isalnum_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _isalnum_l(int _C, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _isalnum_l$descriptor() {
        return _isalnum_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _isalnum_l(int _C, _locale_t _Locale)
     * }
     */
    public static MethodHandle _isalnum_l$handle() {
        return _isalnum_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _isalnum_l(int _C, _locale_t _Locale)
     * }
     */
    public static MemorySegment _isalnum_l$address() {
        return _isalnum_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _isalnum_l(int _C, _locale_t _Locale)
     * }
     */
    public static int _isalnum_l(int _C, MemorySegment _Locale) {
        var mh$ = _isalnum_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_isalnum_l", _C, _Locale);
            }
            return (int)mh$.invokeExact(_C, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class isprint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("isprint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int isprint(int _C)
     * }
     */
    public static FunctionDescriptor isprint$descriptor() {
        return isprint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int isprint(int _C)
     * }
     */
    public static MethodHandle isprint$handle() {
        return isprint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int isprint(int _C)
     * }
     */
    public static MemorySegment isprint$address() {
        return isprint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int isprint(int _C)
     * }
     */
    public static int isprint(int _C) {
        var mh$ = isprint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("isprint", _C);
            }
            return (int)mh$.invokeExact(_C);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _isprint_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_isprint_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _isprint_l(int _C, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _isprint_l$descriptor() {
        return _isprint_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _isprint_l(int _C, _locale_t _Locale)
     * }
     */
    public static MethodHandle _isprint_l$handle() {
        return _isprint_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _isprint_l(int _C, _locale_t _Locale)
     * }
     */
    public static MemorySegment _isprint_l$address() {
        return _isprint_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _isprint_l(int _C, _locale_t _Locale)
     * }
     */
    public static int _isprint_l(int _C, MemorySegment _Locale) {
        var mh$ = _isprint_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_isprint_l", _C, _Locale);
            }
            return (int)mh$.invokeExact(_C, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class isgraph {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("isgraph");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int isgraph(int _C)
     * }
     */
    public static FunctionDescriptor isgraph$descriptor() {
        return isgraph.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int isgraph(int _C)
     * }
     */
    public static MethodHandle isgraph$handle() {
        return isgraph.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int isgraph(int _C)
     * }
     */
    public static MemorySegment isgraph$address() {
        return isgraph.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int isgraph(int _C)
     * }
     */
    public static int isgraph(int _C) {
        var mh$ = isgraph.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("isgraph", _C);
            }
            return (int)mh$.invokeExact(_C);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _isgraph_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_isgraph_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _isgraph_l(int _C, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _isgraph_l$descriptor() {
        return _isgraph_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _isgraph_l(int _C, _locale_t _Locale)
     * }
     */
    public static MethodHandle _isgraph_l$handle() {
        return _isgraph_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _isgraph_l(int _C, _locale_t _Locale)
     * }
     */
    public static MemorySegment _isgraph_l$address() {
        return _isgraph_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _isgraph_l(int _C, _locale_t _Locale)
     * }
     */
    public static int _isgraph_l(int _C, MemorySegment _Locale) {
        var mh$ = _isgraph_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_isgraph_l", _C, _Locale);
            }
            return (int)mh$.invokeExact(_C, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class iscntrl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("iscntrl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int iscntrl(int _C)
     * }
     */
    public static FunctionDescriptor iscntrl$descriptor() {
        return iscntrl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int iscntrl(int _C)
     * }
     */
    public static MethodHandle iscntrl$handle() {
        return iscntrl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int iscntrl(int _C)
     * }
     */
    public static MemorySegment iscntrl$address() {
        return iscntrl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int iscntrl(int _C)
     * }
     */
    public static int iscntrl(int _C) {
        var mh$ = iscntrl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("iscntrl", _C);
            }
            return (int)mh$.invokeExact(_C);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _iscntrl_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_iscntrl_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _iscntrl_l(int _C, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _iscntrl_l$descriptor() {
        return _iscntrl_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _iscntrl_l(int _C, _locale_t _Locale)
     * }
     */
    public static MethodHandle _iscntrl_l$handle() {
        return _iscntrl_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _iscntrl_l(int _C, _locale_t _Locale)
     * }
     */
    public static MemorySegment _iscntrl_l$address() {
        return _iscntrl_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _iscntrl_l(int _C, _locale_t _Locale)
     * }
     */
    public static int _iscntrl_l(int _C, MemorySegment _Locale) {
        var mh$ = _iscntrl_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_iscntrl_l", _C, _Locale);
            }
            return (int)mh$.invokeExact(_C, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class toupper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("toupper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int toupper(int _C)
     * }
     */
    public static FunctionDescriptor toupper$descriptor() {
        return toupper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int toupper(int _C)
     * }
     */
    public static MethodHandle toupper$handle() {
        return toupper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int toupper(int _C)
     * }
     */
    public static MemorySegment toupper$address() {
        return toupper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int toupper(int _C)
     * }
     */
    public static int toupper(int _C) {
        var mh$ = toupper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("toupper", _C);
            }
            return (int)mh$.invokeExact(_C);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tolower {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("tolower");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int tolower(int _C)
     * }
     */
    public static FunctionDescriptor tolower$descriptor() {
        return tolower.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int tolower(int _C)
     * }
     */
    public static MethodHandle tolower$handle() {
        return tolower.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int tolower(int _C)
     * }
     */
    public static MemorySegment tolower$address() {
        return tolower.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int tolower(int _C)
     * }
     */
    public static int tolower(int _C) {
        var mh$ = tolower.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tolower", _C);
            }
            return (int)mh$.invokeExact(_C);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _tolower {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_tolower");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _tolower(int _C)
     * }
     */
    public static FunctionDescriptor _tolower$descriptor() {
        return _tolower.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _tolower(int _C)
     * }
     */
    public static MethodHandle _tolower$handle() {
        return _tolower.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _tolower(int _C)
     * }
     */
    public static MemorySegment _tolower$address() {
        return _tolower.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _tolower(int _C)
     * }
     */
    public static int _tolower(int _C) {
        var mh$ = _tolower.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_tolower", _C);
            }
            return (int)mh$.invokeExact(_C);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _tolower_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_tolower_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _tolower_l(int _C, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _tolower_l$descriptor() {
        return _tolower_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _tolower_l(int _C, _locale_t _Locale)
     * }
     */
    public static MethodHandle _tolower_l$handle() {
        return _tolower_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _tolower_l(int _C, _locale_t _Locale)
     * }
     */
    public static MemorySegment _tolower_l$address() {
        return _tolower_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _tolower_l(int _C, _locale_t _Locale)
     * }
     */
    public static int _tolower_l(int _C, MemorySegment _Locale) {
        var mh$ = _tolower_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_tolower_l", _C, _Locale);
            }
            return (int)mh$.invokeExact(_C, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _toupper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_toupper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _toupper(int _C)
     * }
     */
    public static FunctionDescriptor _toupper$descriptor() {
        return _toupper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _toupper(int _C)
     * }
     */
    public static MethodHandle _toupper$handle() {
        return _toupper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _toupper(int _C)
     * }
     */
    public static MemorySegment _toupper$address() {
        return _toupper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _toupper(int _C)
     * }
     */
    public static int _toupper(int _C) {
        var mh$ = _toupper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_toupper", _C);
            }
            return (int)mh$.invokeExact(_C);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _toupper_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_toupper_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _toupper_l(int _C, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _toupper_l$descriptor() {
        return _toupper_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _toupper_l(int _C, _locale_t _Locale)
     * }
     */
    public static MethodHandle _toupper_l$handle() {
        return _toupper_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _toupper_l(int _C, _locale_t _Locale)
     * }
     */
    public static MemorySegment _toupper_l$address() {
        return _toupper_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _toupper_l(int _C, _locale_t _Locale)
     * }
     */
    public static int _toupper_l(int _C, MemorySegment _Locale) {
        var mh$ = _toupper_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_toupper_l", _C, _Locale);
            }
            return (int)mh$.invokeExact(_C, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __isascii {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("__isascii");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __isascii(int _C)
     * }
     */
    public static FunctionDescriptor __isascii$descriptor() {
        return __isascii.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __isascii(int _C)
     * }
     */
    public static MethodHandle __isascii$handle() {
        return __isascii.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __isascii(int _C)
     * }
     */
    public static MemorySegment __isascii$address() {
        return __isascii.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __isascii(int _C)
     * }
     */
    public static int __isascii(int _C) {
        var mh$ = __isascii.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__isascii", _C);
            }
            return (int)mh$.invokeExact(_C);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __toascii {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("__toascii");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __toascii(int _C)
     * }
     */
    public static FunctionDescriptor __toascii$descriptor() {
        return __toascii.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __toascii(int _C)
     * }
     */
    public static MethodHandle __toascii$handle() {
        return __toascii.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __toascii(int _C)
     * }
     */
    public static MemorySegment __toascii$address() {
        return __toascii.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __toascii(int _C)
     * }
     */
    public static int __toascii(int _C) {
        var mh$ = __toascii.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__toascii", _C);
            }
            return (int)mh$.invokeExact(_C);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __iscsymf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("__iscsymf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __iscsymf(int _C)
     * }
     */
    public static FunctionDescriptor __iscsymf$descriptor() {
        return __iscsymf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __iscsymf(int _C)
     * }
     */
    public static MethodHandle __iscsymf$handle() {
        return __iscsymf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __iscsymf(int _C)
     * }
     */
    public static MemorySegment __iscsymf$address() {
        return __iscsymf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __iscsymf(int _C)
     * }
     */
    public static int __iscsymf(int _C) {
        var mh$ = __iscsymf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__iscsymf", _C);
            }
            return (int)mh$.invokeExact(_C);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __iscsym {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("__iscsym");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __iscsym(int _C)
     * }
     */
    public static FunctionDescriptor __iscsym$descriptor() {
        return __iscsym.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __iscsym(int _C)
     * }
     */
    public static MethodHandle __iscsym$handle() {
        return __iscsym.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __iscsym(int _C)
     * }
     */
    public static MemorySegment __iscsym$address() {
        return __iscsym.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __iscsym(int _C)
     * }
     */
    public static int __iscsym(int _C) {
        var mh$ = __iscsym.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__iscsym", _C);
            }
            return (int)mh$.invokeExact(_C);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ___mb_cur_max_func {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("___mb_cur_max_func");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ___mb_cur_max_func()
     * }
     */
    public static FunctionDescriptor ___mb_cur_max_func$descriptor() {
        return ___mb_cur_max_func.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ___mb_cur_max_func()
     * }
     */
    public static MethodHandle ___mb_cur_max_func$handle() {
        return ___mb_cur_max_func.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ___mb_cur_max_func()
     * }
     */
    public static MemorySegment ___mb_cur_max_func$address() {
        return ___mb_cur_max_func.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ___mb_cur_max_func()
     * }
     */
    public static int ___mb_cur_max_func() {
        var mh$ = ___mb_cur_max_func.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("___mb_cur_max_func");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ___mb_cur_max_l_func {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("___mb_cur_max_l_func");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ___mb_cur_max_l_func(_locale_t _Locale)
     * }
     */
    public static FunctionDescriptor ___mb_cur_max_l_func$descriptor() {
        return ___mb_cur_max_l_func.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ___mb_cur_max_l_func(_locale_t _Locale)
     * }
     */
    public static MethodHandle ___mb_cur_max_l_func$handle() {
        return ___mb_cur_max_l_func.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ___mb_cur_max_l_func(_locale_t _Locale)
     * }
     */
    public static MemorySegment ___mb_cur_max_l_func$address() {
        return ___mb_cur_max_l_func.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ___mb_cur_max_l_func(_locale_t _Locale)
     * }
     */
    public static int ___mb_cur_max_l_func(MemorySegment _Locale) {
        var mh$ = ___mb_cur_max_l_func.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("___mb_cur_max_l_func", _Locale);
            }
            return (int)mh$.invokeExact(_Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef uint32_t Py_UCS4
     * }
     */
    public static final OfInt Py_UCS4 = Python_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef uint16_t Py_UCS2
     * }
     */
    public static final OfShort Py_UCS2 = Python_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef uint8_t Py_UCS1
     * }
     */
    public static final OfByte Py_UCS1 = Python_h.C_CHAR;

    private static class PyUnicode_Type$constants {
        public static final GroupLayout LAYOUT = _object.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyUnicode_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyUnicode_Type
     * }
     */
    public static GroupLayout PyUnicode_Type$layout() {
        return PyUnicode_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyUnicode_Type
     * }
     */
    public static MemorySegment PyUnicode_Type() {
        return PyUnicode_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyUnicode_Type
     * }
     */
    public static void PyUnicode_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyUnicode_Type$constants.SEGMENT, 0L, PyUnicode_Type$constants.LAYOUT.byteSize());
    }

    private static class PyUnicodeIter_Type$constants {
        public static final GroupLayout LAYOUT = _object.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyUnicodeIter_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyUnicodeIter_Type
     * }
     */
    public static GroupLayout PyUnicodeIter_Type$layout() {
        return PyUnicodeIter_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyUnicodeIter_Type
     * }
     */
    public static MemorySegment PyUnicodeIter_Type() {
        return PyUnicodeIter_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyUnicodeIter_Type
     * }
     */
    public static void PyUnicodeIter_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyUnicodeIter_Type$constants.SEGMENT, 0L, PyUnicodeIter_Type$constants.LAYOUT.byteSize());
    }

    private static class PyUnicode_FromStringAndSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_FromStringAndSize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_FromStringAndSize(const char *u, Py_ssize_t size)
     * }
     */
    public static FunctionDescriptor PyUnicode_FromStringAndSize$descriptor() {
        return PyUnicode_FromStringAndSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_FromStringAndSize(const char *u, Py_ssize_t size)
     * }
     */
    public static MethodHandle PyUnicode_FromStringAndSize$handle() {
        return PyUnicode_FromStringAndSize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_FromStringAndSize(const char *u, Py_ssize_t size)
     * }
     */
    public static MemorySegment PyUnicode_FromStringAndSize$address() {
        return PyUnicode_FromStringAndSize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_FromStringAndSize(const char *u, Py_ssize_t size)
     * }
     */
    public static MemorySegment PyUnicode_FromStringAndSize(MemorySegment u, long size) {
        var mh$ = PyUnicode_FromStringAndSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_FromStringAndSize", u, size);
            }
            return (MemorySegment)mh$.invokeExact(u, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_FromString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_FromString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_FromString(const char *u)
     * }
     */
    public static FunctionDescriptor PyUnicode_FromString$descriptor() {
        return PyUnicode_FromString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_FromString(const char *u)
     * }
     */
    public static MethodHandle PyUnicode_FromString$handle() {
        return PyUnicode_FromString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_FromString(const char *u)
     * }
     */
    public static MemorySegment PyUnicode_FromString$address() {
        return PyUnicode_FromString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_FromString(const char *u)
     * }
     */
    public static MemorySegment PyUnicode_FromString(MemorySegment u) {
        var mh$ = PyUnicode_FromString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_FromString", u);
            }
            return (MemorySegment)mh$.invokeExact(u);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_Substring {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_Substring");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_Substring(PyObject *str, Py_ssize_t start, Py_ssize_t end)
     * }
     */
    public static FunctionDescriptor PyUnicode_Substring$descriptor() {
        return PyUnicode_Substring.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_Substring(PyObject *str, Py_ssize_t start, Py_ssize_t end)
     * }
     */
    public static MethodHandle PyUnicode_Substring$handle() {
        return PyUnicode_Substring.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_Substring(PyObject *str, Py_ssize_t start, Py_ssize_t end)
     * }
     */
    public static MemorySegment PyUnicode_Substring$address() {
        return PyUnicode_Substring.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_Substring(PyObject *str, Py_ssize_t start, Py_ssize_t end)
     * }
     */
    public static MemorySegment PyUnicode_Substring(MemorySegment str, long start, long end) {
        var mh$ = PyUnicode_Substring.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_Substring", str, start, end);
            }
            return (MemorySegment)mh$.invokeExact(str, start, end);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_AsUCS4 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_AsUCS4");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_UCS4 *PyUnicode_AsUCS4(PyObject *unicode, Py_UCS4 *buffer, Py_ssize_t buflen, int copy_null)
     * }
     */
    public static FunctionDescriptor PyUnicode_AsUCS4$descriptor() {
        return PyUnicode_AsUCS4.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_UCS4 *PyUnicode_AsUCS4(PyObject *unicode, Py_UCS4 *buffer, Py_ssize_t buflen, int copy_null)
     * }
     */
    public static MethodHandle PyUnicode_AsUCS4$handle() {
        return PyUnicode_AsUCS4.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_UCS4 *PyUnicode_AsUCS4(PyObject *unicode, Py_UCS4 *buffer, Py_ssize_t buflen, int copy_null)
     * }
     */
    public static MemorySegment PyUnicode_AsUCS4$address() {
        return PyUnicode_AsUCS4.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_UCS4 *PyUnicode_AsUCS4(PyObject *unicode, Py_UCS4 *buffer, Py_ssize_t buflen, int copy_null)
     * }
     */
    public static MemorySegment PyUnicode_AsUCS4(MemorySegment unicode, MemorySegment buffer, long buflen, int copy_null) {
        var mh$ = PyUnicode_AsUCS4.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_AsUCS4", unicode, buffer, buflen, copy_null);
            }
            return (MemorySegment)mh$.invokeExact(unicode, buffer, buflen, copy_null);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_AsUCS4Copy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_AsUCS4Copy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_UCS4 *PyUnicode_AsUCS4Copy(PyObject *unicode)
     * }
     */
    public static FunctionDescriptor PyUnicode_AsUCS4Copy$descriptor() {
        return PyUnicode_AsUCS4Copy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_UCS4 *PyUnicode_AsUCS4Copy(PyObject *unicode)
     * }
     */
    public static MethodHandle PyUnicode_AsUCS4Copy$handle() {
        return PyUnicode_AsUCS4Copy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_UCS4 *PyUnicode_AsUCS4Copy(PyObject *unicode)
     * }
     */
    public static MemorySegment PyUnicode_AsUCS4Copy$address() {
        return PyUnicode_AsUCS4Copy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_UCS4 *PyUnicode_AsUCS4Copy(PyObject *unicode)
     * }
     */
    public static MemorySegment PyUnicode_AsUCS4Copy(MemorySegment unicode) {
        var mh$ = PyUnicode_AsUCS4Copy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_AsUCS4Copy", unicode);
            }
            return (MemorySegment)mh$.invokeExact(unicode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_GetLength {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_GetLength");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_ssize_t PyUnicode_GetLength(PyObject *unicode)
     * }
     */
    public static FunctionDescriptor PyUnicode_GetLength$descriptor() {
        return PyUnicode_GetLength.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_ssize_t PyUnicode_GetLength(PyObject *unicode)
     * }
     */
    public static MethodHandle PyUnicode_GetLength$handle() {
        return PyUnicode_GetLength.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_ssize_t PyUnicode_GetLength(PyObject *unicode)
     * }
     */
    public static MemorySegment PyUnicode_GetLength$address() {
        return PyUnicode_GetLength.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_ssize_t PyUnicode_GetLength(PyObject *unicode)
     * }
     */
    public static long PyUnicode_GetLength(MemorySegment unicode) {
        var mh$ = PyUnicode_GetLength.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_GetLength", unicode);
            }
            return (long)mh$.invokeExact(unicode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_ReadChar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_ReadChar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_UCS4 PyUnicode_ReadChar(PyObject *unicode, Py_ssize_t index)
     * }
     */
    public static FunctionDescriptor PyUnicode_ReadChar$descriptor() {
        return PyUnicode_ReadChar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_UCS4 PyUnicode_ReadChar(PyObject *unicode, Py_ssize_t index)
     * }
     */
    public static MethodHandle PyUnicode_ReadChar$handle() {
        return PyUnicode_ReadChar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_UCS4 PyUnicode_ReadChar(PyObject *unicode, Py_ssize_t index)
     * }
     */
    public static MemorySegment PyUnicode_ReadChar$address() {
        return PyUnicode_ReadChar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_UCS4 PyUnicode_ReadChar(PyObject *unicode, Py_ssize_t index)
     * }
     */
    public static int PyUnicode_ReadChar(MemorySegment unicode, long index) {
        var mh$ = PyUnicode_ReadChar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_ReadChar", unicode, index);
            }
            return (int)mh$.invokeExact(unicode, index);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_WriteChar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_WriteChar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyUnicode_WriteChar(PyObject *unicode, Py_ssize_t index, Py_UCS4 character)
     * }
     */
    public static FunctionDescriptor PyUnicode_WriteChar$descriptor() {
        return PyUnicode_WriteChar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyUnicode_WriteChar(PyObject *unicode, Py_ssize_t index, Py_UCS4 character)
     * }
     */
    public static MethodHandle PyUnicode_WriteChar$handle() {
        return PyUnicode_WriteChar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyUnicode_WriteChar(PyObject *unicode, Py_ssize_t index, Py_UCS4 character)
     * }
     */
    public static MemorySegment PyUnicode_WriteChar$address() {
        return PyUnicode_WriteChar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyUnicode_WriteChar(PyObject *unicode, Py_ssize_t index, Py_UCS4 character)
     * }
     */
    public static int PyUnicode_WriteChar(MemorySegment unicode, long index, int character) {
        var mh$ = PyUnicode_WriteChar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_WriteChar", unicode, index, character);
            }
            return (int)mh$.invokeExact(unicode, index, character);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_Resize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_Resize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyUnicode_Resize(PyObject **unicode, Py_ssize_t length)
     * }
     */
    public static FunctionDescriptor PyUnicode_Resize$descriptor() {
        return PyUnicode_Resize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyUnicode_Resize(PyObject **unicode, Py_ssize_t length)
     * }
     */
    public static MethodHandle PyUnicode_Resize$handle() {
        return PyUnicode_Resize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyUnicode_Resize(PyObject **unicode, Py_ssize_t length)
     * }
     */
    public static MemorySegment PyUnicode_Resize$address() {
        return PyUnicode_Resize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyUnicode_Resize(PyObject **unicode, Py_ssize_t length)
     * }
     */
    public static int PyUnicode_Resize(MemorySegment unicode, long length) {
        var mh$ = PyUnicode_Resize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_Resize", unicode, length);
            }
            return (int)mh$.invokeExact(unicode, length);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_FromEncodedObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_FromEncodedObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_FromEncodedObject(PyObject *obj, const char *encoding, const char *errors)
     * }
     */
    public static FunctionDescriptor PyUnicode_FromEncodedObject$descriptor() {
        return PyUnicode_FromEncodedObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_FromEncodedObject(PyObject *obj, const char *encoding, const char *errors)
     * }
     */
    public static MethodHandle PyUnicode_FromEncodedObject$handle() {
        return PyUnicode_FromEncodedObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_FromEncodedObject(PyObject *obj, const char *encoding, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_FromEncodedObject$address() {
        return PyUnicode_FromEncodedObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_FromEncodedObject(PyObject *obj, const char *encoding, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_FromEncodedObject(MemorySegment obj, MemorySegment encoding, MemorySegment errors) {
        var mh$ = PyUnicode_FromEncodedObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_FromEncodedObject", obj, encoding, errors);
            }
            return (MemorySegment)mh$.invokeExact(obj, encoding, errors);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_FromObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_FromObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_FromObject(PyObject *obj)
     * }
     */
    public static FunctionDescriptor PyUnicode_FromObject$descriptor() {
        return PyUnicode_FromObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_FromObject(PyObject *obj)
     * }
     */
    public static MethodHandle PyUnicode_FromObject$handle() {
        return PyUnicode_FromObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_FromObject(PyObject *obj)
     * }
     */
    public static MemorySegment PyUnicode_FromObject$address() {
        return PyUnicode_FromObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_FromObject(PyObject *obj)
     * }
     */
    public static MemorySegment PyUnicode_FromObject(MemorySegment obj) {
        var mh$ = PyUnicode_FromObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_FromObject", obj);
            }
            return (MemorySegment)mh$.invokeExact(obj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_FromFormatV {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_FromFormatV");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_FromFormatV(const char *format, va_list vargs)
     * }
     */
    public static FunctionDescriptor PyUnicode_FromFormatV$descriptor() {
        return PyUnicode_FromFormatV.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_FromFormatV(const char *format, va_list vargs)
     * }
     */
    public static MethodHandle PyUnicode_FromFormatV$handle() {
        return PyUnicode_FromFormatV.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_FromFormatV(const char *format, va_list vargs)
     * }
     */
    public static MemorySegment PyUnicode_FromFormatV$address() {
        return PyUnicode_FromFormatV.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_FromFormatV(const char *format, va_list vargs)
     * }
     */
    public static MemorySegment PyUnicode_FromFormatV(MemorySegment format, MemorySegment vargs) {
        var mh$ = PyUnicode_FromFormatV.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_FromFormatV", format, vargs);
            }
            return (MemorySegment)mh$.invokeExact(format, vargs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_FromFormat(const char *format, ...)
     * }
     */
    public static class PyUnicode_FromFormat {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_POINTER,
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_FromFormat");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private PyUnicode_FromFormat(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * PyObject *PyUnicode_FromFormat(const char *format, ...)
         * }
         */
        public static PyUnicode_FromFormat makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new PyUnicode_FromFormat(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public MemorySegment apply(MemorySegment format, Object... x1) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("PyUnicode_FromFormat", format, x1);
                }
                return (MemorySegment)spreader.invokeExact(format, x1);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class PyUnicode_InternInPlace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_InternInPlace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyUnicode_InternInPlace(PyObject **)
     * }
     */
    public static FunctionDescriptor PyUnicode_InternInPlace$descriptor() {
        return PyUnicode_InternInPlace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyUnicode_InternInPlace(PyObject **)
     * }
     */
    public static MethodHandle PyUnicode_InternInPlace$handle() {
        return PyUnicode_InternInPlace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyUnicode_InternInPlace(PyObject **)
     * }
     */
    public static MemorySegment PyUnicode_InternInPlace$address() {
        return PyUnicode_InternInPlace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyUnicode_InternInPlace(PyObject **)
     * }
     */
    public static void PyUnicode_InternInPlace(MemorySegment x0) {
        var mh$ = PyUnicode_InternInPlace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_InternInPlace", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_InternFromString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_InternFromString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_InternFromString(const char *u)
     * }
     */
    public static FunctionDescriptor PyUnicode_InternFromString$descriptor() {
        return PyUnicode_InternFromString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_InternFromString(const char *u)
     * }
     */
    public static MethodHandle PyUnicode_InternFromString$handle() {
        return PyUnicode_InternFromString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_InternFromString(const char *u)
     * }
     */
    public static MemorySegment PyUnicode_InternFromString$address() {
        return PyUnicode_InternFromString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_InternFromString(const char *u)
     * }
     */
    public static MemorySegment PyUnicode_InternFromString(MemorySegment u) {
        var mh$ = PyUnicode_InternFromString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_InternFromString", u);
            }
            return (MemorySegment)mh$.invokeExact(u);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_FromWideChar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_FromWideChar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_FromWideChar(const wchar_t *w, Py_ssize_t size)
     * }
     */
    public static FunctionDescriptor PyUnicode_FromWideChar$descriptor() {
        return PyUnicode_FromWideChar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_FromWideChar(const wchar_t *w, Py_ssize_t size)
     * }
     */
    public static MethodHandle PyUnicode_FromWideChar$handle() {
        return PyUnicode_FromWideChar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_FromWideChar(const wchar_t *w, Py_ssize_t size)
     * }
     */
    public static MemorySegment PyUnicode_FromWideChar$address() {
        return PyUnicode_FromWideChar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_FromWideChar(const wchar_t *w, Py_ssize_t size)
     * }
     */
    public static MemorySegment PyUnicode_FromWideChar(MemorySegment w, long size) {
        var mh$ = PyUnicode_FromWideChar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_FromWideChar", w, size);
            }
            return (MemorySegment)mh$.invokeExact(w, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_AsWideChar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_AsWideChar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_ssize_t PyUnicode_AsWideChar(PyObject *unicode, wchar_t *w, Py_ssize_t size)
     * }
     */
    public static FunctionDescriptor PyUnicode_AsWideChar$descriptor() {
        return PyUnicode_AsWideChar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_ssize_t PyUnicode_AsWideChar(PyObject *unicode, wchar_t *w, Py_ssize_t size)
     * }
     */
    public static MethodHandle PyUnicode_AsWideChar$handle() {
        return PyUnicode_AsWideChar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_ssize_t PyUnicode_AsWideChar(PyObject *unicode, wchar_t *w, Py_ssize_t size)
     * }
     */
    public static MemorySegment PyUnicode_AsWideChar$address() {
        return PyUnicode_AsWideChar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_ssize_t PyUnicode_AsWideChar(PyObject *unicode, wchar_t *w, Py_ssize_t size)
     * }
     */
    public static long PyUnicode_AsWideChar(MemorySegment unicode, MemorySegment w, long size) {
        var mh$ = PyUnicode_AsWideChar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_AsWideChar", unicode, w, size);
            }
            return (long)mh$.invokeExact(unicode, w, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_AsWideCharString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_AsWideCharString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *PyUnicode_AsWideCharString(PyObject *unicode, Py_ssize_t *size)
     * }
     */
    public static FunctionDescriptor PyUnicode_AsWideCharString$descriptor() {
        return PyUnicode_AsWideCharString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *PyUnicode_AsWideCharString(PyObject *unicode, Py_ssize_t *size)
     * }
     */
    public static MethodHandle PyUnicode_AsWideCharString$handle() {
        return PyUnicode_AsWideCharString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *PyUnicode_AsWideCharString(PyObject *unicode, Py_ssize_t *size)
     * }
     */
    public static MemorySegment PyUnicode_AsWideCharString$address() {
        return PyUnicode_AsWideCharString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *PyUnicode_AsWideCharString(PyObject *unicode, Py_ssize_t *size)
     * }
     */
    public static MemorySegment PyUnicode_AsWideCharString(MemorySegment unicode, MemorySegment size) {
        var mh$ = PyUnicode_AsWideCharString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_AsWideCharString", unicode, size);
            }
            return (MemorySegment)mh$.invokeExact(unicode, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_FromOrdinal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_FromOrdinal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_FromOrdinal(int ordinal)
     * }
     */
    public static FunctionDescriptor PyUnicode_FromOrdinal$descriptor() {
        return PyUnicode_FromOrdinal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_FromOrdinal(int ordinal)
     * }
     */
    public static MethodHandle PyUnicode_FromOrdinal$handle() {
        return PyUnicode_FromOrdinal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_FromOrdinal(int ordinal)
     * }
     */
    public static MemorySegment PyUnicode_FromOrdinal$address() {
        return PyUnicode_FromOrdinal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_FromOrdinal(int ordinal)
     * }
     */
    public static MemorySegment PyUnicode_FromOrdinal(int ordinal) {
        var mh$ = PyUnicode_FromOrdinal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_FromOrdinal", ordinal);
            }
            return (MemorySegment)mh$.invokeExact(ordinal);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_GetDefaultEncoding {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_GetDefaultEncoding");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *PyUnicode_GetDefaultEncoding()
     * }
     */
    public static FunctionDescriptor PyUnicode_GetDefaultEncoding$descriptor() {
        return PyUnicode_GetDefaultEncoding.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *PyUnicode_GetDefaultEncoding()
     * }
     */
    public static MethodHandle PyUnicode_GetDefaultEncoding$handle() {
        return PyUnicode_GetDefaultEncoding.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *PyUnicode_GetDefaultEncoding()
     * }
     */
    public static MemorySegment PyUnicode_GetDefaultEncoding$address() {
        return PyUnicode_GetDefaultEncoding.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *PyUnicode_GetDefaultEncoding()
     * }
     */
    public static MemorySegment PyUnicode_GetDefaultEncoding() {
        var mh$ = PyUnicode_GetDefaultEncoding.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_GetDefaultEncoding");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_Decode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_Decode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_Decode(const char *s, Py_ssize_t size, const char *encoding, const char *errors)
     * }
     */
    public static FunctionDescriptor PyUnicode_Decode$descriptor() {
        return PyUnicode_Decode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_Decode(const char *s, Py_ssize_t size, const char *encoding, const char *errors)
     * }
     */
    public static MethodHandle PyUnicode_Decode$handle() {
        return PyUnicode_Decode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_Decode(const char *s, Py_ssize_t size, const char *encoding, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_Decode$address() {
        return PyUnicode_Decode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_Decode(const char *s, Py_ssize_t size, const char *encoding, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_Decode(MemorySegment s, long size, MemorySegment encoding, MemorySegment errors) {
        var mh$ = PyUnicode_Decode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_Decode", s, size, encoding, errors);
            }
            return (MemorySegment)mh$.invokeExact(s, size, encoding, errors);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_AsDecodedObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_AsDecodedObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsDecodedObject(PyObject *unicode, const char *encoding, const char *errors)
     * }
     */
    public static FunctionDescriptor PyUnicode_AsDecodedObject$descriptor() {
        return PyUnicode_AsDecodedObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsDecodedObject(PyObject *unicode, const char *encoding, const char *errors)
     * }
     */
    public static MethodHandle PyUnicode_AsDecodedObject$handle() {
        return PyUnicode_AsDecodedObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsDecodedObject(PyObject *unicode, const char *encoding, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_AsDecodedObject$address() {
        return PyUnicode_AsDecodedObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsDecodedObject(PyObject *unicode, const char *encoding, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_AsDecodedObject(MemorySegment unicode, MemorySegment encoding, MemorySegment errors) {
        var mh$ = PyUnicode_AsDecodedObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_AsDecodedObject", unicode, encoding, errors);
            }
            return (MemorySegment)mh$.invokeExact(unicode, encoding, errors);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_AsDecodedUnicode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_AsDecodedUnicode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsDecodedUnicode(PyObject *unicode, const char *encoding, const char *errors)
     * }
     */
    public static FunctionDescriptor PyUnicode_AsDecodedUnicode$descriptor() {
        return PyUnicode_AsDecodedUnicode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsDecodedUnicode(PyObject *unicode, const char *encoding, const char *errors)
     * }
     */
    public static MethodHandle PyUnicode_AsDecodedUnicode$handle() {
        return PyUnicode_AsDecodedUnicode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsDecodedUnicode(PyObject *unicode, const char *encoding, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_AsDecodedUnicode$address() {
        return PyUnicode_AsDecodedUnicode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsDecodedUnicode(PyObject *unicode, const char *encoding, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_AsDecodedUnicode(MemorySegment unicode, MemorySegment encoding, MemorySegment errors) {
        var mh$ = PyUnicode_AsDecodedUnicode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_AsDecodedUnicode", unicode, encoding, errors);
            }
            return (MemorySegment)mh$.invokeExact(unicode, encoding, errors);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_AsEncodedObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_AsEncodedObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsEncodedObject(PyObject *unicode, const char *encoding, const char *errors)
     * }
     */
    public static FunctionDescriptor PyUnicode_AsEncodedObject$descriptor() {
        return PyUnicode_AsEncodedObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsEncodedObject(PyObject *unicode, const char *encoding, const char *errors)
     * }
     */
    public static MethodHandle PyUnicode_AsEncodedObject$handle() {
        return PyUnicode_AsEncodedObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsEncodedObject(PyObject *unicode, const char *encoding, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_AsEncodedObject$address() {
        return PyUnicode_AsEncodedObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsEncodedObject(PyObject *unicode, const char *encoding, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_AsEncodedObject(MemorySegment unicode, MemorySegment encoding, MemorySegment errors) {
        var mh$ = PyUnicode_AsEncodedObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_AsEncodedObject", unicode, encoding, errors);
            }
            return (MemorySegment)mh$.invokeExact(unicode, encoding, errors);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_AsEncodedString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_AsEncodedString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsEncodedString(PyObject *unicode, const char *encoding, const char *errors)
     * }
     */
    public static FunctionDescriptor PyUnicode_AsEncodedString$descriptor() {
        return PyUnicode_AsEncodedString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsEncodedString(PyObject *unicode, const char *encoding, const char *errors)
     * }
     */
    public static MethodHandle PyUnicode_AsEncodedString$handle() {
        return PyUnicode_AsEncodedString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsEncodedString(PyObject *unicode, const char *encoding, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_AsEncodedString$address() {
        return PyUnicode_AsEncodedString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsEncodedString(PyObject *unicode, const char *encoding, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_AsEncodedString(MemorySegment unicode, MemorySegment encoding, MemorySegment errors) {
        var mh$ = PyUnicode_AsEncodedString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_AsEncodedString", unicode, encoding, errors);
            }
            return (MemorySegment)mh$.invokeExact(unicode, encoding, errors);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_AsEncodedUnicode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_AsEncodedUnicode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsEncodedUnicode(PyObject *unicode, const char *encoding, const char *errors)
     * }
     */
    public static FunctionDescriptor PyUnicode_AsEncodedUnicode$descriptor() {
        return PyUnicode_AsEncodedUnicode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsEncodedUnicode(PyObject *unicode, const char *encoding, const char *errors)
     * }
     */
    public static MethodHandle PyUnicode_AsEncodedUnicode$handle() {
        return PyUnicode_AsEncodedUnicode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsEncodedUnicode(PyObject *unicode, const char *encoding, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_AsEncodedUnicode$address() {
        return PyUnicode_AsEncodedUnicode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsEncodedUnicode(PyObject *unicode, const char *encoding, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_AsEncodedUnicode(MemorySegment unicode, MemorySegment encoding, MemorySegment errors) {
        var mh$ = PyUnicode_AsEncodedUnicode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_AsEncodedUnicode", unicode, encoding, errors);
            }
            return (MemorySegment)mh$.invokeExact(unicode, encoding, errors);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_BuildEncodingMap {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_BuildEncodingMap");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_BuildEncodingMap(PyObject *string)
     * }
     */
    public static FunctionDescriptor PyUnicode_BuildEncodingMap$descriptor() {
        return PyUnicode_BuildEncodingMap.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_BuildEncodingMap(PyObject *string)
     * }
     */
    public static MethodHandle PyUnicode_BuildEncodingMap$handle() {
        return PyUnicode_BuildEncodingMap.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_BuildEncodingMap(PyObject *string)
     * }
     */
    public static MemorySegment PyUnicode_BuildEncodingMap$address() {
        return PyUnicode_BuildEncodingMap.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_BuildEncodingMap(PyObject *string)
     * }
     */
    public static MemorySegment PyUnicode_BuildEncodingMap(MemorySegment string) {
        var mh$ = PyUnicode_BuildEncodingMap.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_BuildEncodingMap", string);
            }
            return (MemorySegment)mh$.invokeExact(string);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_DecodeUTF7 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_DecodeUTF7");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUTF7(const char *string, Py_ssize_t length, const char *errors)
     * }
     */
    public static FunctionDescriptor PyUnicode_DecodeUTF7$descriptor() {
        return PyUnicode_DecodeUTF7.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUTF7(const char *string, Py_ssize_t length, const char *errors)
     * }
     */
    public static MethodHandle PyUnicode_DecodeUTF7$handle() {
        return PyUnicode_DecodeUTF7.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUTF7(const char *string, Py_ssize_t length, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_DecodeUTF7$address() {
        return PyUnicode_DecodeUTF7.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUTF7(const char *string, Py_ssize_t length, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_DecodeUTF7(MemorySegment string, long length, MemorySegment errors) {
        var mh$ = PyUnicode_DecodeUTF7.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_DecodeUTF7", string, length, errors);
            }
            return (MemorySegment)mh$.invokeExact(string, length, errors);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_DecodeUTF7Stateful {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_DecodeUTF7Stateful");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUTF7Stateful(const char *string, Py_ssize_t length, const char *errors, Py_ssize_t *consumed)
     * }
     */
    public static FunctionDescriptor PyUnicode_DecodeUTF7Stateful$descriptor() {
        return PyUnicode_DecodeUTF7Stateful.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUTF7Stateful(const char *string, Py_ssize_t length, const char *errors, Py_ssize_t *consumed)
     * }
     */
    public static MethodHandle PyUnicode_DecodeUTF7Stateful$handle() {
        return PyUnicode_DecodeUTF7Stateful.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUTF7Stateful(const char *string, Py_ssize_t length, const char *errors, Py_ssize_t *consumed)
     * }
     */
    public static MemorySegment PyUnicode_DecodeUTF7Stateful$address() {
        return PyUnicode_DecodeUTF7Stateful.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUTF7Stateful(const char *string, Py_ssize_t length, const char *errors, Py_ssize_t *consumed)
     * }
     */
    public static MemorySegment PyUnicode_DecodeUTF7Stateful(MemorySegment string, long length, MemorySegment errors, MemorySegment consumed) {
        var mh$ = PyUnicode_DecodeUTF7Stateful.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_DecodeUTF7Stateful", string, length, errors, consumed);
            }
            return (MemorySegment)mh$.invokeExact(string, length, errors, consumed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_DecodeUTF8 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_DecodeUTF8");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUTF8(const char *string, Py_ssize_t length, const char *errors)
     * }
     */
    public static FunctionDescriptor PyUnicode_DecodeUTF8$descriptor() {
        return PyUnicode_DecodeUTF8.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUTF8(const char *string, Py_ssize_t length, const char *errors)
     * }
     */
    public static MethodHandle PyUnicode_DecodeUTF8$handle() {
        return PyUnicode_DecodeUTF8.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUTF8(const char *string, Py_ssize_t length, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_DecodeUTF8$address() {
        return PyUnicode_DecodeUTF8.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUTF8(const char *string, Py_ssize_t length, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_DecodeUTF8(MemorySegment string, long length, MemorySegment errors) {
        var mh$ = PyUnicode_DecodeUTF8.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_DecodeUTF8", string, length, errors);
            }
            return (MemorySegment)mh$.invokeExact(string, length, errors);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_DecodeUTF8Stateful {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_DecodeUTF8Stateful");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUTF8Stateful(const char *string, Py_ssize_t length, const char *errors, Py_ssize_t *consumed)
     * }
     */
    public static FunctionDescriptor PyUnicode_DecodeUTF8Stateful$descriptor() {
        return PyUnicode_DecodeUTF8Stateful.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUTF8Stateful(const char *string, Py_ssize_t length, const char *errors, Py_ssize_t *consumed)
     * }
     */
    public static MethodHandle PyUnicode_DecodeUTF8Stateful$handle() {
        return PyUnicode_DecodeUTF8Stateful.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUTF8Stateful(const char *string, Py_ssize_t length, const char *errors, Py_ssize_t *consumed)
     * }
     */
    public static MemorySegment PyUnicode_DecodeUTF8Stateful$address() {
        return PyUnicode_DecodeUTF8Stateful.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUTF8Stateful(const char *string, Py_ssize_t length, const char *errors, Py_ssize_t *consumed)
     * }
     */
    public static MemorySegment PyUnicode_DecodeUTF8Stateful(MemorySegment string, long length, MemorySegment errors, MemorySegment consumed) {
        var mh$ = PyUnicode_DecodeUTF8Stateful.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_DecodeUTF8Stateful", string, length, errors, consumed);
            }
            return (MemorySegment)mh$.invokeExact(string, length, errors, consumed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_AsUTF8String {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_AsUTF8String");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsUTF8String(PyObject *unicode)
     * }
     */
    public static FunctionDescriptor PyUnicode_AsUTF8String$descriptor() {
        return PyUnicode_AsUTF8String.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsUTF8String(PyObject *unicode)
     * }
     */
    public static MethodHandle PyUnicode_AsUTF8String$handle() {
        return PyUnicode_AsUTF8String.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsUTF8String(PyObject *unicode)
     * }
     */
    public static MemorySegment PyUnicode_AsUTF8String$address() {
        return PyUnicode_AsUTF8String.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsUTF8String(PyObject *unicode)
     * }
     */
    public static MemorySegment PyUnicode_AsUTF8String(MemorySegment unicode) {
        var mh$ = PyUnicode_AsUTF8String.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_AsUTF8String", unicode);
            }
            return (MemorySegment)mh$.invokeExact(unicode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_AsUTF8AndSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_AsUTF8AndSize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *PyUnicode_AsUTF8AndSize(PyObject *unicode, Py_ssize_t *size)
     * }
     */
    public static FunctionDescriptor PyUnicode_AsUTF8AndSize$descriptor() {
        return PyUnicode_AsUTF8AndSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *PyUnicode_AsUTF8AndSize(PyObject *unicode, Py_ssize_t *size)
     * }
     */
    public static MethodHandle PyUnicode_AsUTF8AndSize$handle() {
        return PyUnicode_AsUTF8AndSize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *PyUnicode_AsUTF8AndSize(PyObject *unicode, Py_ssize_t *size)
     * }
     */
    public static MemorySegment PyUnicode_AsUTF8AndSize$address() {
        return PyUnicode_AsUTF8AndSize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *PyUnicode_AsUTF8AndSize(PyObject *unicode, Py_ssize_t *size)
     * }
     */
    public static MemorySegment PyUnicode_AsUTF8AndSize(MemorySegment unicode, MemorySegment size) {
        var mh$ = PyUnicode_AsUTF8AndSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_AsUTF8AndSize", unicode, size);
            }
            return (MemorySegment)mh$.invokeExact(unicode, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_DecodeUTF32 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_DecodeUTF32");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUTF32(const char *string, Py_ssize_t length, const char *errors, int *byteorder)
     * }
     */
    public static FunctionDescriptor PyUnicode_DecodeUTF32$descriptor() {
        return PyUnicode_DecodeUTF32.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUTF32(const char *string, Py_ssize_t length, const char *errors, int *byteorder)
     * }
     */
    public static MethodHandle PyUnicode_DecodeUTF32$handle() {
        return PyUnicode_DecodeUTF32.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUTF32(const char *string, Py_ssize_t length, const char *errors, int *byteorder)
     * }
     */
    public static MemorySegment PyUnicode_DecodeUTF32$address() {
        return PyUnicode_DecodeUTF32.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUTF32(const char *string, Py_ssize_t length, const char *errors, int *byteorder)
     * }
     */
    public static MemorySegment PyUnicode_DecodeUTF32(MemorySegment string, long length, MemorySegment errors, MemorySegment byteorder) {
        var mh$ = PyUnicode_DecodeUTF32.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_DecodeUTF32", string, length, errors, byteorder);
            }
            return (MemorySegment)mh$.invokeExact(string, length, errors, byteorder);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_DecodeUTF32Stateful {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_DecodeUTF32Stateful");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUTF32Stateful(const char *string, Py_ssize_t length, const char *errors, int *byteorder, Py_ssize_t *consumed)
     * }
     */
    public static FunctionDescriptor PyUnicode_DecodeUTF32Stateful$descriptor() {
        return PyUnicode_DecodeUTF32Stateful.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUTF32Stateful(const char *string, Py_ssize_t length, const char *errors, int *byteorder, Py_ssize_t *consumed)
     * }
     */
    public static MethodHandle PyUnicode_DecodeUTF32Stateful$handle() {
        return PyUnicode_DecodeUTF32Stateful.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUTF32Stateful(const char *string, Py_ssize_t length, const char *errors, int *byteorder, Py_ssize_t *consumed)
     * }
     */
    public static MemorySegment PyUnicode_DecodeUTF32Stateful$address() {
        return PyUnicode_DecodeUTF32Stateful.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUTF32Stateful(const char *string, Py_ssize_t length, const char *errors, int *byteorder, Py_ssize_t *consumed)
     * }
     */
    public static MemorySegment PyUnicode_DecodeUTF32Stateful(MemorySegment string, long length, MemorySegment errors, MemorySegment byteorder, MemorySegment consumed) {
        var mh$ = PyUnicode_DecodeUTF32Stateful.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_DecodeUTF32Stateful", string, length, errors, byteorder, consumed);
            }
            return (MemorySegment)mh$.invokeExact(string, length, errors, byteorder, consumed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_AsUTF32String {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_AsUTF32String");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsUTF32String(PyObject *unicode)
     * }
     */
    public static FunctionDescriptor PyUnicode_AsUTF32String$descriptor() {
        return PyUnicode_AsUTF32String.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsUTF32String(PyObject *unicode)
     * }
     */
    public static MethodHandle PyUnicode_AsUTF32String$handle() {
        return PyUnicode_AsUTF32String.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsUTF32String(PyObject *unicode)
     * }
     */
    public static MemorySegment PyUnicode_AsUTF32String$address() {
        return PyUnicode_AsUTF32String.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsUTF32String(PyObject *unicode)
     * }
     */
    public static MemorySegment PyUnicode_AsUTF32String(MemorySegment unicode) {
        var mh$ = PyUnicode_AsUTF32String.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_AsUTF32String", unicode);
            }
            return (MemorySegment)mh$.invokeExact(unicode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_DecodeUTF16 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_DecodeUTF16");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUTF16(const char *string, Py_ssize_t length, const char *errors, int *byteorder)
     * }
     */
    public static FunctionDescriptor PyUnicode_DecodeUTF16$descriptor() {
        return PyUnicode_DecodeUTF16.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUTF16(const char *string, Py_ssize_t length, const char *errors, int *byteorder)
     * }
     */
    public static MethodHandle PyUnicode_DecodeUTF16$handle() {
        return PyUnicode_DecodeUTF16.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUTF16(const char *string, Py_ssize_t length, const char *errors, int *byteorder)
     * }
     */
    public static MemorySegment PyUnicode_DecodeUTF16$address() {
        return PyUnicode_DecodeUTF16.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUTF16(const char *string, Py_ssize_t length, const char *errors, int *byteorder)
     * }
     */
    public static MemorySegment PyUnicode_DecodeUTF16(MemorySegment string, long length, MemorySegment errors, MemorySegment byteorder) {
        var mh$ = PyUnicode_DecodeUTF16.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_DecodeUTF16", string, length, errors, byteorder);
            }
            return (MemorySegment)mh$.invokeExact(string, length, errors, byteorder);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_DecodeUTF16Stateful {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_DecodeUTF16Stateful");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUTF16Stateful(const char *string, Py_ssize_t length, const char *errors, int *byteorder, Py_ssize_t *consumed)
     * }
     */
    public static FunctionDescriptor PyUnicode_DecodeUTF16Stateful$descriptor() {
        return PyUnicode_DecodeUTF16Stateful.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUTF16Stateful(const char *string, Py_ssize_t length, const char *errors, int *byteorder, Py_ssize_t *consumed)
     * }
     */
    public static MethodHandle PyUnicode_DecodeUTF16Stateful$handle() {
        return PyUnicode_DecodeUTF16Stateful.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUTF16Stateful(const char *string, Py_ssize_t length, const char *errors, int *byteorder, Py_ssize_t *consumed)
     * }
     */
    public static MemorySegment PyUnicode_DecodeUTF16Stateful$address() {
        return PyUnicode_DecodeUTF16Stateful.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUTF16Stateful(const char *string, Py_ssize_t length, const char *errors, int *byteorder, Py_ssize_t *consumed)
     * }
     */
    public static MemorySegment PyUnicode_DecodeUTF16Stateful(MemorySegment string, long length, MemorySegment errors, MemorySegment byteorder, MemorySegment consumed) {
        var mh$ = PyUnicode_DecodeUTF16Stateful.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_DecodeUTF16Stateful", string, length, errors, byteorder, consumed);
            }
            return (MemorySegment)mh$.invokeExact(string, length, errors, byteorder, consumed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_AsUTF16String {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_AsUTF16String");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsUTF16String(PyObject *unicode)
     * }
     */
    public static FunctionDescriptor PyUnicode_AsUTF16String$descriptor() {
        return PyUnicode_AsUTF16String.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsUTF16String(PyObject *unicode)
     * }
     */
    public static MethodHandle PyUnicode_AsUTF16String$handle() {
        return PyUnicode_AsUTF16String.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsUTF16String(PyObject *unicode)
     * }
     */
    public static MemorySegment PyUnicode_AsUTF16String$address() {
        return PyUnicode_AsUTF16String.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsUTF16String(PyObject *unicode)
     * }
     */
    public static MemorySegment PyUnicode_AsUTF16String(MemorySegment unicode) {
        var mh$ = PyUnicode_AsUTF16String.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_AsUTF16String", unicode);
            }
            return (MemorySegment)mh$.invokeExact(unicode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_DecodeUnicodeEscape {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_DecodeUnicodeEscape");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUnicodeEscape(const char *string, Py_ssize_t length, const char *errors)
     * }
     */
    public static FunctionDescriptor PyUnicode_DecodeUnicodeEscape$descriptor() {
        return PyUnicode_DecodeUnicodeEscape.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUnicodeEscape(const char *string, Py_ssize_t length, const char *errors)
     * }
     */
    public static MethodHandle PyUnicode_DecodeUnicodeEscape$handle() {
        return PyUnicode_DecodeUnicodeEscape.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUnicodeEscape(const char *string, Py_ssize_t length, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_DecodeUnicodeEscape$address() {
        return PyUnicode_DecodeUnicodeEscape.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUnicodeEscape(const char *string, Py_ssize_t length, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_DecodeUnicodeEscape(MemorySegment string, long length, MemorySegment errors) {
        var mh$ = PyUnicode_DecodeUnicodeEscape.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_DecodeUnicodeEscape", string, length, errors);
            }
            return (MemorySegment)mh$.invokeExact(string, length, errors);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_AsUnicodeEscapeString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_AsUnicodeEscapeString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsUnicodeEscapeString(PyObject *unicode)
     * }
     */
    public static FunctionDescriptor PyUnicode_AsUnicodeEscapeString$descriptor() {
        return PyUnicode_AsUnicodeEscapeString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsUnicodeEscapeString(PyObject *unicode)
     * }
     */
    public static MethodHandle PyUnicode_AsUnicodeEscapeString$handle() {
        return PyUnicode_AsUnicodeEscapeString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsUnicodeEscapeString(PyObject *unicode)
     * }
     */
    public static MemorySegment PyUnicode_AsUnicodeEscapeString$address() {
        return PyUnicode_AsUnicodeEscapeString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsUnicodeEscapeString(PyObject *unicode)
     * }
     */
    public static MemorySegment PyUnicode_AsUnicodeEscapeString(MemorySegment unicode) {
        var mh$ = PyUnicode_AsUnicodeEscapeString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_AsUnicodeEscapeString", unicode);
            }
            return (MemorySegment)mh$.invokeExact(unicode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_DecodeRawUnicodeEscape {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_DecodeRawUnicodeEscape");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeRawUnicodeEscape(const char *string, Py_ssize_t length, const char *errors)
     * }
     */
    public static FunctionDescriptor PyUnicode_DecodeRawUnicodeEscape$descriptor() {
        return PyUnicode_DecodeRawUnicodeEscape.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeRawUnicodeEscape(const char *string, Py_ssize_t length, const char *errors)
     * }
     */
    public static MethodHandle PyUnicode_DecodeRawUnicodeEscape$handle() {
        return PyUnicode_DecodeRawUnicodeEscape.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeRawUnicodeEscape(const char *string, Py_ssize_t length, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_DecodeRawUnicodeEscape$address() {
        return PyUnicode_DecodeRawUnicodeEscape.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeRawUnicodeEscape(const char *string, Py_ssize_t length, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_DecodeRawUnicodeEscape(MemorySegment string, long length, MemorySegment errors) {
        var mh$ = PyUnicode_DecodeRawUnicodeEscape.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_DecodeRawUnicodeEscape", string, length, errors);
            }
            return (MemorySegment)mh$.invokeExact(string, length, errors);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_AsRawUnicodeEscapeString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_AsRawUnicodeEscapeString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsRawUnicodeEscapeString(PyObject *unicode)
     * }
     */
    public static FunctionDescriptor PyUnicode_AsRawUnicodeEscapeString$descriptor() {
        return PyUnicode_AsRawUnicodeEscapeString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsRawUnicodeEscapeString(PyObject *unicode)
     * }
     */
    public static MethodHandle PyUnicode_AsRawUnicodeEscapeString$handle() {
        return PyUnicode_AsRawUnicodeEscapeString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsRawUnicodeEscapeString(PyObject *unicode)
     * }
     */
    public static MemorySegment PyUnicode_AsRawUnicodeEscapeString$address() {
        return PyUnicode_AsRawUnicodeEscapeString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsRawUnicodeEscapeString(PyObject *unicode)
     * }
     */
    public static MemorySegment PyUnicode_AsRawUnicodeEscapeString(MemorySegment unicode) {
        var mh$ = PyUnicode_AsRawUnicodeEscapeString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_AsRawUnicodeEscapeString", unicode);
            }
            return (MemorySegment)mh$.invokeExact(unicode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_DecodeLatin1 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_DecodeLatin1");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeLatin1(const char *string, Py_ssize_t length, const char *errors)
     * }
     */
    public static FunctionDescriptor PyUnicode_DecodeLatin1$descriptor() {
        return PyUnicode_DecodeLatin1.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeLatin1(const char *string, Py_ssize_t length, const char *errors)
     * }
     */
    public static MethodHandle PyUnicode_DecodeLatin1$handle() {
        return PyUnicode_DecodeLatin1.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeLatin1(const char *string, Py_ssize_t length, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_DecodeLatin1$address() {
        return PyUnicode_DecodeLatin1.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeLatin1(const char *string, Py_ssize_t length, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_DecodeLatin1(MemorySegment string, long length, MemorySegment errors) {
        var mh$ = PyUnicode_DecodeLatin1.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_DecodeLatin1", string, length, errors);
            }
            return (MemorySegment)mh$.invokeExact(string, length, errors);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_AsLatin1String {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_AsLatin1String");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsLatin1String(PyObject *unicode)
     * }
     */
    public static FunctionDescriptor PyUnicode_AsLatin1String$descriptor() {
        return PyUnicode_AsLatin1String.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsLatin1String(PyObject *unicode)
     * }
     */
    public static MethodHandle PyUnicode_AsLatin1String$handle() {
        return PyUnicode_AsLatin1String.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsLatin1String(PyObject *unicode)
     * }
     */
    public static MemorySegment PyUnicode_AsLatin1String$address() {
        return PyUnicode_AsLatin1String.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsLatin1String(PyObject *unicode)
     * }
     */
    public static MemorySegment PyUnicode_AsLatin1String(MemorySegment unicode) {
        var mh$ = PyUnicode_AsLatin1String.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_AsLatin1String", unicode);
            }
            return (MemorySegment)mh$.invokeExact(unicode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_DecodeASCII {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_DecodeASCII");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeASCII(const char *string, Py_ssize_t length, const char *errors)
     * }
     */
    public static FunctionDescriptor PyUnicode_DecodeASCII$descriptor() {
        return PyUnicode_DecodeASCII.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeASCII(const char *string, Py_ssize_t length, const char *errors)
     * }
     */
    public static MethodHandle PyUnicode_DecodeASCII$handle() {
        return PyUnicode_DecodeASCII.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeASCII(const char *string, Py_ssize_t length, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_DecodeASCII$address() {
        return PyUnicode_DecodeASCII.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeASCII(const char *string, Py_ssize_t length, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_DecodeASCII(MemorySegment string, long length, MemorySegment errors) {
        var mh$ = PyUnicode_DecodeASCII.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_DecodeASCII", string, length, errors);
            }
            return (MemorySegment)mh$.invokeExact(string, length, errors);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_AsASCIIString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_AsASCIIString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsASCIIString(PyObject *unicode)
     * }
     */
    public static FunctionDescriptor PyUnicode_AsASCIIString$descriptor() {
        return PyUnicode_AsASCIIString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsASCIIString(PyObject *unicode)
     * }
     */
    public static MethodHandle PyUnicode_AsASCIIString$handle() {
        return PyUnicode_AsASCIIString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsASCIIString(PyObject *unicode)
     * }
     */
    public static MemorySegment PyUnicode_AsASCIIString$address() {
        return PyUnicode_AsASCIIString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsASCIIString(PyObject *unicode)
     * }
     */
    public static MemorySegment PyUnicode_AsASCIIString(MemorySegment unicode) {
        var mh$ = PyUnicode_AsASCIIString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_AsASCIIString", unicode);
            }
            return (MemorySegment)mh$.invokeExact(unicode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_DecodeCharmap {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_DecodeCharmap");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeCharmap(const char *string, Py_ssize_t length, PyObject *mapping, const char *errors)
     * }
     */
    public static FunctionDescriptor PyUnicode_DecodeCharmap$descriptor() {
        return PyUnicode_DecodeCharmap.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeCharmap(const char *string, Py_ssize_t length, PyObject *mapping, const char *errors)
     * }
     */
    public static MethodHandle PyUnicode_DecodeCharmap$handle() {
        return PyUnicode_DecodeCharmap.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeCharmap(const char *string, Py_ssize_t length, PyObject *mapping, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_DecodeCharmap$address() {
        return PyUnicode_DecodeCharmap.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeCharmap(const char *string, Py_ssize_t length, PyObject *mapping, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_DecodeCharmap(MemorySegment string, long length, MemorySegment mapping, MemorySegment errors) {
        var mh$ = PyUnicode_DecodeCharmap.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_DecodeCharmap", string, length, mapping, errors);
            }
            return (MemorySegment)mh$.invokeExact(string, length, mapping, errors);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_AsCharmapString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_AsCharmapString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsCharmapString(PyObject *unicode, PyObject *mapping)
     * }
     */
    public static FunctionDescriptor PyUnicode_AsCharmapString$descriptor() {
        return PyUnicode_AsCharmapString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsCharmapString(PyObject *unicode, PyObject *mapping)
     * }
     */
    public static MethodHandle PyUnicode_AsCharmapString$handle() {
        return PyUnicode_AsCharmapString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsCharmapString(PyObject *unicode, PyObject *mapping)
     * }
     */
    public static MemorySegment PyUnicode_AsCharmapString$address() {
        return PyUnicode_AsCharmapString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsCharmapString(PyObject *unicode, PyObject *mapping)
     * }
     */
    public static MemorySegment PyUnicode_AsCharmapString(MemorySegment unicode, MemorySegment mapping) {
        var mh$ = PyUnicode_AsCharmapString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_AsCharmapString", unicode, mapping);
            }
            return (MemorySegment)mh$.invokeExact(unicode, mapping);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_DecodeMBCS {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_DecodeMBCS");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeMBCS(const char *string, Py_ssize_t length, const char *errors)
     * }
     */
    public static FunctionDescriptor PyUnicode_DecodeMBCS$descriptor() {
        return PyUnicode_DecodeMBCS.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeMBCS(const char *string, Py_ssize_t length, const char *errors)
     * }
     */
    public static MethodHandle PyUnicode_DecodeMBCS$handle() {
        return PyUnicode_DecodeMBCS.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeMBCS(const char *string, Py_ssize_t length, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_DecodeMBCS$address() {
        return PyUnicode_DecodeMBCS.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeMBCS(const char *string, Py_ssize_t length, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_DecodeMBCS(MemorySegment string, long length, MemorySegment errors) {
        var mh$ = PyUnicode_DecodeMBCS.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_DecodeMBCS", string, length, errors);
            }
            return (MemorySegment)mh$.invokeExact(string, length, errors);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_DecodeMBCSStateful {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_DecodeMBCSStateful");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeMBCSStateful(const char *string, Py_ssize_t length, const char *errors, Py_ssize_t *consumed)
     * }
     */
    public static FunctionDescriptor PyUnicode_DecodeMBCSStateful$descriptor() {
        return PyUnicode_DecodeMBCSStateful.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeMBCSStateful(const char *string, Py_ssize_t length, const char *errors, Py_ssize_t *consumed)
     * }
     */
    public static MethodHandle PyUnicode_DecodeMBCSStateful$handle() {
        return PyUnicode_DecodeMBCSStateful.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeMBCSStateful(const char *string, Py_ssize_t length, const char *errors, Py_ssize_t *consumed)
     * }
     */
    public static MemorySegment PyUnicode_DecodeMBCSStateful$address() {
        return PyUnicode_DecodeMBCSStateful.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeMBCSStateful(const char *string, Py_ssize_t length, const char *errors, Py_ssize_t *consumed)
     * }
     */
    public static MemorySegment PyUnicode_DecodeMBCSStateful(MemorySegment string, long length, MemorySegment errors, MemorySegment consumed) {
        var mh$ = PyUnicode_DecodeMBCSStateful.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_DecodeMBCSStateful", string, length, errors, consumed);
            }
            return (MemorySegment)mh$.invokeExact(string, length, errors, consumed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_DecodeCodePageStateful {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_DecodeCodePageStateful");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeCodePageStateful(int code_page, const char *string, Py_ssize_t length, const char *errors, Py_ssize_t *consumed)
     * }
     */
    public static FunctionDescriptor PyUnicode_DecodeCodePageStateful$descriptor() {
        return PyUnicode_DecodeCodePageStateful.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeCodePageStateful(int code_page, const char *string, Py_ssize_t length, const char *errors, Py_ssize_t *consumed)
     * }
     */
    public static MethodHandle PyUnicode_DecodeCodePageStateful$handle() {
        return PyUnicode_DecodeCodePageStateful.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeCodePageStateful(int code_page, const char *string, Py_ssize_t length, const char *errors, Py_ssize_t *consumed)
     * }
     */
    public static MemorySegment PyUnicode_DecodeCodePageStateful$address() {
        return PyUnicode_DecodeCodePageStateful.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeCodePageStateful(int code_page, const char *string, Py_ssize_t length, const char *errors, Py_ssize_t *consumed)
     * }
     */
    public static MemorySegment PyUnicode_DecodeCodePageStateful(int code_page, MemorySegment string, long length, MemorySegment errors, MemorySegment consumed) {
        var mh$ = PyUnicode_DecodeCodePageStateful.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_DecodeCodePageStateful", code_page, string, length, errors, consumed);
            }
            return (MemorySegment)mh$.invokeExact(code_page, string, length, errors, consumed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_AsMBCSString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_AsMBCSString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsMBCSString(PyObject *unicode)
     * }
     */
    public static FunctionDescriptor PyUnicode_AsMBCSString$descriptor() {
        return PyUnicode_AsMBCSString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsMBCSString(PyObject *unicode)
     * }
     */
    public static MethodHandle PyUnicode_AsMBCSString$handle() {
        return PyUnicode_AsMBCSString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsMBCSString(PyObject *unicode)
     * }
     */
    public static MemorySegment PyUnicode_AsMBCSString$address() {
        return PyUnicode_AsMBCSString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsMBCSString(PyObject *unicode)
     * }
     */
    public static MemorySegment PyUnicode_AsMBCSString(MemorySegment unicode) {
        var mh$ = PyUnicode_AsMBCSString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_AsMBCSString", unicode);
            }
            return (MemorySegment)mh$.invokeExact(unicode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_EncodeCodePage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_EncodeCodePage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_EncodeCodePage(int code_page, PyObject *unicode, const char *errors)
     * }
     */
    public static FunctionDescriptor PyUnicode_EncodeCodePage$descriptor() {
        return PyUnicode_EncodeCodePage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_EncodeCodePage(int code_page, PyObject *unicode, const char *errors)
     * }
     */
    public static MethodHandle PyUnicode_EncodeCodePage$handle() {
        return PyUnicode_EncodeCodePage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_EncodeCodePage(int code_page, PyObject *unicode, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_EncodeCodePage$address() {
        return PyUnicode_EncodeCodePage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_EncodeCodePage(int code_page, PyObject *unicode, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_EncodeCodePage(int code_page, MemorySegment unicode, MemorySegment errors) {
        var mh$ = PyUnicode_EncodeCodePage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_EncodeCodePage", code_page, unicode, errors);
            }
            return (MemorySegment)mh$.invokeExact(code_page, unicode, errors);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_DecodeLocaleAndSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_DecodeLocaleAndSize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeLocaleAndSize(const char *str, Py_ssize_t len, const char *errors)
     * }
     */
    public static FunctionDescriptor PyUnicode_DecodeLocaleAndSize$descriptor() {
        return PyUnicode_DecodeLocaleAndSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeLocaleAndSize(const char *str, Py_ssize_t len, const char *errors)
     * }
     */
    public static MethodHandle PyUnicode_DecodeLocaleAndSize$handle() {
        return PyUnicode_DecodeLocaleAndSize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeLocaleAndSize(const char *str, Py_ssize_t len, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_DecodeLocaleAndSize$address() {
        return PyUnicode_DecodeLocaleAndSize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeLocaleAndSize(const char *str, Py_ssize_t len, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_DecodeLocaleAndSize(MemorySegment str, long len, MemorySegment errors) {
        var mh$ = PyUnicode_DecodeLocaleAndSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_DecodeLocaleAndSize", str, len, errors);
            }
            return (MemorySegment)mh$.invokeExact(str, len, errors);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_DecodeLocale {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_DecodeLocale");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeLocale(const char *str, const char *errors)
     * }
     */
    public static FunctionDescriptor PyUnicode_DecodeLocale$descriptor() {
        return PyUnicode_DecodeLocale.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeLocale(const char *str, const char *errors)
     * }
     */
    public static MethodHandle PyUnicode_DecodeLocale$handle() {
        return PyUnicode_DecodeLocale.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeLocale(const char *str, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_DecodeLocale$address() {
        return PyUnicode_DecodeLocale.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeLocale(const char *str, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_DecodeLocale(MemorySegment str, MemorySegment errors) {
        var mh$ = PyUnicode_DecodeLocale.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_DecodeLocale", str, errors);
            }
            return (MemorySegment)mh$.invokeExact(str, errors);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_EncodeLocale {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_EncodeLocale");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_EncodeLocale(PyObject *unicode, const char *errors)
     * }
     */
    public static FunctionDescriptor PyUnicode_EncodeLocale$descriptor() {
        return PyUnicode_EncodeLocale.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_EncodeLocale(PyObject *unicode, const char *errors)
     * }
     */
    public static MethodHandle PyUnicode_EncodeLocale$handle() {
        return PyUnicode_EncodeLocale.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_EncodeLocale(PyObject *unicode, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_EncodeLocale$address() {
        return PyUnicode_EncodeLocale.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_EncodeLocale(PyObject *unicode, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_EncodeLocale(MemorySegment unicode, MemorySegment errors) {
        var mh$ = PyUnicode_EncodeLocale.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_EncodeLocale", unicode, errors);
            }
            return (MemorySegment)mh$.invokeExact(unicode, errors);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_FSConverter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_FSConverter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyUnicode_FSConverter(PyObject *, void *)
     * }
     */
    public static FunctionDescriptor PyUnicode_FSConverter$descriptor() {
        return PyUnicode_FSConverter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyUnicode_FSConverter(PyObject *, void *)
     * }
     */
    public static MethodHandle PyUnicode_FSConverter$handle() {
        return PyUnicode_FSConverter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyUnicode_FSConverter(PyObject *, void *)
     * }
     */
    public static MemorySegment PyUnicode_FSConverter$address() {
        return PyUnicode_FSConverter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyUnicode_FSConverter(PyObject *, void *)
     * }
     */
    public static int PyUnicode_FSConverter(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyUnicode_FSConverter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_FSConverter", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_FSDecoder {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_FSDecoder");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyUnicode_FSDecoder(PyObject *, void *)
     * }
     */
    public static FunctionDescriptor PyUnicode_FSDecoder$descriptor() {
        return PyUnicode_FSDecoder.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyUnicode_FSDecoder(PyObject *, void *)
     * }
     */
    public static MethodHandle PyUnicode_FSDecoder$handle() {
        return PyUnicode_FSDecoder.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyUnicode_FSDecoder(PyObject *, void *)
     * }
     */
    public static MemorySegment PyUnicode_FSDecoder$address() {
        return PyUnicode_FSDecoder.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyUnicode_FSDecoder(PyObject *, void *)
     * }
     */
    public static int PyUnicode_FSDecoder(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyUnicode_FSDecoder.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_FSDecoder", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_DecodeFSDefault {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_DecodeFSDefault");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeFSDefault(const char *s)
     * }
     */
    public static FunctionDescriptor PyUnicode_DecodeFSDefault$descriptor() {
        return PyUnicode_DecodeFSDefault.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeFSDefault(const char *s)
     * }
     */
    public static MethodHandle PyUnicode_DecodeFSDefault$handle() {
        return PyUnicode_DecodeFSDefault.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeFSDefault(const char *s)
     * }
     */
    public static MemorySegment PyUnicode_DecodeFSDefault$address() {
        return PyUnicode_DecodeFSDefault.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeFSDefault(const char *s)
     * }
     */
    public static MemorySegment PyUnicode_DecodeFSDefault(MemorySegment s) {
        var mh$ = PyUnicode_DecodeFSDefault.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_DecodeFSDefault", s);
            }
            return (MemorySegment)mh$.invokeExact(s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_DecodeFSDefaultAndSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_DecodeFSDefaultAndSize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeFSDefaultAndSize(const char *s, Py_ssize_t size)
     * }
     */
    public static FunctionDescriptor PyUnicode_DecodeFSDefaultAndSize$descriptor() {
        return PyUnicode_DecodeFSDefaultAndSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeFSDefaultAndSize(const char *s, Py_ssize_t size)
     * }
     */
    public static MethodHandle PyUnicode_DecodeFSDefaultAndSize$handle() {
        return PyUnicode_DecodeFSDefaultAndSize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeFSDefaultAndSize(const char *s, Py_ssize_t size)
     * }
     */
    public static MemorySegment PyUnicode_DecodeFSDefaultAndSize$address() {
        return PyUnicode_DecodeFSDefaultAndSize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeFSDefaultAndSize(const char *s, Py_ssize_t size)
     * }
     */
    public static MemorySegment PyUnicode_DecodeFSDefaultAndSize(MemorySegment s, long size) {
        var mh$ = PyUnicode_DecodeFSDefaultAndSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_DecodeFSDefaultAndSize", s, size);
            }
            return (MemorySegment)mh$.invokeExact(s, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_EncodeFSDefault {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_EncodeFSDefault");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_EncodeFSDefault(PyObject *unicode)
     * }
     */
    public static FunctionDescriptor PyUnicode_EncodeFSDefault$descriptor() {
        return PyUnicode_EncodeFSDefault.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_EncodeFSDefault(PyObject *unicode)
     * }
     */
    public static MethodHandle PyUnicode_EncodeFSDefault$handle() {
        return PyUnicode_EncodeFSDefault.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_EncodeFSDefault(PyObject *unicode)
     * }
     */
    public static MemorySegment PyUnicode_EncodeFSDefault$address() {
        return PyUnicode_EncodeFSDefault.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_EncodeFSDefault(PyObject *unicode)
     * }
     */
    public static MemorySegment PyUnicode_EncodeFSDefault(MemorySegment unicode) {
        var mh$ = PyUnicode_EncodeFSDefault.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_EncodeFSDefault", unicode);
            }
            return (MemorySegment)mh$.invokeExact(unicode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_Concat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_Concat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_Concat(PyObject *left, PyObject *right)
     * }
     */
    public static FunctionDescriptor PyUnicode_Concat$descriptor() {
        return PyUnicode_Concat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_Concat(PyObject *left, PyObject *right)
     * }
     */
    public static MethodHandle PyUnicode_Concat$handle() {
        return PyUnicode_Concat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_Concat(PyObject *left, PyObject *right)
     * }
     */
    public static MemorySegment PyUnicode_Concat$address() {
        return PyUnicode_Concat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_Concat(PyObject *left, PyObject *right)
     * }
     */
    public static MemorySegment PyUnicode_Concat(MemorySegment left, MemorySegment right) {
        var mh$ = PyUnicode_Concat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_Concat", left, right);
            }
            return (MemorySegment)mh$.invokeExact(left, right);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_Append {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_Append");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyUnicode_Append(PyObject **pleft, PyObject *right)
     * }
     */
    public static FunctionDescriptor PyUnicode_Append$descriptor() {
        return PyUnicode_Append.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyUnicode_Append(PyObject **pleft, PyObject *right)
     * }
     */
    public static MethodHandle PyUnicode_Append$handle() {
        return PyUnicode_Append.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyUnicode_Append(PyObject **pleft, PyObject *right)
     * }
     */
    public static MemorySegment PyUnicode_Append$address() {
        return PyUnicode_Append.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyUnicode_Append(PyObject **pleft, PyObject *right)
     * }
     */
    public static void PyUnicode_Append(MemorySegment pleft, MemorySegment right) {
        var mh$ = PyUnicode_Append.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_Append", pleft, right);
            }
            mh$.invokeExact(pleft, right);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_AppendAndDel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_AppendAndDel");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyUnicode_AppendAndDel(PyObject **pleft, PyObject *right)
     * }
     */
    public static FunctionDescriptor PyUnicode_AppendAndDel$descriptor() {
        return PyUnicode_AppendAndDel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyUnicode_AppendAndDel(PyObject **pleft, PyObject *right)
     * }
     */
    public static MethodHandle PyUnicode_AppendAndDel$handle() {
        return PyUnicode_AppendAndDel.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyUnicode_AppendAndDel(PyObject **pleft, PyObject *right)
     * }
     */
    public static MemorySegment PyUnicode_AppendAndDel$address() {
        return PyUnicode_AppendAndDel.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyUnicode_AppendAndDel(PyObject **pleft, PyObject *right)
     * }
     */
    public static void PyUnicode_AppendAndDel(MemorySegment pleft, MemorySegment right) {
        var mh$ = PyUnicode_AppendAndDel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_AppendAndDel", pleft, right);
            }
            mh$.invokeExact(pleft, right);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_Split {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_Split");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_Split(PyObject *s, PyObject *sep, Py_ssize_t maxsplit)
     * }
     */
    public static FunctionDescriptor PyUnicode_Split$descriptor() {
        return PyUnicode_Split.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_Split(PyObject *s, PyObject *sep, Py_ssize_t maxsplit)
     * }
     */
    public static MethodHandle PyUnicode_Split$handle() {
        return PyUnicode_Split.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_Split(PyObject *s, PyObject *sep, Py_ssize_t maxsplit)
     * }
     */
    public static MemorySegment PyUnicode_Split$address() {
        return PyUnicode_Split.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_Split(PyObject *s, PyObject *sep, Py_ssize_t maxsplit)
     * }
     */
    public static MemorySegment PyUnicode_Split(MemorySegment s, MemorySegment sep, long maxsplit) {
        var mh$ = PyUnicode_Split.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_Split", s, sep, maxsplit);
            }
            return (MemorySegment)mh$.invokeExact(s, sep, maxsplit);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_Splitlines {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_Splitlines");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_Splitlines(PyObject *s, int keepends)
     * }
     */
    public static FunctionDescriptor PyUnicode_Splitlines$descriptor() {
        return PyUnicode_Splitlines.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_Splitlines(PyObject *s, int keepends)
     * }
     */
    public static MethodHandle PyUnicode_Splitlines$handle() {
        return PyUnicode_Splitlines.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_Splitlines(PyObject *s, int keepends)
     * }
     */
    public static MemorySegment PyUnicode_Splitlines$address() {
        return PyUnicode_Splitlines.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_Splitlines(PyObject *s, int keepends)
     * }
     */
    public static MemorySegment PyUnicode_Splitlines(MemorySegment s, int keepends) {
        var mh$ = PyUnicode_Splitlines.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_Splitlines", s, keepends);
            }
            return (MemorySegment)mh$.invokeExact(s, keepends);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_Partition {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_Partition");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_Partition(PyObject *s, PyObject *sep)
     * }
     */
    public static FunctionDescriptor PyUnicode_Partition$descriptor() {
        return PyUnicode_Partition.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_Partition(PyObject *s, PyObject *sep)
     * }
     */
    public static MethodHandle PyUnicode_Partition$handle() {
        return PyUnicode_Partition.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_Partition(PyObject *s, PyObject *sep)
     * }
     */
    public static MemorySegment PyUnicode_Partition$address() {
        return PyUnicode_Partition.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_Partition(PyObject *s, PyObject *sep)
     * }
     */
    public static MemorySegment PyUnicode_Partition(MemorySegment s, MemorySegment sep) {
        var mh$ = PyUnicode_Partition.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_Partition", s, sep);
            }
            return (MemorySegment)mh$.invokeExact(s, sep);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_RPartition {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_RPartition");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_RPartition(PyObject *s, PyObject *sep)
     * }
     */
    public static FunctionDescriptor PyUnicode_RPartition$descriptor() {
        return PyUnicode_RPartition.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_RPartition(PyObject *s, PyObject *sep)
     * }
     */
    public static MethodHandle PyUnicode_RPartition$handle() {
        return PyUnicode_RPartition.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_RPartition(PyObject *s, PyObject *sep)
     * }
     */
    public static MemorySegment PyUnicode_RPartition$address() {
        return PyUnicode_RPartition.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_RPartition(PyObject *s, PyObject *sep)
     * }
     */
    public static MemorySegment PyUnicode_RPartition(MemorySegment s, MemorySegment sep) {
        var mh$ = PyUnicode_RPartition.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_RPartition", s, sep);
            }
            return (MemorySegment)mh$.invokeExact(s, sep);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_RSplit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_RSplit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_RSplit(PyObject *s, PyObject *sep, Py_ssize_t maxsplit)
     * }
     */
    public static FunctionDescriptor PyUnicode_RSplit$descriptor() {
        return PyUnicode_RSplit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_RSplit(PyObject *s, PyObject *sep, Py_ssize_t maxsplit)
     * }
     */
    public static MethodHandle PyUnicode_RSplit$handle() {
        return PyUnicode_RSplit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_RSplit(PyObject *s, PyObject *sep, Py_ssize_t maxsplit)
     * }
     */
    public static MemorySegment PyUnicode_RSplit$address() {
        return PyUnicode_RSplit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_RSplit(PyObject *s, PyObject *sep, Py_ssize_t maxsplit)
     * }
     */
    public static MemorySegment PyUnicode_RSplit(MemorySegment s, MemorySegment sep, long maxsplit) {
        var mh$ = PyUnicode_RSplit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_RSplit", s, sep, maxsplit);
            }
            return (MemorySegment)mh$.invokeExact(s, sep, maxsplit);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_Translate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_Translate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_Translate(PyObject *str, PyObject *table, const char *errors)
     * }
     */
    public static FunctionDescriptor PyUnicode_Translate$descriptor() {
        return PyUnicode_Translate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_Translate(PyObject *str, PyObject *table, const char *errors)
     * }
     */
    public static MethodHandle PyUnicode_Translate$handle() {
        return PyUnicode_Translate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_Translate(PyObject *str, PyObject *table, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_Translate$address() {
        return PyUnicode_Translate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_Translate(PyObject *str, PyObject *table, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_Translate(MemorySegment str, MemorySegment table, MemorySegment errors) {
        var mh$ = PyUnicode_Translate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_Translate", str, table, errors);
            }
            return (MemorySegment)mh$.invokeExact(str, table, errors);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_Join {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_Join");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_Join(PyObject *separator, PyObject *seq)
     * }
     */
    public static FunctionDescriptor PyUnicode_Join$descriptor() {
        return PyUnicode_Join.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_Join(PyObject *separator, PyObject *seq)
     * }
     */
    public static MethodHandle PyUnicode_Join$handle() {
        return PyUnicode_Join.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_Join(PyObject *separator, PyObject *seq)
     * }
     */
    public static MemorySegment PyUnicode_Join$address() {
        return PyUnicode_Join.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_Join(PyObject *separator, PyObject *seq)
     * }
     */
    public static MemorySegment PyUnicode_Join(MemorySegment separator, MemorySegment seq) {
        var mh$ = PyUnicode_Join.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_Join", separator, seq);
            }
            return (MemorySegment)mh$.invokeExact(separator, seq);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_Tailmatch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_LONG_LONG,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_Tailmatch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_ssize_t PyUnicode_Tailmatch(PyObject *str, PyObject *substr, Py_ssize_t start, Py_ssize_t end, int direction)
     * }
     */
    public static FunctionDescriptor PyUnicode_Tailmatch$descriptor() {
        return PyUnicode_Tailmatch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_ssize_t PyUnicode_Tailmatch(PyObject *str, PyObject *substr, Py_ssize_t start, Py_ssize_t end, int direction)
     * }
     */
    public static MethodHandle PyUnicode_Tailmatch$handle() {
        return PyUnicode_Tailmatch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_ssize_t PyUnicode_Tailmatch(PyObject *str, PyObject *substr, Py_ssize_t start, Py_ssize_t end, int direction)
     * }
     */
    public static MemorySegment PyUnicode_Tailmatch$address() {
        return PyUnicode_Tailmatch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_ssize_t PyUnicode_Tailmatch(PyObject *str, PyObject *substr, Py_ssize_t start, Py_ssize_t end, int direction)
     * }
     */
    public static long PyUnicode_Tailmatch(MemorySegment str, MemorySegment substr, long start, long end, int direction) {
        var mh$ = PyUnicode_Tailmatch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_Tailmatch", str, substr, start, end, direction);
            }
            return (long)mh$.invokeExact(str, substr, start, end, direction);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_Find {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_LONG_LONG,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_Find");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_ssize_t PyUnicode_Find(PyObject *str, PyObject *substr, Py_ssize_t start, Py_ssize_t end, int direction)
     * }
     */
    public static FunctionDescriptor PyUnicode_Find$descriptor() {
        return PyUnicode_Find.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_ssize_t PyUnicode_Find(PyObject *str, PyObject *substr, Py_ssize_t start, Py_ssize_t end, int direction)
     * }
     */
    public static MethodHandle PyUnicode_Find$handle() {
        return PyUnicode_Find.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_ssize_t PyUnicode_Find(PyObject *str, PyObject *substr, Py_ssize_t start, Py_ssize_t end, int direction)
     * }
     */
    public static MemorySegment PyUnicode_Find$address() {
        return PyUnicode_Find.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_ssize_t PyUnicode_Find(PyObject *str, PyObject *substr, Py_ssize_t start, Py_ssize_t end, int direction)
     * }
     */
    public static long PyUnicode_Find(MemorySegment str, MemorySegment substr, long start, long end, int direction) {
        var mh$ = PyUnicode_Find.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_Find", str, substr, start, end, direction);
            }
            return (long)mh$.invokeExact(str, substr, start, end, direction);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_FindChar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_LONG_LONG,
            Python_h.C_LONG_LONG,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_FindChar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_ssize_t PyUnicode_FindChar(PyObject *str, Py_UCS4 ch, Py_ssize_t start, Py_ssize_t end, int direction)
     * }
     */
    public static FunctionDescriptor PyUnicode_FindChar$descriptor() {
        return PyUnicode_FindChar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_ssize_t PyUnicode_FindChar(PyObject *str, Py_UCS4 ch, Py_ssize_t start, Py_ssize_t end, int direction)
     * }
     */
    public static MethodHandle PyUnicode_FindChar$handle() {
        return PyUnicode_FindChar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_ssize_t PyUnicode_FindChar(PyObject *str, Py_UCS4 ch, Py_ssize_t start, Py_ssize_t end, int direction)
     * }
     */
    public static MemorySegment PyUnicode_FindChar$address() {
        return PyUnicode_FindChar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_ssize_t PyUnicode_FindChar(PyObject *str, Py_UCS4 ch, Py_ssize_t start, Py_ssize_t end, int direction)
     * }
     */
    public static long PyUnicode_FindChar(MemorySegment str, int ch, long start, long end, int direction) {
        var mh$ = PyUnicode_FindChar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_FindChar", str, ch, start, end, direction);
            }
            return (long)mh$.invokeExact(str, ch, start, end, direction);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_Count {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_Count");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_ssize_t PyUnicode_Count(PyObject *str, PyObject *substr, Py_ssize_t start, Py_ssize_t end)
     * }
     */
    public static FunctionDescriptor PyUnicode_Count$descriptor() {
        return PyUnicode_Count.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_ssize_t PyUnicode_Count(PyObject *str, PyObject *substr, Py_ssize_t start, Py_ssize_t end)
     * }
     */
    public static MethodHandle PyUnicode_Count$handle() {
        return PyUnicode_Count.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_ssize_t PyUnicode_Count(PyObject *str, PyObject *substr, Py_ssize_t start, Py_ssize_t end)
     * }
     */
    public static MemorySegment PyUnicode_Count$address() {
        return PyUnicode_Count.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_ssize_t PyUnicode_Count(PyObject *str, PyObject *substr, Py_ssize_t start, Py_ssize_t end)
     * }
     */
    public static long PyUnicode_Count(MemorySegment str, MemorySegment substr, long start, long end) {
        var mh$ = PyUnicode_Count.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_Count", str, substr, start, end);
            }
            return (long)mh$.invokeExact(str, substr, start, end);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_Replace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_Replace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_Replace(PyObject *str, PyObject *substr, PyObject *replstr, Py_ssize_t maxcount)
     * }
     */
    public static FunctionDescriptor PyUnicode_Replace$descriptor() {
        return PyUnicode_Replace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_Replace(PyObject *str, PyObject *substr, PyObject *replstr, Py_ssize_t maxcount)
     * }
     */
    public static MethodHandle PyUnicode_Replace$handle() {
        return PyUnicode_Replace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_Replace(PyObject *str, PyObject *substr, PyObject *replstr, Py_ssize_t maxcount)
     * }
     */
    public static MemorySegment PyUnicode_Replace$address() {
        return PyUnicode_Replace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_Replace(PyObject *str, PyObject *substr, PyObject *replstr, Py_ssize_t maxcount)
     * }
     */
    public static MemorySegment PyUnicode_Replace(MemorySegment str, MemorySegment substr, MemorySegment replstr, long maxcount) {
        var mh$ = PyUnicode_Replace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_Replace", str, substr, replstr, maxcount);
            }
            return (MemorySegment)mh$.invokeExact(str, substr, replstr, maxcount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_Compare {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_Compare");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyUnicode_Compare(PyObject *left, PyObject *right)
     * }
     */
    public static FunctionDescriptor PyUnicode_Compare$descriptor() {
        return PyUnicode_Compare.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyUnicode_Compare(PyObject *left, PyObject *right)
     * }
     */
    public static MethodHandle PyUnicode_Compare$handle() {
        return PyUnicode_Compare.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyUnicode_Compare(PyObject *left, PyObject *right)
     * }
     */
    public static MemorySegment PyUnicode_Compare$address() {
        return PyUnicode_Compare.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyUnicode_Compare(PyObject *left, PyObject *right)
     * }
     */
    public static int PyUnicode_Compare(MemorySegment left, MemorySegment right) {
        var mh$ = PyUnicode_Compare.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_Compare", left, right);
            }
            return (int)mh$.invokeExact(left, right);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_CompareWithASCIIString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_CompareWithASCIIString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyUnicode_CompareWithASCIIString(PyObject *left, const char *right)
     * }
     */
    public static FunctionDescriptor PyUnicode_CompareWithASCIIString$descriptor() {
        return PyUnicode_CompareWithASCIIString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyUnicode_CompareWithASCIIString(PyObject *left, const char *right)
     * }
     */
    public static MethodHandle PyUnicode_CompareWithASCIIString$handle() {
        return PyUnicode_CompareWithASCIIString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyUnicode_CompareWithASCIIString(PyObject *left, const char *right)
     * }
     */
    public static MemorySegment PyUnicode_CompareWithASCIIString$address() {
        return PyUnicode_CompareWithASCIIString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyUnicode_CompareWithASCIIString(PyObject *left, const char *right)
     * }
     */
    public static int PyUnicode_CompareWithASCIIString(MemorySegment left, MemorySegment right) {
        var mh$ = PyUnicode_CompareWithASCIIString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_CompareWithASCIIString", left, right);
            }
            return (int)mh$.invokeExact(left, right);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_RichCompare {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_RichCompare");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_RichCompare(PyObject *left, PyObject *right, int op)
     * }
     */
    public static FunctionDescriptor PyUnicode_RichCompare$descriptor() {
        return PyUnicode_RichCompare.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_RichCompare(PyObject *left, PyObject *right, int op)
     * }
     */
    public static MethodHandle PyUnicode_RichCompare$handle() {
        return PyUnicode_RichCompare.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_RichCompare(PyObject *left, PyObject *right, int op)
     * }
     */
    public static MemorySegment PyUnicode_RichCompare$address() {
        return PyUnicode_RichCompare.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_RichCompare(PyObject *left, PyObject *right, int op)
     * }
     */
    public static MemorySegment PyUnicode_RichCompare(MemorySegment left, MemorySegment right, int op) {
        var mh$ = PyUnicode_RichCompare.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_RichCompare", left, right, op);
            }
            return (MemorySegment)mh$.invokeExact(left, right, op);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_Format {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_Format");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_Format(PyObject *format, PyObject *args)
     * }
     */
    public static FunctionDescriptor PyUnicode_Format$descriptor() {
        return PyUnicode_Format.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_Format(PyObject *format, PyObject *args)
     * }
     */
    public static MethodHandle PyUnicode_Format$handle() {
        return PyUnicode_Format.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_Format(PyObject *format, PyObject *args)
     * }
     */
    public static MemorySegment PyUnicode_Format$address() {
        return PyUnicode_Format.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_Format(PyObject *format, PyObject *args)
     * }
     */
    public static MemorySegment PyUnicode_Format(MemorySegment format, MemorySegment args) {
        var mh$ = PyUnicode_Format.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_Format", format, args);
            }
            return (MemorySegment)mh$.invokeExact(format, args);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_Contains {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_Contains");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyUnicode_Contains(PyObject *container, PyObject *element)
     * }
     */
    public static FunctionDescriptor PyUnicode_Contains$descriptor() {
        return PyUnicode_Contains.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyUnicode_Contains(PyObject *container, PyObject *element)
     * }
     */
    public static MethodHandle PyUnicode_Contains$handle() {
        return PyUnicode_Contains.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyUnicode_Contains(PyObject *container, PyObject *element)
     * }
     */
    public static MemorySegment PyUnicode_Contains$address() {
        return PyUnicode_Contains.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyUnicode_Contains(PyObject *container, PyObject *element)
     * }
     */
    public static int PyUnicode_Contains(MemorySegment container, MemorySegment element) {
        var mh$ = PyUnicode_Contains.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_Contains", container, element);
            }
            return (int)mh$.invokeExact(container, element);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_IsIdentifier {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_IsIdentifier");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyUnicode_IsIdentifier(PyObject *s)
     * }
     */
    public static FunctionDescriptor PyUnicode_IsIdentifier$descriptor() {
        return PyUnicode_IsIdentifier.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyUnicode_IsIdentifier(PyObject *s)
     * }
     */
    public static MethodHandle PyUnicode_IsIdentifier$handle() {
        return PyUnicode_IsIdentifier.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyUnicode_IsIdentifier(PyObject *s)
     * }
     */
    public static MemorySegment PyUnicode_IsIdentifier$address() {
        return PyUnicode_IsIdentifier.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyUnicode_IsIdentifier(PyObject *s)
     * }
     */
    public static int PyUnicode_IsIdentifier(MemorySegment s) {
        var mh$ = PyUnicode_IsIdentifier.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_IsIdentifier", s);
            }
            return (int)mh$.invokeExact(s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyLong_FromLong {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyLong_FromLong");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyLong_FromLong(long)
     * }
     */
    public static FunctionDescriptor PyLong_FromLong$descriptor() {
        return PyLong_FromLong.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyLong_FromLong(long)
     * }
     */
    public static MethodHandle PyLong_FromLong$handle() {
        return PyLong_FromLong.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyLong_FromLong(long)
     * }
     */
    public static MemorySegment PyLong_FromLong$address() {
        return PyLong_FromLong.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyLong_FromLong(long)
     * }
     */
    public static MemorySegment PyLong_FromLong(int x0) {
        var mh$ = PyLong_FromLong.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyLong_FromLong", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyLong_FromUnsignedLong {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyLong_FromUnsignedLong");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyLong_FromUnsignedLong(unsigned long)
     * }
     */
    public static FunctionDescriptor PyLong_FromUnsignedLong$descriptor() {
        return PyLong_FromUnsignedLong.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyLong_FromUnsignedLong(unsigned long)
     * }
     */
    public static MethodHandle PyLong_FromUnsignedLong$handle() {
        return PyLong_FromUnsignedLong.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyLong_FromUnsignedLong(unsigned long)
     * }
     */
    public static MemorySegment PyLong_FromUnsignedLong$address() {
        return PyLong_FromUnsignedLong.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyLong_FromUnsignedLong(unsigned long)
     * }
     */
    public static MemorySegment PyLong_FromUnsignedLong(int x0) {
        var mh$ = PyLong_FromUnsignedLong.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyLong_FromUnsignedLong", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyLong_FromSize_t {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyLong_FromSize_t");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyLong_FromSize_t(size_t)
     * }
     */
    public static FunctionDescriptor PyLong_FromSize_t$descriptor() {
        return PyLong_FromSize_t.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyLong_FromSize_t(size_t)
     * }
     */
    public static MethodHandle PyLong_FromSize_t$handle() {
        return PyLong_FromSize_t.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyLong_FromSize_t(size_t)
     * }
     */
    public static MemorySegment PyLong_FromSize_t$address() {
        return PyLong_FromSize_t.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyLong_FromSize_t(size_t)
     * }
     */
    public static MemorySegment PyLong_FromSize_t(long x0) {
        var mh$ = PyLong_FromSize_t.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyLong_FromSize_t", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyLong_FromSsize_t {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyLong_FromSsize_t");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyLong_FromSsize_t(Py_ssize_t)
     * }
     */
    public static FunctionDescriptor PyLong_FromSsize_t$descriptor() {
        return PyLong_FromSsize_t.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyLong_FromSsize_t(Py_ssize_t)
     * }
     */
    public static MethodHandle PyLong_FromSsize_t$handle() {
        return PyLong_FromSsize_t.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyLong_FromSsize_t(Py_ssize_t)
     * }
     */
    public static MemorySegment PyLong_FromSsize_t$address() {
        return PyLong_FromSsize_t.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyLong_FromSsize_t(Py_ssize_t)
     * }
     */
    public static MemorySegment PyLong_FromSsize_t(long x0) {
        var mh$ = PyLong_FromSsize_t.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyLong_FromSsize_t", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyLong_FromDouble {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyLong_FromDouble");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyLong_FromDouble(double)
     * }
     */
    public static FunctionDescriptor PyLong_FromDouble$descriptor() {
        return PyLong_FromDouble.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyLong_FromDouble(double)
     * }
     */
    public static MethodHandle PyLong_FromDouble$handle() {
        return PyLong_FromDouble.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyLong_FromDouble(double)
     * }
     */
    public static MemorySegment PyLong_FromDouble$address() {
        return PyLong_FromDouble.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyLong_FromDouble(double)
     * }
     */
    public static MemorySegment PyLong_FromDouble(double x0) {
        var mh$ = PyLong_FromDouble.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyLong_FromDouble", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyLong_AsLong {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyLong_AsLong");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long PyLong_AsLong(PyObject *)
     * }
     */
    public static FunctionDescriptor PyLong_AsLong$descriptor() {
        return PyLong_AsLong.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long PyLong_AsLong(PyObject *)
     * }
     */
    public static MethodHandle PyLong_AsLong$handle() {
        return PyLong_AsLong.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long PyLong_AsLong(PyObject *)
     * }
     */
    public static MemorySegment PyLong_AsLong$address() {
        return PyLong_AsLong.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long PyLong_AsLong(PyObject *)
     * }
     */
    public static int PyLong_AsLong(MemorySegment x0) {
        var mh$ = PyLong_AsLong.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyLong_AsLong", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyLong_AsLongAndOverflow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyLong_AsLongAndOverflow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long PyLong_AsLongAndOverflow(PyObject *, int *)
     * }
     */
    public static FunctionDescriptor PyLong_AsLongAndOverflow$descriptor() {
        return PyLong_AsLongAndOverflow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long PyLong_AsLongAndOverflow(PyObject *, int *)
     * }
     */
    public static MethodHandle PyLong_AsLongAndOverflow$handle() {
        return PyLong_AsLongAndOverflow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long PyLong_AsLongAndOverflow(PyObject *, int *)
     * }
     */
    public static MemorySegment PyLong_AsLongAndOverflow$address() {
        return PyLong_AsLongAndOverflow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long PyLong_AsLongAndOverflow(PyObject *, int *)
     * }
     */
    public static int PyLong_AsLongAndOverflow(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyLong_AsLongAndOverflow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyLong_AsLongAndOverflow", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyLong_AsSsize_t {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyLong_AsSsize_t");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_ssize_t PyLong_AsSsize_t(PyObject *)
     * }
     */
    public static FunctionDescriptor PyLong_AsSsize_t$descriptor() {
        return PyLong_AsSsize_t.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_ssize_t PyLong_AsSsize_t(PyObject *)
     * }
     */
    public static MethodHandle PyLong_AsSsize_t$handle() {
        return PyLong_AsSsize_t.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_ssize_t PyLong_AsSsize_t(PyObject *)
     * }
     */
    public static MemorySegment PyLong_AsSsize_t$address() {
        return PyLong_AsSsize_t.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_ssize_t PyLong_AsSsize_t(PyObject *)
     * }
     */
    public static long PyLong_AsSsize_t(MemorySegment x0) {
        var mh$ = PyLong_AsSsize_t.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyLong_AsSsize_t", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyLong_AsSize_t {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyLong_AsSize_t");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t PyLong_AsSize_t(PyObject *)
     * }
     */
    public static FunctionDescriptor PyLong_AsSize_t$descriptor() {
        return PyLong_AsSize_t.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t PyLong_AsSize_t(PyObject *)
     * }
     */
    public static MethodHandle PyLong_AsSize_t$handle() {
        return PyLong_AsSize_t.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t PyLong_AsSize_t(PyObject *)
     * }
     */
    public static MemorySegment PyLong_AsSize_t$address() {
        return PyLong_AsSize_t.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t PyLong_AsSize_t(PyObject *)
     * }
     */
    public static long PyLong_AsSize_t(MemorySegment x0) {
        var mh$ = PyLong_AsSize_t.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyLong_AsSize_t", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyLong_AsUnsignedLong {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyLong_AsUnsignedLong");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long PyLong_AsUnsignedLong(PyObject *)
     * }
     */
    public static FunctionDescriptor PyLong_AsUnsignedLong$descriptor() {
        return PyLong_AsUnsignedLong.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long PyLong_AsUnsignedLong(PyObject *)
     * }
     */
    public static MethodHandle PyLong_AsUnsignedLong$handle() {
        return PyLong_AsUnsignedLong.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long PyLong_AsUnsignedLong(PyObject *)
     * }
     */
    public static MemorySegment PyLong_AsUnsignedLong$address() {
        return PyLong_AsUnsignedLong.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long PyLong_AsUnsignedLong(PyObject *)
     * }
     */
    public static int PyLong_AsUnsignedLong(MemorySegment x0) {
        var mh$ = PyLong_AsUnsignedLong.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyLong_AsUnsignedLong", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyLong_AsUnsignedLongMask {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyLong_AsUnsignedLongMask");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long PyLong_AsUnsignedLongMask(PyObject *)
     * }
     */
    public static FunctionDescriptor PyLong_AsUnsignedLongMask$descriptor() {
        return PyLong_AsUnsignedLongMask.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long PyLong_AsUnsignedLongMask(PyObject *)
     * }
     */
    public static MethodHandle PyLong_AsUnsignedLongMask$handle() {
        return PyLong_AsUnsignedLongMask.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long PyLong_AsUnsignedLongMask(PyObject *)
     * }
     */
    public static MemorySegment PyLong_AsUnsignedLongMask$address() {
        return PyLong_AsUnsignedLongMask.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long PyLong_AsUnsignedLongMask(PyObject *)
     * }
     */
    public static int PyLong_AsUnsignedLongMask(MemorySegment x0) {
        var mh$ = PyLong_AsUnsignedLongMask.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyLong_AsUnsignedLongMask", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyLong_GetInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyLong_GetInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyLong_GetInfo()
     * }
     */
    public static FunctionDescriptor PyLong_GetInfo$descriptor() {
        return PyLong_GetInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyLong_GetInfo()
     * }
     */
    public static MethodHandle PyLong_GetInfo$handle() {
        return PyLong_GetInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyLong_GetInfo()
     * }
     */
    public static MemorySegment PyLong_GetInfo$address() {
        return PyLong_GetInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyLong_GetInfo()
     * }
     */
    public static MemorySegment PyLong_GetInfo() {
        var mh$ = PyLong_GetInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyLong_GetInfo");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyLong_AsDouble {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyLong_AsDouble");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double PyLong_AsDouble(PyObject *)
     * }
     */
    public static FunctionDescriptor PyLong_AsDouble$descriptor() {
        return PyLong_AsDouble.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double PyLong_AsDouble(PyObject *)
     * }
     */
    public static MethodHandle PyLong_AsDouble$handle() {
        return PyLong_AsDouble.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double PyLong_AsDouble(PyObject *)
     * }
     */
    public static MemorySegment PyLong_AsDouble$address() {
        return PyLong_AsDouble.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double PyLong_AsDouble(PyObject *)
     * }
     */
    public static double PyLong_AsDouble(MemorySegment x0) {
        var mh$ = PyLong_AsDouble.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyLong_AsDouble", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyLong_FromVoidPtr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyLong_FromVoidPtr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyLong_FromVoidPtr(void *)
     * }
     */
    public static FunctionDescriptor PyLong_FromVoidPtr$descriptor() {
        return PyLong_FromVoidPtr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyLong_FromVoidPtr(void *)
     * }
     */
    public static MethodHandle PyLong_FromVoidPtr$handle() {
        return PyLong_FromVoidPtr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyLong_FromVoidPtr(void *)
     * }
     */
    public static MemorySegment PyLong_FromVoidPtr$address() {
        return PyLong_FromVoidPtr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyLong_FromVoidPtr(void *)
     * }
     */
    public static MemorySegment PyLong_FromVoidPtr(MemorySegment x0) {
        var mh$ = PyLong_FromVoidPtr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyLong_FromVoidPtr", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyLong_AsVoidPtr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyLong_AsVoidPtr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *PyLong_AsVoidPtr(PyObject *)
     * }
     */
    public static FunctionDescriptor PyLong_AsVoidPtr$descriptor() {
        return PyLong_AsVoidPtr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *PyLong_AsVoidPtr(PyObject *)
     * }
     */
    public static MethodHandle PyLong_AsVoidPtr$handle() {
        return PyLong_AsVoidPtr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *PyLong_AsVoidPtr(PyObject *)
     * }
     */
    public static MemorySegment PyLong_AsVoidPtr$address() {
        return PyLong_AsVoidPtr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *PyLong_AsVoidPtr(PyObject *)
     * }
     */
    public static MemorySegment PyLong_AsVoidPtr(MemorySegment x0) {
        var mh$ = PyLong_AsVoidPtr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyLong_AsVoidPtr", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyLong_FromLongLong {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyLong_FromLongLong");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyLong_FromLongLong(long long)
     * }
     */
    public static FunctionDescriptor PyLong_FromLongLong$descriptor() {
        return PyLong_FromLongLong.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyLong_FromLongLong(long long)
     * }
     */
    public static MethodHandle PyLong_FromLongLong$handle() {
        return PyLong_FromLongLong.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyLong_FromLongLong(long long)
     * }
     */
    public static MemorySegment PyLong_FromLongLong$address() {
        return PyLong_FromLongLong.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyLong_FromLongLong(long long)
     * }
     */
    public static MemorySegment PyLong_FromLongLong(long x0) {
        var mh$ = PyLong_FromLongLong.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyLong_FromLongLong", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyLong_FromUnsignedLongLong {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyLong_FromUnsignedLongLong");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyLong_FromUnsignedLongLong(unsigned long long)
     * }
     */
    public static FunctionDescriptor PyLong_FromUnsignedLongLong$descriptor() {
        return PyLong_FromUnsignedLongLong.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyLong_FromUnsignedLongLong(unsigned long long)
     * }
     */
    public static MethodHandle PyLong_FromUnsignedLongLong$handle() {
        return PyLong_FromUnsignedLongLong.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyLong_FromUnsignedLongLong(unsigned long long)
     * }
     */
    public static MemorySegment PyLong_FromUnsignedLongLong$address() {
        return PyLong_FromUnsignedLongLong.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyLong_FromUnsignedLongLong(unsigned long long)
     * }
     */
    public static MemorySegment PyLong_FromUnsignedLongLong(long x0) {
        var mh$ = PyLong_FromUnsignedLongLong.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyLong_FromUnsignedLongLong", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyLong_AsLongLong {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyLong_AsLongLong");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long PyLong_AsLongLong(PyObject *)
     * }
     */
    public static FunctionDescriptor PyLong_AsLongLong$descriptor() {
        return PyLong_AsLongLong.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long PyLong_AsLongLong(PyObject *)
     * }
     */
    public static MethodHandle PyLong_AsLongLong$handle() {
        return PyLong_AsLongLong.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long PyLong_AsLongLong(PyObject *)
     * }
     */
    public static MemorySegment PyLong_AsLongLong$address() {
        return PyLong_AsLongLong.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long PyLong_AsLongLong(PyObject *)
     * }
     */
    public static long PyLong_AsLongLong(MemorySegment x0) {
        var mh$ = PyLong_AsLongLong.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyLong_AsLongLong", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyLong_AsUnsignedLongLong {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyLong_AsUnsignedLongLong");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long long PyLong_AsUnsignedLongLong(PyObject *)
     * }
     */
    public static FunctionDescriptor PyLong_AsUnsignedLongLong$descriptor() {
        return PyLong_AsUnsignedLongLong.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long long PyLong_AsUnsignedLongLong(PyObject *)
     * }
     */
    public static MethodHandle PyLong_AsUnsignedLongLong$handle() {
        return PyLong_AsUnsignedLongLong.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long long PyLong_AsUnsignedLongLong(PyObject *)
     * }
     */
    public static MemorySegment PyLong_AsUnsignedLongLong$address() {
        return PyLong_AsUnsignedLongLong.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long long PyLong_AsUnsignedLongLong(PyObject *)
     * }
     */
    public static long PyLong_AsUnsignedLongLong(MemorySegment x0) {
        var mh$ = PyLong_AsUnsignedLongLong.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyLong_AsUnsignedLongLong", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyLong_AsUnsignedLongLongMask {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyLong_AsUnsignedLongLongMask");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long long PyLong_AsUnsignedLongLongMask(PyObject *)
     * }
     */
    public static FunctionDescriptor PyLong_AsUnsignedLongLongMask$descriptor() {
        return PyLong_AsUnsignedLongLongMask.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long long PyLong_AsUnsignedLongLongMask(PyObject *)
     * }
     */
    public static MethodHandle PyLong_AsUnsignedLongLongMask$handle() {
        return PyLong_AsUnsignedLongLongMask.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long long PyLong_AsUnsignedLongLongMask(PyObject *)
     * }
     */
    public static MemorySegment PyLong_AsUnsignedLongLongMask$address() {
        return PyLong_AsUnsignedLongLongMask.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long long PyLong_AsUnsignedLongLongMask(PyObject *)
     * }
     */
    public static long PyLong_AsUnsignedLongLongMask(MemorySegment x0) {
        var mh$ = PyLong_AsUnsignedLongLongMask.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyLong_AsUnsignedLongLongMask", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyLong_AsLongLongAndOverflow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyLong_AsLongLongAndOverflow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long PyLong_AsLongLongAndOverflow(PyObject *, int *)
     * }
     */
    public static FunctionDescriptor PyLong_AsLongLongAndOverflow$descriptor() {
        return PyLong_AsLongLongAndOverflow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long PyLong_AsLongLongAndOverflow(PyObject *, int *)
     * }
     */
    public static MethodHandle PyLong_AsLongLongAndOverflow$handle() {
        return PyLong_AsLongLongAndOverflow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long PyLong_AsLongLongAndOverflow(PyObject *, int *)
     * }
     */
    public static MemorySegment PyLong_AsLongLongAndOverflow$address() {
        return PyLong_AsLongLongAndOverflow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long PyLong_AsLongLongAndOverflow(PyObject *, int *)
     * }
     */
    public static long PyLong_AsLongLongAndOverflow(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyLong_AsLongLongAndOverflow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyLong_AsLongLongAndOverflow", x0, x1);
            }
            return (long)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyLong_FromString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyLong_FromString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyLong_FromString(const char *, char **, int)
     * }
     */
    public static FunctionDescriptor PyLong_FromString$descriptor() {
        return PyLong_FromString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyLong_FromString(const char *, char **, int)
     * }
     */
    public static MethodHandle PyLong_FromString$handle() {
        return PyLong_FromString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyLong_FromString(const char *, char **, int)
     * }
     */
    public static MemorySegment PyLong_FromString$address() {
        return PyLong_FromString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyLong_FromString(const char *, char **, int)
     * }
     */
    public static MemorySegment PyLong_FromString(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = PyLong_FromString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyLong_FromString", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyOS_strtoul {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyOS_strtoul");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long PyOS_strtoul(const char *, char **, int)
     * }
     */
    public static FunctionDescriptor PyOS_strtoul$descriptor() {
        return PyOS_strtoul.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long PyOS_strtoul(const char *, char **, int)
     * }
     */
    public static MethodHandle PyOS_strtoul$handle() {
        return PyOS_strtoul.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long PyOS_strtoul(const char *, char **, int)
     * }
     */
    public static MemorySegment PyOS_strtoul$address() {
        return PyOS_strtoul.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long PyOS_strtoul(const char *, char **, int)
     * }
     */
    public static int PyOS_strtoul(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = PyOS_strtoul.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyOS_strtoul", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyOS_strtol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyOS_strtol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long PyOS_strtol(const char *, char **, int)
     * }
     */
    public static FunctionDescriptor PyOS_strtol$descriptor() {
        return PyOS_strtol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long PyOS_strtol(const char *, char **, int)
     * }
     */
    public static MethodHandle PyOS_strtol$handle() {
        return PyOS_strtol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long PyOS_strtol(const char *, char **, int)
     * }
     */
    public static MemorySegment PyOS_strtol$address() {
        return PyOS_strtol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long PyOS_strtol(const char *, char **, int)
     * }
     */
    public static int PyOS_strtol(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = PyOS_strtol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyOS_strtol", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _Py_FalseStruct$constants {
        public static final GroupLayout LAYOUT = _object.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("_Py_FalseStruct").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyLongObject _Py_FalseStruct
     * }
     */
    public static GroupLayout _Py_FalseStruct$layout() {
        return _Py_FalseStruct$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyLongObject _Py_FalseStruct
     * }
     */
    public static MemorySegment _Py_FalseStruct() {
        return _Py_FalseStruct$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyLongObject _Py_FalseStruct
     * }
     */
    public static void _Py_FalseStruct(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, _Py_FalseStruct$constants.SEGMENT, 0L, _Py_FalseStruct$constants.LAYOUT.byteSize());
    }

    private static class _Py_TrueStruct$constants {
        public static final GroupLayout LAYOUT = _object.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("_Py_TrueStruct").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyLongObject _Py_TrueStruct
     * }
     */
    public static GroupLayout _Py_TrueStruct$layout() {
        return _Py_TrueStruct$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyLongObject _Py_TrueStruct
     * }
     */
    public static MemorySegment _Py_TrueStruct() {
        return _Py_TrueStruct$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyLongObject _Py_TrueStruct
     * }
     */
    public static void _Py_TrueStruct(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, _Py_TrueStruct$constants.SEGMENT, 0L, _Py_TrueStruct$constants.LAYOUT.byteSize());
    }

    private static class Py_IsTrue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_IsTrue");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int Py_IsTrue(PyObject *x)
     * }
     */
    public static FunctionDescriptor Py_IsTrue$descriptor() {
        return Py_IsTrue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int Py_IsTrue(PyObject *x)
     * }
     */
    public static MethodHandle Py_IsTrue$handle() {
        return Py_IsTrue.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int Py_IsTrue(PyObject *x)
     * }
     */
    public static MemorySegment Py_IsTrue$address() {
        return Py_IsTrue.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int Py_IsTrue(PyObject *x)
     * }
     */
    public static int Py_IsTrue(MemorySegment x) {
        var mh$ = Py_IsTrue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_IsTrue", x);
            }
            return (int)mh$.invokeExact(x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_IsFalse {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_IsFalse");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int Py_IsFalse(PyObject *x)
     * }
     */
    public static FunctionDescriptor Py_IsFalse$descriptor() {
        return Py_IsFalse.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int Py_IsFalse(PyObject *x)
     * }
     */
    public static MethodHandle Py_IsFalse$handle() {
        return Py_IsFalse.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int Py_IsFalse(PyObject *x)
     * }
     */
    public static MemorySegment Py_IsFalse$address() {
        return Py_IsFalse.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int Py_IsFalse(PyObject *x)
     * }
     */
    public static int Py_IsFalse(MemorySegment x) {
        var mh$ = Py_IsFalse.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_IsFalse", x);
            }
            return (int)mh$.invokeExact(x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyBool_FromLong {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyBool_FromLong");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyBool_FromLong(long)
     * }
     */
    public static FunctionDescriptor PyBool_FromLong$descriptor() {
        return PyBool_FromLong.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyBool_FromLong(long)
     * }
     */
    public static MethodHandle PyBool_FromLong$handle() {
        return PyBool_FromLong.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyBool_FromLong(long)
     * }
     */
    public static MemorySegment PyBool_FromLong$address() {
        return PyBool_FromLong.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyBool_FromLong(long)
     * }
     */
    public static MemorySegment PyBool_FromLong(int x0) {
        var mh$ = PyBool_FromLong.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyBool_FromLong", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyFloat_Type$constants {
        public static final GroupLayout LAYOUT = _object.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyFloat_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyFloat_Type
     * }
     */
    public static GroupLayout PyFloat_Type$layout() {
        return PyFloat_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyFloat_Type
     * }
     */
    public static MemorySegment PyFloat_Type() {
        return PyFloat_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyFloat_Type
     * }
     */
    public static void PyFloat_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyFloat_Type$constants.SEGMENT, 0L, PyFloat_Type$constants.LAYOUT.byteSize());
    }

    private static class PyFloat_GetMax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyFloat_GetMax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double PyFloat_GetMax()
     * }
     */
    public static FunctionDescriptor PyFloat_GetMax$descriptor() {
        return PyFloat_GetMax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double PyFloat_GetMax()
     * }
     */
    public static MethodHandle PyFloat_GetMax$handle() {
        return PyFloat_GetMax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double PyFloat_GetMax()
     * }
     */
    public static MemorySegment PyFloat_GetMax$address() {
        return PyFloat_GetMax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double PyFloat_GetMax()
     * }
     */
    public static double PyFloat_GetMax() {
        var mh$ = PyFloat_GetMax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyFloat_GetMax");
            }
            return (double)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyFloat_GetMin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyFloat_GetMin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double PyFloat_GetMin()
     * }
     */
    public static FunctionDescriptor PyFloat_GetMin$descriptor() {
        return PyFloat_GetMin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double PyFloat_GetMin()
     * }
     */
    public static MethodHandle PyFloat_GetMin$handle() {
        return PyFloat_GetMin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double PyFloat_GetMin()
     * }
     */
    public static MemorySegment PyFloat_GetMin$address() {
        return PyFloat_GetMin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double PyFloat_GetMin()
     * }
     */
    public static double PyFloat_GetMin() {
        var mh$ = PyFloat_GetMin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyFloat_GetMin");
            }
            return (double)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyFloat_GetInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyFloat_GetInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyFloat_GetInfo()
     * }
     */
    public static FunctionDescriptor PyFloat_GetInfo$descriptor() {
        return PyFloat_GetInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyFloat_GetInfo()
     * }
     */
    public static MethodHandle PyFloat_GetInfo$handle() {
        return PyFloat_GetInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyFloat_GetInfo()
     * }
     */
    public static MemorySegment PyFloat_GetInfo$address() {
        return PyFloat_GetInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyFloat_GetInfo()
     * }
     */
    public static MemorySegment PyFloat_GetInfo() {
        var mh$ = PyFloat_GetInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyFloat_GetInfo");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyFloat_FromString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyFloat_FromString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyFloat_FromString(PyObject *)
     * }
     */
    public static FunctionDescriptor PyFloat_FromString$descriptor() {
        return PyFloat_FromString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyFloat_FromString(PyObject *)
     * }
     */
    public static MethodHandle PyFloat_FromString$handle() {
        return PyFloat_FromString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyFloat_FromString(PyObject *)
     * }
     */
    public static MemorySegment PyFloat_FromString$address() {
        return PyFloat_FromString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyFloat_FromString(PyObject *)
     * }
     */
    public static MemorySegment PyFloat_FromString(MemorySegment x0) {
        var mh$ = PyFloat_FromString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyFloat_FromString", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyFloat_FromDouble {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyFloat_FromDouble");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyFloat_FromDouble(double)
     * }
     */
    public static FunctionDescriptor PyFloat_FromDouble$descriptor() {
        return PyFloat_FromDouble.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyFloat_FromDouble(double)
     * }
     */
    public static MethodHandle PyFloat_FromDouble$handle() {
        return PyFloat_FromDouble.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyFloat_FromDouble(double)
     * }
     */
    public static MemorySegment PyFloat_FromDouble$address() {
        return PyFloat_FromDouble.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyFloat_FromDouble(double)
     * }
     */
    public static MemorySegment PyFloat_FromDouble(double x0) {
        var mh$ = PyFloat_FromDouble.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyFloat_FromDouble", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyFloat_AsDouble {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyFloat_AsDouble");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double PyFloat_AsDouble(PyObject *)
     * }
     */
    public static FunctionDescriptor PyFloat_AsDouble$descriptor() {
        return PyFloat_AsDouble.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double PyFloat_AsDouble(PyObject *)
     * }
     */
    public static MethodHandle PyFloat_AsDouble$handle() {
        return PyFloat_AsDouble.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double PyFloat_AsDouble(PyObject *)
     * }
     */
    public static MemorySegment PyFloat_AsDouble$address() {
        return PyFloat_AsDouble.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double PyFloat_AsDouble(PyObject *)
     * }
     */
    public static double PyFloat_AsDouble(MemorySegment x0) {
        var mh$ = PyFloat_AsDouble.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyFloat_AsDouble", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyComplex_Type$constants {
        public static final GroupLayout LAYOUT = _object.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyComplex_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyComplex_Type
     * }
     */
    public static GroupLayout PyComplex_Type$layout() {
        return PyComplex_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyComplex_Type
     * }
     */
    public static MemorySegment PyComplex_Type() {
        return PyComplex_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyComplex_Type
     * }
     */
    public static void PyComplex_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyComplex_Type$constants.SEGMENT, 0L, PyComplex_Type$constants.LAYOUT.byteSize());
    }

    private static class PyComplex_FromDoubles {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyComplex_FromDoubles");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyComplex_FromDoubles(double real, double imag)
     * }
     */
    public static FunctionDescriptor PyComplex_FromDoubles$descriptor() {
        return PyComplex_FromDoubles.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyComplex_FromDoubles(double real, double imag)
     * }
     */
    public static MethodHandle PyComplex_FromDoubles$handle() {
        return PyComplex_FromDoubles.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyComplex_FromDoubles(double real, double imag)
     * }
     */
    public static MemorySegment PyComplex_FromDoubles$address() {
        return PyComplex_FromDoubles.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyComplex_FromDoubles(double real, double imag)
     * }
     */
    public static MemorySegment PyComplex_FromDoubles(double real, double imag) {
        var mh$ = PyComplex_FromDoubles.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyComplex_FromDoubles", real, imag);
            }
            return (MemorySegment)mh$.invokeExact(real, imag);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyComplex_RealAsDouble {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyComplex_RealAsDouble");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double PyComplex_RealAsDouble(PyObject *op)
     * }
     */
    public static FunctionDescriptor PyComplex_RealAsDouble$descriptor() {
        return PyComplex_RealAsDouble.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double PyComplex_RealAsDouble(PyObject *op)
     * }
     */
    public static MethodHandle PyComplex_RealAsDouble$handle() {
        return PyComplex_RealAsDouble.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double PyComplex_RealAsDouble(PyObject *op)
     * }
     */
    public static MemorySegment PyComplex_RealAsDouble$address() {
        return PyComplex_RealAsDouble.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double PyComplex_RealAsDouble(PyObject *op)
     * }
     */
    public static double PyComplex_RealAsDouble(MemorySegment op) {
        var mh$ = PyComplex_RealAsDouble.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyComplex_RealAsDouble", op);
            }
            return (double)mh$.invokeExact(op);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyComplex_ImagAsDouble {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyComplex_ImagAsDouble");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double PyComplex_ImagAsDouble(PyObject *op)
     * }
     */
    public static FunctionDescriptor PyComplex_ImagAsDouble$descriptor() {
        return PyComplex_ImagAsDouble.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double PyComplex_ImagAsDouble(PyObject *op)
     * }
     */
    public static MethodHandle PyComplex_ImagAsDouble$handle() {
        return PyComplex_ImagAsDouble.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double PyComplex_ImagAsDouble(PyObject *op)
     * }
     */
    public static MemorySegment PyComplex_ImagAsDouble$address() {
        return PyComplex_ImagAsDouble.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double PyComplex_ImagAsDouble(PyObject *op)
     * }
     */
    public static double PyComplex_ImagAsDouble(MemorySegment op) {
        var mh$ = PyComplex_ImagAsDouble.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyComplex_ImagAsDouble", op);
            }
            return (double)mh$.invokeExact(op);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyRange_Type$constants {
        public static final GroupLayout LAYOUT = _object.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyRange_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyRange_Type
     * }
     */
    public static GroupLayout PyRange_Type$layout() {
        return PyRange_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyRange_Type
     * }
     */
    public static MemorySegment PyRange_Type() {
        return PyRange_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyRange_Type
     * }
     */
    public static void PyRange_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyRange_Type$constants.SEGMENT, 0L, PyRange_Type$constants.LAYOUT.byteSize());
    }

    private static class PyRangeIter_Type$constants {
        public static final GroupLayout LAYOUT = _object.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyRangeIter_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyRangeIter_Type
     * }
     */
    public static GroupLayout PyRangeIter_Type$layout() {
        return PyRangeIter_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyRangeIter_Type
     * }
     */
    public static MemorySegment PyRangeIter_Type() {
        return PyRangeIter_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyRangeIter_Type
     * }
     */
    public static void PyRangeIter_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyRangeIter_Type$constants.SEGMENT, 0L, PyRangeIter_Type$constants.LAYOUT.byteSize());
    }

    private static class PyLongRangeIter_Type$constants {
        public static final GroupLayout LAYOUT = _object.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyLongRangeIter_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyLongRangeIter_Type
     * }
     */
    public static GroupLayout PyLongRangeIter_Type$layout() {
        return PyLongRangeIter_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyLongRangeIter_Type
     * }
     */
    public static MemorySegment PyLongRangeIter_Type() {
        return PyLongRangeIter_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyLongRangeIter_Type
     * }
     */
    public static void PyLongRangeIter_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyLongRangeIter_Type$constants.SEGMENT, 0L, PyLongRangeIter_Type$constants.LAYOUT.byteSize());
    }

    private static class PyMemoryView_Type$constants {
        public static final GroupLayout LAYOUT = _object.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyMemoryView_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyMemoryView_Type
     * }
     */
    public static GroupLayout PyMemoryView_Type$layout() {
        return PyMemoryView_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyMemoryView_Type
     * }
     */
    public static MemorySegment PyMemoryView_Type() {
        return PyMemoryView_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyMemoryView_Type
     * }
     */
    public static void PyMemoryView_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyMemoryView_Type$constants.SEGMENT, 0L, PyMemoryView_Type$constants.LAYOUT.byteSize());
    }

    private static class PyMemoryView_FromObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyMemoryView_FromObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyMemoryView_FromObject(PyObject *base)
     * }
     */
    public static FunctionDescriptor PyMemoryView_FromObject$descriptor() {
        return PyMemoryView_FromObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyMemoryView_FromObject(PyObject *base)
     * }
     */
    public static MethodHandle PyMemoryView_FromObject$handle() {
        return PyMemoryView_FromObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyMemoryView_FromObject(PyObject *base)
     * }
     */
    public static MemorySegment PyMemoryView_FromObject$address() {
        return PyMemoryView_FromObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyMemoryView_FromObject(PyObject *base)
     * }
     */
    public static MemorySegment PyMemoryView_FromObject(MemorySegment base) {
        var mh$ = PyMemoryView_FromObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyMemoryView_FromObject", base);
            }
            return (MemorySegment)mh$.invokeExact(base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyMemoryView_FromMemory {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyMemoryView_FromMemory");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyMemoryView_FromMemory(char *mem, Py_ssize_t size, int flags)
     * }
     */
    public static FunctionDescriptor PyMemoryView_FromMemory$descriptor() {
        return PyMemoryView_FromMemory.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyMemoryView_FromMemory(char *mem, Py_ssize_t size, int flags)
     * }
     */
    public static MethodHandle PyMemoryView_FromMemory$handle() {
        return PyMemoryView_FromMemory.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyMemoryView_FromMemory(char *mem, Py_ssize_t size, int flags)
     * }
     */
    public static MemorySegment PyMemoryView_FromMemory$address() {
        return PyMemoryView_FromMemory.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyMemoryView_FromMemory(char *mem, Py_ssize_t size, int flags)
     * }
     */
    public static MemorySegment PyMemoryView_FromMemory(MemorySegment mem, long size, int flags) {
        var mh$ = PyMemoryView_FromMemory.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyMemoryView_FromMemory", mem, size, flags);
            }
            return (MemorySegment)mh$.invokeExact(mem, size, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyMemoryView_FromBuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyMemoryView_FromBuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyMemoryView_FromBuffer(const Py_buffer *info)
     * }
     */
    public static FunctionDescriptor PyMemoryView_FromBuffer$descriptor() {
        return PyMemoryView_FromBuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyMemoryView_FromBuffer(const Py_buffer *info)
     * }
     */
    public static MethodHandle PyMemoryView_FromBuffer$handle() {
        return PyMemoryView_FromBuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyMemoryView_FromBuffer(const Py_buffer *info)
     * }
     */
    public static MemorySegment PyMemoryView_FromBuffer$address() {
        return PyMemoryView_FromBuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyMemoryView_FromBuffer(const Py_buffer *info)
     * }
     */
    public static MemorySegment PyMemoryView_FromBuffer(MemorySegment info) {
        var mh$ = PyMemoryView_FromBuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyMemoryView_FromBuffer", info);
            }
            return (MemorySegment)mh$.invokeExact(info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyMemoryView_GetContiguous {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_CHAR
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyMemoryView_GetContiguous");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyMemoryView_GetContiguous(PyObject *base, int buffertype, char order)
     * }
     */
    public static FunctionDescriptor PyMemoryView_GetContiguous$descriptor() {
        return PyMemoryView_GetContiguous.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyMemoryView_GetContiguous(PyObject *base, int buffertype, char order)
     * }
     */
    public static MethodHandle PyMemoryView_GetContiguous$handle() {
        return PyMemoryView_GetContiguous.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyMemoryView_GetContiguous(PyObject *base, int buffertype, char order)
     * }
     */
    public static MemorySegment PyMemoryView_GetContiguous$address() {
        return PyMemoryView_GetContiguous.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyMemoryView_GetContiguous(PyObject *base, int buffertype, char order)
     * }
     */
    public static MemorySegment PyMemoryView_GetContiguous(MemorySegment base, int buffertype, byte order) {
        var mh$ = PyMemoryView_GetContiguous.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyMemoryView_GetContiguous", base, buffertype, order);
            }
            return (MemorySegment)mh$.invokeExact(base, buffertype, order);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyTuple_Type$constants {
        public static final GroupLayout LAYOUT = _object.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyTuple_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyTuple_Type
     * }
     */
    public static GroupLayout PyTuple_Type$layout() {
        return PyTuple_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyTuple_Type
     * }
     */
    public static MemorySegment PyTuple_Type() {
        return PyTuple_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyTuple_Type
     * }
     */
    public static void PyTuple_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyTuple_Type$constants.SEGMENT, 0L, PyTuple_Type$constants.LAYOUT.byteSize());
    }

    private static class PyTupleIter_Type$constants {
        public static final GroupLayout LAYOUT = _object.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyTupleIter_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyTupleIter_Type
     * }
     */
    public static GroupLayout PyTupleIter_Type$layout() {
        return PyTupleIter_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyTupleIter_Type
     * }
     */
    public static MemorySegment PyTupleIter_Type() {
        return PyTupleIter_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyTupleIter_Type
     * }
     */
    public static void PyTupleIter_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyTupleIter_Type$constants.SEGMENT, 0L, PyTupleIter_Type$constants.LAYOUT.byteSize());
    }

    private static class PyTuple_New {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyTuple_New");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyTuple_New(Py_ssize_t size)
     * }
     */
    public static FunctionDescriptor PyTuple_New$descriptor() {
        return PyTuple_New.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyTuple_New(Py_ssize_t size)
     * }
     */
    public static MethodHandle PyTuple_New$handle() {
        return PyTuple_New.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyTuple_New(Py_ssize_t size)
     * }
     */
    public static MemorySegment PyTuple_New$address() {
        return PyTuple_New.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyTuple_New(Py_ssize_t size)
     * }
     */
    public static MemorySegment PyTuple_New(long size) {
        var mh$ = PyTuple_New.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyTuple_New", size);
            }
            return (MemorySegment)mh$.invokeExact(size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyTuple_Size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyTuple_Size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_ssize_t PyTuple_Size(PyObject *)
     * }
     */
    public static FunctionDescriptor PyTuple_Size$descriptor() {
        return PyTuple_Size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_ssize_t PyTuple_Size(PyObject *)
     * }
     */
    public static MethodHandle PyTuple_Size$handle() {
        return PyTuple_Size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_ssize_t PyTuple_Size(PyObject *)
     * }
     */
    public static MemorySegment PyTuple_Size$address() {
        return PyTuple_Size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_ssize_t PyTuple_Size(PyObject *)
     * }
     */
    public static long PyTuple_Size(MemorySegment x0) {
        var mh$ = PyTuple_Size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyTuple_Size", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyTuple_GetItem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyTuple_GetItem");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyTuple_GetItem(PyObject *, Py_ssize_t)
     * }
     */
    public static FunctionDescriptor PyTuple_GetItem$descriptor() {
        return PyTuple_GetItem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyTuple_GetItem(PyObject *, Py_ssize_t)
     * }
     */
    public static MethodHandle PyTuple_GetItem$handle() {
        return PyTuple_GetItem.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyTuple_GetItem(PyObject *, Py_ssize_t)
     * }
     */
    public static MemorySegment PyTuple_GetItem$address() {
        return PyTuple_GetItem.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyTuple_GetItem(PyObject *, Py_ssize_t)
     * }
     */
    public static MemorySegment PyTuple_GetItem(MemorySegment x0, long x1) {
        var mh$ = PyTuple_GetItem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyTuple_GetItem", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyTuple_SetItem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyTuple_SetItem");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyTuple_SetItem(PyObject *, Py_ssize_t, PyObject *)
     * }
     */
    public static FunctionDescriptor PyTuple_SetItem$descriptor() {
        return PyTuple_SetItem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyTuple_SetItem(PyObject *, Py_ssize_t, PyObject *)
     * }
     */
    public static MethodHandle PyTuple_SetItem$handle() {
        return PyTuple_SetItem.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyTuple_SetItem(PyObject *, Py_ssize_t, PyObject *)
     * }
     */
    public static MemorySegment PyTuple_SetItem$address() {
        return PyTuple_SetItem.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyTuple_SetItem(PyObject *, Py_ssize_t, PyObject *)
     * }
     */
    public static int PyTuple_SetItem(MemorySegment x0, long x1, MemorySegment x2) {
        var mh$ = PyTuple_SetItem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyTuple_SetItem", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyTuple_GetSlice {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyTuple_GetSlice");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyTuple_GetSlice(PyObject *, Py_ssize_t, Py_ssize_t)
     * }
     */
    public static FunctionDescriptor PyTuple_GetSlice$descriptor() {
        return PyTuple_GetSlice.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyTuple_GetSlice(PyObject *, Py_ssize_t, Py_ssize_t)
     * }
     */
    public static MethodHandle PyTuple_GetSlice$handle() {
        return PyTuple_GetSlice.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyTuple_GetSlice(PyObject *, Py_ssize_t, Py_ssize_t)
     * }
     */
    public static MemorySegment PyTuple_GetSlice$address() {
        return PyTuple_GetSlice.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyTuple_GetSlice(PyObject *, Py_ssize_t, Py_ssize_t)
     * }
     */
    public static MemorySegment PyTuple_GetSlice(MemorySegment x0, long x1, long x2) {
        var mh$ = PyTuple_GetSlice.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyTuple_GetSlice", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * PyObject *PyTuple_Pack(Py_ssize_t, ...)
     * }
     */
    public static class PyTuple_Pack {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_POINTER,
                Python_h.C_LONG_LONG
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("PyTuple_Pack");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private PyTuple_Pack(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * PyObject *PyTuple_Pack(Py_ssize_t, ...)
         * }
         */
        public static PyTuple_Pack makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new PyTuple_Pack(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public MemorySegment apply(long x0, Object... x1) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("PyTuple_Pack", x0, x1);
                }
                return (MemorySegment)spreader.invokeExact(x0, x1);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class PyList_Type$constants {
        public static final GroupLayout LAYOUT = _object.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyList_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyList_Type
     * }
     */
    public static GroupLayout PyList_Type$layout() {
        return PyList_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyList_Type
     * }
     */
    public static MemorySegment PyList_Type() {
        return PyList_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyList_Type
     * }
     */
    public static void PyList_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyList_Type$constants.SEGMENT, 0L, PyList_Type$constants.LAYOUT.byteSize());
    }

    private static class PyListIter_Type$constants {
        public static final GroupLayout LAYOUT = _object.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyListIter_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyListIter_Type
     * }
     */
    public static GroupLayout PyListIter_Type$layout() {
        return PyListIter_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyListIter_Type
     * }
     */
    public static MemorySegment PyListIter_Type() {
        return PyListIter_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyListIter_Type
     * }
     */
    public static void PyListIter_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyListIter_Type$constants.SEGMENT, 0L, PyListIter_Type$constants.LAYOUT.byteSize());
    }

    private static class PyListRevIter_Type$constants {
        public static final GroupLayout LAYOUT = _object.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyListRevIter_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyListRevIter_Type
     * }
     */
    public static GroupLayout PyListRevIter_Type$layout() {
        return PyListRevIter_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyListRevIter_Type
     * }
     */
    public static MemorySegment PyListRevIter_Type() {
        return PyListRevIter_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyListRevIter_Type
     * }
     */
    public static void PyListRevIter_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyListRevIter_Type$constants.SEGMENT, 0L, PyListRevIter_Type$constants.LAYOUT.byteSize());
    }

    private static class PyList_New {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyList_New");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyList_New(Py_ssize_t size)
     * }
     */
    public static FunctionDescriptor PyList_New$descriptor() {
        return PyList_New.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyList_New(Py_ssize_t size)
     * }
     */
    public static MethodHandle PyList_New$handle() {
        return PyList_New.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyList_New(Py_ssize_t size)
     * }
     */
    public static MemorySegment PyList_New$address() {
        return PyList_New.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyList_New(Py_ssize_t size)
     * }
     */
    public static MemorySegment PyList_New(long size) {
        var mh$ = PyList_New.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyList_New", size);
            }
            return (MemorySegment)mh$.invokeExact(size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyList_Size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyList_Size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_ssize_t PyList_Size(PyObject *)
     * }
     */
    public static FunctionDescriptor PyList_Size$descriptor() {
        return PyList_Size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_ssize_t PyList_Size(PyObject *)
     * }
     */
    public static MethodHandle PyList_Size$handle() {
        return PyList_Size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_ssize_t PyList_Size(PyObject *)
     * }
     */
    public static MemorySegment PyList_Size$address() {
        return PyList_Size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_ssize_t PyList_Size(PyObject *)
     * }
     */
    public static long PyList_Size(MemorySegment x0) {
        var mh$ = PyList_Size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyList_Size", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyList_GetItem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyList_GetItem");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyList_GetItem(PyObject *, Py_ssize_t)
     * }
     */
    public static FunctionDescriptor PyList_GetItem$descriptor() {
        return PyList_GetItem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyList_GetItem(PyObject *, Py_ssize_t)
     * }
     */
    public static MethodHandle PyList_GetItem$handle() {
        return PyList_GetItem.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyList_GetItem(PyObject *, Py_ssize_t)
     * }
     */
    public static MemorySegment PyList_GetItem$address() {
        return PyList_GetItem.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyList_GetItem(PyObject *, Py_ssize_t)
     * }
     */
    public static MemorySegment PyList_GetItem(MemorySegment x0, long x1) {
        var mh$ = PyList_GetItem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyList_GetItem", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyList_SetItem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyList_SetItem");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyList_SetItem(PyObject *, Py_ssize_t, PyObject *)
     * }
     */
    public static FunctionDescriptor PyList_SetItem$descriptor() {
        return PyList_SetItem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyList_SetItem(PyObject *, Py_ssize_t, PyObject *)
     * }
     */
    public static MethodHandle PyList_SetItem$handle() {
        return PyList_SetItem.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyList_SetItem(PyObject *, Py_ssize_t, PyObject *)
     * }
     */
    public static MemorySegment PyList_SetItem$address() {
        return PyList_SetItem.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyList_SetItem(PyObject *, Py_ssize_t, PyObject *)
     * }
     */
    public static int PyList_SetItem(MemorySegment x0, long x1, MemorySegment x2) {
        var mh$ = PyList_SetItem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyList_SetItem", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyList_Insert {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyList_Insert");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyList_Insert(PyObject *, Py_ssize_t, PyObject *)
     * }
     */
    public static FunctionDescriptor PyList_Insert$descriptor() {
        return PyList_Insert.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyList_Insert(PyObject *, Py_ssize_t, PyObject *)
     * }
     */
    public static MethodHandle PyList_Insert$handle() {
        return PyList_Insert.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyList_Insert(PyObject *, Py_ssize_t, PyObject *)
     * }
     */
    public static MemorySegment PyList_Insert$address() {
        return PyList_Insert.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyList_Insert(PyObject *, Py_ssize_t, PyObject *)
     * }
     */
    public static int PyList_Insert(MemorySegment x0, long x1, MemorySegment x2) {
        var mh$ = PyList_Insert.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyList_Insert", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyList_Append {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyList_Append");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyList_Append(PyObject *, PyObject *)
     * }
     */
    public static FunctionDescriptor PyList_Append$descriptor() {
        return PyList_Append.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyList_Append(PyObject *, PyObject *)
     * }
     */
    public static MethodHandle PyList_Append$handle() {
        return PyList_Append.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyList_Append(PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyList_Append$address() {
        return PyList_Append.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyList_Append(PyObject *, PyObject *)
     * }
     */
    public static int PyList_Append(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyList_Append.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyList_Append", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyList_GetSlice {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyList_GetSlice");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyList_GetSlice(PyObject *, Py_ssize_t, Py_ssize_t)
     * }
     */
    public static FunctionDescriptor PyList_GetSlice$descriptor() {
        return PyList_GetSlice.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyList_GetSlice(PyObject *, Py_ssize_t, Py_ssize_t)
     * }
     */
    public static MethodHandle PyList_GetSlice$handle() {
        return PyList_GetSlice.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyList_GetSlice(PyObject *, Py_ssize_t, Py_ssize_t)
     * }
     */
    public static MemorySegment PyList_GetSlice$address() {
        return PyList_GetSlice.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyList_GetSlice(PyObject *, Py_ssize_t, Py_ssize_t)
     * }
     */
    public static MemorySegment PyList_GetSlice(MemorySegment x0, long x1, long x2) {
        var mh$ = PyList_GetSlice.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyList_GetSlice", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyList_SetSlice {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyList_SetSlice");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyList_SetSlice(PyObject *, Py_ssize_t, Py_ssize_t, PyObject *)
     * }
     */
    public static FunctionDescriptor PyList_SetSlice$descriptor() {
        return PyList_SetSlice.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyList_SetSlice(PyObject *, Py_ssize_t, Py_ssize_t, PyObject *)
     * }
     */
    public static MethodHandle PyList_SetSlice$handle() {
        return PyList_SetSlice.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyList_SetSlice(PyObject *, Py_ssize_t, Py_ssize_t, PyObject *)
     * }
     */
    public static MemorySegment PyList_SetSlice$address() {
        return PyList_SetSlice.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyList_SetSlice(PyObject *, Py_ssize_t, Py_ssize_t, PyObject *)
     * }
     */
    public static int PyList_SetSlice(MemorySegment x0, long x1, long x2, MemorySegment x3) {
        var mh$ = PyList_SetSlice.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyList_SetSlice", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyList_Sort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyList_Sort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyList_Sort(PyObject *)
     * }
     */
    public static FunctionDescriptor PyList_Sort$descriptor() {
        return PyList_Sort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyList_Sort(PyObject *)
     * }
     */
    public static MethodHandle PyList_Sort$handle() {
        return PyList_Sort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyList_Sort(PyObject *)
     * }
     */
    public static MemorySegment PyList_Sort$address() {
        return PyList_Sort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyList_Sort(PyObject *)
     * }
     */
    public static int PyList_Sort(MemorySegment x0) {
        var mh$ = PyList_Sort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyList_Sort", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyList_Reverse {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyList_Reverse");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyList_Reverse(PyObject *)
     * }
     */
    public static FunctionDescriptor PyList_Reverse$descriptor() {
        return PyList_Reverse.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyList_Reverse(PyObject *)
     * }
     */
    public static MethodHandle PyList_Reverse$handle() {
        return PyList_Reverse.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyList_Reverse(PyObject *)
     * }
     */
    public static MemorySegment PyList_Reverse$address() {
        return PyList_Reverse.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyList_Reverse(PyObject *)
     * }
     */
    public static int PyList_Reverse(MemorySegment x0) {
        var mh$ = PyList_Reverse.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyList_Reverse", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyList_AsTuple {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyList_AsTuple");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyList_AsTuple(PyObject *)
     * }
     */
    public static FunctionDescriptor PyList_AsTuple$descriptor() {
        return PyList_AsTuple.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyList_AsTuple(PyObject *)
     * }
     */
    public static MethodHandle PyList_AsTuple$handle() {
        return PyList_AsTuple.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyList_AsTuple(PyObject *)
     * }
     */
    public static MemorySegment PyList_AsTuple$address() {
        return PyList_AsTuple.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyList_AsTuple(PyObject *)
     * }
     */
    public static MemorySegment PyList_AsTuple(MemorySegment x0) {
        var mh$ = PyList_AsTuple.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyList_AsTuple", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyDict_Type$constants {
        public static final GroupLayout LAYOUT = _object.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyDict_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyDict_Type
     * }
     */
    public static GroupLayout PyDict_Type$layout() {
        return PyDict_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyDict_Type
     * }
     */
    public static MemorySegment PyDict_Type() {
        return PyDict_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyDict_Type
     * }
     */
    public static void PyDict_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyDict_Type$constants.SEGMENT, 0L, PyDict_Type$constants.LAYOUT.byteSize());
    }

    private static class PyDict_New {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyDict_New");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyDict_New()
     * }
     */
    public static FunctionDescriptor PyDict_New$descriptor() {
        return PyDict_New.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyDict_New()
     * }
     */
    public static MethodHandle PyDict_New$handle() {
        return PyDict_New.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyDict_New()
     * }
     */
    public static MemorySegment PyDict_New$address() {
        return PyDict_New.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyDict_New()
     * }
     */
    public static MemorySegment PyDict_New() {
        var mh$ = PyDict_New.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyDict_New");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyDict_GetItem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyDict_GetItem");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyDict_GetItem(PyObject *mp, PyObject *key)
     * }
     */
    public static FunctionDescriptor PyDict_GetItem$descriptor() {
        return PyDict_GetItem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyDict_GetItem(PyObject *mp, PyObject *key)
     * }
     */
    public static MethodHandle PyDict_GetItem$handle() {
        return PyDict_GetItem.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyDict_GetItem(PyObject *mp, PyObject *key)
     * }
     */
    public static MemorySegment PyDict_GetItem$address() {
        return PyDict_GetItem.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyDict_GetItem(PyObject *mp, PyObject *key)
     * }
     */
    public static MemorySegment PyDict_GetItem(MemorySegment mp, MemorySegment key) {
        var mh$ = PyDict_GetItem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyDict_GetItem", mp, key);
            }
            return (MemorySegment)mh$.invokeExact(mp, key);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyDict_GetItemWithError {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyDict_GetItemWithError");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyDict_GetItemWithError(PyObject *mp, PyObject *key)
     * }
     */
    public static FunctionDescriptor PyDict_GetItemWithError$descriptor() {
        return PyDict_GetItemWithError.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyDict_GetItemWithError(PyObject *mp, PyObject *key)
     * }
     */
    public static MethodHandle PyDict_GetItemWithError$handle() {
        return PyDict_GetItemWithError.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyDict_GetItemWithError(PyObject *mp, PyObject *key)
     * }
     */
    public static MemorySegment PyDict_GetItemWithError$address() {
        return PyDict_GetItemWithError.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyDict_GetItemWithError(PyObject *mp, PyObject *key)
     * }
     */
    public static MemorySegment PyDict_GetItemWithError(MemorySegment mp, MemorySegment key) {
        var mh$ = PyDict_GetItemWithError.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyDict_GetItemWithError", mp, key);
            }
            return (MemorySegment)mh$.invokeExact(mp, key);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyDict_SetItem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyDict_SetItem");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyDict_SetItem(PyObject *mp, PyObject *key, PyObject *item)
     * }
     */
    public static FunctionDescriptor PyDict_SetItem$descriptor() {
        return PyDict_SetItem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyDict_SetItem(PyObject *mp, PyObject *key, PyObject *item)
     * }
     */
    public static MethodHandle PyDict_SetItem$handle() {
        return PyDict_SetItem.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyDict_SetItem(PyObject *mp, PyObject *key, PyObject *item)
     * }
     */
    public static MemorySegment PyDict_SetItem$address() {
        return PyDict_SetItem.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyDict_SetItem(PyObject *mp, PyObject *key, PyObject *item)
     * }
     */
    public static int PyDict_SetItem(MemorySegment mp, MemorySegment key, MemorySegment item) {
        var mh$ = PyDict_SetItem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyDict_SetItem", mp, key, item);
            }
            return (int)mh$.invokeExact(mp, key, item);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyDict_DelItem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyDict_DelItem");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyDict_DelItem(PyObject *mp, PyObject *key)
     * }
     */
    public static FunctionDescriptor PyDict_DelItem$descriptor() {
        return PyDict_DelItem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyDict_DelItem(PyObject *mp, PyObject *key)
     * }
     */
    public static MethodHandle PyDict_DelItem$handle() {
        return PyDict_DelItem.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyDict_DelItem(PyObject *mp, PyObject *key)
     * }
     */
    public static MemorySegment PyDict_DelItem$address() {
        return PyDict_DelItem.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyDict_DelItem(PyObject *mp, PyObject *key)
     * }
     */
    public static int PyDict_DelItem(MemorySegment mp, MemorySegment key) {
        var mh$ = PyDict_DelItem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyDict_DelItem", mp, key);
            }
            return (int)mh$.invokeExact(mp, key);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyDict_Clear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyDict_Clear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyDict_Clear(PyObject *mp)
     * }
     */
    public static FunctionDescriptor PyDict_Clear$descriptor() {
        return PyDict_Clear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyDict_Clear(PyObject *mp)
     * }
     */
    public static MethodHandle PyDict_Clear$handle() {
        return PyDict_Clear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyDict_Clear(PyObject *mp)
     * }
     */
    public static MemorySegment PyDict_Clear$address() {
        return PyDict_Clear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyDict_Clear(PyObject *mp)
     * }
     */
    public static void PyDict_Clear(MemorySegment mp) {
        var mh$ = PyDict_Clear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyDict_Clear", mp);
            }
            mh$.invokeExact(mp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyDict_Next {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyDict_Next");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyDict_Next(PyObject *mp, Py_ssize_t *pos, PyObject **key, PyObject **value)
     * }
     */
    public static FunctionDescriptor PyDict_Next$descriptor() {
        return PyDict_Next.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyDict_Next(PyObject *mp, Py_ssize_t *pos, PyObject **key, PyObject **value)
     * }
     */
    public static MethodHandle PyDict_Next$handle() {
        return PyDict_Next.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyDict_Next(PyObject *mp, Py_ssize_t *pos, PyObject **key, PyObject **value)
     * }
     */
    public static MemorySegment PyDict_Next$address() {
        return PyDict_Next.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyDict_Next(PyObject *mp, Py_ssize_t *pos, PyObject **key, PyObject **value)
     * }
     */
    public static int PyDict_Next(MemorySegment mp, MemorySegment pos, MemorySegment key, MemorySegment value) {
        var mh$ = PyDict_Next.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyDict_Next", mp, pos, key, value);
            }
            return (int)mh$.invokeExact(mp, pos, key, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyDict_Keys {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyDict_Keys");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyDict_Keys(PyObject *mp)
     * }
     */
    public static FunctionDescriptor PyDict_Keys$descriptor() {
        return PyDict_Keys.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyDict_Keys(PyObject *mp)
     * }
     */
    public static MethodHandle PyDict_Keys$handle() {
        return PyDict_Keys.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyDict_Keys(PyObject *mp)
     * }
     */
    public static MemorySegment PyDict_Keys$address() {
        return PyDict_Keys.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyDict_Keys(PyObject *mp)
     * }
     */
    public static MemorySegment PyDict_Keys(MemorySegment mp) {
        var mh$ = PyDict_Keys.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyDict_Keys", mp);
            }
            return (MemorySegment)mh$.invokeExact(mp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyDict_Values {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyDict_Values");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyDict_Values(PyObject *mp)
     * }
     */
    public static FunctionDescriptor PyDict_Values$descriptor() {
        return PyDict_Values.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyDict_Values(PyObject *mp)
     * }
     */
    public static MethodHandle PyDict_Values$handle() {
        return PyDict_Values.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyDict_Values(PyObject *mp)
     * }
     */
    public static MemorySegment PyDict_Values$address() {
        return PyDict_Values.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyDict_Values(PyObject *mp)
     * }
     */
    public static MemorySegment PyDict_Values(MemorySegment mp) {
        var mh$ = PyDict_Values.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyDict_Values", mp);
            }
            return (MemorySegment)mh$.invokeExact(mp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyDict_Items {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyDict_Items");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyDict_Items(PyObject *mp)
     * }
     */
    public static FunctionDescriptor PyDict_Items$descriptor() {
        return PyDict_Items.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyDict_Items(PyObject *mp)
     * }
     */
    public static MethodHandle PyDict_Items$handle() {
        return PyDict_Items.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyDict_Items(PyObject *mp)
     * }
     */
    public static MemorySegment PyDict_Items$address() {
        return PyDict_Items.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyDict_Items(PyObject *mp)
     * }
     */
    public static MemorySegment PyDict_Items(MemorySegment mp) {
        var mh$ = PyDict_Items.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyDict_Items", mp);
            }
            return (MemorySegment)mh$.invokeExact(mp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyDict_Size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyDict_Size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_ssize_t PyDict_Size(PyObject *mp)
     * }
     */
    public static FunctionDescriptor PyDict_Size$descriptor() {
        return PyDict_Size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_ssize_t PyDict_Size(PyObject *mp)
     * }
     */
    public static MethodHandle PyDict_Size$handle() {
        return PyDict_Size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_ssize_t PyDict_Size(PyObject *mp)
     * }
     */
    public static MemorySegment PyDict_Size$address() {
        return PyDict_Size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_ssize_t PyDict_Size(PyObject *mp)
     * }
     */
    public static long PyDict_Size(MemorySegment mp) {
        var mh$ = PyDict_Size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyDict_Size", mp);
            }
            return (long)mh$.invokeExact(mp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyDict_Copy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyDict_Copy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyDict_Copy(PyObject *mp)
     * }
     */
    public static FunctionDescriptor PyDict_Copy$descriptor() {
        return PyDict_Copy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyDict_Copy(PyObject *mp)
     * }
     */
    public static MethodHandle PyDict_Copy$handle() {
        return PyDict_Copy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyDict_Copy(PyObject *mp)
     * }
     */
    public static MemorySegment PyDict_Copy$address() {
        return PyDict_Copy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyDict_Copy(PyObject *mp)
     * }
     */
    public static MemorySegment PyDict_Copy(MemorySegment mp) {
        var mh$ = PyDict_Copy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyDict_Copy", mp);
            }
            return (MemorySegment)mh$.invokeExact(mp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyDict_Contains {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyDict_Contains");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyDict_Contains(PyObject *mp, PyObject *key)
     * }
     */
    public static FunctionDescriptor PyDict_Contains$descriptor() {
        return PyDict_Contains.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyDict_Contains(PyObject *mp, PyObject *key)
     * }
     */
    public static MethodHandle PyDict_Contains$handle() {
        return PyDict_Contains.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyDict_Contains(PyObject *mp, PyObject *key)
     * }
     */
    public static MemorySegment PyDict_Contains$address() {
        return PyDict_Contains.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyDict_Contains(PyObject *mp, PyObject *key)
     * }
     */
    public static int PyDict_Contains(MemorySegment mp, MemorySegment key) {
        var mh$ = PyDict_Contains.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyDict_Contains", mp, key);
            }
            return (int)mh$.invokeExact(mp, key);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyDict_Update {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyDict_Update");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyDict_Update(PyObject *mp, PyObject *other)
     * }
     */
    public static FunctionDescriptor PyDict_Update$descriptor() {
        return PyDict_Update.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyDict_Update(PyObject *mp, PyObject *other)
     * }
     */
    public static MethodHandle PyDict_Update$handle() {
        return PyDict_Update.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyDict_Update(PyObject *mp, PyObject *other)
     * }
     */
    public static MemorySegment PyDict_Update$address() {
        return PyDict_Update.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyDict_Update(PyObject *mp, PyObject *other)
     * }
     */
    public static int PyDict_Update(MemorySegment mp, MemorySegment other) {
        var mh$ = PyDict_Update.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyDict_Update", mp, other);
            }
            return (int)mh$.invokeExact(mp, other);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyDict_Merge {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyDict_Merge");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyDict_Merge(PyObject *mp, PyObject *other, int override)
     * }
     */
    public static FunctionDescriptor PyDict_Merge$descriptor() {
        return PyDict_Merge.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyDict_Merge(PyObject *mp, PyObject *other, int override)
     * }
     */
    public static MethodHandle PyDict_Merge$handle() {
        return PyDict_Merge.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyDict_Merge(PyObject *mp, PyObject *other, int override)
     * }
     */
    public static MemorySegment PyDict_Merge$address() {
        return PyDict_Merge.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyDict_Merge(PyObject *mp, PyObject *other, int override)
     * }
     */
    public static int PyDict_Merge(MemorySegment mp, MemorySegment other, int override) {
        var mh$ = PyDict_Merge.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyDict_Merge", mp, other, override);
            }
            return (int)mh$.invokeExact(mp, other, override);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyDict_MergeFromSeq2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyDict_MergeFromSeq2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyDict_MergeFromSeq2(PyObject *d, PyObject *seq2, int override)
     * }
     */
    public static FunctionDescriptor PyDict_MergeFromSeq2$descriptor() {
        return PyDict_MergeFromSeq2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyDict_MergeFromSeq2(PyObject *d, PyObject *seq2, int override)
     * }
     */
    public static MethodHandle PyDict_MergeFromSeq2$handle() {
        return PyDict_MergeFromSeq2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyDict_MergeFromSeq2(PyObject *d, PyObject *seq2, int override)
     * }
     */
    public static MemorySegment PyDict_MergeFromSeq2$address() {
        return PyDict_MergeFromSeq2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyDict_MergeFromSeq2(PyObject *d, PyObject *seq2, int override)
     * }
     */
    public static int PyDict_MergeFromSeq2(MemorySegment d, MemorySegment seq2, int override) {
        var mh$ = PyDict_MergeFromSeq2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyDict_MergeFromSeq2", d, seq2, override);
            }
            return (int)mh$.invokeExact(d, seq2, override);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyDict_GetItemString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyDict_GetItemString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyDict_GetItemString(PyObject *dp, const char *key)
     * }
     */
    public static FunctionDescriptor PyDict_GetItemString$descriptor() {
        return PyDict_GetItemString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyDict_GetItemString(PyObject *dp, const char *key)
     * }
     */
    public static MethodHandle PyDict_GetItemString$handle() {
        return PyDict_GetItemString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyDict_GetItemString(PyObject *dp, const char *key)
     * }
     */
    public static MemorySegment PyDict_GetItemString$address() {
        return PyDict_GetItemString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyDict_GetItemString(PyObject *dp, const char *key)
     * }
     */
    public static MemorySegment PyDict_GetItemString(MemorySegment dp, MemorySegment key) {
        var mh$ = PyDict_GetItemString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyDict_GetItemString", dp, key);
            }
            return (MemorySegment)mh$.invokeExact(dp, key);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyDict_SetItemString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyDict_SetItemString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyDict_SetItemString(PyObject *dp, const char *key, PyObject *item)
     * }
     */
    public static FunctionDescriptor PyDict_SetItemString$descriptor() {
        return PyDict_SetItemString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyDict_SetItemString(PyObject *dp, const char *key, PyObject *item)
     * }
     */
    public static MethodHandle PyDict_SetItemString$handle() {
        return PyDict_SetItemString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyDict_SetItemString(PyObject *dp, const char *key, PyObject *item)
     * }
     */
    public static MemorySegment PyDict_SetItemString$address() {
        return PyDict_SetItemString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyDict_SetItemString(PyObject *dp, const char *key, PyObject *item)
     * }
     */
    public static int PyDict_SetItemString(MemorySegment dp, MemorySegment key, MemorySegment item) {
        var mh$ = PyDict_SetItemString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyDict_SetItemString", dp, key, item);
            }
            return (int)mh$.invokeExact(dp, key, item);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyDict_DelItemString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyDict_DelItemString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyDict_DelItemString(PyObject *dp, const char *key)
     * }
     */
    public static FunctionDescriptor PyDict_DelItemString$descriptor() {
        return PyDict_DelItemString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyDict_DelItemString(PyObject *dp, const char *key)
     * }
     */
    public static MethodHandle PyDict_DelItemString$handle() {
        return PyDict_DelItemString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyDict_DelItemString(PyObject *dp, const char *key)
     * }
     */
    public static MemorySegment PyDict_DelItemString$address() {
        return PyDict_DelItemString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyDict_DelItemString(PyObject *dp, const char *key)
     * }
     */
    public static int PyDict_DelItemString(MemorySegment dp, MemorySegment key) {
        var mh$ = PyDict_DelItemString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyDict_DelItemString", dp, key);
            }
            return (int)mh$.invokeExact(dp, key);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_GenericGetDict {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_GenericGetDict");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyObject_GenericGetDict(PyObject *, void *)
     * }
     */
    public static FunctionDescriptor PyObject_GenericGetDict$descriptor() {
        return PyObject_GenericGetDict.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyObject_GenericGetDict(PyObject *, void *)
     * }
     */
    public static MethodHandle PyObject_GenericGetDict$handle() {
        return PyObject_GenericGetDict.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyObject_GenericGetDict(PyObject *, void *)
     * }
     */
    public static MemorySegment PyObject_GenericGetDict$address() {
        return PyObject_GenericGetDict.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyObject_GenericGetDict(PyObject *, void *)
     * }
     */
    public static MemorySegment PyObject_GenericGetDict(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyObject_GenericGetDict.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_GenericGetDict", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyDictKeys_Type$constants {
        public static final GroupLayout LAYOUT = _object.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyDictKeys_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyDictKeys_Type
     * }
     */
    public static GroupLayout PyDictKeys_Type$layout() {
        return PyDictKeys_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyDictKeys_Type
     * }
     */
    public static MemorySegment PyDictKeys_Type() {
        return PyDictKeys_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyDictKeys_Type
     * }
     */
    public static void PyDictKeys_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyDictKeys_Type$constants.SEGMENT, 0L, PyDictKeys_Type$constants.LAYOUT.byteSize());
    }

    private static class PyDictValues_Type$constants {
        public static final GroupLayout LAYOUT = _object.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyDictValues_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyDictValues_Type
     * }
     */
    public static GroupLayout PyDictValues_Type$layout() {
        return PyDictValues_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyDictValues_Type
     * }
     */
    public static MemorySegment PyDictValues_Type() {
        return PyDictValues_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyDictValues_Type
     * }
     */
    public static void PyDictValues_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyDictValues_Type$constants.SEGMENT, 0L, PyDictValues_Type$constants.LAYOUT.byteSize());
    }

    private static class PyDictItems_Type$constants {
        public static final GroupLayout LAYOUT = _object.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyDictItems_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyDictItems_Type
     * }
     */
    public static GroupLayout PyDictItems_Type$layout() {
        return PyDictItems_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyDictItems_Type
     * }
     */
    public static MemorySegment PyDictItems_Type() {
        return PyDictItems_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyDictItems_Type
     * }
     */
    public static void PyDictItems_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyDictItems_Type$constants.SEGMENT, 0L, PyDictItems_Type$constants.LAYOUT.byteSize());
    }

    private static class PyDictIterKey_Type$constants {
        public static final GroupLayout LAYOUT = _object.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyDictIterKey_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyDictIterKey_Type
     * }
     */
    public static GroupLayout PyDictIterKey_Type$layout() {
        return PyDictIterKey_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyDictIterKey_Type
     * }
     */
    public static MemorySegment PyDictIterKey_Type() {
        return PyDictIterKey_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyDictIterKey_Type
     * }
     */
    public static void PyDictIterKey_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyDictIterKey_Type$constants.SEGMENT, 0L, PyDictIterKey_Type$constants.LAYOUT.byteSize());
    }

    private static class PyDictIterValue_Type$constants {
        public static final GroupLayout LAYOUT = _object.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyDictIterValue_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyDictIterValue_Type
     * }
     */
    public static GroupLayout PyDictIterValue_Type$layout() {
        return PyDictIterValue_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyDictIterValue_Type
     * }
     */
    public static MemorySegment PyDictIterValue_Type() {
        return PyDictIterValue_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyDictIterValue_Type
     * }
     */
    public static void PyDictIterValue_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyDictIterValue_Type$constants.SEGMENT, 0L, PyDictIterValue_Type$constants.LAYOUT.byteSize());
    }

    private static class PyDictIterItem_Type$constants {
        public static final GroupLayout LAYOUT = _object.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyDictIterItem_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyDictIterItem_Type
     * }
     */
    public static GroupLayout PyDictIterItem_Type$layout() {
        return PyDictIterItem_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyDictIterItem_Type
     * }
     */
    public static MemorySegment PyDictIterItem_Type() {
        return PyDictIterItem_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyDictIterItem_Type
     * }
     */
    public static void PyDictIterItem_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyDictIterItem_Type$constants.SEGMENT, 0L, PyDictIterItem_Type$constants.LAYOUT.byteSize());
    }

    private static class PyDictRevIterKey_Type$constants {
        public static final GroupLayout LAYOUT = _object.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyDictRevIterKey_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyDictRevIterKey_Type
     * }
     */
    public static GroupLayout PyDictRevIterKey_Type$layout() {
        return PyDictRevIterKey_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyDictRevIterKey_Type
     * }
     */
    public static MemorySegment PyDictRevIterKey_Type() {
        return PyDictRevIterKey_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyDictRevIterKey_Type
     * }
     */
    public static void PyDictRevIterKey_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyDictRevIterKey_Type$constants.SEGMENT, 0L, PyDictRevIterKey_Type$constants.LAYOUT.byteSize());
    }

    private static class PyDictRevIterItem_Type$constants {
        public static final GroupLayout LAYOUT = _object.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyDictRevIterItem_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyDictRevIterItem_Type
     * }
     */
    public static GroupLayout PyDictRevIterItem_Type$layout() {
        return PyDictRevIterItem_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyDictRevIterItem_Type
     * }
     */
    public static MemorySegment PyDictRevIterItem_Type() {
        return PyDictRevIterItem_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyDictRevIterItem_Type
     * }
     */
    public static void PyDictRevIterItem_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyDictRevIterItem_Type$constants.SEGMENT, 0L, PyDictRevIterItem_Type$constants.LAYOUT.byteSize());
    }

    private static class PyDictRevIterValue_Type$constants {
        public static final GroupLayout LAYOUT = _object.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyDictRevIterValue_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyDictRevIterValue_Type
     * }
     */
    public static GroupLayout PyDictRevIterValue_Type$layout() {
        return PyDictRevIterValue_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyDictRevIterValue_Type
     * }
     */
    public static MemorySegment PyDictRevIterValue_Type() {
        return PyDictRevIterValue_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyDictRevIterValue_Type
     * }
     */
    public static void PyDictRevIterValue_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyDictRevIterValue_Type$constants.SEGMENT, 0L, PyDictRevIterValue_Type$constants.LAYOUT.byteSize());
    }

    private static class PyEnum_Type$constants {
        public static final GroupLayout LAYOUT = _object.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyEnum_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyEnum_Type
     * }
     */
    public static GroupLayout PyEnum_Type$layout() {
        return PyEnum_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyEnum_Type
     * }
     */
    public static MemorySegment PyEnum_Type() {
        return PyEnum_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyEnum_Type
     * }
     */
    public static void PyEnum_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyEnum_Type$constants.SEGMENT, 0L, PyEnum_Type$constants.LAYOUT.byteSize());
    }

    private static class PyReversed_Type$constants {
        public static final GroupLayout LAYOUT = _object.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyReversed_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyReversed_Type
     * }
     */
    public static GroupLayout PyReversed_Type$layout() {
        return PyReversed_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyReversed_Type
     * }
     */
    public static MemorySegment PyReversed_Type() {
        return PyReversed_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyReversed_Type
     * }
     */
    public static void PyReversed_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyReversed_Type$constants.SEGMENT, 0L, PyReversed_Type$constants.LAYOUT.byteSize());
    }

    private static class PySet_Type$constants {
        public static final GroupLayout LAYOUT = _object.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PySet_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PySet_Type
     * }
     */
    public static GroupLayout PySet_Type$layout() {
        return PySet_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PySet_Type
     * }
     */
    public static MemorySegment PySet_Type() {
        return PySet_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PySet_Type
     * }
     */
    public static void PySet_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PySet_Type$constants.SEGMENT, 0L, PySet_Type$constants.LAYOUT.byteSize());
    }

    private static class PyFrozenSet_Type$constants {
        public static final GroupLayout LAYOUT = _object.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyFrozenSet_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyFrozenSet_Type
     * }
     */
    public static GroupLayout PyFrozenSet_Type$layout() {
        return PyFrozenSet_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyFrozenSet_Type
     * }
     */
    public static MemorySegment PyFrozenSet_Type() {
        return PyFrozenSet_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyFrozenSet_Type
     * }
     */
    public static void PyFrozenSet_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyFrozenSet_Type$constants.SEGMENT, 0L, PyFrozenSet_Type$constants.LAYOUT.byteSize());
    }

    private static class PySetIter_Type$constants {
        public static final GroupLayout LAYOUT = _object.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PySetIter_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PySetIter_Type
     * }
     */
    public static GroupLayout PySetIter_Type$layout() {
        return PySetIter_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PySetIter_Type
     * }
     */
    public static MemorySegment PySetIter_Type() {
        return PySetIter_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PySetIter_Type
     * }
     */
    public static void PySetIter_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PySetIter_Type$constants.SEGMENT, 0L, PySetIter_Type$constants.LAYOUT.byteSize());
    }

    private static class PySet_New {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PySet_New");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PySet_New(PyObject *)
     * }
     */
    public static FunctionDescriptor PySet_New$descriptor() {
        return PySet_New.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PySet_New(PyObject *)
     * }
     */
    public static MethodHandle PySet_New$handle() {
        return PySet_New.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PySet_New(PyObject *)
     * }
     */
    public static MemorySegment PySet_New$address() {
        return PySet_New.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PySet_New(PyObject *)
     * }
     */
    public static MemorySegment PySet_New(MemorySegment x0) {
        var mh$ = PySet_New.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PySet_New", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyFrozenSet_New {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyFrozenSet_New");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyFrozenSet_New(PyObject *)
     * }
     */
    public static FunctionDescriptor PyFrozenSet_New$descriptor() {
        return PyFrozenSet_New.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyFrozenSet_New(PyObject *)
     * }
     */
    public static MethodHandle PyFrozenSet_New$handle() {
        return PyFrozenSet_New.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyFrozenSet_New(PyObject *)
     * }
     */
    public static MemorySegment PyFrozenSet_New$address() {
        return PyFrozenSet_New.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyFrozenSet_New(PyObject *)
     * }
     */
    public static MemorySegment PyFrozenSet_New(MemorySegment x0) {
        var mh$ = PyFrozenSet_New.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyFrozenSet_New", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PySet_Add {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PySet_Add");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PySet_Add(PyObject *set, PyObject *key)
     * }
     */
    public static FunctionDescriptor PySet_Add$descriptor() {
        return PySet_Add.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PySet_Add(PyObject *set, PyObject *key)
     * }
     */
    public static MethodHandle PySet_Add$handle() {
        return PySet_Add.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PySet_Add(PyObject *set, PyObject *key)
     * }
     */
    public static MemorySegment PySet_Add$address() {
        return PySet_Add.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PySet_Add(PyObject *set, PyObject *key)
     * }
     */
    public static int PySet_Add(MemorySegment set, MemorySegment key) {
        var mh$ = PySet_Add.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PySet_Add", set, key);
            }
            return (int)mh$.invokeExact(set, key);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PySet_Clear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PySet_Clear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PySet_Clear(PyObject *set)
     * }
     */
    public static FunctionDescriptor PySet_Clear$descriptor() {
        return PySet_Clear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PySet_Clear(PyObject *set)
     * }
     */
    public static MethodHandle PySet_Clear$handle() {
        return PySet_Clear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PySet_Clear(PyObject *set)
     * }
     */
    public static MemorySegment PySet_Clear$address() {
        return PySet_Clear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PySet_Clear(PyObject *set)
     * }
     */
    public static int PySet_Clear(MemorySegment set) {
        var mh$ = PySet_Clear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PySet_Clear", set);
            }
            return (int)mh$.invokeExact(set);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PySet_Contains {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PySet_Contains");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PySet_Contains(PyObject *anyset, PyObject *key)
     * }
     */
    public static FunctionDescriptor PySet_Contains$descriptor() {
        return PySet_Contains.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PySet_Contains(PyObject *anyset, PyObject *key)
     * }
     */
    public static MethodHandle PySet_Contains$handle() {
        return PySet_Contains.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PySet_Contains(PyObject *anyset, PyObject *key)
     * }
     */
    public static MemorySegment PySet_Contains$address() {
        return PySet_Contains.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PySet_Contains(PyObject *anyset, PyObject *key)
     * }
     */
    public static int PySet_Contains(MemorySegment anyset, MemorySegment key) {
        var mh$ = PySet_Contains.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PySet_Contains", anyset, key);
            }
            return (int)mh$.invokeExact(anyset, key);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PySet_Discard {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PySet_Discard");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PySet_Discard(PyObject *set, PyObject *key)
     * }
     */
    public static FunctionDescriptor PySet_Discard$descriptor() {
        return PySet_Discard.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PySet_Discard(PyObject *set, PyObject *key)
     * }
     */
    public static MethodHandle PySet_Discard$handle() {
        return PySet_Discard.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PySet_Discard(PyObject *set, PyObject *key)
     * }
     */
    public static MemorySegment PySet_Discard$address() {
        return PySet_Discard.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PySet_Discard(PyObject *set, PyObject *key)
     * }
     */
    public static int PySet_Discard(MemorySegment set, MemorySegment key) {
        var mh$ = PySet_Discard.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PySet_Discard", set, key);
            }
            return (int)mh$.invokeExact(set, key);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PySet_Pop {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PySet_Pop");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PySet_Pop(PyObject *set)
     * }
     */
    public static FunctionDescriptor PySet_Pop$descriptor() {
        return PySet_Pop.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PySet_Pop(PyObject *set)
     * }
     */
    public static MethodHandle PySet_Pop$handle() {
        return PySet_Pop.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PySet_Pop(PyObject *set)
     * }
     */
    public static MemorySegment PySet_Pop$address() {
        return PySet_Pop.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PySet_Pop(PyObject *set)
     * }
     */
    public static MemorySegment PySet_Pop(MemorySegment set) {
        var mh$ = PySet_Pop.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PySet_Pop", set);
            }
            return (MemorySegment)mh$.invokeExact(set);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PySet_Size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PySet_Size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_ssize_t PySet_Size(PyObject *anyset)
     * }
     */
    public static FunctionDescriptor PySet_Size$descriptor() {
        return PySet_Size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_ssize_t PySet_Size(PyObject *anyset)
     * }
     */
    public static MethodHandle PySet_Size$handle() {
        return PySet_Size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_ssize_t PySet_Size(PyObject *anyset)
     * }
     */
    public static MemorySegment PySet_Size$address() {
        return PySet_Size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_ssize_t PySet_Size(PyObject *anyset)
     * }
     */
    public static long PySet_Size(MemorySegment anyset) {
        var mh$ = PySet_Size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PySet_Size", anyset);
            }
            return (long)mh$.invokeExact(anyset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCFunction_Type$constants {
        public static final GroupLayout LAYOUT = _object.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyCFunction_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyCFunction_Type
     * }
     */
    public static GroupLayout PyCFunction_Type$layout() {
        return PyCFunction_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyCFunction_Type
     * }
     */
    public static MemorySegment PyCFunction_Type() {
        return PyCFunction_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyCFunction_Type
     * }
     */
    public static void PyCFunction_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyCFunction_Type$constants.SEGMENT, 0L, PyCFunction_Type$constants.LAYOUT.byteSize());
    }

    private static class PyCFunction_GetFunction {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCFunction_GetFunction");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyCFunction PyCFunction_GetFunction(PyObject *)
     * }
     */
    public static FunctionDescriptor PyCFunction_GetFunction$descriptor() {
        return PyCFunction_GetFunction.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyCFunction PyCFunction_GetFunction(PyObject *)
     * }
     */
    public static MethodHandle PyCFunction_GetFunction$handle() {
        return PyCFunction_GetFunction.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyCFunction PyCFunction_GetFunction(PyObject *)
     * }
     */
    public static MemorySegment PyCFunction_GetFunction$address() {
        return PyCFunction_GetFunction.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyCFunction PyCFunction_GetFunction(PyObject *)
     * }
     */
    public static MemorySegment PyCFunction_GetFunction(MemorySegment x0) {
        var mh$ = PyCFunction_GetFunction.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCFunction_GetFunction", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCFunction_GetSelf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCFunction_GetSelf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyCFunction_GetSelf(PyObject *)
     * }
     */
    public static FunctionDescriptor PyCFunction_GetSelf$descriptor() {
        return PyCFunction_GetSelf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyCFunction_GetSelf(PyObject *)
     * }
     */
    public static MethodHandle PyCFunction_GetSelf$handle() {
        return PyCFunction_GetSelf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyCFunction_GetSelf(PyObject *)
     * }
     */
    public static MemorySegment PyCFunction_GetSelf$address() {
        return PyCFunction_GetSelf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyCFunction_GetSelf(PyObject *)
     * }
     */
    public static MemorySegment PyCFunction_GetSelf(MemorySegment x0) {
        var mh$ = PyCFunction_GetSelf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCFunction_GetSelf", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCFunction_GetFlags {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCFunction_GetFlags");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyCFunction_GetFlags(PyObject *)
     * }
     */
    public static FunctionDescriptor PyCFunction_GetFlags$descriptor() {
        return PyCFunction_GetFlags.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyCFunction_GetFlags(PyObject *)
     * }
     */
    public static MethodHandle PyCFunction_GetFlags$handle() {
        return PyCFunction_GetFlags.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyCFunction_GetFlags(PyObject *)
     * }
     */
    public static MemorySegment PyCFunction_GetFlags$address() {
        return PyCFunction_GetFlags.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyCFunction_GetFlags(PyObject *)
     * }
     */
    public static int PyCFunction_GetFlags(MemorySegment x0) {
        var mh$ = PyCFunction_GetFlags.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCFunction_GetFlags", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCFunction_Call {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCFunction_Call");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyCFunction_Call(PyObject *, PyObject *, PyObject *)
     * }
     */
    public static FunctionDescriptor PyCFunction_Call$descriptor() {
        return PyCFunction_Call.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyCFunction_Call(PyObject *, PyObject *, PyObject *)
     * }
     */
    public static MethodHandle PyCFunction_Call$handle() {
        return PyCFunction_Call.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyCFunction_Call(PyObject *, PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyCFunction_Call$address() {
        return PyCFunction_Call.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyCFunction_Call(PyObject *, PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyCFunction_Call(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = PyCFunction_Call.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCFunction_Call", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCFunction_New {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCFunction_New");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyCFunction_New(PyMethodDef *, PyObject *)
     * }
     */
    public static FunctionDescriptor PyCFunction_New$descriptor() {
        return PyCFunction_New.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyCFunction_New(PyMethodDef *, PyObject *)
     * }
     */
    public static MethodHandle PyCFunction_New$handle() {
        return PyCFunction_New.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyCFunction_New(PyMethodDef *, PyObject *)
     * }
     */
    public static MemorySegment PyCFunction_New$address() {
        return PyCFunction_New.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyCFunction_New(PyMethodDef *, PyObject *)
     * }
     */
    public static MemorySegment PyCFunction_New(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyCFunction_New.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCFunction_New", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCFunction_NewEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCFunction_NewEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyCFunction_NewEx(PyMethodDef *, PyObject *, PyObject *)
     * }
     */
    public static FunctionDescriptor PyCFunction_NewEx$descriptor() {
        return PyCFunction_NewEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyCFunction_NewEx(PyMethodDef *, PyObject *, PyObject *)
     * }
     */
    public static MethodHandle PyCFunction_NewEx$handle() {
        return PyCFunction_NewEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyCFunction_NewEx(PyMethodDef *, PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyCFunction_NewEx$address() {
        return PyCFunction_NewEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyCFunction_NewEx(PyMethodDef *, PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyCFunction_NewEx(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = PyCFunction_NewEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCFunction_NewEx", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCMethod_New {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCMethod_New");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyCMethod_New(PyMethodDef *, PyObject *, PyObject *, PyTypeObject *)
     * }
     */
    public static FunctionDescriptor PyCMethod_New$descriptor() {
        return PyCMethod_New.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyCMethod_New(PyMethodDef *, PyObject *, PyObject *, PyTypeObject *)
     * }
     */
    public static MethodHandle PyCMethod_New$handle() {
        return PyCMethod_New.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyCMethod_New(PyMethodDef *, PyObject *, PyObject *, PyTypeObject *)
     * }
     */
    public static MemorySegment PyCMethod_New$address() {
        return PyCMethod_New.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyCMethod_New(PyMethodDef *, PyObject *, PyObject *, PyTypeObject *)
     * }
     */
    public static MemorySegment PyCMethod_New(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = PyCMethod_New.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCMethod_New", x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyModule_Type$constants {
        public static final GroupLayout LAYOUT = _object.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyModule_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyModule_Type
     * }
     */
    public static GroupLayout PyModule_Type$layout() {
        return PyModule_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyModule_Type
     * }
     */
    public static MemorySegment PyModule_Type() {
        return PyModule_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyModule_Type
     * }
     */
    public static void PyModule_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyModule_Type$constants.SEGMENT, 0L, PyModule_Type$constants.LAYOUT.byteSize());
    }

    private static class PyModule_NewObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyModule_NewObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyModule_NewObject(PyObject *name)
     * }
     */
    public static FunctionDescriptor PyModule_NewObject$descriptor() {
        return PyModule_NewObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyModule_NewObject(PyObject *name)
     * }
     */
    public static MethodHandle PyModule_NewObject$handle() {
        return PyModule_NewObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyModule_NewObject(PyObject *name)
     * }
     */
    public static MemorySegment PyModule_NewObject$address() {
        return PyModule_NewObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyModule_NewObject(PyObject *name)
     * }
     */
    public static MemorySegment PyModule_NewObject(MemorySegment name) {
        var mh$ = PyModule_NewObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyModule_NewObject", name);
            }
            return (MemorySegment)mh$.invokeExact(name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyModule_New {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyModule_New");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyModule_New(const char *name)
     * }
     */
    public static FunctionDescriptor PyModule_New$descriptor() {
        return PyModule_New.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyModule_New(const char *name)
     * }
     */
    public static MethodHandle PyModule_New$handle() {
        return PyModule_New.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyModule_New(const char *name)
     * }
     */
    public static MemorySegment PyModule_New$address() {
        return PyModule_New.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyModule_New(const char *name)
     * }
     */
    public static MemorySegment PyModule_New(MemorySegment name) {
        var mh$ = PyModule_New.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyModule_New", name);
            }
            return (MemorySegment)mh$.invokeExact(name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyModule_GetDict {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyModule_GetDict");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyModule_GetDict(PyObject *)
     * }
     */
    public static FunctionDescriptor PyModule_GetDict$descriptor() {
        return PyModule_GetDict.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyModule_GetDict(PyObject *)
     * }
     */
    public static MethodHandle PyModule_GetDict$handle() {
        return PyModule_GetDict.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyModule_GetDict(PyObject *)
     * }
     */
    public static MemorySegment PyModule_GetDict$address() {
        return PyModule_GetDict.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyModule_GetDict(PyObject *)
     * }
     */
    public static MemorySegment PyModule_GetDict(MemorySegment x0) {
        var mh$ = PyModule_GetDict.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyModule_GetDict", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyModule_GetNameObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyModule_GetNameObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyModule_GetNameObject(PyObject *)
     * }
     */
    public static FunctionDescriptor PyModule_GetNameObject$descriptor() {
        return PyModule_GetNameObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyModule_GetNameObject(PyObject *)
     * }
     */
    public static MethodHandle PyModule_GetNameObject$handle() {
        return PyModule_GetNameObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyModule_GetNameObject(PyObject *)
     * }
     */
    public static MemorySegment PyModule_GetNameObject$address() {
        return PyModule_GetNameObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyModule_GetNameObject(PyObject *)
     * }
     */
    public static MemorySegment PyModule_GetNameObject(MemorySegment x0) {
        var mh$ = PyModule_GetNameObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyModule_GetNameObject", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyModule_GetName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyModule_GetName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *PyModule_GetName(PyObject *)
     * }
     */
    public static FunctionDescriptor PyModule_GetName$descriptor() {
        return PyModule_GetName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *PyModule_GetName(PyObject *)
     * }
     */
    public static MethodHandle PyModule_GetName$handle() {
        return PyModule_GetName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *PyModule_GetName(PyObject *)
     * }
     */
    public static MemorySegment PyModule_GetName$address() {
        return PyModule_GetName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *PyModule_GetName(PyObject *)
     * }
     */
    public static MemorySegment PyModule_GetName(MemorySegment x0) {
        var mh$ = PyModule_GetName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyModule_GetName", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyModule_GetFilename {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyModule_GetFilename");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *PyModule_GetFilename(PyObject *)
     * }
     */
    public static FunctionDescriptor PyModule_GetFilename$descriptor() {
        return PyModule_GetFilename.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *PyModule_GetFilename(PyObject *)
     * }
     */
    public static MethodHandle PyModule_GetFilename$handle() {
        return PyModule_GetFilename.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *PyModule_GetFilename(PyObject *)
     * }
     */
    public static MemorySegment PyModule_GetFilename$address() {
        return PyModule_GetFilename.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *PyModule_GetFilename(PyObject *)
     * }
     */
    public static MemorySegment PyModule_GetFilename(MemorySegment x0) {
        var mh$ = PyModule_GetFilename.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyModule_GetFilename", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyModule_GetFilenameObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyModule_GetFilenameObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyModule_GetFilenameObject(PyObject *)
     * }
     */
    public static FunctionDescriptor PyModule_GetFilenameObject$descriptor() {
        return PyModule_GetFilenameObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyModule_GetFilenameObject(PyObject *)
     * }
     */
    public static MethodHandle PyModule_GetFilenameObject$handle() {
        return PyModule_GetFilenameObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyModule_GetFilenameObject(PyObject *)
     * }
     */
    public static MemorySegment PyModule_GetFilenameObject$address() {
        return PyModule_GetFilenameObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyModule_GetFilenameObject(PyObject *)
     * }
     */
    public static MemorySegment PyModule_GetFilenameObject(MemorySegment x0) {
        var mh$ = PyModule_GetFilenameObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyModule_GetFilenameObject", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyModule_GetDef {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyModule_GetDef");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyModuleDef *PyModule_GetDef(PyObject *)
     * }
     */
    public static FunctionDescriptor PyModule_GetDef$descriptor() {
        return PyModule_GetDef.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyModuleDef *PyModule_GetDef(PyObject *)
     * }
     */
    public static MethodHandle PyModule_GetDef$handle() {
        return PyModule_GetDef.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyModuleDef *PyModule_GetDef(PyObject *)
     * }
     */
    public static MemorySegment PyModule_GetDef$address() {
        return PyModule_GetDef.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyModuleDef *PyModule_GetDef(PyObject *)
     * }
     */
    public static MemorySegment PyModule_GetDef(MemorySegment x0) {
        var mh$ = PyModule_GetDef.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyModule_GetDef", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyModule_GetState {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyModule_GetState");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *PyModule_GetState(PyObject *)
     * }
     */
    public static FunctionDescriptor PyModule_GetState$descriptor() {
        return PyModule_GetState.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *PyModule_GetState(PyObject *)
     * }
     */
    public static MethodHandle PyModule_GetState$handle() {
        return PyModule_GetState.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *PyModule_GetState(PyObject *)
     * }
     */
    public static MemorySegment PyModule_GetState$address() {
        return PyModule_GetState.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *PyModule_GetState(PyObject *)
     * }
     */
    public static MemorySegment PyModule_GetState(MemorySegment x0) {
        var mh$ = PyModule_GetState.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyModule_GetState", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyModuleDef_Init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyModuleDef_Init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyModuleDef_Init(PyModuleDef *)
     * }
     */
    public static FunctionDescriptor PyModuleDef_Init$descriptor() {
        return PyModuleDef_Init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyModuleDef_Init(PyModuleDef *)
     * }
     */
    public static MethodHandle PyModuleDef_Init$handle() {
        return PyModuleDef_Init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyModuleDef_Init(PyModuleDef *)
     * }
     */
    public static MemorySegment PyModuleDef_Init$address() {
        return PyModuleDef_Init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyModuleDef_Init(PyModuleDef *)
     * }
     */
    public static MemorySegment PyModuleDef_Init(MemorySegment x0) {
        var mh$ = PyModuleDef_Init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyModuleDef_Init", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyModuleDef_Type$constants {
        public static final GroupLayout LAYOUT = _object.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyModuleDef_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyModuleDef_Type
     * }
     */
    public static GroupLayout PyModuleDef_Type$layout() {
        return PyModuleDef_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyModuleDef_Type
     * }
     */
    public static MemorySegment PyModuleDef_Type() {
        return PyModuleDef_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyModuleDef_Type
     * }
     */
    public static void PyModuleDef_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyModuleDef_Type$constants.SEGMENT, 0L, PyModuleDef_Type$constants.LAYOUT.byteSize());
    }

    private static class PyFile_FromFd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyFile_FromFd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyFile_FromFd(int, const char *, const char *, int, const char *, const char *, const char *, int)
     * }
     */
    public static FunctionDescriptor PyFile_FromFd$descriptor() {
        return PyFile_FromFd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyFile_FromFd(int, const char *, const char *, int, const char *, const char *, const char *, int)
     * }
     */
    public static MethodHandle PyFile_FromFd$handle() {
        return PyFile_FromFd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyFile_FromFd(int, const char *, const char *, int, const char *, const char *, const char *, int)
     * }
     */
    public static MemorySegment PyFile_FromFd$address() {
        return PyFile_FromFd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyFile_FromFd(int, const char *, const char *, int, const char *, const char *, const char *, int)
     * }
     */
    public static MemorySegment PyFile_FromFd(int x0, MemorySegment x1, MemorySegment x2, int x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, int x7) {
        var mh$ = PyFile_FromFd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyFile_FromFd", x0, x1, x2, x3, x4, x5, x6, x7);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyFile_GetLine {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyFile_GetLine");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyFile_GetLine(PyObject *, int)
     * }
     */
    public static FunctionDescriptor PyFile_GetLine$descriptor() {
        return PyFile_GetLine.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyFile_GetLine(PyObject *, int)
     * }
     */
    public static MethodHandle PyFile_GetLine$handle() {
        return PyFile_GetLine.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyFile_GetLine(PyObject *, int)
     * }
     */
    public static MemorySegment PyFile_GetLine$address() {
        return PyFile_GetLine.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyFile_GetLine(PyObject *, int)
     * }
     */
    public static MemorySegment PyFile_GetLine(MemorySegment x0, int x1) {
        var mh$ = PyFile_GetLine.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyFile_GetLine", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyFile_WriteObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyFile_WriteObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyFile_WriteObject(PyObject *, PyObject *, int)
     * }
     */
    public static FunctionDescriptor PyFile_WriteObject$descriptor() {
        return PyFile_WriteObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyFile_WriteObject(PyObject *, PyObject *, int)
     * }
     */
    public static MethodHandle PyFile_WriteObject$handle() {
        return PyFile_WriteObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyFile_WriteObject(PyObject *, PyObject *, int)
     * }
     */
    public static MemorySegment PyFile_WriteObject$address() {
        return PyFile_WriteObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyFile_WriteObject(PyObject *, PyObject *, int)
     * }
     */
    public static int PyFile_WriteObject(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = PyFile_WriteObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyFile_WriteObject", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyFile_WriteString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyFile_WriteString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyFile_WriteString(const char *, PyObject *)
     * }
     */
    public static FunctionDescriptor PyFile_WriteString$descriptor() {
        return PyFile_WriteString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyFile_WriteString(const char *, PyObject *)
     * }
     */
    public static MethodHandle PyFile_WriteString$handle() {
        return PyFile_WriteString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyFile_WriteString(const char *, PyObject *)
     * }
     */
    public static MemorySegment PyFile_WriteString$address() {
        return PyFile_WriteString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyFile_WriteString(const char *, PyObject *)
     * }
     */
    public static int PyFile_WriteString(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyFile_WriteString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyFile_WriteString", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_AsFileDescriptor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_AsFileDescriptor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyObject_AsFileDescriptor(PyObject *)
     * }
     */
    public static FunctionDescriptor PyObject_AsFileDescriptor$descriptor() {
        return PyObject_AsFileDescriptor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyObject_AsFileDescriptor(PyObject *)
     * }
     */
    public static MethodHandle PyObject_AsFileDescriptor$handle() {
        return PyObject_AsFileDescriptor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyObject_AsFileDescriptor(PyObject *)
     * }
     */
    public static MemorySegment PyObject_AsFileDescriptor$address() {
        return PyObject_AsFileDescriptor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyObject_AsFileDescriptor(PyObject *)
     * }
     */
    public static int PyObject_AsFileDescriptor(MemorySegment x0) {
        var mh$ = PyObject_AsFileDescriptor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_AsFileDescriptor", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_FileSystemDefaultEncoding$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("Py_FileSystemDefaultEncoding").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const char *Py_FileSystemDefaultEncoding
     * }
     */
    public static AddressLayout Py_FileSystemDefaultEncoding$layout() {
        return Py_FileSystemDefaultEncoding$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const char *Py_FileSystemDefaultEncoding
     * }
     */
    public static MemorySegment Py_FileSystemDefaultEncoding$segment() {
        return Py_FileSystemDefaultEncoding$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const char *Py_FileSystemDefaultEncoding
     * }
     */
    public static MemorySegment Py_FileSystemDefaultEncoding() {
        return Py_FileSystemDefaultEncoding$constants.SEGMENT.get(Py_FileSystemDefaultEncoding$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const char *Py_FileSystemDefaultEncoding
     * }
     */
    public static void Py_FileSystemDefaultEncoding(MemorySegment varValue) {
        Py_FileSystemDefaultEncoding$constants.SEGMENT.set(Py_FileSystemDefaultEncoding$constants.LAYOUT, 0L, varValue);
    }

    private static class Py_FileSystemDefaultEncodeErrors$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("Py_FileSystemDefaultEncodeErrors").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const char *Py_FileSystemDefaultEncodeErrors
     * }
     */
    public static AddressLayout Py_FileSystemDefaultEncodeErrors$layout() {
        return Py_FileSystemDefaultEncodeErrors$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const char *Py_FileSystemDefaultEncodeErrors
     * }
     */
    public static MemorySegment Py_FileSystemDefaultEncodeErrors$segment() {
        return Py_FileSystemDefaultEncodeErrors$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const char *Py_FileSystemDefaultEncodeErrors
     * }
     */
    public static MemorySegment Py_FileSystemDefaultEncodeErrors() {
        return Py_FileSystemDefaultEncodeErrors$constants.SEGMENT.get(Py_FileSystemDefaultEncodeErrors$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const char *Py_FileSystemDefaultEncodeErrors
     * }
     */
    public static void Py_FileSystemDefaultEncodeErrors(MemorySegment varValue) {
        Py_FileSystemDefaultEncodeErrors$constants.SEGMENT.set(Py_FileSystemDefaultEncodeErrors$constants.LAYOUT, 0L, varValue);
    }

    private static class Py_HasFileSystemDefaultEncoding$constants {
        public static final OfInt LAYOUT = Python_h.C_INT;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("Py_HasFileSystemDefaultEncoding").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int Py_HasFileSystemDefaultEncoding
     * }
     */
    public static OfInt Py_HasFileSystemDefaultEncoding$layout() {
        return Py_HasFileSystemDefaultEncoding$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int Py_HasFileSystemDefaultEncoding
     * }
     */
    public static MemorySegment Py_HasFileSystemDefaultEncoding$segment() {
        return Py_HasFileSystemDefaultEncoding$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int Py_HasFileSystemDefaultEncoding
     * }
     */
    public static int Py_HasFileSystemDefaultEncoding() {
        return Py_HasFileSystemDefaultEncoding$constants.SEGMENT.get(Py_HasFileSystemDefaultEncoding$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int Py_HasFileSystemDefaultEncoding
     * }
     */
    public static void Py_HasFileSystemDefaultEncoding(int varValue) {
        Py_HasFileSystemDefaultEncoding$constants.SEGMENT.set(Py_HasFileSystemDefaultEncoding$constants.LAYOUT, 0L, varValue);
    }

    private static class Py_UTF8Mode$constants {
        public static final OfInt LAYOUT = Python_h.C_INT;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("Py_UTF8Mode").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int Py_UTF8Mode
     * }
     */
    public static OfInt Py_UTF8Mode$layout() {
        return Py_UTF8Mode$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int Py_UTF8Mode
     * }
     */
    public static MemorySegment Py_UTF8Mode$segment() {
        return Py_UTF8Mode$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int Py_UTF8Mode
     * }
     */
    public static int Py_UTF8Mode() {
        return Py_UTF8Mode$constants.SEGMENT.get(Py_UTF8Mode$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int Py_UTF8Mode
     * }
     */
    public static void Py_UTF8Mode(int varValue) {
        Py_UTF8Mode$constants.SEGMENT.set(Py_UTF8Mode$constants.LAYOUT, 0L, varValue);
    }

    private static class PyCapsule_Type$constants {
        public static final GroupLayout LAYOUT = _object.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyCapsule_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyCapsule_Type
     * }
     */
    public static GroupLayout PyCapsule_Type$layout() {
        return PyCapsule_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyCapsule_Type
     * }
     */
    public static MemorySegment PyCapsule_Type() {
        return PyCapsule_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyCapsule_Type
     * }
     */
    public static void PyCapsule_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyCapsule_Type$constants.SEGMENT, 0L, PyCapsule_Type$constants.LAYOUT.byteSize());
    }

    private static class PyCapsule_New {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCapsule_New");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyCapsule_New(void *pointer, const char *name, PyCapsule_Destructor destructor)
     * }
     */
    public static FunctionDescriptor PyCapsule_New$descriptor() {
        return PyCapsule_New.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyCapsule_New(void *pointer, const char *name, PyCapsule_Destructor destructor)
     * }
     */
    public static MethodHandle PyCapsule_New$handle() {
        return PyCapsule_New.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyCapsule_New(void *pointer, const char *name, PyCapsule_Destructor destructor)
     * }
     */
    public static MemorySegment PyCapsule_New$address() {
        return PyCapsule_New.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyCapsule_New(void *pointer, const char *name, PyCapsule_Destructor destructor)
     * }
     */
    public static MemorySegment PyCapsule_New(MemorySegment pointer, MemorySegment name, MemorySegment destructor) {
        var mh$ = PyCapsule_New.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCapsule_New", pointer, name, destructor);
            }
            return (MemorySegment)mh$.invokeExact(pointer, name, destructor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCapsule_GetPointer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCapsule_GetPointer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *PyCapsule_GetPointer(PyObject *capsule, const char *name)
     * }
     */
    public static FunctionDescriptor PyCapsule_GetPointer$descriptor() {
        return PyCapsule_GetPointer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *PyCapsule_GetPointer(PyObject *capsule, const char *name)
     * }
     */
    public static MethodHandle PyCapsule_GetPointer$handle() {
        return PyCapsule_GetPointer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *PyCapsule_GetPointer(PyObject *capsule, const char *name)
     * }
     */
    public static MemorySegment PyCapsule_GetPointer$address() {
        return PyCapsule_GetPointer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *PyCapsule_GetPointer(PyObject *capsule, const char *name)
     * }
     */
    public static MemorySegment PyCapsule_GetPointer(MemorySegment capsule, MemorySegment name) {
        var mh$ = PyCapsule_GetPointer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCapsule_GetPointer", capsule, name);
            }
            return (MemorySegment)mh$.invokeExact(capsule, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCapsule_GetDestructor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCapsule_GetDestructor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyCapsule_Destructor PyCapsule_GetDestructor(PyObject *capsule)
     * }
     */
    public static FunctionDescriptor PyCapsule_GetDestructor$descriptor() {
        return PyCapsule_GetDestructor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyCapsule_Destructor PyCapsule_GetDestructor(PyObject *capsule)
     * }
     */
    public static MethodHandle PyCapsule_GetDestructor$handle() {
        return PyCapsule_GetDestructor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyCapsule_Destructor PyCapsule_GetDestructor(PyObject *capsule)
     * }
     */
    public static MemorySegment PyCapsule_GetDestructor$address() {
        return PyCapsule_GetDestructor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyCapsule_Destructor PyCapsule_GetDestructor(PyObject *capsule)
     * }
     */
    public static MemorySegment PyCapsule_GetDestructor(MemorySegment capsule) {
        var mh$ = PyCapsule_GetDestructor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCapsule_GetDestructor", capsule);
            }
            return (MemorySegment)mh$.invokeExact(capsule);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCapsule_GetName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCapsule_GetName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *PyCapsule_GetName(PyObject *capsule)
     * }
     */
    public static FunctionDescriptor PyCapsule_GetName$descriptor() {
        return PyCapsule_GetName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *PyCapsule_GetName(PyObject *capsule)
     * }
     */
    public static MethodHandle PyCapsule_GetName$handle() {
        return PyCapsule_GetName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *PyCapsule_GetName(PyObject *capsule)
     * }
     */
    public static MemorySegment PyCapsule_GetName$address() {
        return PyCapsule_GetName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *PyCapsule_GetName(PyObject *capsule)
     * }
     */
    public static MemorySegment PyCapsule_GetName(MemorySegment capsule) {
        var mh$ = PyCapsule_GetName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCapsule_GetName", capsule);
            }
            return (MemorySegment)mh$.invokeExact(capsule);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCapsule_GetContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCapsule_GetContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *PyCapsule_GetContext(PyObject *capsule)
     * }
     */
    public static FunctionDescriptor PyCapsule_GetContext$descriptor() {
        return PyCapsule_GetContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *PyCapsule_GetContext(PyObject *capsule)
     * }
     */
    public static MethodHandle PyCapsule_GetContext$handle() {
        return PyCapsule_GetContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *PyCapsule_GetContext(PyObject *capsule)
     * }
     */
    public static MemorySegment PyCapsule_GetContext$address() {
        return PyCapsule_GetContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *PyCapsule_GetContext(PyObject *capsule)
     * }
     */
    public static MemorySegment PyCapsule_GetContext(MemorySegment capsule) {
        var mh$ = PyCapsule_GetContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCapsule_GetContext", capsule);
            }
            return (MemorySegment)mh$.invokeExact(capsule);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCapsule_IsValid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCapsule_IsValid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyCapsule_IsValid(PyObject *capsule, const char *name)
     * }
     */
    public static FunctionDescriptor PyCapsule_IsValid$descriptor() {
        return PyCapsule_IsValid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyCapsule_IsValid(PyObject *capsule, const char *name)
     * }
     */
    public static MethodHandle PyCapsule_IsValid$handle() {
        return PyCapsule_IsValid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyCapsule_IsValid(PyObject *capsule, const char *name)
     * }
     */
    public static MemorySegment PyCapsule_IsValid$address() {
        return PyCapsule_IsValid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyCapsule_IsValid(PyObject *capsule, const char *name)
     * }
     */
    public static int PyCapsule_IsValid(MemorySegment capsule, MemorySegment name) {
        var mh$ = PyCapsule_IsValid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCapsule_IsValid", capsule, name);
            }
            return (int)mh$.invokeExact(capsule, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCapsule_SetPointer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCapsule_SetPointer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyCapsule_SetPointer(PyObject *capsule, void *pointer)
     * }
     */
    public static FunctionDescriptor PyCapsule_SetPointer$descriptor() {
        return PyCapsule_SetPointer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyCapsule_SetPointer(PyObject *capsule, void *pointer)
     * }
     */
    public static MethodHandle PyCapsule_SetPointer$handle() {
        return PyCapsule_SetPointer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyCapsule_SetPointer(PyObject *capsule, void *pointer)
     * }
     */
    public static MemorySegment PyCapsule_SetPointer$address() {
        return PyCapsule_SetPointer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyCapsule_SetPointer(PyObject *capsule, void *pointer)
     * }
     */
    public static int PyCapsule_SetPointer(MemorySegment capsule, MemorySegment pointer) {
        var mh$ = PyCapsule_SetPointer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCapsule_SetPointer", capsule, pointer);
            }
            return (int)mh$.invokeExact(capsule, pointer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCapsule_SetDestructor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCapsule_SetDestructor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyCapsule_SetDestructor(PyObject *capsule, PyCapsule_Destructor destructor)
     * }
     */
    public static FunctionDescriptor PyCapsule_SetDestructor$descriptor() {
        return PyCapsule_SetDestructor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyCapsule_SetDestructor(PyObject *capsule, PyCapsule_Destructor destructor)
     * }
     */
    public static MethodHandle PyCapsule_SetDestructor$handle() {
        return PyCapsule_SetDestructor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyCapsule_SetDestructor(PyObject *capsule, PyCapsule_Destructor destructor)
     * }
     */
    public static MemorySegment PyCapsule_SetDestructor$address() {
        return PyCapsule_SetDestructor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyCapsule_SetDestructor(PyObject *capsule, PyCapsule_Destructor destructor)
     * }
     */
    public static int PyCapsule_SetDestructor(MemorySegment capsule, MemorySegment destructor) {
        var mh$ = PyCapsule_SetDestructor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCapsule_SetDestructor", capsule, destructor);
            }
            return (int)mh$.invokeExact(capsule, destructor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCapsule_SetName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCapsule_SetName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyCapsule_SetName(PyObject *capsule, const char *name)
     * }
     */
    public static FunctionDescriptor PyCapsule_SetName$descriptor() {
        return PyCapsule_SetName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyCapsule_SetName(PyObject *capsule, const char *name)
     * }
     */
    public static MethodHandle PyCapsule_SetName$handle() {
        return PyCapsule_SetName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyCapsule_SetName(PyObject *capsule, const char *name)
     * }
     */
    public static MemorySegment PyCapsule_SetName$address() {
        return PyCapsule_SetName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyCapsule_SetName(PyObject *capsule, const char *name)
     * }
     */
    public static int PyCapsule_SetName(MemorySegment capsule, MemorySegment name) {
        var mh$ = PyCapsule_SetName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCapsule_SetName", capsule, name);
            }
            return (int)mh$.invokeExact(capsule, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCapsule_SetContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCapsule_SetContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyCapsule_SetContext(PyObject *capsule, void *context)
     * }
     */
    public static FunctionDescriptor PyCapsule_SetContext$descriptor() {
        return PyCapsule_SetContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyCapsule_SetContext(PyObject *capsule, void *context)
     * }
     */
    public static MethodHandle PyCapsule_SetContext$handle() {
        return PyCapsule_SetContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyCapsule_SetContext(PyObject *capsule, void *context)
     * }
     */
    public static MemorySegment PyCapsule_SetContext$address() {
        return PyCapsule_SetContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyCapsule_SetContext(PyObject *capsule, void *context)
     * }
     */
    public static int PyCapsule_SetContext(MemorySegment capsule, MemorySegment context) {
        var mh$ = PyCapsule_SetContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCapsule_SetContext", capsule, context);
            }
            return (int)mh$.invokeExact(capsule, context);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCapsule_Import {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCapsule_Import");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *PyCapsule_Import(const char *name, int no_block)
     * }
     */
    public static FunctionDescriptor PyCapsule_Import$descriptor() {
        return PyCapsule_Import.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *PyCapsule_Import(const char *name, int no_block)
     * }
     */
    public static MethodHandle PyCapsule_Import$handle() {
        return PyCapsule_Import.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *PyCapsule_Import(const char *name, int no_block)
     * }
     */
    public static MemorySegment PyCapsule_Import$address() {
        return PyCapsule_Import.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *PyCapsule_Import(const char *name, int no_block)
     * }
     */
    public static MemorySegment PyCapsule_Import(MemorySegment name, int no_block) {
        var mh$ = PyCapsule_Import.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCapsule_Import", name, no_block);
            }
            return (MemorySegment)mh$.invokeExact(name, no_block);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyFrame_GetLineNumber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyFrame_GetLineNumber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyFrame_GetLineNumber(PyFrameObject *)
     * }
     */
    public static FunctionDescriptor PyFrame_GetLineNumber$descriptor() {
        return PyFrame_GetLineNumber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyFrame_GetLineNumber(PyFrameObject *)
     * }
     */
    public static MethodHandle PyFrame_GetLineNumber$handle() {
        return PyFrame_GetLineNumber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyFrame_GetLineNumber(PyFrameObject *)
     * }
     */
    public static MemorySegment PyFrame_GetLineNumber$address() {
        return PyFrame_GetLineNumber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyFrame_GetLineNumber(PyFrameObject *)
     * }
     */
    public static int PyFrame_GetLineNumber(MemorySegment x0) {
        var mh$ = PyFrame_GetLineNumber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyFrame_GetLineNumber", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyFrame_GetCode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyFrame_GetCode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyCodeObject *PyFrame_GetCode(PyFrameObject *frame)
     * }
     */
    public static FunctionDescriptor PyFrame_GetCode$descriptor() {
        return PyFrame_GetCode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyCodeObject *PyFrame_GetCode(PyFrameObject *frame)
     * }
     */
    public static MethodHandle PyFrame_GetCode$handle() {
        return PyFrame_GetCode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyCodeObject *PyFrame_GetCode(PyFrameObject *frame)
     * }
     */
    public static MemorySegment PyFrame_GetCode$address() {
        return PyFrame_GetCode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyCodeObject *PyFrame_GetCode(PyFrameObject *frame)
     * }
     */
    public static MemorySegment PyFrame_GetCode(MemorySegment frame) {
        var mh$ = PyFrame_GetCode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyFrame_GetCode", frame);
            }
            return (MemorySegment)mh$.invokeExact(frame);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyTraceBack_Here {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyTraceBack_Here");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyTraceBack_Here(PyFrameObject *)
     * }
     */
    public static FunctionDescriptor PyTraceBack_Here$descriptor() {
        return PyTraceBack_Here.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyTraceBack_Here(PyFrameObject *)
     * }
     */
    public static MethodHandle PyTraceBack_Here$handle() {
        return PyTraceBack_Here.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyTraceBack_Here(PyFrameObject *)
     * }
     */
    public static MemorySegment PyTraceBack_Here$address() {
        return PyTraceBack_Here.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyTraceBack_Here(PyFrameObject *)
     * }
     */
    public static int PyTraceBack_Here(MemorySegment x0) {
        var mh$ = PyTraceBack_Here.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyTraceBack_Here", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyTraceBack_Print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyTraceBack_Print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyTraceBack_Print(PyObject *, PyObject *)
     * }
     */
    public static FunctionDescriptor PyTraceBack_Print$descriptor() {
        return PyTraceBack_Print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyTraceBack_Print(PyObject *, PyObject *)
     * }
     */
    public static MethodHandle PyTraceBack_Print$handle() {
        return PyTraceBack_Print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyTraceBack_Print(PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyTraceBack_Print$address() {
        return PyTraceBack_Print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyTraceBack_Print(PyObject *, PyObject *)
     * }
     */
    public static int PyTraceBack_Print(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyTraceBack_Print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyTraceBack_Print", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyTraceBack_Type$constants {
        public static final GroupLayout LAYOUT = _object.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyTraceBack_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyTraceBack_Type
     * }
     */
    public static GroupLayout PyTraceBack_Type$layout() {
        return PyTraceBack_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyTraceBack_Type
     * }
     */
    public static MemorySegment PyTraceBack_Type() {
        return PyTraceBack_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyTraceBack_Type
     * }
     */
    public static void PyTraceBack_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyTraceBack_Type$constants.SEGMENT, 0L, PyTraceBack_Type$constants.LAYOUT.byteSize());
    }

    private static class _Py_EllipsisObject$constants {
        public static final GroupLayout LAYOUT = _object.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("_Py_EllipsisObject").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject _Py_EllipsisObject
     * }
     */
    public static GroupLayout _Py_EllipsisObject$layout() {
        return _Py_EllipsisObject$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject _Py_EllipsisObject
     * }
     */
    public static MemorySegment _Py_EllipsisObject() {
        return _Py_EllipsisObject$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject _Py_EllipsisObject
     * }
     */
    public static void _Py_EllipsisObject(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, _Py_EllipsisObject$constants.SEGMENT, 0L, _Py_EllipsisObject$constants.LAYOUT.byteSize());
    }

    private static class PySlice_Type$constants {
        public static final GroupLayout LAYOUT = _object.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PySlice_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PySlice_Type
     * }
     */
    public static GroupLayout PySlice_Type$layout() {
        return PySlice_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PySlice_Type
     * }
     */
    public static MemorySegment PySlice_Type() {
        return PySlice_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PySlice_Type
     * }
     */
    public static void PySlice_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PySlice_Type$constants.SEGMENT, 0L, PySlice_Type$constants.LAYOUT.byteSize());
    }

    private static class PyEllipsis_Type$constants {
        public static final GroupLayout LAYOUT = _object.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyEllipsis_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyEllipsis_Type
     * }
     */
    public static GroupLayout PyEllipsis_Type$layout() {
        return PyEllipsis_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyEllipsis_Type
     * }
     */
    public static MemorySegment PyEllipsis_Type() {
        return PyEllipsis_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyEllipsis_Type
     * }
     */
    public static void PyEllipsis_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyEllipsis_Type$constants.SEGMENT, 0L, PyEllipsis_Type$constants.LAYOUT.byteSize());
    }

    private static class PySlice_New {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PySlice_New");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PySlice_New(PyObject *start, PyObject *stop, PyObject *step)
     * }
     */
    public static FunctionDescriptor PySlice_New$descriptor() {
        return PySlice_New.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PySlice_New(PyObject *start, PyObject *stop, PyObject *step)
     * }
     */
    public static MethodHandle PySlice_New$handle() {
        return PySlice_New.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PySlice_New(PyObject *start, PyObject *stop, PyObject *step)
     * }
     */
    public static MemorySegment PySlice_New$address() {
        return PySlice_New.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PySlice_New(PyObject *start, PyObject *stop, PyObject *step)
     * }
     */
    public static MemorySegment PySlice_New(MemorySegment start, MemorySegment stop, MemorySegment step) {
        var mh$ = PySlice_New.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PySlice_New", start, stop, step);
            }
            return (MemorySegment)mh$.invokeExact(start, stop, step);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PySlice_GetIndices {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PySlice_GetIndices");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PySlice_GetIndices(PyObject *r, Py_ssize_t length, Py_ssize_t *start, Py_ssize_t *stop, Py_ssize_t *step)
     * }
     */
    public static FunctionDescriptor PySlice_GetIndices$descriptor() {
        return PySlice_GetIndices.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PySlice_GetIndices(PyObject *r, Py_ssize_t length, Py_ssize_t *start, Py_ssize_t *stop, Py_ssize_t *step)
     * }
     */
    public static MethodHandle PySlice_GetIndices$handle() {
        return PySlice_GetIndices.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PySlice_GetIndices(PyObject *r, Py_ssize_t length, Py_ssize_t *start, Py_ssize_t *stop, Py_ssize_t *step)
     * }
     */
    public static MemorySegment PySlice_GetIndices$address() {
        return PySlice_GetIndices.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PySlice_GetIndices(PyObject *r, Py_ssize_t length, Py_ssize_t *start, Py_ssize_t *stop, Py_ssize_t *step)
     * }
     */
    public static int PySlice_GetIndices(MemorySegment r, long length, MemorySegment start, MemorySegment stop, MemorySegment step) {
        var mh$ = PySlice_GetIndices.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PySlice_GetIndices", r, length, start, stop, step);
            }
            return (int)mh$.invokeExact(r, length, start, stop, step);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PySlice_GetIndicesEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PySlice_GetIndicesEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PySlice_GetIndicesEx(PyObject *r, Py_ssize_t length, Py_ssize_t *start, Py_ssize_t *stop, Py_ssize_t *step, Py_ssize_t *slicelength)
     * }
     */
    public static FunctionDescriptor PySlice_GetIndicesEx$descriptor() {
        return PySlice_GetIndicesEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PySlice_GetIndicesEx(PyObject *r, Py_ssize_t length, Py_ssize_t *start, Py_ssize_t *stop, Py_ssize_t *step, Py_ssize_t *slicelength)
     * }
     */
    public static MethodHandle PySlice_GetIndicesEx$handle() {
        return PySlice_GetIndicesEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PySlice_GetIndicesEx(PyObject *r, Py_ssize_t length, Py_ssize_t *start, Py_ssize_t *stop, Py_ssize_t *step, Py_ssize_t *slicelength)
     * }
     */
    public static MemorySegment PySlice_GetIndicesEx$address() {
        return PySlice_GetIndicesEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PySlice_GetIndicesEx(PyObject *r, Py_ssize_t length, Py_ssize_t *start, Py_ssize_t *stop, Py_ssize_t *step, Py_ssize_t *slicelength)
     * }
     */
    public static int PySlice_GetIndicesEx(MemorySegment r, long length, MemorySegment start, MemorySegment stop, MemorySegment step, MemorySegment slicelength) {
        var mh$ = PySlice_GetIndicesEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PySlice_GetIndicesEx", r, length, start, stop, step, slicelength);
            }
            return (int)mh$.invokeExact(r, length, start, stop, step, slicelength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PySlice_Unpack {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PySlice_Unpack");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PySlice_Unpack(PyObject *slice, Py_ssize_t *start, Py_ssize_t *stop, Py_ssize_t *step)
     * }
     */
    public static FunctionDescriptor PySlice_Unpack$descriptor() {
        return PySlice_Unpack.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PySlice_Unpack(PyObject *slice, Py_ssize_t *start, Py_ssize_t *stop, Py_ssize_t *step)
     * }
     */
    public static MethodHandle PySlice_Unpack$handle() {
        return PySlice_Unpack.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PySlice_Unpack(PyObject *slice, Py_ssize_t *start, Py_ssize_t *stop, Py_ssize_t *step)
     * }
     */
    public static MemorySegment PySlice_Unpack$address() {
        return PySlice_Unpack.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PySlice_Unpack(PyObject *slice, Py_ssize_t *start, Py_ssize_t *stop, Py_ssize_t *step)
     * }
     */
    public static int PySlice_Unpack(MemorySegment slice, MemorySegment start, MemorySegment stop, MemorySegment step) {
        var mh$ = PySlice_Unpack.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PySlice_Unpack", slice, start, stop, step);
            }
            return (int)mh$.invokeExact(slice, start, stop, step);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PySlice_AdjustIndices {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PySlice_AdjustIndices");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_ssize_t PySlice_AdjustIndices(Py_ssize_t length, Py_ssize_t *start, Py_ssize_t *stop, Py_ssize_t step)
     * }
     */
    public static FunctionDescriptor PySlice_AdjustIndices$descriptor() {
        return PySlice_AdjustIndices.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_ssize_t PySlice_AdjustIndices(Py_ssize_t length, Py_ssize_t *start, Py_ssize_t *stop, Py_ssize_t step)
     * }
     */
    public static MethodHandle PySlice_AdjustIndices$handle() {
        return PySlice_AdjustIndices.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_ssize_t PySlice_AdjustIndices(Py_ssize_t length, Py_ssize_t *start, Py_ssize_t *stop, Py_ssize_t step)
     * }
     */
    public static MemorySegment PySlice_AdjustIndices$address() {
        return PySlice_AdjustIndices.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_ssize_t PySlice_AdjustIndices(Py_ssize_t length, Py_ssize_t *start, Py_ssize_t *stop, Py_ssize_t step)
     * }
     */
    public static long PySlice_AdjustIndices(long length, MemorySegment start, MemorySegment stop, long step) {
        var mh$ = PySlice_AdjustIndices.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PySlice_AdjustIndices", length, start, stop, step);
            }
            return (long)mh$.invokeExact(length, start, stop, step);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PySeqIter_Type$constants {
        public static final GroupLayout LAYOUT = _object.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PySeqIter_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PySeqIter_Type
     * }
     */
    public static GroupLayout PySeqIter_Type$layout() {
        return PySeqIter_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PySeqIter_Type
     * }
     */
    public static MemorySegment PySeqIter_Type() {
        return PySeqIter_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PySeqIter_Type
     * }
     */
    public static void PySeqIter_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PySeqIter_Type$constants.SEGMENT, 0L, PySeqIter_Type$constants.LAYOUT.byteSize());
    }

    private static class PyCallIter_Type$constants {
        public static final GroupLayout LAYOUT = _object.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyCallIter_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyCallIter_Type
     * }
     */
    public static GroupLayout PyCallIter_Type$layout() {
        return PyCallIter_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyCallIter_Type
     * }
     */
    public static MemorySegment PyCallIter_Type() {
        return PyCallIter_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyCallIter_Type
     * }
     */
    public static void PyCallIter_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyCallIter_Type$constants.SEGMENT, 0L, PyCallIter_Type$constants.LAYOUT.byteSize());
    }

    private static class PySeqIter_New {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PySeqIter_New");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PySeqIter_New(PyObject *)
     * }
     */
    public static FunctionDescriptor PySeqIter_New$descriptor() {
        return PySeqIter_New.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PySeqIter_New(PyObject *)
     * }
     */
    public static MethodHandle PySeqIter_New$handle() {
        return PySeqIter_New.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PySeqIter_New(PyObject *)
     * }
     */
    public static MemorySegment PySeqIter_New$address() {
        return PySeqIter_New.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PySeqIter_New(PyObject *)
     * }
     */
    public static MemorySegment PySeqIter_New(MemorySegment x0) {
        var mh$ = PySeqIter_New.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PySeqIter_New", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCallIter_New {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCallIter_New");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyCallIter_New(PyObject *, PyObject *)
     * }
     */
    public static FunctionDescriptor PyCallIter_New$descriptor() {
        return PyCallIter_New.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyCallIter_New(PyObject *, PyObject *)
     * }
     */
    public static MethodHandle PyCallIter_New$handle() {
        return PyCallIter_New.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyCallIter_New(PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyCallIter_New$address() {
        return PyCallIter_New.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyCallIter_New(PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyCallIter_New(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyCallIter_New.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCallIter_New", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyInterpreterState_New {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyInterpreterState_New");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyInterpreterState *PyInterpreterState_New()
     * }
     */
    public static FunctionDescriptor PyInterpreterState_New$descriptor() {
        return PyInterpreterState_New.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyInterpreterState *PyInterpreterState_New()
     * }
     */
    public static MethodHandle PyInterpreterState_New$handle() {
        return PyInterpreterState_New.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyInterpreterState *PyInterpreterState_New()
     * }
     */
    public static MemorySegment PyInterpreterState_New$address() {
        return PyInterpreterState_New.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyInterpreterState *PyInterpreterState_New()
     * }
     */
    public static MemorySegment PyInterpreterState_New() {
        var mh$ = PyInterpreterState_New.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyInterpreterState_New");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyInterpreterState_Clear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyInterpreterState_Clear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyInterpreterState_Clear(PyInterpreterState *)
     * }
     */
    public static FunctionDescriptor PyInterpreterState_Clear$descriptor() {
        return PyInterpreterState_Clear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyInterpreterState_Clear(PyInterpreterState *)
     * }
     */
    public static MethodHandle PyInterpreterState_Clear$handle() {
        return PyInterpreterState_Clear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyInterpreterState_Clear(PyInterpreterState *)
     * }
     */
    public static MemorySegment PyInterpreterState_Clear$address() {
        return PyInterpreterState_Clear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyInterpreterState_Clear(PyInterpreterState *)
     * }
     */
    public static void PyInterpreterState_Clear(MemorySegment x0) {
        var mh$ = PyInterpreterState_Clear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyInterpreterState_Clear", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyInterpreterState_Delete {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyInterpreterState_Delete");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyInterpreterState_Delete(PyInterpreterState *)
     * }
     */
    public static FunctionDescriptor PyInterpreterState_Delete$descriptor() {
        return PyInterpreterState_Delete.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyInterpreterState_Delete(PyInterpreterState *)
     * }
     */
    public static MethodHandle PyInterpreterState_Delete$handle() {
        return PyInterpreterState_Delete.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyInterpreterState_Delete(PyInterpreterState *)
     * }
     */
    public static MemorySegment PyInterpreterState_Delete$address() {
        return PyInterpreterState_Delete.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyInterpreterState_Delete(PyInterpreterState *)
     * }
     */
    public static void PyInterpreterState_Delete(MemorySegment x0) {
        var mh$ = PyInterpreterState_Delete.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyInterpreterState_Delete", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyInterpreterState_Get {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyInterpreterState_Get");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyInterpreterState *PyInterpreterState_Get()
     * }
     */
    public static FunctionDescriptor PyInterpreterState_Get$descriptor() {
        return PyInterpreterState_Get.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyInterpreterState *PyInterpreterState_Get()
     * }
     */
    public static MethodHandle PyInterpreterState_Get$handle() {
        return PyInterpreterState_Get.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyInterpreterState *PyInterpreterState_Get()
     * }
     */
    public static MemorySegment PyInterpreterState_Get$address() {
        return PyInterpreterState_Get.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyInterpreterState *PyInterpreterState_Get()
     * }
     */
    public static MemorySegment PyInterpreterState_Get() {
        var mh$ = PyInterpreterState_Get.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyInterpreterState_Get");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyInterpreterState_GetDict {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyInterpreterState_GetDict");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyInterpreterState_GetDict(PyInterpreterState *)
     * }
     */
    public static FunctionDescriptor PyInterpreterState_GetDict$descriptor() {
        return PyInterpreterState_GetDict.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyInterpreterState_GetDict(PyInterpreterState *)
     * }
     */
    public static MethodHandle PyInterpreterState_GetDict$handle() {
        return PyInterpreterState_GetDict.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyInterpreterState_GetDict(PyInterpreterState *)
     * }
     */
    public static MemorySegment PyInterpreterState_GetDict$address() {
        return PyInterpreterState_GetDict.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyInterpreterState_GetDict(PyInterpreterState *)
     * }
     */
    public static MemorySegment PyInterpreterState_GetDict(MemorySegment x0) {
        var mh$ = PyInterpreterState_GetDict.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyInterpreterState_GetDict", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyInterpreterState_GetID {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyInterpreterState_GetID");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int64_t PyInterpreterState_GetID(PyInterpreterState *)
     * }
     */
    public static FunctionDescriptor PyInterpreterState_GetID$descriptor() {
        return PyInterpreterState_GetID.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int64_t PyInterpreterState_GetID(PyInterpreterState *)
     * }
     */
    public static MethodHandle PyInterpreterState_GetID$handle() {
        return PyInterpreterState_GetID.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int64_t PyInterpreterState_GetID(PyInterpreterState *)
     * }
     */
    public static MemorySegment PyInterpreterState_GetID$address() {
        return PyInterpreterState_GetID.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int64_t PyInterpreterState_GetID(PyInterpreterState *)
     * }
     */
    public static long PyInterpreterState_GetID(MemorySegment x0) {
        var mh$ = PyInterpreterState_GetID.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyInterpreterState_GetID", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyState_AddModule {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyState_AddModule");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyState_AddModule(PyObject *, PyModuleDef *)
     * }
     */
    public static FunctionDescriptor PyState_AddModule$descriptor() {
        return PyState_AddModule.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyState_AddModule(PyObject *, PyModuleDef *)
     * }
     */
    public static MethodHandle PyState_AddModule$handle() {
        return PyState_AddModule.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyState_AddModule(PyObject *, PyModuleDef *)
     * }
     */
    public static MemorySegment PyState_AddModule$address() {
        return PyState_AddModule.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyState_AddModule(PyObject *, PyModuleDef *)
     * }
     */
    public static int PyState_AddModule(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyState_AddModule.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyState_AddModule", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyState_RemoveModule {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyState_RemoveModule");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyState_RemoveModule(PyModuleDef *)
     * }
     */
    public static FunctionDescriptor PyState_RemoveModule$descriptor() {
        return PyState_RemoveModule.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyState_RemoveModule(PyModuleDef *)
     * }
     */
    public static MethodHandle PyState_RemoveModule$handle() {
        return PyState_RemoveModule.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyState_RemoveModule(PyModuleDef *)
     * }
     */
    public static MemorySegment PyState_RemoveModule$address() {
        return PyState_RemoveModule.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyState_RemoveModule(PyModuleDef *)
     * }
     */
    public static int PyState_RemoveModule(MemorySegment x0) {
        var mh$ = PyState_RemoveModule.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyState_RemoveModule", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyState_FindModule {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyState_FindModule");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyState_FindModule(PyModuleDef *)
     * }
     */
    public static FunctionDescriptor PyState_FindModule$descriptor() {
        return PyState_FindModule.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyState_FindModule(PyModuleDef *)
     * }
     */
    public static MethodHandle PyState_FindModule$handle() {
        return PyState_FindModule.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyState_FindModule(PyModuleDef *)
     * }
     */
    public static MemorySegment PyState_FindModule$address() {
        return PyState_FindModule.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyState_FindModule(PyModuleDef *)
     * }
     */
    public static MemorySegment PyState_FindModule(MemorySegment x0) {
        var mh$ = PyState_FindModule.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyState_FindModule", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyThreadState_New {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyThreadState_New");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyThreadState *PyThreadState_New(PyInterpreterState *)
     * }
     */
    public static FunctionDescriptor PyThreadState_New$descriptor() {
        return PyThreadState_New.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyThreadState *PyThreadState_New(PyInterpreterState *)
     * }
     */
    public static MethodHandle PyThreadState_New$handle() {
        return PyThreadState_New.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyThreadState *PyThreadState_New(PyInterpreterState *)
     * }
     */
    public static MemorySegment PyThreadState_New$address() {
        return PyThreadState_New.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyThreadState *PyThreadState_New(PyInterpreterState *)
     * }
     */
    public static MemorySegment PyThreadState_New(MemorySegment x0) {
        var mh$ = PyThreadState_New.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyThreadState_New", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyThreadState_Clear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyThreadState_Clear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyThreadState_Clear(PyThreadState *)
     * }
     */
    public static FunctionDescriptor PyThreadState_Clear$descriptor() {
        return PyThreadState_Clear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyThreadState_Clear(PyThreadState *)
     * }
     */
    public static MethodHandle PyThreadState_Clear$handle() {
        return PyThreadState_Clear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyThreadState_Clear(PyThreadState *)
     * }
     */
    public static MemorySegment PyThreadState_Clear$address() {
        return PyThreadState_Clear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyThreadState_Clear(PyThreadState *)
     * }
     */
    public static void PyThreadState_Clear(MemorySegment x0) {
        var mh$ = PyThreadState_Clear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyThreadState_Clear", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyThreadState_Delete {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyThreadState_Delete");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyThreadState_Delete(PyThreadState *)
     * }
     */
    public static FunctionDescriptor PyThreadState_Delete$descriptor() {
        return PyThreadState_Delete.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyThreadState_Delete(PyThreadState *)
     * }
     */
    public static MethodHandle PyThreadState_Delete$handle() {
        return PyThreadState_Delete.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyThreadState_Delete(PyThreadState *)
     * }
     */
    public static MemorySegment PyThreadState_Delete$address() {
        return PyThreadState_Delete.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyThreadState_Delete(PyThreadState *)
     * }
     */
    public static void PyThreadState_Delete(MemorySegment x0) {
        var mh$ = PyThreadState_Delete.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyThreadState_Delete", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyThreadState_Get {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyThreadState_Get");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyThreadState *PyThreadState_Get()
     * }
     */
    public static FunctionDescriptor PyThreadState_Get$descriptor() {
        return PyThreadState_Get.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyThreadState *PyThreadState_Get()
     * }
     */
    public static MethodHandle PyThreadState_Get$handle() {
        return PyThreadState_Get.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyThreadState *PyThreadState_Get()
     * }
     */
    public static MemorySegment PyThreadState_Get$address() {
        return PyThreadState_Get.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyThreadState *PyThreadState_Get()
     * }
     */
    public static MemorySegment PyThreadState_Get() {
        var mh$ = PyThreadState_Get.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyThreadState_Get");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyThreadState_Swap {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyThreadState_Swap");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyThreadState *PyThreadState_Swap(PyThreadState *)
     * }
     */
    public static FunctionDescriptor PyThreadState_Swap$descriptor() {
        return PyThreadState_Swap.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyThreadState *PyThreadState_Swap(PyThreadState *)
     * }
     */
    public static MethodHandle PyThreadState_Swap$handle() {
        return PyThreadState_Swap.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyThreadState *PyThreadState_Swap(PyThreadState *)
     * }
     */
    public static MemorySegment PyThreadState_Swap$address() {
        return PyThreadState_Swap.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyThreadState *PyThreadState_Swap(PyThreadState *)
     * }
     */
    public static MemorySegment PyThreadState_Swap(MemorySegment x0) {
        var mh$ = PyThreadState_Swap.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyThreadState_Swap", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyThreadState_GetDict {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyThreadState_GetDict");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyThreadState_GetDict()
     * }
     */
    public static FunctionDescriptor PyThreadState_GetDict$descriptor() {
        return PyThreadState_GetDict.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyThreadState_GetDict()
     * }
     */
    public static MethodHandle PyThreadState_GetDict$handle() {
        return PyThreadState_GetDict.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyThreadState_GetDict()
     * }
     */
    public static MemorySegment PyThreadState_GetDict$address() {
        return PyThreadState_GetDict.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyThreadState_GetDict()
     * }
     */
    public static MemorySegment PyThreadState_GetDict() {
        var mh$ = PyThreadState_GetDict.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyThreadState_GetDict");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyThreadState_SetAsyncExc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyThreadState_SetAsyncExc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyThreadState_SetAsyncExc(unsigned long, PyObject *)
     * }
     */
    public static FunctionDescriptor PyThreadState_SetAsyncExc$descriptor() {
        return PyThreadState_SetAsyncExc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyThreadState_SetAsyncExc(unsigned long, PyObject *)
     * }
     */
    public static MethodHandle PyThreadState_SetAsyncExc$handle() {
        return PyThreadState_SetAsyncExc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyThreadState_SetAsyncExc(unsigned long, PyObject *)
     * }
     */
    public static MemorySegment PyThreadState_SetAsyncExc$address() {
        return PyThreadState_SetAsyncExc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyThreadState_SetAsyncExc(unsigned long, PyObject *)
     * }
     */
    public static int PyThreadState_SetAsyncExc(int x0, MemorySegment x1) {
        var mh$ = PyThreadState_SetAsyncExc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyThreadState_SetAsyncExc", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyThreadState_GetInterpreter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyThreadState_GetInterpreter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyInterpreterState *PyThreadState_GetInterpreter(PyThreadState *tstate)
     * }
     */
    public static FunctionDescriptor PyThreadState_GetInterpreter$descriptor() {
        return PyThreadState_GetInterpreter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyInterpreterState *PyThreadState_GetInterpreter(PyThreadState *tstate)
     * }
     */
    public static MethodHandle PyThreadState_GetInterpreter$handle() {
        return PyThreadState_GetInterpreter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyInterpreterState *PyThreadState_GetInterpreter(PyThreadState *tstate)
     * }
     */
    public static MemorySegment PyThreadState_GetInterpreter$address() {
        return PyThreadState_GetInterpreter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyInterpreterState *PyThreadState_GetInterpreter(PyThreadState *tstate)
     * }
     */
    public static MemorySegment PyThreadState_GetInterpreter(MemorySegment tstate) {
        var mh$ = PyThreadState_GetInterpreter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyThreadState_GetInterpreter", tstate);
            }
            return (MemorySegment)mh$.invokeExact(tstate);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyThreadState_GetFrame {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyThreadState_GetFrame");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyFrameObject *PyThreadState_GetFrame(PyThreadState *tstate)
     * }
     */
    public static FunctionDescriptor PyThreadState_GetFrame$descriptor() {
        return PyThreadState_GetFrame.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyFrameObject *PyThreadState_GetFrame(PyThreadState *tstate)
     * }
     */
    public static MethodHandle PyThreadState_GetFrame$handle() {
        return PyThreadState_GetFrame.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyFrameObject *PyThreadState_GetFrame(PyThreadState *tstate)
     * }
     */
    public static MemorySegment PyThreadState_GetFrame$address() {
        return PyThreadState_GetFrame.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyFrameObject *PyThreadState_GetFrame(PyThreadState *tstate)
     * }
     */
    public static MemorySegment PyThreadState_GetFrame(MemorySegment tstate) {
        var mh$ = PyThreadState_GetFrame.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyThreadState_GetFrame", tstate);
            }
            return (MemorySegment)mh$.invokeExact(tstate);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyThreadState_GetID {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyThreadState_GetID");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint64_t PyThreadState_GetID(PyThreadState *tstate)
     * }
     */
    public static FunctionDescriptor PyThreadState_GetID$descriptor() {
        return PyThreadState_GetID.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint64_t PyThreadState_GetID(PyThreadState *tstate)
     * }
     */
    public static MethodHandle PyThreadState_GetID$handle() {
        return PyThreadState_GetID.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uint64_t PyThreadState_GetID(PyThreadState *tstate)
     * }
     */
    public static MemorySegment PyThreadState_GetID$address() {
        return PyThreadState_GetID.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uint64_t PyThreadState_GetID(PyThreadState *tstate)
     * }
     */
    public static long PyThreadState_GetID(MemorySegment tstate) {
        var mh$ = PyThreadState_GetID.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyThreadState_GetID", tstate);
            }
            return (long)mh$.invokeExact(tstate);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int PyGILState_LOCKED = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PyGILState_LOCKED = 0
     * }
     */
    public static int PyGILState_LOCKED() {
        return PyGILState_LOCKED;
    }
    private static final int PyGILState_UNLOCKED = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PyGILState_UNLOCKED = 1
     * }
     */
    public static int PyGILState_UNLOCKED() {
        return PyGILState_UNLOCKED;
    }

    private static class PyGILState_Ensure {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyGILState_Ensure");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyGILState_STATE PyGILState_Ensure()
     * }
     */
    public static FunctionDescriptor PyGILState_Ensure$descriptor() {
        return PyGILState_Ensure.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyGILState_STATE PyGILState_Ensure()
     * }
     */
    public static MethodHandle PyGILState_Ensure$handle() {
        return PyGILState_Ensure.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyGILState_STATE PyGILState_Ensure()
     * }
     */
    public static MemorySegment PyGILState_Ensure$address() {
        return PyGILState_Ensure.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyGILState_STATE PyGILState_Ensure()
     * }
     */
    public static int PyGILState_Ensure() {
        var mh$ = PyGILState_Ensure.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyGILState_Ensure");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyGILState_Release {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyGILState_Release");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyGILState_Release(PyGILState_STATE)
     * }
     */
    public static FunctionDescriptor PyGILState_Release$descriptor() {
        return PyGILState_Release.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyGILState_Release(PyGILState_STATE)
     * }
     */
    public static MethodHandle PyGILState_Release$handle() {
        return PyGILState_Release.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyGILState_Release(PyGILState_STATE)
     * }
     */
    public static MemorySegment PyGILState_Release$address() {
        return PyGILState_Release.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyGILState_Release(PyGILState_STATE)
     * }
     */
    public static void PyGILState_Release(int x0) {
        var mh$ = PyGILState_Release.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyGILState_Release", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyGILState_GetThisThreadState {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyGILState_GetThisThreadState");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyThreadState *PyGILState_GetThisThreadState()
     * }
     */
    public static FunctionDescriptor PyGILState_GetThisThreadState$descriptor() {
        return PyGILState_GetThisThreadState.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyThreadState *PyGILState_GetThisThreadState()
     * }
     */
    public static MethodHandle PyGILState_GetThisThreadState$handle() {
        return PyGILState_GetThisThreadState.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyThreadState *PyGILState_GetThisThreadState()
     * }
     */
    public static MemorySegment PyGILState_GetThisThreadState$address() {
        return PyGILState_GetThisThreadState.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyThreadState *PyGILState_GetThisThreadState()
     * }
     */
    public static MemorySegment PyGILState_GetThisThreadState() {
        var mh$ = PyGILState_GetThisThreadState.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyGILState_GetThisThreadState");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyClassMethodDescr_Type$constants {
        public static final GroupLayout LAYOUT = _object.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyClassMethodDescr_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyClassMethodDescr_Type
     * }
     */
    public static GroupLayout PyClassMethodDescr_Type$layout() {
        return PyClassMethodDescr_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyClassMethodDescr_Type
     * }
     */
    public static MemorySegment PyClassMethodDescr_Type() {
        return PyClassMethodDescr_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyClassMethodDescr_Type
     * }
     */
    public static void PyClassMethodDescr_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyClassMethodDescr_Type$constants.SEGMENT, 0L, PyClassMethodDescr_Type$constants.LAYOUT.byteSize());
    }

    private static class PyGetSetDescr_Type$constants {
        public static final GroupLayout LAYOUT = _object.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyGetSetDescr_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyGetSetDescr_Type
     * }
     */
    public static GroupLayout PyGetSetDescr_Type$layout() {
        return PyGetSetDescr_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyGetSetDescr_Type
     * }
     */
    public static MemorySegment PyGetSetDescr_Type() {
        return PyGetSetDescr_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyGetSetDescr_Type
     * }
     */
    public static void PyGetSetDescr_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyGetSetDescr_Type$constants.SEGMENT, 0L, PyGetSetDescr_Type$constants.LAYOUT.byteSize());
    }

    private static class PyMemberDescr_Type$constants {
        public static final GroupLayout LAYOUT = _object.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyMemberDescr_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyMemberDescr_Type
     * }
     */
    public static GroupLayout PyMemberDescr_Type$layout() {
        return PyMemberDescr_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyMemberDescr_Type
     * }
     */
    public static MemorySegment PyMemberDescr_Type() {
        return PyMemberDescr_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyMemberDescr_Type
     * }
     */
    public static void PyMemberDescr_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyMemberDescr_Type$constants.SEGMENT, 0L, PyMemberDescr_Type$constants.LAYOUT.byteSize());
    }

    private static class PyMethodDescr_Type$constants {
        public static final GroupLayout LAYOUT = _object.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyMethodDescr_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyMethodDescr_Type
     * }
     */
    public static GroupLayout PyMethodDescr_Type$layout() {
        return PyMethodDescr_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyMethodDescr_Type
     * }
     */
    public static MemorySegment PyMethodDescr_Type() {
        return PyMethodDescr_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyMethodDescr_Type
     * }
     */
    public static void PyMethodDescr_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyMethodDescr_Type$constants.SEGMENT, 0L, PyMethodDescr_Type$constants.LAYOUT.byteSize());
    }

    private static class PyWrapperDescr_Type$constants {
        public static final GroupLayout LAYOUT = _object.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyWrapperDescr_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyWrapperDescr_Type
     * }
     */
    public static GroupLayout PyWrapperDescr_Type$layout() {
        return PyWrapperDescr_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyWrapperDescr_Type
     * }
     */
    public static MemorySegment PyWrapperDescr_Type() {
        return PyWrapperDescr_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyWrapperDescr_Type
     * }
     */
    public static void PyWrapperDescr_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyWrapperDescr_Type$constants.SEGMENT, 0L, PyWrapperDescr_Type$constants.LAYOUT.byteSize());
    }

    private static class PyDictProxy_Type$constants {
        public static final GroupLayout LAYOUT = _object.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyDictProxy_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyDictProxy_Type
     * }
     */
    public static GroupLayout PyDictProxy_Type$layout() {
        return PyDictProxy_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyDictProxy_Type
     * }
     */
    public static MemorySegment PyDictProxy_Type() {
        return PyDictProxy_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyDictProxy_Type
     * }
     */
    public static void PyDictProxy_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyDictProxy_Type$constants.SEGMENT, 0L, PyDictProxy_Type$constants.LAYOUT.byteSize());
    }

    private static class PyProperty_Type$constants {
        public static final GroupLayout LAYOUT = _object.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyProperty_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyProperty_Type
     * }
     */
    public static GroupLayout PyProperty_Type$layout() {
        return PyProperty_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyProperty_Type
     * }
     */
    public static MemorySegment PyProperty_Type() {
        return PyProperty_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyProperty_Type
     * }
     */
    public static void PyProperty_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyProperty_Type$constants.SEGMENT, 0L, PyProperty_Type$constants.LAYOUT.byteSize());
    }

    private static class PyDescr_NewMethod {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyDescr_NewMethod");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyDescr_NewMethod(PyTypeObject *, PyMethodDef *)
     * }
     */
    public static FunctionDescriptor PyDescr_NewMethod$descriptor() {
        return PyDescr_NewMethod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyDescr_NewMethod(PyTypeObject *, PyMethodDef *)
     * }
     */
    public static MethodHandle PyDescr_NewMethod$handle() {
        return PyDescr_NewMethod.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyDescr_NewMethod(PyTypeObject *, PyMethodDef *)
     * }
     */
    public static MemorySegment PyDescr_NewMethod$address() {
        return PyDescr_NewMethod.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyDescr_NewMethod(PyTypeObject *, PyMethodDef *)
     * }
     */
    public static MemorySegment PyDescr_NewMethod(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyDescr_NewMethod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyDescr_NewMethod", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyDescr_NewClassMethod {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyDescr_NewClassMethod");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyDescr_NewClassMethod(PyTypeObject *, PyMethodDef *)
     * }
     */
    public static FunctionDescriptor PyDescr_NewClassMethod$descriptor() {
        return PyDescr_NewClassMethod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyDescr_NewClassMethod(PyTypeObject *, PyMethodDef *)
     * }
     */
    public static MethodHandle PyDescr_NewClassMethod$handle() {
        return PyDescr_NewClassMethod.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyDescr_NewClassMethod(PyTypeObject *, PyMethodDef *)
     * }
     */
    public static MemorySegment PyDescr_NewClassMethod$address() {
        return PyDescr_NewClassMethod.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyDescr_NewClassMethod(PyTypeObject *, PyMethodDef *)
     * }
     */
    public static MemorySegment PyDescr_NewClassMethod(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyDescr_NewClassMethod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyDescr_NewClassMethod", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyDescr_NewMember {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyDescr_NewMember");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyDescr_NewMember(PyTypeObject *, PyMemberDef *)
     * }
     */
    public static FunctionDescriptor PyDescr_NewMember$descriptor() {
        return PyDescr_NewMember.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyDescr_NewMember(PyTypeObject *, PyMemberDef *)
     * }
     */
    public static MethodHandle PyDescr_NewMember$handle() {
        return PyDescr_NewMember.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyDescr_NewMember(PyTypeObject *, PyMemberDef *)
     * }
     */
    public static MemorySegment PyDescr_NewMember$address() {
        return PyDescr_NewMember.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyDescr_NewMember(PyTypeObject *, PyMemberDef *)
     * }
     */
    public static MemorySegment PyDescr_NewMember(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyDescr_NewMember.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyDescr_NewMember", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyDescr_NewGetSet {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyDescr_NewGetSet");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyDescr_NewGetSet(PyTypeObject *, PyGetSetDef *)
     * }
     */
    public static FunctionDescriptor PyDescr_NewGetSet$descriptor() {
        return PyDescr_NewGetSet.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyDescr_NewGetSet(PyTypeObject *, PyGetSetDef *)
     * }
     */
    public static MethodHandle PyDescr_NewGetSet$handle() {
        return PyDescr_NewGetSet.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyDescr_NewGetSet(PyTypeObject *, PyGetSetDef *)
     * }
     */
    public static MemorySegment PyDescr_NewGetSet$address() {
        return PyDescr_NewGetSet.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyDescr_NewGetSet(PyTypeObject *, PyGetSetDef *)
     * }
     */
    public static MemorySegment PyDescr_NewGetSet(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyDescr_NewGetSet.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyDescr_NewGetSet", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyDictProxy_New {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyDictProxy_New");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyDictProxy_New(PyObject *)
     * }
     */
    public static FunctionDescriptor PyDictProxy_New$descriptor() {
        return PyDictProxy_New.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyDictProxy_New(PyObject *)
     * }
     */
    public static MethodHandle PyDictProxy_New$handle() {
        return PyDictProxy_New.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyDictProxy_New(PyObject *)
     * }
     */
    public static MemorySegment PyDictProxy_New$address() {
        return PyDictProxy_New.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyDictProxy_New(PyObject *)
     * }
     */
    public static MemorySegment PyDictProxy_New(MemorySegment x0) {
        var mh$ = PyDictProxy_New.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyDictProxy_New", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyWrapper_New {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyWrapper_New");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyWrapper_New(PyObject *, PyObject *)
     * }
     */
    public static FunctionDescriptor PyWrapper_New$descriptor() {
        return PyWrapper_New.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyWrapper_New(PyObject *, PyObject *)
     * }
     */
    public static MethodHandle PyWrapper_New$handle() {
        return PyWrapper_New.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyWrapper_New(PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyWrapper_New$address() {
        return PyWrapper_New.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyWrapper_New(PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyWrapper_New(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyWrapper_New.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyWrapper_New", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyMember_GetOne {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyMember_GetOne");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyMember_GetOne(const char *, PyMemberDef *)
     * }
     */
    public static FunctionDescriptor PyMember_GetOne$descriptor() {
        return PyMember_GetOne.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyMember_GetOne(const char *, PyMemberDef *)
     * }
     */
    public static MethodHandle PyMember_GetOne$handle() {
        return PyMember_GetOne.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyMember_GetOne(const char *, PyMemberDef *)
     * }
     */
    public static MemorySegment PyMember_GetOne$address() {
        return PyMember_GetOne.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyMember_GetOne(const char *, PyMemberDef *)
     * }
     */
    public static MemorySegment PyMember_GetOne(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyMember_GetOne.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyMember_GetOne", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyMember_SetOne {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyMember_SetOne");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyMember_SetOne(char *, PyMemberDef *, PyObject *)
     * }
     */
    public static FunctionDescriptor PyMember_SetOne$descriptor() {
        return PyMember_SetOne.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyMember_SetOne(char *, PyMemberDef *, PyObject *)
     * }
     */
    public static MethodHandle PyMember_SetOne$handle() {
        return PyMember_SetOne.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyMember_SetOne(char *, PyMemberDef *, PyObject *)
     * }
     */
    public static MemorySegment PyMember_SetOne$address() {
        return PyMember_SetOne.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyMember_SetOne(char *, PyMemberDef *, PyObject *)
     * }
     */
    public static int PyMember_SetOne(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = PyMember_SetOne.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyMember_SetOne", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_GenericAlias {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_GenericAlias");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *Py_GenericAlias(PyObject *, PyObject *)
     * }
     */
    public static FunctionDescriptor Py_GenericAlias$descriptor() {
        return Py_GenericAlias.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *Py_GenericAlias(PyObject *, PyObject *)
     * }
     */
    public static MethodHandle Py_GenericAlias$handle() {
        return Py_GenericAlias.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *Py_GenericAlias(PyObject *, PyObject *)
     * }
     */
    public static MemorySegment Py_GenericAlias$address() {
        return Py_GenericAlias.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *Py_GenericAlias(PyObject *, PyObject *)
     * }
     */
    public static MemorySegment Py_GenericAlias(MemorySegment x0, MemorySegment x1) {
        var mh$ = Py_GenericAlias.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_GenericAlias", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_GenericAliasType$constants {
        public static final GroupLayout LAYOUT = _object.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("Py_GenericAliasType").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject Py_GenericAliasType
     * }
     */
    public static GroupLayout Py_GenericAliasType$layout() {
        return Py_GenericAliasType$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject Py_GenericAliasType
     * }
     */
    public static MemorySegment Py_GenericAliasType() {
        return Py_GenericAliasType$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject Py_GenericAliasType
     * }
     */
    public static void Py_GenericAliasType(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, Py_GenericAliasType$constants.SEGMENT, 0L, Py_GenericAliasType$constants.LAYOUT.byteSize());
    }

    private static class PyErr_WarnEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_WarnEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyErr_WarnEx(PyObject *category, const char *message, Py_ssize_t stack_level)
     * }
     */
    public static FunctionDescriptor PyErr_WarnEx$descriptor() {
        return PyErr_WarnEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyErr_WarnEx(PyObject *category, const char *message, Py_ssize_t stack_level)
     * }
     */
    public static MethodHandle PyErr_WarnEx$handle() {
        return PyErr_WarnEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyErr_WarnEx(PyObject *category, const char *message, Py_ssize_t stack_level)
     * }
     */
    public static MemorySegment PyErr_WarnEx$address() {
        return PyErr_WarnEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyErr_WarnEx(PyObject *category, const char *message, Py_ssize_t stack_level)
     * }
     */
    public static int PyErr_WarnEx(MemorySegment category, MemorySegment message, long stack_level) {
        var mh$ = PyErr_WarnEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyErr_WarnEx", category, message, stack_level);
            }
            return (int)mh$.invokeExact(category, message, stack_level);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int PyErr_WarnFormat(PyObject *category, Py_ssize_t stack_level, const char *format, ...)
     * }
     */
    public static class PyErr_WarnFormat {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_INT,
                Python_h.C_POINTER,
                Python_h.C_LONG_LONG,
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_WarnFormat");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private PyErr_WarnFormat(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int PyErr_WarnFormat(PyObject *category, Py_ssize_t stack_level, const char *format, ...)
         * }
         */
        public static PyErr_WarnFormat makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new PyErr_WarnFormat(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment category, long stack_level, MemorySegment format, Object... x3) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("PyErr_WarnFormat", category, stack_level, format, x3);
                }
                return (int)spreader.invokeExact(category, stack_level, format, x3);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int PyErr_ResourceWarning(PyObject *source, Py_ssize_t stack_level, const char *format, ...)
     * }
     */
    public static class PyErr_ResourceWarning {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_INT,
                Python_h.C_POINTER,
                Python_h.C_LONG_LONG,
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_ResourceWarning");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private PyErr_ResourceWarning(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int PyErr_ResourceWarning(PyObject *source, Py_ssize_t stack_level, const char *format, ...)
         * }
         */
        public static PyErr_ResourceWarning makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new PyErr_ResourceWarning(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment source, long stack_level, MemorySegment format, Object... x3) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("PyErr_ResourceWarning", source, stack_level, format, x3);
                }
                return (int)spreader.invokeExact(source, stack_level, format, x3);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class PyErr_WarnExplicit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_WarnExplicit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyErr_WarnExplicit(PyObject *category, const char *message, const char *filename, int lineno, const char *module, PyObject *registry)
     * }
     */
    public static FunctionDescriptor PyErr_WarnExplicit$descriptor() {
        return PyErr_WarnExplicit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyErr_WarnExplicit(PyObject *category, const char *message, const char *filename, int lineno, const char *module, PyObject *registry)
     * }
     */
    public static MethodHandle PyErr_WarnExplicit$handle() {
        return PyErr_WarnExplicit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyErr_WarnExplicit(PyObject *category, const char *message, const char *filename, int lineno, const char *module, PyObject *registry)
     * }
     */
    public static MemorySegment PyErr_WarnExplicit$address() {
        return PyErr_WarnExplicit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyErr_WarnExplicit(PyObject *category, const char *message, const char *filename, int lineno, const char *module, PyObject *registry)
     * }
     */
    public static int PyErr_WarnExplicit(MemorySegment category, MemorySegment message, MemorySegment filename, int lineno, MemorySegment module, MemorySegment registry) {
        var mh$ = PyErr_WarnExplicit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyErr_WarnExplicit", category, message, filename, lineno, module, registry);
            }
            return (int)mh$.invokeExact(category, message, filename, lineno, module, registry);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyWeakref_RefType$constants {
        public static final GroupLayout LAYOUT = _object.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("_PyWeakref_RefType").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject _PyWeakref_RefType
     * }
     */
    public static GroupLayout _PyWeakref_RefType$layout() {
        return _PyWeakref_RefType$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject _PyWeakref_RefType
     * }
     */
    public static MemorySegment _PyWeakref_RefType() {
        return _PyWeakref_RefType$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject _PyWeakref_RefType
     * }
     */
    public static void _PyWeakref_RefType(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, _PyWeakref_RefType$constants.SEGMENT, 0L, _PyWeakref_RefType$constants.LAYOUT.byteSize());
    }

    private static class _PyWeakref_ProxyType$constants {
        public static final GroupLayout LAYOUT = _object.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("_PyWeakref_ProxyType").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject _PyWeakref_ProxyType
     * }
     */
    public static GroupLayout _PyWeakref_ProxyType$layout() {
        return _PyWeakref_ProxyType$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject _PyWeakref_ProxyType
     * }
     */
    public static MemorySegment _PyWeakref_ProxyType() {
        return _PyWeakref_ProxyType$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject _PyWeakref_ProxyType
     * }
     */
    public static void _PyWeakref_ProxyType(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, _PyWeakref_ProxyType$constants.SEGMENT, 0L, _PyWeakref_ProxyType$constants.LAYOUT.byteSize());
    }

    private static class _PyWeakref_CallableProxyType$constants {
        public static final GroupLayout LAYOUT = _object.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("_PyWeakref_CallableProxyType").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject _PyWeakref_CallableProxyType
     * }
     */
    public static GroupLayout _PyWeakref_CallableProxyType$layout() {
        return _PyWeakref_CallableProxyType$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject _PyWeakref_CallableProxyType
     * }
     */
    public static MemorySegment _PyWeakref_CallableProxyType() {
        return _PyWeakref_CallableProxyType$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject _PyWeakref_CallableProxyType
     * }
     */
    public static void _PyWeakref_CallableProxyType(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, _PyWeakref_CallableProxyType$constants.SEGMENT, 0L, _PyWeakref_CallableProxyType$constants.LAYOUT.byteSize());
    }

    private static class PyWeakref_NewRef {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyWeakref_NewRef");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyWeakref_NewRef(PyObject *ob, PyObject *callback)
     * }
     */
    public static FunctionDescriptor PyWeakref_NewRef$descriptor() {
        return PyWeakref_NewRef.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyWeakref_NewRef(PyObject *ob, PyObject *callback)
     * }
     */
    public static MethodHandle PyWeakref_NewRef$handle() {
        return PyWeakref_NewRef.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyWeakref_NewRef(PyObject *ob, PyObject *callback)
     * }
     */
    public static MemorySegment PyWeakref_NewRef$address() {
        return PyWeakref_NewRef.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyWeakref_NewRef(PyObject *ob, PyObject *callback)
     * }
     */
    public static MemorySegment PyWeakref_NewRef(MemorySegment ob, MemorySegment callback) {
        var mh$ = PyWeakref_NewRef.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyWeakref_NewRef", ob, callback);
            }
            return (MemorySegment)mh$.invokeExact(ob, callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyWeakref_NewProxy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyWeakref_NewProxy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyWeakref_NewProxy(PyObject *ob, PyObject *callback)
     * }
     */
    public static FunctionDescriptor PyWeakref_NewProxy$descriptor() {
        return PyWeakref_NewProxy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyWeakref_NewProxy(PyObject *ob, PyObject *callback)
     * }
     */
    public static MethodHandle PyWeakref_NewProxy$handle() {
        return PyWeakref_NewProxy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyWeakref_NewProxy(PyObject *ob, PyObject *callback)
     * }
     */
    public static MemorySegment PyWeakref_NewProxy$address() {
        return PyWeakref_NewProxy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyWeakref_NewProxy(PyObject *ob, PyObject *callback)
     * }
     */
    public static MemorySegment PyWeakref_NewProxy(MemorySegment ob, MemorySegment callback) {
        var mh$ = PyWeakref_NewProxy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyWeakref_NewProxy", ob, callback);
            }
            return (MemorySegment)mh$.invokeExact(ob, callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyWeakref_GetObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyWeakref_GetObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyWeakref_GetObject(PyObject *ref)
     * }
     */
    public static FunctionDescriptor PyWeakref_GetObject$descriptor() {
        return PyWeakref_GetObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyWeakref_GetObject(PyObject *ref)
     * }
     */
    public static MethodHandle PyWeakref_GetObject$handle() {
        return PyWeakref_GetObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyWeakref_GetObject(PyObject *ref)
     * }
     */
    public static MemorySegment PyWeakref_GetObject$address() {
        return PyWeakref_GetObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyWeakref_GetObject(PyObject *ref)
     * }
     */
    public static MemorySegment PyWeakref_GetObject(MemorySegment ref) {
        var mh$ = PyWeakref_GetObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyWeakref_GetObject", ref);
            }
            return (MemorySegment)mh$.invokeExact(ref);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyStructSequence_UnnamedField$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyStructSequence_UnnamedField").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const char *const PyStructSequence_UnnamedField
     * }
     */
    public static AddressLayout PyStructSequence_UnnamedField$layout() {
        return PyStructSequence_UnnamedField$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const char *const PyStructSequence_UnnamedField
     * }
     */
    public static MemorySegment PyStructSequence_UnnamedField$segment() {
        return PyStructSequence_UnnamedField$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const char *const PyStructSequence_UnnamedField
     * }
     */
    public static MemorySegment PyStructSequence_UnnamedField() {
        return PyStructSequence_UnnamedField$constants.SEGMENT.get(PyStructSequence_UnnamedField$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const char *const PyStructSequence_UnnamedField
     * }
     */
    public static void PyStructSequence_UnnamedField(MemorySegment varValue) {
        PyStructSequence_UnnamedField$constants.SEGMENT.set(PyStructSequence_UnnamedField$constants.LAYOUT, 0L, varValue);
    }

    private static class PyStructSequence_NewType {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyStructSequence_NewType");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyTypeObject *PyStructSequence_NewType(PyStructSequence_Desc *desc)
     * }
     */
    public static FunctionDescriptor PyStructSequence_NewType$descriptor() {
        return PyStructSequence_NewType.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyTypeObject *PyStructSequence_NewType(PyStructSequence_Desc *desc)
     * }
     */
    public static MethodHandle PyStructSequence_NewType$handle() {
        return PyStructSequence_NewType.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyTypeObject *PyStructSequence_NewType(PyStructSequence_Desc *desc)
     * }
     */
    public static MemorySegment PyStructSequence_NewType$address() {
        return PyStructSequence_NewType.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyTypeObject *PyStructSequence_NewType(PyStructSequence_Desc *desc)
     * }
     */
    public static MemorySegment PyStructSequence_NewType(MemorySegment desc) {
        var mh$ = PyStructSequence_NewType.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyStructSequence_NewType", desc);
            }
            return (MemorySegment)mh$.invokeExact(desc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyStructSequence_New {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyStructSequence_New");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyStructSequence_New(PyTypeObject *type)
     * }
     */
    public static FunctionDescriptor PyStructSequence_New$descriptor() {
        return PyStructSequence_New.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyStructSequence_New(PyTypeObject *type)
     * }
     */
    public static MethodHandle PyStructSequence_New$handle() {
        return PyStructSequence_New.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyStructSequence_New(PyTypeObject *type)
     * }
     */
    public static MemorySegment PyStructSequence_New$address() {
        return PyStructSequence_New.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyStructSequence_New(PyTypeObject *type)
     * }
     */
    public static MemorySegment PyStructSequence_New(MemorySegment type) {
        var mh$ = PyStructSequence_New.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyStructSequence_New", type);
            }
            return (MemorySegment)mh$.invokeExact(type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyStructSequence_SetItem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyStructSequence_SetItem");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyStructSequence_SetItem(PyObject *, Py_ssize_t, PyObject *)
     * }
     */
    public static FunctionDescriptor PyStructSequence_SetItem$descriptor() {
        return PyStructSequence_SetItem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyStructSequence_SetItem(PyObject *, Py_ssize_t, PyObject *)
     * }
     */
    public static MethodHandle PyStructSequence_SetItem$handle() {
        return PyStructSequence_SetItem.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyStructSequence_SetItem(PyObject *, Py_ssize_t, PyObject *)
     * }
     */
    public static MemorySegment PyStructSequence_SetItem$address() {
        return PyStructSequence_SetItem.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyStructSequence_SetItem(PyObject *, Py_ssize_t, PyObject *)
     * }
     */
    public static void PyStructSequence_SetItem(MemorySegment x0, long x1, MemorySegment x2) {
        var mh$ = PyStructSequence_SetItem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyStructSequence_SetItem", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyStructSequence_GetItem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyStructSequence_GetItem");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyStructSequence_GetItem(PyObject *, Py_ssize_t)
     * }
     */
    public static FunctionDescriptor PyStructSequence_GetItem$descriptor() {
        return PyStructSequence_GetItem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyStructSequence_GetItem(PyObject *, Py_ssize_t)
     * }
     */
    public static MethodHandle PyStructSequence_GetItem$handle() {
        return PyStructSequence_GetItem.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyStructSequence_GetItem(PyObject *, Py_ssize_t)
     * }
     */
    public static MemorySegment PyStructSequence_GetItem$address() {
        return PyStructSequence_GetItem.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyStructSequence_GetItem(PyObject *, Py_ssize_t)
     * }
     */
    public static MemorySegment PyStructSequence_GetItem(MemorySegment x0, long x1) {
        var mh$ = PyStructSequence_GetItem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyStructSequence_GetItem", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCodec_Register {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCodec_Register");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyCodec_Register(PyObject *search_function)
     * }
     */
    public static FunctionDescriptor PyCodec_Register$descriptor() {
        return PyCodec_Register.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyCodec_Register(PyObject *search_function)
     * }
     */
    public static MethodHandle PyCodec_Register$handle() {
        return PyCodec_Register.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyCodec_Register(PyObject *search_function)
     * }
     */
    public static MemorySegment PyCodec_Register$address() {
        return PyCodec_Register.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyCodec_Register(PyObject *search_function)
     * }
     */
    public static int PyCodec_Register(MemorySegment search_function) {
        var mh$ = PyCodec_Register.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCodec_Register", search_function);
            }
            return (int)mh$.invokeExact(search_function);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCodec_Unregister {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCodec_Unregister");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyCodec_Unregister(PyObject *search_function)
     * }
     */
    public static FunctionDescriptor PyCodec_Unregister$descriptor() {
        return PyCodec_Unregister.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyCodec_Unregister(PyObject *search_function)
     * }
     */
    public static MethodHandle PyCodec_Unregister$handle() {
        return PyCodec_Unregister.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyCodec_Unregister(PyObject *search_function)
     * }
     */
    public static MemorySegment PyCodec_Unregister$address() {
        return PyCodec_Unregister.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyCodec_Unregister(PyObject *search_function)
     * }
     */
    public static int PyCodec_Unregister(MemorySegment search_function) {
        var mh$ = PyCodec_Unregister.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCodec_Unregister", search_function);
            }
            return (int)mh$.invokeExact(search_function);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCodec_KnownEncoding {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCodec_KnownEncoding");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyCodec_KnownEncoding(const char *encoding)
     * }
     */
    public static FunctionDescriptor PyCodec_KnownEncoding$descriptor() {
        return PyCodec_KnownEncoding.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyCodec_KnownEncoding(const char *encoding)
     * }
     */
    public static MethodHandle PyCodec_KnownEncoding$handle() {
        return PyCodec_KnownEncoding.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyCodec_KnownEncoding(const char *encoding)
     * }
     */
    public static MemorySegment PyCodec_KnownEncoding$address() {
        return PyCodec_KnownEncoding.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyCodec_KnownEncoding(const char *encoding)
     * }
     */
    public static int PyCodec_KnownEncoding(MemorySegment encoding) {
        var mh$ = PyCodec_KnownEncoding.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCodec_KnownEncoding", encoding);
            }
            return (int)mh$.invokeExact(encoding);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCodec_Encode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCodec_Encode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyCodec_Encode(PyObject *object, const char *encoding, const char *errors)
     * }
     */
    public static FunctionDescriptor PyCodec_Encode$descriptor() {
        return PyCodec_Encode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyCodec_Encode(PyObject *object, const char *encoding, const char *errors)
     * }
     */
    public static MethodHandle PyCodec_Encode$handle() {
        return PyCodec_Encode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyCodec_Encode(PyObject *object, const char *encoding, const char *errors)
     * }
     */
    public static MemorySegment PyCodec_Encode$address() {
        return PyCodec_Encode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyCodec_Encode(PyObject *object, const char *encoding, const char *errors)
     * }
     */
    public static MemorySegment PyCodec_Encode(MemorySegment object, MemorySegment encoding, MemorySegment errors) {
        var mh$ = PyCodec_Encode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCodec_Encode", object, encoding, errors);
            }
            return (MemorySegment)mh$.invokeExact(object, encoding, errors);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCodec_Decode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCodec_Decode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyCodec_Decode(PyObject *object, const char *encoding, const char *errors)
     * }
     */
    public static FunctionDescriptor PyCodec_Decode$descriptor() {
        return PyCodec_Decode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyCodec_Decode(PyObject *object, const char *encoding, const char *errors)
     * }
     */
    public static MethodHandle PyCodec_Decode$handle() {
        return PyCodec_Decode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyCodec_Decode(PyObject *object, const char *encoding, const char *errors)
     * }
     */
    public static MemorySegment PyCodec_Decode$address() {
        return PyCodec_Decode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyCodec_Decode(PyObject *object, const char *encoding, const char *errors)
     * }
     */
    public static MemorySegment PyCodec_Decode(MemorySegment object, MemorySegment encoding, MemorySegment errors) {
        var mh$ = PyCodec_Decode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCodec_Decode", object, encoding, errors);
            }
            return (MemorySegment)mh$.invokeExact(object, encoding, errors);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCodec_Encoder {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCodec_Encoder");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyCodec_Encoder(const char *encoding)
     * }
     */
    public static FunctionDescriptor PyCodec_Encoder$descriptor() {
        return PyCodec_Encoder.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyCodec_Encoder(const char *encoding)
     * }
     */
    public static MethodHandle PyCodec_Encoder$handle() {
        return PyCodec_Encoder.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyCodec_Encoder(const char *encoding)
     * }
     */
    public static MemorySegment PyCodec_Encoder$address() {
        return PyCodec_Encoder.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyCodec_Encoder(const char *encoding)
     * }
     */
    public static MemorySegment PyCodec_Encoder(MemorySegment encoding) {
        var mh$ = PyCodec_Encoder.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCodec_Encoder", encoding);
            }
            return (MemorySegment)mh$.invokeExact(encoding);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCodec_Decoder {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCodec_Decoder");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyCodec_Decoder(const char *encoding)
     * }
     */
    public static FunctionDescriptor PyCodec_Decoder$descriptor() {
        return PyCodec_Decoder.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyCodec_Decoder(const char *encoding)
     * }
     */
    public static MethodHandle PyCodec_Decoder$handle() {
        return PyCodec_Decoder.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyCodec_Decoder(const char *encoding)
     * }
     */
    public static MemorySegment PyCodec_Decoder$address() {
        return PyCodec_Decoder.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyCodec_Decoder(const char *encoding)
     * }
     */
    public static MemorySegment PyCodec_Decoder(MemorySegment encoding) {
        var mh$ = PyCodec_Decoder.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCodec_Decoder", encoding);
            }
            return (MemorySegment)mh$.invokeExact(encoding);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCodec_IncrementalEncoder {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCodec_IncrementalEncoder");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyCodec_IncrementalEncoder(const char *encoding, const char *errors)
     * }
     */
    public static FunctionDescriptor PyCodec_IncrementalEncoder$descriptor() {
        return PyCodec_IncrementalEncoder.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyCodec_IncrementalEncoder(const char *encoding, const char *errors)
     * }
     */
    public static MethodHandle PyCodec_IncrementalEncoder$handle() {
        return PyCodec_IncrementalEncoder.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyCodec_IncrementalEncoder(const char *encoding, const char *errors)
     * }
     */
    public static MemorySegment PyCodec_IncrementalEncoder$address() {
        return PyCodec_IncrementalEncoder.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyCodec_IncrementalEncoder(const char *encoding, const char *errors)
     * }
     */
    public static MemorySegment PyCodec_IncrementalEncoder(MemorySegment encoding, MemorySegment errors) {
        var mh$ = PyCodec_IncrementalEncoder.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCodec_IncrementalEncoder", encoding, errors);
            }
            return (MemorySegment)mh$.invokeExact(encoding, errors);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCodec_IncrementalDecoder {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCodec_IncrementalDecoder");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyCodec_IncrementalDecoder(const char *encoding, const char *errors)
     * }
     */
    public static FunctionDescriptor PyCodec_IncrementalDecoder$descriptor() {
        return PyCodec_IncrementalDecoder.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyCodec_IncrementalDecoder(const char *encoding, const char *errors)
     * }
     */
    public static MethodHandle PyCodec_IncrementalDecoder$handle() {
        return PyCodec_IncrementalDecoder.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyCodec_IncrementalDecoder(const char *encoding, const char *errors)
     * }
     */
    public static MemorySegment PyCodec_IncrementalDecoder$address() {
        return PyCodec_IncrementalDecoder.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyCodec_IncrementalDecoder(const char *encoding, const char *errors)
     * }
     */
    public static MemorySegment PyCodec_IncrementalDecoder(MemorySegment encoding, MemorySegment errors) {
        var mh$ = PyCodec_IncrementalDecoder.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCodec_IncrementalDecoder", encoding, errors);
            }
            return (MemorySegment)mh$.invokeExact(encoding, errors);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCodec_StreamReader {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCodec_StreamReader");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyCodec_StreamReader(const char *encoding, PyObject *stream, const char *errors)
     * }
     */
    public static FunctionDescriptor PyCodec_StreamReader$descriptor() {
        return PyCodec_StreamReader.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyCodec_StreamReader(const char *encoding, PyObject *stream, const char *errors)
     * }
     */
    public static MethodHandle PyCodec_StreamReader$handle() {
        return PyCodec_StreamReader.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyCodec_StreamReader(const char *encoding, PyObject *stream, const char *errors)
     * }
     */
    public static MemorySegment PyCodec_StreamReader$address() {
        return PyCodec_StreamReader.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyCodec_StreamReader(const char *encoding, PyObject *stream, const char *errors)
     * }
     */
    public static MemorySegment PyCodec_StreamReader(MemorySegment encoding, MemorySegment stream, MemorySegment errors) {
        var mh$ = PyCodec_StreamReader.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCodec_StreamReader", encoding, stream, errors);
            }
            return (MemorySegment)mh$.invokeExact(encoding, stream, errors);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCodec_StreamWriter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCodec_StreamWriter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyCodec_StreamWriter(const char *encoding, PyObject *stream, const char *errors)
     * }
     */
    public static FunctionDescriptor PyCodec_StreamWriter$descriptor() {
        return PyCodec_StreamWriter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyCodec_StreamWriter(const char *encoding, PyObject *stream, const char *errors)
     * }
     */
    public static MethodHandle PyCodec_StreamWriter$handle() {
        return PyCodec_StreamWriter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyCodec_StreamWriter(const char *encoding, PyObject *stream, const char *errors)
     * }
     */
    public static MemorySegment PyCodec_StreamWriter$address() {
        return PyCodec_StreamWriter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyCodec_StreamWriter(const char *encoding, PyObject *stream, const char *errors)
     * }
     */
    public static MemorySegment PyCodec_StreamWriter(MemorySegment encoding, MemorySegment stream, MemorySegment errors) {
        var mh$ = PyCodec_StreamWriter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCodec_StreamWriter", encoding, stream, errors);
            }
            return (MemorySegment)mh$.invokeExact(encoding, stream, errors);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCodec_RegisterError {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCodec_RegisterError");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyCodec_RegisterError(const char *name, PyObject *error)
     * }
     */
    public static FunctionDescriptor PyCodec_RegisterError$descriptor() {
        return PyCodec_RegisterError.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyCodec_RegisterError(const char *name, PyObject *error)
     * }
     */
    public static MethodHandle PyCodec_RegisterError$handle() {
        return PyCodec_RegisterError.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyCodec_RegisterError(const char *name, PyObject *error)
     * }
     */
    public static MemorySegment PyCodec_RegisterError$address() {
        return PyCodec_RegisterError.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyCodec_RegisterError(const char *name, PyObject *error)
     * }
     */
    public static int PyCodec_RegisterError(MemorySegment name, MemorySegment error) {
        var mh$ = PyCodec_RegisterError.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCodec_RegisterError", name, error);
            }
            return (int)mh$.invokeExact(name, error);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCodec_LookupError {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCodec_LookupError");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyCodec_LookupError(const char *name)
     * }
     */
    public static FunctionDescriptor PyCodec_LookupError$descriptor() {
        return PyCodec_LookupError.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyCodec_LookupError(const char *name)
     * }
     */
    public static MethodHandle PyCodec_LookupError$handle() {
        return PyCodec_LookupError.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyCodec_LookupError(const char *name)
     * }
     */
    public static MemorySegment PyCodec_LookupError$address() {
        return PyCodec_LookupError.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyCodec_LookupError(const char *name)
     * }
     */
    public static MemorySegment PyCodec_LookupError(MemorySegment name) {
        var mh$ = PyCodec_LookupError.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCodec_LookupError", name);
            }
            return (MemorySegment)mh$.invokeExact(name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCodec_StrictErrors {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCodec_StrictErrors");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyCodec_StrictErrors(PyObject *exc)
     * }
     */
    public static FunctionDescriptor PyCodec_StrictErrors$descriptor() {
        return PyCodec_StrictErrors.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyCodec_StrictErrors(PyObject *exc)
     * }
     */
    public static MethodHandle PyCodec_StrictErrors$handle() {
        return PyCodec_StrictErrors.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyCodec_StrictErrors(PyObject *exc)
     * }
     */
    public static MemorySegment PyCodec_StrictErrors$address() {
        return PyCodec_StrictErrors.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyCodec_StrictErrors(PyObject *exc)
     * }
     */
    public static MemorySegment PyCodec_StrictErrors(MemorySegment exc) {
        var mh$ = PyCodec_StrictErrors.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCodec_StrictErrors", exc);
            }
            return (MemorySegment)mh$.invokeExact(exc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCodec_IgnoreErrors {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCodec_IgnoreErrors");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyCodec_IgnoreErrors(PyObject *exc)
     * }
     */
    public static FunctionDescriptor PyCodec_IgnoreErrors$descriptor() {
        return PyCodec_IgnoreErrors.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyCodec_IgnoreErrors(PyObject *exc)
     * }
     */
    public static MethodHandle PyCodec_IgnoreErrors$handle() {
        return PyCodec_IgnoreErrors.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyCodec_IgnoreErrors(PyObject *exc)
     * }
     */
    public static MemorySegment PyCodec_IgnoreErrors$address() {
        return PyCodec_IgnoreErrors.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyCodec_IgnoreErrors(PyObject *exc)
     * }
     */
    public static MemorySegment PyCodec_IgnoreErrors(MemorySegment exc) {
        var mh$ = PyCodec_IgnoreErrors.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCodec_IgnoreErrors", exc);
            }
            return (MemorySegment)mh$.invokeExact(exc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCodec_ReplaceErrors {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCodec_ReplaceErrors");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyCodec_ReplaceErrors(PyObject *exc)
     * }
     */
    public static FunctionDescriptor PyCodec_ReplaceErrors$descriptor() {
        return PyCodec_ReplaceErrors.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyCodec_ReplaceErrors(PyObject *exc)
     * }
     */
    public static MethodHandle PyCodec_ReplaceErrors$handle() {
        return PyCodec_ReplaceErrors.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyCodec_ReplaceErrors(PyObject *exc)
     * }
     */
    public static MemorySegment PyCodec_ReplaceErrors$address() {
        return PyCodec_ReplaceErrors.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyCodec_ReplaceErrors(PyObject *exc)
     * }
     */
    public static MemorySegment PyCodec_ReplaceErrors(MemorySegment exc) {
        var mh$ = PyCodec_ReplaceErrors.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCodec_ReplaceErrors", exc);
            }
            return (MemorySegment)mh$.invokeExact(exc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCodec_XMLCharRefReplaceErrors {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCodec_XMLCharRefReplaceErrors");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyCodec_XMLCharRefReplaceErrors(PyObject *exc)
     * }
     */
    public static FunctionDescriptor PyCodec_XMLCharRefReplaceErrors$descriptor() {
        return PyCodec_XMLCharRefReplaceErrors.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyCodec_XMLCharRefReplaceErrors(PyObject *exc)
     * }
     */
    public static MethodHandle PyCodec_XMLCharRefReplaceErrors$handle() {
        return PyCodec_XMLCharRefReplaceErrors.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyCodec_XMLCharRefReplaceErrors(PyObject *exc)
     * }
     */
    public static MemorySegment PyCodec_XMLCharRefReplaceErrors$address() {
        return PyCodec_XMLCharRefReplaceErrors.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyCodec_XMLCharRefReplaceErrors(PyObject *exc)
     * }
     */
    public static MemorySegment PyCodec_XMLCharRefReplaceErrors(MemorySegment exc) {
        var mh$ = PyCodec_XMLCharRefReplaceErrors.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCodec_XMLCharRefReplaceErrors", exc);
            }
            return (MemorySegment)mh$.invokeExact(exc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCodec_BackslashReplaceErrors {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCodec_BackslashReplaceErrors");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyCodec_BackslashReplaceErrors(PyObject *exc)
     * }
     */
    public static FunctionDescriptor PyCodec_BackslashReplaceErrors$descriptor() {
        return PyCodec_BackslashReplaceErrors.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyCodec_BackslashReplaceErrors(PyObject *exc)
     * }
     */
    public static MethodHandle PyCodec_BackslashReplaceErrors$handle() {
        return PyCodec_BackslashReplaceErrors.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyCodec_BackslashReplaceErrors(PyObject *exc)
     * }
     */
    public static MemorySegment PyCodec_BackslashReplaceErrors$address() {
        return PyCodec_BackslashReplaceErrors.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyCodec_BackslashReplaceErrors(PyObject *exc)
     * }
     */
    public static MemorySegment PyCodec_BackslashReplaceErrors(MemorySegment exc) {
        var mh$ = PyCodec_BackslashReplaceErrors.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCodec_BackslashReplaceErrors", exc);
            }
            return (MemorySegment)mh$.invokeExact(exc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCodec_NameReplaceErrors {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCodec_NameReplaceErrors");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyCodec_NameReplaceErrors(PyObject *exc)
     * }
     */
    public static FunctionDescriptor PyCodec_NameReplaceErrors$descriptor() {
        return PyCodec_NameReplaceErrors.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyCodec_NameReplaceErrors(PyObject *exc)
     * }
     */
    public static MethodHandle PyCodec_NameReplaceErrors$handle() {
        return PyCodec_NameReplaceErrors.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyCodec_NameReplaceErrors(PyObject *exc)
     * }
     */
    public static MemorySegment PyCodec_NameReplaceErrors$address() {
        return PyCodec_NameReplaceErrors.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyCodec_NameReplaceErrors(PyObject *exc)
     * }
     */
    public static MemorySegment PyCodec_NameReplaceErrors(MemorySegment exc) {
        var mh$ = PyCodec_NameReplaceErrors.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCodec_NameReplaceErrors", exc);
            }
            return (MemorySegment)mh$.invokeExact(exc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyErr_SetNone {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_SetNone");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyErr_SetNone(PyObject *)
     * }
     */
    public static FunctionDescriptor PyErr_SetNone$descriptor() {
        return PyErr_SetNone.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyErr_SetNone(PyObject *)
     * }
     */
    public static MethodHandle PyErr_SetNone$handle() {
        return PyErr_SetNone.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyErr_SetNone(PyObject *)
     * }
     */
    public static MemorySegment PyErr_SetNone$address() {
        return PyErr_SetNone.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyErr_SetNone(PyObject *)
     * }
     */
    public static void PyErr_SetNone(MemorySegment x0) {
        var mh$ = PyErr_SetNone.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyErr_SetNone", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyErr_SetObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_SetObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyErr_SetObject(PyObject *, PyObject *)
     * }
     */
    public static FunctionDescriptor PyErr_SetObject$descriptor() {
        return PyErr_SetObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyErr_SetObject(PyObject *, PyObject *)
     * }
     */
    public static MethodHandle PyErr_SetObject$handle() {
        return PyErr_SetObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyErr_SetObject(PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyErr_SetObject$address() {
        return PyErr_SetObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyErr_SetObject(PyObject *, PyObject *)
     * }
     */
    public static void PyErr_SetObject(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyErr_SetObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyErr_SetObject", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyErr_SetString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_SetString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyErr_SetString(PyObject *exception, const char *string)
     * }
     */
    public static FunctionDescriptor PyErr_SetString$descriptor() {
        return PyErr_SetString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyErr_SetString(PyObject *exception, const char *string)
     * }
     */
    public static MethodHandle PyErr_SetString$handle() {
        return PyErr_SetString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyErr_SetString(PyObject *exception, const char *string)
     * }
     */
    public static MemorySegment PyErr_SetString$address() {
        return PyErr_SetString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyErr_SetString(PyObject *exception, const char *string)
     * }
     */
    public static void PyErr_SetString(MemorySegment exception, MemorySegment string) {
        var mh$ = PyErr_SetString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyErr_SetString", exception, string);
            }
            mh$.invokeExact(exception, string);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyErr_Occurred {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_Occurred");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyErr_Occurred()
     * }
     */
    public static FunctionDescriptor PyErr_Occurred$descriptor() {
        return PyErr_Occurred.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyErr_Occurred()
     * }
     */
    public static MethodHandle PyErr_Occurred$handle() {
        return PyErr_Occurred.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyErr_Occurred()
     * }
     */
    public static MemorySegment PyErr_Occurred$address() {
        return PyErr_Occurred.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyErr_Occurred()
     * }
     */
    public static MemorySegment PyErr_Occurred() {
        var mh$ = PyErr_Occurred.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyErr_Occurred");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyErr_Clear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_Clear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyErr_Clear()
     * }
     */
    public static FunctionDescriptor PyErr_Clear$descriptor() {
        return PyErr_Clear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyErr_Clear()
     * }
     */
    public static MethodHandle PyErr_Clear$handle() {
        return PyErr_Clear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyErr_Clear()
     * }
     */
    public static MemorySegment PyErr_Clear$address() {
        return PyErr_Clear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyErr_Clear()
     * }
     */
    public static void PyErr_Clear() {
        var mh$ = PyErr_Clear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyErr_Clear");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyErr_Fetch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_Fetch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyErr_Fetch(PyObject **, PyObject **, PyObject **)
     * }
     */
    public static FunctionDescriptor PyErr_Fetch$descriptor() {
        return PyErr_Fetch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyErr_Fetch(PyObject **, PyObject **, PyObject **)
     * }
     */
    public static MethodHandle PyErr_Fetch$handle() {
        return PyErr_Fetch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyErr_Fetch(PyObject **, PyObject **, PyObject **)
     * }
     */
    public static MemorySegment PyErr_Fetch$address() {
        return PyErr_Fetch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyErr_Fetch(PyObject **, PyObject **, PyObject **)
     * }
     */
    public static void PyErr_Fetch(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = PyErr_Fetch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyErr_Fetch", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyErr_Restore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_Restore");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyErr_Restore(PyObject *, PyObject *, PyObject *)
     * }
     */
    public static FunctionDescriptor PyErr_Restore$descriptor() {
        return PyErr_Restore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyErr_Restore(PyObject *, PyObject *, PyObject *)
     * }
     */
    public static MethodHandle PyErr_Restore$handle() {
        return PyErr_Restore.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyErr_Restore(PyObject *, PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyErr_Restore$address() {
        return PyErr_Restore.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyErr_Restore(PyObject *, PyObject *, PyObject *)
     * }
     */
    public static void PyErr_Restore(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = PyErr_Restore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyErr_Restore", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyErr_GetRaisedException {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_GetRaisedException");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyErr_GetRaisedException()
     * }
     */
    public static FunctionDescriptor PyErr_GetRaisedException$descriptor() {
        return PyErr_GetRaisedException.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyErr_GetRaisedException()
     * }
     */
    public static MethodHandle PyErr_GetRaisedException$handle() {
        return PyErr_GetRaisedException.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyErr_GetRaisedException()
     * }
     */
    public static MemorySegment PyErr_GetRaisedException$address() {
        return PyErr_GetRaisedException.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyErr_GetRaisedException()
     * }
     */
    public static MemorySegment PyErr_GetRaisedException() {
        var mh$ = PyErr_GetRaisedException.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyErr_GetRaisedException");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyErr_SetRaisedException {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_SetRaisedException");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyErr_SetRaisedException(PyObject *)
     * }
     */
    public static FunctionDescriptor PyErr_SetRaisedException$descriptor() {
        return PyErr_SetRaisedException.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyErr_SetRaisedException(PyObject *)
     * }
     */
    public static MethodHandle PyErr_SetRaisedException$handle() {
        return PyErr_SetRaisedException.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyErr_SetRaisedException(PyObject *)
     * }
     */
    public static MemorySegment PyErr_SetRaisedException$address() {
        return PyErr_SetRaisedException.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyErr_SetRaisedException(PyObject *)
     * }
     */
    public static void PyErr_SetRaisedException(MemorySegment x0) {
        var mh$ = PyErr_SetRaisedException.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyErr_SetRaisedException", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyErr_GetHandledException {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_GetHandledException");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyErr_GetHandledException()
     * }
     */
    public static FunctionDescriptor PyErr_GetHandledException$descriptor() {
        return PyErr_GetHandledException.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyErr_GetHandledException()
     * }
     */
    public static MethodHandle PyErr_GetHandledException$handle() {
        return PyErr_GetHandledException.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyErr_GetHandledException()
     * }
     */
    public static MemorySegment PyErr_GetHandledException$address() {
        return PyErr_GetHandledException.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyErr_GetHandledException()
     * }
     */
    public static MemorySegment PyErr_GetHandledException() {
        var mh$ = PyErr_GetHandledException.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyErr_GetHandledException");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyErr_SetHandledException {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_SetHandledException");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyErr_SetHandledException(PyObject *)
     * }
     */
    public static FunctionDescriptor PyErr_SetHandledException$descriptor() {
        return PyErr_SetHandledException.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyErr_SetHandledException(PyObject *)
     * }
     */
    public static MethodHandle PyErr_SetHandledException$handle() {
        return PyErr_SetHandledException.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyErr_SetHandledException(PyObject *)
     * }
     */
    public static MemorySegment PyErr_SetHandledException$address() {
        return PyErr_SetHandledException.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyErr_SetHandledException(PyObject *)
     * }
     */
    public static void PyErr_SetHandledException(MemorySegment x0) {
        var mh$ = PyErr_SetHandledException.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyErr_SetHandledException", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyErr_GetExcInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_GetExcInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyErr_GetExcInfo(PyObject **, PyObject **, PyObject **)
     * }
     */
    public static FunctionDescriptor PyErr_GetExcInfo$descriptor() {
        return PyErr_GetExcInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyErr_GetExcInfo(PyObject **, PyObject **, PyObject **)
     * }
     */
    public static MethodHandle PyErr_GetExcInfo$handle() {
        return PyErr_GetExcInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyErr_GetExcInfo(PyObject **, PyObject **, PyObject **)
     * }
     */
    public static MemorySegment PyErr_GetExcInfo$address() {
        return PyErr_GetExcInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyErr_GetExcInfo(PyObject **, PyObject **, PyObject **)
     * }
     */
    public static void PyErr_GetExcInfo(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = PyErr_GetExcInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyErr_GetExcInfo", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyErr_SetExcInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_SetExcInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyErr_SetExcInfo(PyObject *, PyObject *, PyObject *)
     * }
     */
    public static FunctionDescriptor PyErr_SetExcInfo$descriptor() {
        return PyErr_SetExcInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyErr_SetExcInfo(PyObject *, PyObject *, PyObject *)
     * }
     */
    public static MethodHandle PyErr_SetExcInfo$handle() {
        return PyErr_SetExcInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyErr_SetExcInfo(PyObject *, PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyErr_SetExcInfo$address() {
        return PyErr_SetExcInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyErr_SetExcInfo(PyObject *, PyObject *, PyObject *)
     * }
     */
    public static void PyErr_SetExcInfo(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = PyErr_SetExcInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyErr_SetExcInfo", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_FatalError {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_FatalError");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void Py_FatalError(const char *message)
     * }
     */
    public static FunctionDescriptor Py_FatalError$descriptor() {
        return Py_FatalError.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void Py_FatalError(const char *message)
     * }
     */
    public static MethodHandle Py_FatalError$handle() {
        return Py_FatalError.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void Py_FatalError(const char *message)
     * }
     */
    public static MemorySegment Py_FatalError$address() {
        return Py_FatalError.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void Py_FatalError(const char *message)
     * }
     */
    public static void Py_FatalError(MemorySegment message) {
        var mh$ = Py_FatalError.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_FatalError", message);
            }
            mh$.invokeExact(message);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyErr_GivenExceptionMatches {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_GivenExceptionMatches");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyErr_GivenExceptionMatches(PyObject *, PyObject *)
     * }
     */
    public static FunctionDescriptor PyErr_GivenExceptionMatches$descriptor() {
        return PyErr_GivenExceptionMatches.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyErr_GivenExceptionMatches(PyObject *, PyObject *)
     * }
     */
    public static MethodHandle PyErr_GivenExceptionMatches$handle() {
        return PyErr_GivenExceptionMatches.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyErr_GivenExceptionMatches(PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyErr_GivenExceptionMatches$address() {
        return PyErr_GivenExceptionMatches.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyErr_GivenExceptionMatches(PyObject *, PyObject *)
     * }
     */
    public static int PyErr_GivenExceptionMatches(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyErr_GivenExceptionMatches.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyErr_GivenExceptionMatches", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyErr_ExceptionMatches {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_ExceptionMatches");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyErr_ExceptionMatches(PyObject *)
     * }
     */
    public static FunctionDescriptor PyErr_ExceptionMatches$descriptor() {
        return PyErr_ExceptionMatches.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyErr_ExceptionMatches(PyObject *)
     * }
     */
    public static MethodHandle PyErr_ExceptionMatches$handle() {
        return PyErr_ExceptionMatches.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyErr_ExceptionMatches(PyObject *)
     * }
     */
    public static MemorySegment PyErr_ExceptionMatches$address() {
        return PyErr_ExceptionMatches.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyErr_ExceptionMatches(PyObject *)
     * }
     */
    public static int PyErr_ExceptionMatches(MemorySegment x0) {
        var mh$ = PyErr_ExceptionMatches.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyErr_ExceptionMatches", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyErr_NormalizeException {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_NormalizeException");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyErr_NormalizeException(PyObject **, PyObject **, PyObject **)
     * }
     */
    public static FunctionDescriptor PyErr_NormalizeException$descriptor() {
        return PyErr_NormalizeException.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyErr_NormalizeException(PyObject **, PyObject **, PyObject **)
     * }
     */
    public static MethodHandle PyErr_NormalizeException$handle() {
        return PyErr_NormalizeException.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyErr_NormalizeException(PyObject **, PyObject **, PyObject **)
     * }
     */
    public static MemorySegment PyErr_NormalizeException$address() {
        return PyErr_NormalizeException.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyErr_NormalizeException(PyObject **, PyObject **, PyObject **)
     * }
     */
    public static void PyErr_NormalizeException(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = PyErr_NormalizeException.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyErr_NormalizeException", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyException_SetTraceback {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyException_SetTraceback");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyException_SetTraceback(PyObject *, PyObject *)
     * }
     */
    public static FunctionDescriptor PyException_SetTraceback$descriptor() {
        return PyException_SetTraceback.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyException_SetTraceback(PyObject *, PyObject *)
     * }
     */
    public static MethodHandle PyException_SetTraceback$handle() {
        return PyException_SetTraceback.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyException_SetTraceback(PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyException_SetTraceback$address() {
        return PyException_SetTraceback.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyException_SetTraceback(PyObject *, PyObject *)
     * }
     */
    public static int PyException_SetTraceback(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyException_SetTraceback.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyException_SetTraceback", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyException_GetTraceback {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyException_GetTraceback");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyException_GetTraceback(PyObject *)
     * }
     */
    public static FunctionDescriptor PyException_GetTraceback$descriptor() {
        return PyException_GetTraceback.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyException_GetTraceback(PyObject *)
     * }
     */
    public static MethodHandle PyException_GetTraceback$handle() {
        return PyException_GetTraceback.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyException_GetTraceback(PyObject *)
     * }
     */
    public static MemorySegment PyException_GetTraceback$address() {
        return PyException_GetTraceback.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyException_GetTraceback(PyObject *)
     * }
     */
    public static MemorySegment PyException_GetTraceback(MemorySegment x0) {
        var mh$ = PyException_GetTraceback.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyException_GetTraceback", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyException_GetCause {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyException_GetCause");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyException_GetCause(PyObject *)
     * }
     */
    public static FunctionDescriptor PyException_GetCause$descriptor() {
        return PyException_GetCause.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyException_GetCause(PyObject *)
     * }
     */
    public static MethodHandle PyException_GetCause$handle() {
        return PyException_GetCause.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyException_GetCause(PyObject *)
     * }
     */
    public static MemorySegment PyException_GetCause$address() {
        return PyException_GetCause.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyException_GetCause(PyObject *)
     * }
     */
    public static MemorySegment PyException_GetCause(MemorySegment x0) {
        var mh$ = PyException_GetCause.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyException_GetCause", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyException_SetCause {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyException_SetCause");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyException_SetCause(PyObject *, PyObject *)
     * }
     */
    public static FunctionDescriptor PyException_SetCause$descriptor() {
        return PyException_SetCause.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyException_SetCause(PyObject *, PyObject *)
     * }
     */
    public static MethodHandle PyException_SetCause$handle() {
        return PyException_SetCause.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyException_SetCause(PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyException_SetCause$address() {
        return PyException_SetCause.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyException_SetCause(PyObject *, PyObject *)
     * }
     */
    public static void PyException_SetCause(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyException_SetCause.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyException_SetCause", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyException_GetContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyException_GetContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyException_GetContext(PyObject *)
     * }
     */
    public static FunctionDescriptor PyException_GetContext$descriptor() {
        return PyException_GetContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyException_GetContext(PyObject *)
     * }
     */
    public static MethodHandle PyException_GetContext$handle() {
        return PyException_GetContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyException_GetContext(PyObject *)
     * }
     */
    public static MemorySegment PyException_GetContext$address() {
        return PyException_GetContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyException_GetContext(PyObject *)
     * }
     */
    public static MemorySegment PyException_GetContext(MemorySegment x0) {
        var mh$ = PyException_GetContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyException_GetContext", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyException_SetContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyException_SetContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyException_SetContext(PyObject *, PyObject *)
     * }
     */
    public static FunctionDescriptor PyException_SetContext$descriptor() {
        return PyException_SetContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyException_SetContext(PyObject *, PyObject *)
     * }
     */
    public static MethodHandle PyException_SetContext$handle() {
        return PyException_SetContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyException_SetContext(PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyException_SetContext$address() {
        return PyException_SetContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyException_SetContext(PyObject *, PyObject *)
     * }
     */
    public static void PyException_SetContext(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyException_SetContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyException_SetContext", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyException_GetArgs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyException_GetArgs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyException_GetArgs(PyObject *)
     * }
     */
    public static FunctionDescriptor PyException_GetArgs$descriptor() {
        return PyException_GetArgs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyException_GetArgs(PyObject *)
     * }
     */
    public static MethodHandle PyException_GetArgs$handle() {
        return PyException_GetArgs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyException_GetArgs(PyObject *)
     * }
     */
    public static MemorySegment PyException_GetArgs$address() {
        return PyException_GetArgs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyException_GetArgs(PyObject *)
     * }
     */
    public static MemorySegment PyException_GetArgs(MemorySegment x0) {
        var mh$ = PyException_GetArgs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyException_GetArgs", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyException_SetArgs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyException_SetArgs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyException_SetArgs(PyObject *, PyObject *)
     * }
     */
    public static FunctionDescriptor PyException_SetArgs$descriptor() {
        return PyException_SetArgs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyException_SetArgs(PyObject *, PyObject *)
     * }
     */
    public static MethodHandle PyException_SetArgs$handle() {
        return PyException_SetArgs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyException_SetArgs(PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyException_SetArgs$address() {
        return PyException_SetArgs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyException_SetArgs(PyObject *, PyObject *)
     * }
     */
    public static void PyException_SetArgs(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyException_SetArgs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyException_SetArgs", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyExceptionClass_Name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyExceptionClass_Name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *PyExceptionClass_Name(PyObject *)
     * }
     */
    public static FunctionDescriptor PyExceptionClass_Name$descriptor() {
        return PyExceptionClass_Name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *PyExceptionClass_Name(PyObject *)
     * }
     */
    public static MethodHandle PyExceptionClass_Name$handle() {
        return PyExceptionClass_Name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *PyExceptionClass_Name(PyObject *)
     * }
     */
    public static MemorySegment PyExceptionClass_Name$address() {
        return PyExceptionClass_Name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *PyExceptionClass_Name(PyObject *)
     * }
     */
    public static MemorySegment PyExceptionClass_Name(MemorySegment x0) {
        var mh$ = PyExceptionClass_Name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyExceptionClass_Name", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyExc_BaseException$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_BaseException").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_BaseException
     * }
     */
    public static AddressLayout PyExc_BaseException$layout() {
        return PyExc_BaseException$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_BaseException
     * }
     */
    public static MemorySegment PyExc_BaseException$segment() {
        return PyExc_BaseException$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_BaseException
     * }
     */
    public static MemorySegment PyExc_BaseException() {
        return PyExc_BaseException$constants.SEGMENT.get(PyExc_BaseException$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_BaseException
     * }
     */
    public static void PyExc_BaseException(MemorySegment varValue) {
        PyExc_BaseException$constants.SEGMENT.set(PyExc_BaseException$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_Exception$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_Exception").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_Exception
     * }
     */
    public static AddressLayout PyExc_Exception$layout() {
        return PyExc_Exception$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_Exception
     * }
     */
    public static MemorySegment PyExc_Exception$segment() {
        return PyExc_Exception$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_Exception
     * }
     */
    public static MemorySegment PyExc_Exception() {
        return PyExc_Exception$constants.SEGMENT.get(PyExc_Exception$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_Exception
     * }
     */
    public static void PyExc_Exception(MemorySegment varValue) {
        PyExc_Exception$constants.SEGMENT.set(PyExc_Exception$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_BaseExceptionGroup$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_BaseExceptionGroup").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_BaseExceptionGroup
     * }
     */
    public static AddressLayout PyExc_BaseExceptionGroup$layout() {
        return PyExc_BaseExceptionGroup$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_BaseExceptionGroup
     * }
     */
    public static MemorySegment PyExc_BaseExceptionGroup$segment() {
        return PyExc_BaseExceptionGroup$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_BaseExceptionGroup
     * }
     */
    public static MemorySegment PyExc_BaseExceptionGroup() {
        return PyExc_BaseExceptionGroup$constants.SEGMENT.get(PyExc_BaseExceptionGroup$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_BaseExceptionGroup
     * }
     */
    public static void PyExc_BaseExceptionGroup(MemorySegment varValue) {
        PyExc_BaseExceptionGroup$constants.SEGMENT.set(PyExc_BaseExceptionGroup$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_StopAsyncIteration$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_StopAsyncIteration").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_StopAsyncIteration
     * }
     */
    public static AddressLayout PyExc_StopAsyncIteration$layout() {
        return PyExc_StopAsyncIteration$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_StopAsyncIteration
     * }
     */
    public static MemorySegment PyExc_StopAsyncIteration$segment() {
        return PyExc_StopAsyncIteration$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_StopAsyncIteration
     * }
     */
    public static MemorySegment PyExc_StopAsyncIteration() {
        return PyExc_StopAsyncIteration$constants.SEGMENT.get(PyExc_StopAsyncIteration$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_StopAsyncIteration
     * }
     */
    public static void PyExc_StopAsyncIteration(MemorySegment varValue) {
        PyExc_StopAsyncIteration$constants.SEGMENT.set(PyExc_StopAsyncIteration$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_StopIteration$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_StopIteration").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_StopIteration
     * }
     */
    public static AddressLayout PyExc_StopIteration$layout() {
        return PyExc_StopIteration$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_StopIteration
     * }
     */
    public static MemorySegment PyExc_StopIteration$segment() {
        return PyExc_StopIteration$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_StopIteration
     * }
     */
    public static MemorySegment PyExc_StopIteration() {
        return PyExc_StopIteration$constants.SEGMENT.get(PyExc_StopIteration$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_StopIteration
     * }
     */
    public static void PyExc_StopIteration(MemorySegment varValue) {
        PyExc_StopIteration$constants.SEGMENT.set(PyExc_StopIteration$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_GeneratorExit$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_GeneratorExit").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_GeneratorExit
     * }
     */
    public static AddressLayout PyExc_GeneratorExit$layout() {
        return PyExc_GeneratorExit$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_GeneratorExit
     * }
     */
    public static MemorySegment PyExc_GeneratorExit$segment() {
        return PyExc_GeneratorExit$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_GeneratorExit
     * }
     */
    public static MemorySegment PyExc_GeneratorExit() {
        return PyExc_GeneratorExit$constants.SEGMENT.get(PyExc_GeneratorExit$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_GeneratorExit
     * }
     */
    public static void PyExc_GeneratorExit(MemorySegment varValue) {
        PyExc_GeneratorExit$constants.SEGMENT.set(PyExc_GeneratorExit$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_ArithmeticError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_ArithmeticError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ArithmeticError
     * }
     */
    public static AddressLayout PyExc_ArithmeticError$layout() {
        return PyExc_ArithmeticError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ArithmeticError
     * }
     */
    public static MemorySegment PyExc_ArithmeticError$segment() {
        return PyExc_ArithmeticError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ArithmeticError
     * }
     */
    public static MemorySegment PyExc_ArithmeticError() {
        return PyExc_ArithmeticError$constants.SEGMENT.get(PyExc_ArithmeticError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ArithmeticError
     * }
     */
    public static void PyExc_ArithmeticError(MemorySegment varValue) {
        PyExc_ArithmeticError$constants.SEGMENT.set(PyExc_ArithmeticError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_LookupError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_LookupError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_LookupError
     * }
     */
    public static AddressLayout PyExc_LookupError$layout() {
        return PyExc_LookupError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_LookupError
     * }
     */
    public static MemorySegment PyExc_LookupError$segment() {
        return PyExc_LookupError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_LookupError
     * }
     */
    public static MemorySegment PyExc_LookupError() {
        return PyExc_LookupError$constants.SEGMENT.get(PyExc_LookupError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_LookupError
     * }
     */
    public static void PyExc_LookupError(MemorySegment varValue) {
        PyExc_LookupError$constants.SEGMENT.set(PyExc_LookupError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_AssertionError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_AssertionError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_AssertionError
     * }
     */
    public static AddressLayout PyExc_AssertionError$layout() {
        return PyExc_AssertionError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_AssertionError
     * }
     */
    public static MemorySegment PyExc_AssertionError$segment() {
        return PyExc_AssertionError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_AssertionError
     * }
     */
    public static MemorySegment PyExc_AssertionError() {
        return PyExc_AssertionError$constants.SEGMENT.get(PyExc_AssertionError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_AssertionError
     * }
     */
    public static void PyExc_AssertionError(MemorySegment varValue) {
        PyExc_AssertionError$constants.SEGMENT.set(PyExc_AssertionError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_AttributeError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_AttributeError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_AttributeError
     * }
     */
    public static AddressLayout PyExc_AttributeError$layout() {
        return PyExc_AttributeError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_AttributeError
     * }
     */
    public static MemorySegment PyExc_AttributeError$segment() {
        return PyExc_AttributeError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_AttributeError
     * }
     */
    public static MemorySegment PyExc_AttributeError() {
        return PyExc_AttributeError$constants.SEGMENT.get(PyExc_AttributeError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_AttributeError
     * }
     */
    public static void PyExc_AttributeError(MemorySegment varValue) {
        PyExc_AttributeError$constants.SEGMENT.set(PyExc_AttributeError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_BufferError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_BufferError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_BufferError
     * }
     */
    public static AddressLayout PyExc_BufferError$layout() {
        return PyExc_BufferError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_BufferError
     * }
     */
    public static MemorySegment PyExc_BufferError$segment() {
        return PyExc_BufferError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_BufferError
     * }
     */
    public static MemorySegment PyExc_BufferError() {
        return PyExc_BufferError$constants.SEGMENT.get(PyExc_BufferError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_BufferError
     * }
     */
    public static void PyExc_BufferError(MemorySegment varValue) {
        PyExc_BufferError$constants.SEGMENT.set(PyExc_BufferError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_EOFError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_EOFError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_EOFError
     * }
     */
    public static AddressLayout PyExc_EOFError$layout() {
        return PyExc_EOFError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_EOFError
     * }
     */
    public static MemorySegment PyExc_EOFError$segment() {
        return PyExc_EOFError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_EOFError
     * }
     */
    public static MemorySegment PyExc_EOFError() {
        return PyExc_EOFError$constants.SEGMENT.get(PyExc_EOFError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_EOFError
     * }
     */
    public static void PyExc_EOFError(MemorySegment varValue) {
        PyExc_EOFError$constants.SEGMENT.set(PyExc_EOFError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_FloatingPointError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_FloatingPointError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_FloatingPointError
     * }
     */
    public static AddressLayout PyExc_FloatingPointError$layout() {
        return PyExc_FloatingPointError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_FloatingPointError
     * }
     */
    public static MemorySegment PyExc_FloatingPointError$segment() {
        return PyExc_FloatingPointError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_FloatingPointError
     * }
     */
    public static MemorySegment PyExc_FloatingPointError() {
        return PyExc_FloatingPointError$constants.SEGMENT.get(PyExc_FloatingPointError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_FloatingPointError
     * }
     */
    public static void PyExc_FloatingPointError(MemorySegment varValue) {
        PyExc_FloatingPointError$constants.SEGMENT.set(PyExc_FloatingPointError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_OSError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_OSError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_OSError
     * }
     */
    public static AddressLayout PyExc_OSError$layout() {
        return PyExc_OSError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_OSError
     * }
     */
    public static MemorySegment PyExc_OSError$segment() {
        return PyExc_OSError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_OSError
     * }
     */
    public static MemorySegment PyExc_OSError() {
        return PyExc_OSError$constants.SEGMENT.get(PyExc_OSError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_OSError
     * }
     */
    public static void PyExc_OSError(MemorySegment varValue) {
        PyExc_OSError$constants.SEGMENT.set(PyExc_OSError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_ImportError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_ImportError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ImportError
     * }
     */
    public static AddressLayout PyExc_ImportError$layout() {
        return PyExc_ImportError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ImportError
     * }
     */
    public static MemorySegment PyExc_ImportError$segment() {
        return PyExc_ImportError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ImportError
     * }
     */
    public static MemorySegment PyExc_ImportError() {
        return PyExc_ImportError$constants.SEGMENT.get(PyExc_ImportError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ImportError
     * }
     */
    public static void PyExc_ImportError(MemorySegment varValue) {
        PyExc_ImportError$constants.SEGMENT.set(PyExc_ImportError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_ModuleNotFoundError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_ModuleNotFoundError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ModuleNotFoundError
     * }
     */
    public static AddressLayout PyExc_ModuleNotFoundError$layout() {
        return PyExc_ModuleNotFoundError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ModuleNotFoundError
     * }
     */
    public static MemorySegment PyExc_ModuleNotFoundError$segment() {
        return PyExc_ModuleNotFoundError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ModuleNotFoundError
     * }
     */
    public static MemorySegment PyExc_ModuleNotFoundError() {
        return PyExc_ModuleNotFoundError$constants.SEGMENT.get(PyExc_ModuleNotFoundError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ModuleNotFoundError
     * }
     */
    public static void PyExc_ModuleNotFoundError(MemorySegment varValue) {
        PyExc_ModuleNotFoundError$constants.SEGMENT.set(PyExc_ModuleNotFoundError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_IndexError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_IndexError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_IndexError
     * }
     */
    public static AddressLayout PyExc_IndexError$layout() {
        return PyExc_IndexError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_IndexError
     * }
     */
    public static MemorySegment PyExc_IndexError$segment() {
        return PyExc_IndexError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_IndexError
     * }
     */
    public static MemorySegment PyExc_IndexError() {
        return PyExc_IndexError$constants.SEGMENT.get(PyExc_IndexError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_IndexError
     * }
     */
    public static void PyExc_IndexError(MemorySegment varValue) {
        PyExc_IndexError$constants.SEGMENT.set(PyExc_IndexError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_KeyError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_KeyError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_KeyError
     * }
     */
    public static AddressLayout PyExc_KeyError$layout() {
        return PyExc_KeyError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_KeyError
     * }
     */
    public static MemorySegment PyExc_KeyError$segment() {
        return PyExc_KeyError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_KeyError
     * }
     */
    public static MemorySegment PyExc_KeyError() {
        return PyExc_KeyError$constants.SEGMENT.get(PyExc_KeyError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_KeyError
     * }
     */
    public static void PyExc_KeyError(MemorySegment varValue) {
        PyExc_KeyError$constants.SEGMENT.set(PyExc_KeyError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_KeyboardInterrupt$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_KeyboardInterrupt").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_KeyboardInterrupt
     * }
     */
    public static AddressLayout PyExc_KeyboardInterrupt$layout() {
        return PyExc_KeyboardInterrupt$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_KeyboardInterrupt
     * }
     */
    public static MemorySegment PyExc_KeyboardInterrupt$segment() {
        return PyExc_KeyboardInterrupt$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_KeyboardInterrupt
     * }
     */
    public static MemorySegment PyExc_KeyboardInterrupt() {
        return PyExc_KeyboardInterrupt$constants.SEGMENT.get(PyExc_KeyboardInterrupt$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_KeyboardInterrupt
     * }
     */
    public static void PyExc_KeyboardInterrupt(MemorySegment varValue) {
        PyExc_KeyboardInterrupt$constants.SEGMENT.set(PyExc_KeyboardInterrupt$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_MemoryError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_MemoryError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_MemoryError
     * }
     */
    public static AddressLayout PyExc_MemoryError$layout() {
        return PyExc_MemoryError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_MemoryError
     * }
     */
    public static MemorySegment PyExc_MemoryError$segment() {
        return PyExc_MemoryError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_MemoryError
     * }
     */
    public static MemorySegment PyExc_MemoryError() {
        return PyExc_MemoryError$constants.SEGMENT.get(PyExc_MemoryError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_MemoryError
     * }
     */
    public static void PyExc_MemoryError(MemorySegment varValue) {
        PyExc_MemoryError$constants.SEGMENT.set(PyExc_MemoryError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_NameError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_NameError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_NameError
     * }
     */
    public static AddressLayout PyExc_NameError$layout() {
        return PyExc_NameError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_NameError
     * }
     */
    public static MemorySegment PyExc_NameError$segment() {
        return PyExc_NameError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_NameError
     * }
     */
    public static MemorySegment PyExc_NameError() {
        return PyExc_NameError$constants.SEGMENT.get(PyExc_NameError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_NameError
     * }
     */
    public static void PyExc_NameError(MemorySegment varValue) {
        PyExc_NameError$constants.SEGMENT.set(PyExc_NameError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_OverflowError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_OverflowError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_OverflowError
     * }
     */
    public static AddressLayout PyExc_OverflowError$layout() {
        return PyExc_OverflowError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_OverflowError
     * }
     */
    public static MemorySegment PyExc_OverflowError$segment() {
        return PyExc_OverflowError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_OverflowError
     * }
     */
    public static MemorySegment PyExc_OverflowError() {
        return PyExc_OverflowError$constants.SEGMENT.get(PyExc_OverflowError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_OverflowError
     * }
     */
    public static void PyExc_OverflowError(MemorySegment varValue) {
        PyExc_OverflowError$constants.SEGMENT.set(PyExc_OverflowError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_RuntimeError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_RuntimeError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_RuntimeError
     * }
     */
    public static AddressLayout PyExc_RuntimeError$layout() {
        return PyExc_RuntimeError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_RuntimeError
     * }
     */
    public static MemorySegment PyExc_RuntimeError$segment() {
        return PyExc_RuntimeError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_RuntimeError
     * }
     */
    public static MemorySegment PyExc_RuntimeError() {
        return PyExc_RuntimeError$constants.SEGMENT.get(PyExc_RuntimeError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_RuntimeError
     * }
     */
    public static void PyExc_RuntimeError(MemorySegment varValue) {
        PyExc_RuntimeError$constants.SEGMENT.set(PyExc_RuntimeError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_RecursionError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_RecursionError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_RecursionError
     * }
     */
    public static AddressLayout PyExc_RecursionError$layout() {
        return PyExc_RecursionError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_RecursionError
     * }
     */
    public static MemorySegment PyExc_RecursionError$segment() {
        return PyExc_RecursionError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_RecursionError
     * }
     */
    public static MemorySegment PyExc_RecursionError() {
        return PyExc_RecursionError$constants.SEGMENT.get(PyExc_RecursionError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_RecursionError
     * }
     */
    public static void PyExc_RecursionError(MemorySegment varValue) {
        PyExc_RecursionError$constants.SEGMENT.set(PyExc_RecursionError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_NotImplementedError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_NotImplementedError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_NotImplementedError
     * }
     */
    public static AddressLayout PyExc_NotImplementedError$layout() {
        return PyExc_NotImplementedError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_NotImplementedError
     * }
     */
    public static MemorySegment PyExc_NotImplementedError$segment() {
        return PyExc_NotImplementedError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_NotImplementedError
     * }
     */
    public static MemorySegment PyExc_NotImplementedError() {
        return PyExc_NotImplementedError$constants.SEGMENT.get(PyExc_NotImplementedError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_NotImplementedError
     * }
     */
    public static void PyExc_NotImplementedError(MemorySegment varValue) {
        PyExc_NotImplementedError$constants.SEGMENT.set(PyExc_NotImplementedError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_SyntaxError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_SyntaxError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_SyntaxError
     * }
     */
    public static AddressLayout PyExc_SyntaxError$layout() {
        return PyExc_SyntaxError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_SyntaxError
     * }
     */
    public static MemorySegment PyExc_SyntaxError$segment() {
        return PyExc_SyntaxError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_SyntaxError
     * }
     */
    public static MemorySegment PyExc_SyntaxError() {
        return PyExc_SyntaxError$constants.SEGMENT.get(PyExc_SyntaxError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_SyntaxError
     * }
     */
    public static void PyExc_SyntaxError(MemorySegment varValue) {
        PyExc_SyntaxError$constants.SEGMENT.set(PyExc_SyntaxError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_IndentationError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_IndentationError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_IndentationError
     * }
     */
    public static AddressLayout PyExc_IndentationError$layout() {
        return PyExc_IndentationError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_IndentationError
     * }
     */
    public static MemorySegment PyExc_IndentationError$segment() {
        return PyExc_IndentationError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_IndentationError
     * }
     */
    public static MemorySegment PyExc_IndentationError() {
        return PyExc_IndentationError$constants.SEGMENT.get(PyExc_IndentationError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_IndentationError
     * }
     */
    public static void PyExc_IndentationError(MemorySegment varValue) {
        PyExc_IndentationError$constants.SEGMENT.set(PyExc_IndentationError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_TabError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_TabError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_TabError
     * }
     */
    public static AddressLayout PyExc_TabError$layout() {
        return PyExc_TabError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_TabError
     * }
     */
    public static MemorySegment PyExc_TabError$segment() {
        return PyExc_TabError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_TabError
     * }
     */
    public static MemorySegment PyExc_TabError() {
        return PyExc_TabError$constants.SEGMENT.get(PyExc_TabError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_TabError
     * }
     */
    public static void PyExc_TabError(MemorySegment varValue) {
        PyExc_TabError$constants.SEGMENT.set(PyExc_TabError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_ReferenceError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_ReferenceError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ReferenceError
     * }
     */
    public static AddressLayout PyExc_ReferenceError$layout() {
        return PyExc_ReferenceError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ReferenceError
     * }
     */
    public static MemorySegment PyExc_ReferenceError$segment() {
        return PyExc_ReferenceError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ReferenceError
     * }
     */
    public static MemorySegment PyExc_ReferenceError() {
        return PyExc_ReferenceError$constants.SEGMENT.get(PyExc_ReferenceError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ReferenceError
     * }
     */
    public static void PyExc_ReferenceError(MemorySegment varValue) {
        PyExc_ReferenceError$constants.SEGMENT.set(PyExc_ReferenceError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_SystemError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_SystemError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_SystemError
     * }
     */
    public static AddressLayout PyExc_SystemError$layout() {
        return PyExc_SystemError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_SystemError
     * }
     */
    public static MemorySegment PyExc_SystemError$segment() {
        return PyExc_SystemError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_SystemError
     * }
     */
    public static MemorySegment PyExc_SystemError() {
        return PyExc_SystemError$constants.SEGMENT.get(PyExc_SystemError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_SystemError
     * }
     */
    public static void PyExc_SystemError(MemorySegment varValue) {
        PyExc_SystemError$constants.SEGMENT.set(PyExc_SystemError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_SystemExit$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_SystemExit").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_SystemExit
     * }
     */
    public static AddressLayout PyExc_SystemExit$layout() {
        return PyExc_SystemExit$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_SystemExit
     * }
     */
    public static MemorySegment PyExc_SystemExit$segment() {
        return PyExc_SystemExit$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_SystemExit
     * }
     */
    public static MemorySegment PyExc_SystemExit() {
        return PyExc_SystemExit$constants.SEGMENT.get(PyExc_SystemExit$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_SystemExit
     * }
     */
    public static void PyExc_SystemExit(MemorySegment varValue) {
        PyExc_SystemExit$constants.SEGMENT.set(PyExc_SystemExit$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_TypeError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_TypeError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_TypeError
     * }
     */
    public static AddressLayout PyExc_TypeError$layout() {
        return PyExc_TypeError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_TypeError
     * }
     */
    public static MemorySegment PyExc_TypeError$segment() {
        return PyExc_TypeError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_TypeError
     * }
     */
    public static MemorySegment PyExc_TypeError() {
        return PyExc_TypeError$constants.SEGMENT.get(PyExc_TypeError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_TypeError
     * }
     */
    public static void PyExc_TypeError(MemorySegment varValue) {
        PyExc_TypeError$constants.SEGMENT.set(PyExc_TypeError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_UnboundLocalError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_UnboundLocalError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_UnboundLocalError
     * }
     */
    public static AddressLayout PyExc_UnboundLocalError$layout() {
        return PyExc_UnboundLocalError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_UnboundLocalError
     * }
     */
    public static MemorySegment PyExc_UnboundLocalError$segment() {
        return PyExc_UnboundLocalError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_UnboundLocalError
     * }
     */
    public static MemorySegment PyExc_UnboundLocalError() {
        return PyExc_UnboundLocalError$constants.SEGMENT.get(PyExc_UnboundLocalError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_UnboundLocalError
     * }
     */
    public static void PyExc_UnboundLocalError(MemorySegment varValue) {
        PyExc_UnboundLocalError$constants.SEGMENT.set(PyExc_UnboundLocalError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_UnicodeError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_UnicodeError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_UnicodeError
     * }
     */
    public static AddressLayout PyExc_UnicodeError$layout() {
        return PyExc_UnicodeError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_UnicodeError
     * }
     */
    public static MemorySegment PyExc_UnicodeError$segment() {
        return PyExc_UnicodeError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_UnicodeError
     * }
     */
    public static MemorySegment PyExc_UnicodeError() {
        return PyExc_UnicodeError$constants.SEGMENT.get(PyExc_UnicodeError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_UnicodeError
     * }
     */
    public static void PyExc_UnicodeError(MemorySegment varValue) {
        PyExc_UnicodeError$constants.SEGMENT.set(PyExc_UnicodeError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_UnicodeEncodeError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_UnicodeEncodeError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_UnicodeEncodeError
     * }
     */
    public static AddressLayout PyExc_UnicodeEncodeError$layout() {
        return PyExc_UnicodeEncodeError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_UnicodeEncodeError
     * }
     */
    public static MemorySegment PyExc_UnicodeEncodeError$segment() {
        return PyExc_UnicodeEncodeError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_UnicodeEncodeError
     * }
     */
    public static MemorySegment PyExc_UnicodeEncodeError() {
        return PyExc_UnicodeEncodeError$constants.SEGMENT.get(PyExc_UnicodeEncodeError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_UnicodeEncodeError
     * }
     */
    public static void PyExc_UnicodeEncodeError(MemorySegment varValue) {
        PyExc_UnicodeEncodeError$constants.SEGMENT.set(PyExc_UnicodeEncodeError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_UnicodeDecodeError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_UnicodeDecodeError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_UnicodeDecodeError
     * }
     */
    public static AddressLayout PyExc_UnicodeDecodeError$layout() {
        return PyExc_UnicodeDecodeError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_UnicodeDecodeError
     * }
     */
    public static MemorySegment PyExc_UnicodeDecodeError$segment() {
        return PyExc_UnicodeDecodeError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_UnicodeDecodeError
     * }
     */
    public static MemorySegment PyExc_UnicodeDecodeError() {
        return PyExc_UnicodeDecodeError$constants.SEGMENT.get(PyExc_UnicodeDecodeError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_UnicodeDecodeError
     * }
     */
    public static void PyExc_UnicodeDecodeError(MemorySegment varValue) {
        PyExc_UnicodeDecodeError$constants.SEGMENT.set(PyExc_UnicodeDecodeError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_UnicodeTranslateError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_UnicodeTranslateError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_UnicodeTranslateError
     * }
     */
    public static AddressLayout PyExc_UnicodeTranslateError$layout() {
        return PyExc_UnicodeTranslateError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_UnicodeTranslateError
     * }
     */
    public static MemorySegment PyExc_UnicodeTranslateError$segment() {
        return PyExc_UnicodeTranslateError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_UnicodeTranslateError
     * }
     */
    public static MemorySegment PyExc_UnicodeTranslateError() {
        return PyExc_UnicodeTranslateError$constants.SEGMENT.get(PyExc_UnicodeTranslateError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_UnicodeTranslateError
     * }
     */
    public static void PyExc_UnicodeTranslateError(MemorySegment varValue) {
        PyExc_UnicodeTranslateError$constants.SEGMENT.set(PyExc_UnicodeTranslateError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_ValueError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_ValueError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ValueError
     * }
     */
    public static AddressLayout PyExc_ValueError$layout() {
        return PyExc_ValueError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ValueError
     * }
     */
    public static MemorySegment PyExc_ValueError$segment() {
        return PyExc_ValueError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ValueError
     * }
     */
    public static MemorySegment PyExc_ValueError() {
        return PyExc_ValueError$constants.SEGMENT.get(PyExc_ValueError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ValueError
     * }
     */
    public static void PyExc_ValueError(MemorySegment varValue) {
        PyExc_ValueError$constants.SEGMENT.set(PyExc_ValueError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_ZeroDivisionError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_ZeroDivisionError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ZeroDivisionError
     * }
     */
    public static AddressLayout PyExc_ZeroDivisionError$layout() {
        return PyExc_ZeroDivisionError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ZeroDivisionError
     * }
     */
    public static MemorySegment PyExc_ZeroDivisionError$segment() {
        return PyExc_ZeroDivisionError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ZeroDivisionError
     * }
     */
    public static MemorySegment PyExc_ZeroDivisionError() {
        return PyExc_ZeroDivisionError$constants.SEGMENT.get(PyExc_ZeroDivisionError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ZeroDivisionError
     * }
     */
    public static void PyExc_ZeroDivisionError(MemorySegment varValue) {
        PyExc_ZeroDivisionError$constants.SEGMENT.set(PyExc_ZeroDivisionError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_BlockingIOError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_BlockingIOError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_BlockingIOError
     * }
     */
    public static AddressLayout PyExc_BlockingIOError$layout() {
        return PyExc_BlockingIOError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_BlockingIOError
     * }
     */
    public static MemorySegment PyExc_BlockingIOError$segment() {
        return PyExc_BlockingIOError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_BlockingIOError
     * }
     */
    public static MemorySegment PyExc_BlockingIOError() {
        return PyExc_BlockingIOError$constants.SEGMENT.get(PyExc_BlockingIOError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_BlockingIOError
     * }
     */
    public static void PyExc_BlockingIOError(MemorySegment varValue) {
        PyExc_BlockingIOError$constants.SEGMENT.set(PyExc_BlockingIOError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_BrokenPipeError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_BrokenPipeError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_BrokenPipeError
     * }
     */
    public static AddressLayout PyExc_BrokenPipeError$layout() {
        return PyExc_BrokenPipeError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_BrokenPipeError
     * }
     */
    public static MemorySegment PyExc_BrokenPipeError$segment() {
        return PyExc_BrokenPipeError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_BrokenPipeError
     * }
     */
    public static MemorySegment PyExc_BrokenPipeError() {
        return PyExc_BrokenPipeError$constants.SEGMENT.get(PyExc_BrokenPipeError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_BrokenPipeError
     * }
     */
    public static void PyExc_BrokenPipeError(MemorySegment varValue) {
        PyExc_BrokenPipeError$constants.SEGMENT.set(PyExc_BrokenPipeError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_ChildProcessError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_ChildProcessError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ChildProcessError
     * }
     */
    public static AddressLayout PyExc_ChildProcessError$layout() {
        return PyExc_ChildProcessError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ChildProcessError
     * }
     */
    public static MemorySegment PyExc_ChildProcessError$segment() {
        return PyExc_ChildProcessError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ChildProcessError
     * }
     */
    public static MemorySegment PyExc_ChildProcessError() {
        return PyExc_ChildProcessError$constants.SEGMENT.get(PyExc_ChildProcessError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ChildProcessError
     * }
     */
    public static void PyExc_ChildProcessError(MemorySegment varValue) {
        PyExc_ChildProcessError$constants.SEGMENT.set(PyExc_ChildProcessError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_ConnectionError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_ConnectionError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ConnectionError
     * }
     */
    public static AddressLayout PyExc_ConnectionError$layout() {
        return PyExc_ConnectionError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ConnectionError
     * }
     */
    public static MemorySegment PyExc_ConnectionError$segment() {
        return PyExc_ConnectionError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ConnectionError
     * }
     */
    public static MemorySegment PyExc_ConnectionError() {
        return PyExc_ConnectionError$constants.SEGMENT.get(PyExc_ConnectionError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ConnectionError
     * }
     */
    public static void PyExc_ConnectionError(MemorySegment varValue) {
        PyExc_ConnectionError$constants.SEGMENT.set(PyExc_ConnectionError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_ConnectionAbortedError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_ConnectionAbortedError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ConnectionAbortedError
     * }
     */
    public static AddressLayout PyExc_ConnectionAbortedError$layout() {
        return PyExc_ConnectionAbortedError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ConnectionAbortedError
     * }
     */
    public static MemorySegment PyExc_ConnectionAbortedError$segment() {
        return PyExc_ConnectionAbortedError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ConnectionAbortedError
     * }
     */
    public static MemorySegment PyExc_ConnectionAbortedError() {
        return PyExc_ConnectionAbortedError$constants.SEGMENT.get(PyExc_ConnectionAbortedError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ConnectionAbortedError
     * }
     */
    public static void PyExc_ConnectionAbortedError(MemorySegment varValue) {
        PyExc_ConnectionAbortedError$constants.SEGMENT.set(PyExc_ConnectionAbortedError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_ConnectionRefusedError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_ConnectionRefusedError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ConnectionRefusedError
     * }
     */
    public static AddressLayout PyExc_ConnectionRefusedError$layout() {
        return PyExc_ConnectionRefusedError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ConnectionRefusedError
     * }
     */
    public static MemorySegment PyExc_ConnectionRefusedError$segment() {
        return PyExc_ConnectionRefusedError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ConnectionRefusedError
     * }
     */
    public static MemorySegment PyExc_ConnectionRefusedError() {
        return PyExc_ConnectionRefusedError$constants.SEGMENT.get(PyExc_ConnectionRefusedError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ConnectionRefusedError
     * }
     */
    public static void PyExc_ConnectionRefusedError(MemorySegment varValue) {
        PyExc_ConnectionRefusedError$constants.SEGMENT.set(PyExc_ConnectionRefusedError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_ConnectionResetError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_ConnectionResetError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ConnectionResetError
     * }
     */
    public static AddressLayout PyExc_ConnectionResetError$layout() {
        return PyExc_ConnectionResetError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ConnectionResetError
     * }
     */
    public static MemorySegment PyExc_ConnectionResetError$segment() {
        return PyExc_ConnectionResetError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ConnectionResetError
     * }
     */
    public static MemorySegment PyExc_ConnectionResetError() {
        return PyExc_ConnectionResetError$constants.SEGMENT.get(PyExc_ConnectionResetError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ConnectionResetError
     * }
     */
    public static void PyExc_ConnectionResetError(MemorySegment varValue) {
        PyExc_ConnectionResetError$constants.SEGMENT.set(PyExc_ConnectionResetError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_FileExistsError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_FileExistsError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_FileExistsError
     * }
     */
    public static AddressLayout PyExc_FileExistsError$layout() {
        return PyExc_FileExistsError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_FileExistsError
     * }
     */
    public static MemorySegment PyExc_FileExistsError$segment() {
        return PyExc_FileExistsError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_FileExistsError
     * }
     */
    public static MemorySegment PyExc_FileExistsError() {
        return PyExc_FileExistsError$constants.SEGMENT.get(PyExc_FileExistsError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_FileExistsError
     * }
     */
    public static void PyExc_FileExistsError(MemorySegment varValue) {
        PyExc_FileExistsError$constants.SEGMENT.set(PyExc_FileExistsError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_FileNotFoundError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_FileNotFoundError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_FileNotFoundError
     * }
     */
    public static AddressLayout PyExc_FileNotFoundError$layout() {
        return PyExc_FileNotFoundError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_FileNotFoundError
     * }
     */
    public static MemorySegment PyExc_FileNotFoundError$segment() {
        return PyExc_FileNotFoundError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_FileNotFoundError
     * }
     */
    public static MemorySegment PyExc_FileNotFoundError() {
        return PyExc_FileNotFoundError$constants.SEGMENT.get(PyExc_FileNotFoundError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_FileNotFoundError
     * }
     */
    public static void PyExc_FileNotFoundError(MemorySegment varValue) {
        PyExc_FileNotFoundError$constants.SEGMENT.set(PyExc_FileNotFoundError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_InterruptedError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_InterruptedError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_InterruptedError
     * }
     */
    public static AddressLayout PyExc_InterruptedError$layout() {
        return PyExc_InterruptedError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_InterruptedError
     * }
     */
    public static MemorySegment PyExc_InterruptedError$segment() {
        return PyExc_InterruptedError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_InterruptedError
     * }
     */
    public static MemorySegment PyExc_InterruptedError() {
        return PyExc_InterruptedError$constants.SEGMENT.get(PyExc_InterruptedError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_InterruptedError
     * }
     */
    public static void PyExc_InterruptedError(MemorySegment varValue) {
        PyExc_InterruptedError$constants.SEGMENT.set(PyExc_InterruptedError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_IsADirectoryError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_IsADirectoryError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_IsADirectoryError
     * }
     */
    public static AddressLayout PyExc_IsADirectoryError$layout() {
        return PyExc_IsADirectoryError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_IsADirectoryError
     * }
     */
    public static MemorySegment PyExc_IsADirectoryError$segment() {
        return PyExc_IsADirectoryError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_IsADirectoryError
     * }
     */
    public static MemorySegment PyExc_IsADirectoryError() {
        return PyExc_IsADirectoryError$constants.SEGMENT.get(PyExc_IsADirectoryError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_IsADirectoryError
     * }
     */
    public static void PyExc_IsADirectoryError(MemorySegment varValue) {
        PyExc_IsADirectoryError$constants.SEGMENT.set(PyExc_IsADirectoryError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_NotADirectoryError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_NotADirectoryError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_NotADirectoryError
     * }
     */
    public static AddressLayout PyExc_NotADirectoryError$layout() {
        return PyExc_NotADirectoryError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_NotADirectoryError
     * }
     */
    public static MemorySegment PyExc_NotADirectoryError$segment() {
        return PyExc_NotADirectoryError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_NotADirectoryError
     * }
     */
    public static MemorySegment PyExc_NotADirectoryError() {
        return PyExc_NotADirectoryError$constants.SEGMENT.get(PyExc_NotADirectoryError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_NotADirectoryError
     * }
     */
    public static void PyExc_NotADirectoryError(MemorySegment varValue) {
        PyExc_NotADirectoryError$constants.SEGMENT.set(PyExc_NotADirectoryError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_PermissionError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_PermissionError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_PermissionError
     * }
     */
    public static AddressLayout PyExc_PermissionError$layout() {
        return PyExc_PermissionError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_PermissionError
     * }
     */
    public static MemorySegment PyExc_PermissionError$segment() {
        return PyExc_PermissionError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_PermissionError
     * }
     */
    public static MemorySegment PyExc_PermissionError() {
        return PyExc_PermissionError$constants.SEGMENT.get(PyExc_PermissionError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_PermissionError
     * }
     */
    public static void PyExc_PermissionError(MemorySegment varValue) {
        PyExc_PermissionError$constants.SEGMENT.set(PyExc_PermissionError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_ProcessLookupError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_ProcessLookupError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ProcessLookupError
     * }
     */
    public static AddressLayout PyExc_ProcessLookupError$layout() {
        return PyExc_ProcessLookupError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ProcessLookupError
     * }
     */
    public static MemorySegment PyExc_ProcessLookupError$segment() {
        return PyExc_ProcessLookupError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ProcessLookupError
     * }
     */
    public static MemorySegment PyExc_ProcessLookupError() {
        return PyExc_ProcessLookupError$constants.SEGMENT.get(PyExc_ProcessLookupError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ProcessLookupError
     * }
     */
    public static void PyExc_ProcessLookupError(MemorySegment varValue) {
        PyExc_ProcessLookupError$constants.SEGMENT.set(PyExc_ProcessLookupError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_TimeoutError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_TimeoutError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_TimeoutError
     * }
     */
    public static AddressLayout PyExc_TimeoutError$layout() {
        return PyExc_TimeoutError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_TimeoutError
     * }
     */
    public static MemorySegment PyExc_TimeoutError$segment() {
        return PyExc_TimeoutError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_TimeoutError
     * }
     */
    public static MemorySegment PyExc_TimeoutError() {
        return PyExc_TimeoutError$constants.SEGMENT.get(PyExc_TimeoutError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_TimeoutError
     * }
     */
    public static void PyExc_TimeoutError(MemorySegment varValue) {
        PyExc_TimeoutError$constants.SEGMENT.set(PyExc_TimeoutError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_EnvironmentError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_EnvironmentError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_EnvironmentError
     * }
     */
    public static AddressLayout PyExc_EnvironmentError$layout() {
        return PyExc_EnvironmentError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_EnvironmentError
     * }
     */
    public static MemorySegment PyExc_EnvironmentError$segment() {
        return PyExc_EnvironmentError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_EnvironmentError
     * }
     */
    public static MemorySegment PyExc_EnvironmentError() {
        return PyExc_EnvironmentError$constants.SEGMENT.get(PyExc_EnvironmentError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_EnvironmentError
     * }
     */
    public static void PyExc_EnvironmentError(MemorySegment varValue) {
        PyExc_EnvironmentError$constants.SEGMENT.set(PyExc_EnvironmentError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_IOError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_IOError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_IOError
     * }
     */
    public static AddressLayout PyExc_IOError$layout() {
        return PyExc_IOError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_IOError
     * }
     */
    public static MemorySegment PyExc_IOError$segment() {
        return PyExc_IOError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_IOError
     * }
     */
    public static MemorySegment PyExc_IOError() {
        return PyExc_IOError$constants.SEGMENT.get(PyExc_IOError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_IOError
     * }
     */
    public static void PyExc_IOError(MemorySegment varValue) {
        PyExc_IOError$constants.SEGMENT.set(PyExc_IOError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_WindowsError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_WindowsError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_WindowsError
     * }
     */
    public static AddressLayout PyExc_WindowsError$layout() {
        return PyExc_WindowsError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_WindowsError
     * }
     */
    public static MemorySegment PyExc_WindowsError$segment() {
        return PyExc_WindowsError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_WindowsError
     * }
     */
    public static MemorySegment PyExc_WindowsError() {
        return PyExc_WindowsError$constants.SEGMENT.get(PyExc_WindowsError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_WindowsError
     * }
     */
    public static void PyExc_WindowsError(MemorySegment varValue) {
        PyExc_WindowsError$constants.SEGMENT.set(PyExc_WindowsError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_Warning$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_Warning").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_Warning
     * }
     */
    public static AddressLayout PyExc_Warning$layout() {
        return PyExc_Warning$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_Warning
     * }
     */
    public static MemorySegment PyExc_Warning$segment() {
        return PyExc_Warning$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_Warning
     * }
     */
    public static MemorySegment PyExc_Warning() {
        return PyExc_Warning$constants.SEGMENT.get(PyExc_Warning$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_Warning
     * }
     */
    public static void PyExc_Warning(MemorySegment varValue) {
        PyExc_Warning$constants.SEGMENT.set(PyExc_Warning$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_UserWarning$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_UserWarning").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_UserWarning
     * }
     */
    public static AddressLayout PyExc_UserWarning$layout() {
        return PyExc_UserWarning$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_UserWarning
     * }
     */
    public static MemorySegment PyExc_UserWarning$segment() {
        return PyExc_UserWarning$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_UserWarning
     * }
     */
    public static MemorySegment PyExc_UserWarning() {
        return PyExc_UserWarning$constants.SEGMENT.get(PyExc_UserWarning$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_UserWarning
     * }
     */
    public static void PyExc_UserWarning(MemorySegment varValue) {
        PyExc_UserWarning$constants.SEGMENT.set(PyExc_UserWarning$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_DeprecationWarning$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_DeprecationWarning").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_DeprecationWarning
     * }
     */
    public static AddressLayout PyExc_DeprecationWarning$layout() {
        return PyExc_DeprecationWarning$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_DeprecationWarning
     * }
     */
    public static MemorySegment PyExc_DeprecationWarning$segment() {
        return PyExc_DeprecationWarning$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_DeprecationWarning
     * }
     */
    public static MemorySegment PyExc_DeprecationWarning() {
        return PyExc_DeprecationWarning$constants.SEGMENT.get(PyExc_DeprecationWarning$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_DeprecationWarning
     * }
     */
    public static void PyExc_DeprecationWarning(MemorySegment varValue) {
        PyExc_DeprecationWarning$constants.SEGMENT.set(PyExc_DeprecationWarning$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_PendingDeprecationWarning$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_PendingDeprecationWarning").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_PendingDeprecationWarning
     * }
     */
    public static AddressLayout PyExc_PendingDeprecationWarning$layout() {
        return PyExc_PendingDeprecationWarning$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_PendingDeprecationWarning
     * }
     */
    public static MemorySegment PyExc_PendingDeprecationWarning$segment() {
        return PyExc_PendingDeprecationWarning$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_PendingDeprecationWarning
     * }
     */
    public static MemorySegment PyExc_PendingDeprecationWarning() {
        return PyExc_PendingDeprecationWarning$constants.SEGMENT.get(PyExc_PendingDeprecationWarning$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_PendingDeprecationWarning
     * }
     */
    public static void PyExc_PendingDeprecationWarning(MemorySegment varValue) {
        PyExc_PendingDeprecationWarning$constants.SEGMENT.set(PyExc_PendingDeprecationWarning$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_SyntaxWarning$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_SyntaxWarning").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_SyntaxWarning
     * }
     */
    public static AddressLayout PyExc_SyntaxWarning$layout() {
        return PyExc_SyntaxWarning$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_SyntaxWarning
     * }
     */
    public static MemorySegment PyExc_SyntaxWarning$segment() {
        return PyExc_SyntaxWarning$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_SyntaxWarning
     * }
     */
    public static MemorySegment PyExc_SyntaxWarning() {
        return PyExc_SyntaxWarning$constants.SEGMENT.get(PyExc_SyntaxWarning$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_SyntaxWarning
     * }
     */
    public static void PyExc_SyntaxWarning(MemorySegment varValue) {
        PyExc_SyntaxWarning$constants.SEGMENT.set(PyExc_SyntaxWarning$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_RuntimeWarning$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_RuntimeWarning").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_RuntimeWarning
     * }
     */
    public static AddressLayout PyExc_RuntimeWarning$layout() {
        return PyExc_RuntimeWarning$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_RuntimeWarning
     * }
     */
    public static MemorySegment PyExc_RuntimeWarning$segment() {
        return PyExc_RuntimeWarning$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_RuntimeWarning
     * }
     */
    public static MemorySegment PyExc_RuntimeWarning() {
        return PyExc_RuntimeWarning$constants.SEGMENT.get(PyExc_RuntimeWarning$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_RuntimeWarning
     * }
     */
    public static void PyExc_RuntimeWarning(MemorySegment varValue) {
        PyExc_RuntimeWarning$constants.SEGMENT.set(PyExc_RuntimeWarning$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_FutureWarning$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_FutureWarning").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_FutureWarning
     * }
     */
    public static AddressLayout PyExc_FutureWarning$layout() {
        return PyExc_FutureWarning$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_FutureWarning
     * }
     */
    public static MemorySegment PyExc_FutureWarning$segment() {
        return PyExc_FutureWarning$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_FutureWarning
     * }
     */
    public static MemorySegment PyExc_FutureWarning() {
        return PyExc_FutureWarning$constants.SEGMENT.get(PyExc_FutureWarning$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_FutureWarning
     * }
     */
    public static void PyExc_FutureWarning(MemorySegment varValue) {
        PyExc_FutureWarning$constants.SEGMENT.set(PyExc_FutureWarning$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_ImportWarning$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_ImportWarning").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ImportWarning
     * }
     */
    public static AddressLayout PyExc_ImportWarning$layout() {
        return PyExc_ImportWarning$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ImportWarning
     * }
     */
    public static MemorySegment PyExc_ImportWarning$segment() {
        return PyExc_ImportWarning$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ImportWarning
     * }
     */
    public static MemorySegment PyExc_ImportWarning() {
        return PyExc_ImportWarning$constants.SEGMENT.get(PyExc_ImportWarning$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ImportWarning
     * }
     */
    public static void PyExc_ImportWarning(MemorySegment varValue) {
        PyExc_ImportWarning$constants.SEGMENT.set(PyExc_ImportWarning$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_UnicodeWarning$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_UnicodeWarning").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_UnicodeWarning
     * }
     */
    public static AddressLayout PyExc_UnicodeWarning$layout() {
        return PyExc_UnicodeWarning$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_UnicodeWarning
     * }
     */
    public static MemorySegment PyExc_UnicodeWarning$segment() {
        return PyExc_UnicodeWarning$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_UnicodeWarning
     * }
     */
    public static MemorySegment PyExc_UnicodeWarning() {
        return PyExc_UnicodeWarning$constants.SEGMENT.get(PyExc_UnicodeWarning$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_UnicodeWarning
     * }
     */
    public static void PyExc_UnicodeWarning(MemorySegment varValue) {
        PyExc_UnicodeWarning$constants.SEGMENT.set(PyExc_UnicodeWarning$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_BytesWarning$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_BytesWarning").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_BytesWarning
     * }
     */
    public static AddressLayout PyExc_BytesWarning$layout() {
        return PyExc_BytesWarning$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_BytesWarning
     * }
     */
    public static MemorySegment PyExc_BytesWarning$segment() {
        return PyExc_BytesWarning$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_BytesWarning
     * }
     */
    public static MemorySegment PyExc_BytesWarning() {
        return PyExc_BytesWarning$constants.SEGMENT.get(PyExc_BytesWarning$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_BytesWarning
     * }
     */
    public static void PyExc_BytesWarning(MemorySegment varValue) {
        PyExc_BytesWarning$constants.SEGMENT.set(PyExc_BytesWarning$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_EncodingWarning$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_EncodingWarning").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_EncodingWarning
     * }
     */
    public static AddressLayout PyExc_EncodingWarning$layout() {
        return PyExc_EncodingWarning$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_EncodingWarning
     * }
     */
    public static MemorySegment PyExc_EncodingWarning$segment() {
        return PyExc_EncodingWarning$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_EncodingWarning
     * }
     */
    public static MemorySegment PyExc_EncodingWarning() {
        return PyExc_EncodingWarning$constants.SEGMENT.get(PyExc_EncodingWarning$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_EncodingWarning
     * }
     */
    public static void PyExc_EncodingWarning(MemorySegment varValue) {
        PyExc_EncodingWarning$constants.SEGMENT.set(PyExc_EncodingWarning$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_ResourceWarning$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_ResourceWarning").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ResourceWarning
     * }
     */
    public static AddressLayout PyExc_ResourceWarning$layout() {
        return PyExc_ResourceWarning$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ResourceWarning
     * }
     */
    public static MemorySegment PyExc_ResourceWarning$segment() {
        return PyExc_ResourceWarning$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ResourceWarning
     * }
     */
    public static MemorySegment PyExc_ResourceWarning() {
        return PyExc_ResourceWarning$constants.SEGMENT.get(PyExc_ResourceWarning$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ResourceWarning
     * }
     */
    public static void PyExc_ResourceWarning(MemorySegment varValue) {
        PyExc_ResourceWarning$constants.SEGMENT.set(PyExc_ResourceWarning$constants.LAYOUT, 0L, varValue);
    }

    private static class PyErr_BadArgument {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_BadArgument");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyErr_BadArgument()
     * }
     */
    public static FunctionDescriptor PyErr_BadArgument$descriptor() {
        return PyErr_BadArgument.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyErr_BadArgument()
     * }
     */
    public static MethodHandle PyErr_BadArgument$handle() {
        return PyErr_BadArgument.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyErr_BadArgument()
     * }
     */
    public static MemorySegment PyErr_BadArgument$address() {
        return PyErr_BadArgument.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyErr_BadArgument()
     * }
     */
    public static int PyErr_BadArgument() {
        var mh$ = PyErr_BadArgument.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyErr_BadArgument");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyErr_NoMemory {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_NoMemory");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyErr_NoMemory()
     * }
     */
    public static FunctionDescriptor PyErr_NoMemory$descriptor() {
        return PyErr_NoMemory.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyErr_NoMemory()
     * }
     */
    public static MethodHandle PyErr_NoMemory$handle() {
        return PyErr_NoMemory.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyErr_NoMemory()
     * }
     */
    public static MemorySegment PyErr_NoMemory$address() {
        return PyErr_NoMemory.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyErr_NoMemory()
     * }
     */
    public static MemorySegment PyErr_NoMemory() {
        var mh$ = PyErr_NoMemory.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyErr_NoMemory");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyErr_SetFromErrno {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_SetFromErrno");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyErr_SetFromErrno(PyObject *)
     * }
     */
    public static FunctionDescriptor PyErr_SetFromErrno$descriptor() {
        return PyErr_SetFromErrno.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyErr_SetFromErrno(PyObject *)
     * }
     */
    public static MethodHandle PyErr_SetFromErrno$handle() {
        return PyErr_SetFromErrno.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyErr_SetFromErrno(PyObject *)
     * }
     */
    public static MemorySegment PyErr_SetFromErrno$address() {
        return PyErr_SetFromErrno.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyErr_SetFromErrno(PyObject *)
     * }
     */
    public static MemorySegment PyErr_SetFromErrno(MemorySegment x0) {
        var mh$ = PyErr_SetFromErrno.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyErr_SetFromErrno", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyErr_SetFromErrnoWithFilenameObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_SetFromErrnoWithFilenameObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyErr_SetFromErrnoWithFilenameObject(PyObject *, PyObject *)
     * }
     */
    public static FunctionDescriptor PyErr_SetFromErrnoWithFilenameObject$descriptor() {
        return PyErr_SetFromErrnoWithFilenameObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyErr_SetFromErrnoWithFilenameObject(PyObject *, PyObject *)
     * }
     */
    public static MethodHandle PyErr_SetFromErrnoWithFilenameObject$handle() {
        return PyErr_SetFromErrnoWithFilenameObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyErr_SetFromErrnoWithFilenameObject(PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyErr_SetFromErrnoWithFilenameObject$address() {
        return PyErr_SetFromErrnoWithFilenameObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyErr_SetFromErrnoWithFilenameObject(PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyErr_SetFromErrnoWithFilenameObject(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyErr_SetFromErrnoWithFilenameObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyErr_SetFromErrnoWithFilenameObject", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyErr_SetFromErrnoWithFilenameObjects {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_SetFromErrnoWithFilenameObjects");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyErr_SetFromErrnoWithFilenameObjects(PyObject *, PyObject *, PyObject *)
     * }
     */
    public static FunctionDescriptor PyErr_SetFromErrnoWithFilenameObjects$descriptor() {
        return PyErr_SetFromErrnoWithFilenameObjects.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyErr_SetFromErrnoWithFilenameObjects(PyObject *, PyObject *, PyObject *)
     * }
     */
    public static MethodHandle PyErr_SetFromErrnoWithFilenameObjects$handle() {
        return PyErr_SetFromErrnoWithFilenameObjects.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyErr_SetFromErrnoWithFilenameObjects(PyObject *, PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyErr_SetFromErrnoWithFilenameObjects$address() {
        return PyErr_SetFromErrnoWithFilenameObjects.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyErr_SetFromErrnoWithFilenameObjects(PyObject *, PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyErr_SetFromErrnoWithFilenameObjects(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = PyErr_SetFromErrnoWithFilenameObjects.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyErr_SetFromErrnoWithFilenameObjects", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyErr_SetFromErrnoWithFilename {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_SetFromErrnoWithFilename");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyErr_SetFromErrnoWithFilename(PyObject *exc, const char *filename)
     * }
     */
    public static FunctionDescriptor PyErr_SetFromErrnoWithFilename$descriptor() {
        return PyErr_SetFromErrnoWithFilename.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyErr_SetFromErrnoWithFilename(PyObject *exc, const char *filename)
     * }
     */
    public static MethodHandle PyErr_SetFromErrnoWithFilename$handle() {
        return PyErr_SetFromErrnoWithFilename.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyErr_SetFromErrnoWithFilename(PyObject *exc, const char *filename)
     * }
     */
    public static MemorySegment PyErr_SetFromErrnoWithFilename$address() {
        return PyErr_SetFromErrnoWithFilename.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyErr_SetFromErrnoWithFilename(PyObject *exc, const char *filename)
     * }
     */
    public static MemorySegment PyErr_SetFromErrnoWithFilename(MemorySegment exc, MemorySegment filename) {
        var mh$ = PyErr_SetFromErrnoWithFilename.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyErr_SetFromErrnoWithFilename", exc, filename);
            }
            return (MemorySegment)mh$.invokeExact(exc, filename);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * PyObject *PyErr_Format(PyObject *exception, const char *format, ...)
     * }
     */
    public static class PyErr_Format {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_POINTER,
                Python_h.C_POINTER,
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_Format");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private PyErr_Format(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * PyObject *PyErr_Format(PyObject *exception, const char *format, ...)
         * }
         */
        public static PyErr_Format makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new PyErr_Format(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public MemorySegment apply(MemorySegment exception, MemorySegment format, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("PyErr_Format", exception, format, x2);
                }
                return (MemorySegment)spreader.invokeExact(exception, format, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class PyErr_FormatV {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_FormatV");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyErr_FormatV(PyObject *exception, const char *format, va_list vargs)
     * }
     */
    public static FunctionDescriptor PyErr_FormatV$descriptor() {
        return PyErr_FormatV.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyErr_FormatV(PyObject *exception, const char *format, va_list vargs)
     * }
     */
    public static MethodHandle PyErr_FormatV$handle() {
        return PyErr_FormatV.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyErr_FormatV(PyObject *exception, const char *format, va_list vargs)
     * }
     */
    public static MemorySegment PyErr_FormatV$address() {
        return PyErr_FormatV.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyErr_FormatV(PyObject *exception, const char *format, va_list vargs)
     * }
     */
    public static MemorySegment PyErr_FormatV(MemorySegment exception, MemorySegment format, MemorySegment vargs) {
        var mh$ = PyErr_FormatV.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyErr_FormatV", exception, format, vargs);
            }
            return (MemorySegment)mh$.invokeExact(exception, format, vargs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyErr_SetFromWindowsErrWithFilename {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_SetFromWindowsErrWithFilename");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyErr_SetFromWindowsErrWithFilename(int ierr, const char *filename)
     * }
     */
    public static FunctionDescriptor PyErr_SetFromWindowsErrWithFilename$descriptor() {
        return PyErr_SetFromWindowsErrWithFilename.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyErr_SetFromWindowsErrWithFilename(int ierr, const char *filename)
     * }
     */
    public static MethodHandle PyErr_SetFromWindowsErrWithFilename$handle() {
        return PyErr_SetFromWindowsErrWithFilename.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyErr_SetFromWindowsErrWithFilename(int ierr, const char *filename)
     * }
     */
    public static MemorySegment PyErr_SetFromWindowsErrWithFilename$address() {
        return PyErr_SetFromWindowsErrWithFilename.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyErr_SetFromWindowsErrWithFilename(int ierr, const char *filename)
     * }
     */
    public static MemorySegment PyErr_SetFromWindowsErrWithFilename(int ierr, MemorySegment filename) {
        var mh$ = PyErr_SetFromWindowsErrWithFilename.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyErr_SetFromWindowsErrWithFilename", ierr, filename);
            }
            return (MemorySegment)mh$.invokeExact(ierr, filename);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyErr_SetFromWindowsErr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_SetFromWindowsErr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyErr_SetFromWindowsErr(int)
     * }
     */
    public static FunctionDescriptor PyErr_SetFromWindowsErr$descriptor() {
        return PyErr_SetFromWindowsErr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyErr_SetFromWindowsErr(int)
     * }
     */
    public static MethodHandle PyErr_SetFromWindowsErr$handle() {
        return PyErr_SetFromWindowsErr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyErr_SetFromWindowsErr(int)
     * }
     */
    public static MemorySegment PyErr_SetFromWindowsErr$address() {
        return PyErr_SetFromWindowsErr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyErr_SetFromWindowsErr(int)
     * }
     */
    public static MemorySegment PyErr_SetFromWindowsErr(int x0) {
        var mh$ = PyErr_SetFromWindowsErr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyErr_SetFromWindowsErr", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyErr_SetExcFromWindowsErrWithFilenameObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_SetExcFromWindowsErrWithFilenameObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyErr_SetExcFromWindowsErrWithFilenameObject(PyObject *, int, PyObject *)
     * }
     */
    public static FunctionDescriptor PyErr_SetExcFromWindowsErrWithFilenameObject$descriptor() {
        return PyErr_SetExcFromWindowsErrWithFilenameObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyErr_SetExcFromWindowsErrWithFilenameObject(PyObject *, int, PyObject *)
     * }
     */
    public static MethodHandle PyErr_SetExcFromWindowsErrWithFilenameObject$handle() {
        return PyErr_SetExcFromWindowsErrWithFilenameObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyErr_SetExcFromWindowsErrWithFilenameObject(PyObject *, int, PyObject *)
     * }
     */
    public static MemorySegment PyErr_SetExcFromWindowsErrWithFilenameObject$address() {
        return PyErr_SetExcFromWindowsErrWithFilenameObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyErr_SetExcFromWindowsErrWithFilenameObject(PyObject *, int, PyObject *)
     * }
     */
    public static MemorySegment PyErr_SetExcFromWindowsErrWithFilenameObject(MemorySegment x0, int x1, MemorySegment x2) {
        var mh$ = PyErr_SetExcFromWindowsErrWithFilenameObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyErr_SetExcFromWindowsErrWithFilenameObject", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyErr_SetExcFromWindowsErrWithFilenameObjects {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_SetExcFromWindowsErrWithFilenameObjects");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyErr_SetExcFromWindowsErrWithFilenameObjects(PyObject *, int, PyObject *, PyObject *)
     * }
     */
    public static FunctionDescriptor PyErr_SetExcFromWindowsErrWithFilenameObjects$descriptor() {
        return PyErr_SetExcFromWindowsErrWithFilenameObjects.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyErr_SetExcFromWindowsErrWithFilenameObjects(PyObject *, int, PyObject *, PyObject *)
     * }
     */
    public static MethodHandle PyErr_SetExcFromWindowsErrWithFilenameObjects$handle() {
        return PyErr_SetExcFromWindowsErrWithFilenameObjects.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyErr_SetExcFromWindowsErrWithFilenameObjects(PyObject *, int, PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyErr_SetExcFromWindowsErrWithFilenameObjects$address() {
        return PyErr_SetExcFromWindowsErrWithFilenameObjects.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyErr_SetExcFromWindowsErrWithFilenameObjects(PyObject *, int, PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyErr_SetExcFromWindowsErrWithFilenameObjects(MemorySegment x0, int x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = PyErr_SetExcFromWindowsErrWithFilenameObjects.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyErr_SetExcFromWindowsErrWithFilenameObjects", x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyErr_SetExcFromWindowsErrWithFilename {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_SetExcFromWindowsErrWithFilename");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyErr_SetExcFromWindowsErrWithFilename(PyObject *exc, int ierr, const char *filename)
     * }
     */
    public static FunctionDescriptor PyErr_SetExcFromWindowsErrWithFilename$descriptor() {
        return PyErr_SetExcFromWindowsErrWithFilename.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyErr_SetExcFromWindowsErrWithFilename(PyObject *exc, int ierr, const char *filename)
     * }
     */
    public static MethodHandle PyErr_SetExcFromWindowsErrWithFilename$handle() {
        return PyErr_SetExcFromWindowsErrWithFilename.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyErr_SetExcFromWindowsErrWithFilename(PyObject *exc, int ierr, const char *filename)
     * }
     */
    public static MemorySegment PyErr_SetExcFromWindowsErrWithFilename$address() {
        return PyErr_SetExcFromWindowsErrWithFilename.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyErr_SetExcFromWindowsErrWithFilename(PyObject *exc, int ierr, const char *filename)
     * }
     */
    public static MemorySegment PyErr_SetExcFromWindowsErrWithFilename(MemorySegment exc, int ierr, MemorySegment filename) {
        var mh$ = PyErr_SetExcFromWindowsErrWithFilename.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyErr_SetExcFromWindowsErrWithFilename", exc, ierr, filename);
            }
            return (MemorySegment)mh$.invokeExact(exc, ierr, filename);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyErr_SetExcFromWindowsErr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_SetExcFromWindowsErr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyErr_SetExcFromWindowsErr(PyObject *, int)
     * }
     */
    public static FunctionDescriptor PyErr_SetExcFromWindowsErr$descriptor() {
        return PyErr_SetExcFromWindowsErr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyErr_SetExcFromWindowsErr(PyObject *, int)
     * }
     */
    public static MethodHandle PyErr_SetExcFromWindowsErr$handle() {
        return PyErr_SetExcFromWindowsErr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyErr_SetExcFromWindowsErr(PyObject *, int)
     * }
     */
    public static MemorySegment PyErr_SetExcFromWindowsErr$address() {
        return PyErr_SetExcFromWindowsErr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyErr_SetExcFromWindowsErr(PyObject *, int)
     * }
     */
    public static MemorySegment PyErr_SetExcFromWindowsErr(MemorySegment x0, int x1) {
        var mh$ = PyErr_SetExcFromWindowsErr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyErr_SetExcFromWindowsErr", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyErr_SetImportErrorSubclass {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_SetImportErrorSubclass");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyErr_SetImportErrorSubclass(PyObject *, PyObject *, PyObject *, PyObject *)
     * }
     */
    public static FunctionDescriptor PyErr_SetImportErrorSubclass$descriptor() {
        return PyErr_SetImportErrorSubclass.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyErr_SetImportErrorSubclass(PyObject *, PyObject *, PyObject *, PyObject *)
     * }
     */
    public static MethodHandle PyErr_SetImportErrorSubclass$handle() {
        return PyErr_SetImportErrorSubclass.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyErr_SetImportErrorSubclass(PyObject *, PyObject *, PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyErr_SetImportErrorSubclass$address() {
        return PyErr_SetImportErrorSubclass.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyErr_SetImportErrorSubclass(PyObject *, PyObject *, PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyErr_SetImportErrorSubclass(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = PyErr_SetImportErrorSubclass.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyErr_SetImportErrorSubclass", x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyErr_SetImportError {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_SetImportError");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyErr_SetImportError(PyObject *, PyObject *, PyObject *)
     * }
     */
    public static FunctionDescriptor PyErr_SetImportError$descriptor() {
        return PyErr_SetImportError.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyErr_SetImportError(PyObject *, PyObject *, PyObject *)
     * }
     */
    public static MethodHandle PyErr_SetImportError$handle() {
        return PyErr_SetImportError.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyErr_SetImportError(PyObject *, PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyErr_SetImportError$address() {
        return PyErr_SetImportError.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyErr_SetImportError(PyObject *, PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyErr_SetImportError(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = PyErr_SetImportError.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyErr_SetImportError", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyErr_BadInternalCall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_BadInternalCall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyErr_BadInternalCall()
     * }
     */
    public static FunctionDescriptor PyErr_BadInternalCall$descriptor() {
        return PyErr_BadInternalCall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyErr_BadInternalCall()
     * }
     */
    public static MethodHandle PyErr_BadInternalCall$handle() {
        return PyErr_BadInternalCall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyErr_BadInternalCall()
     * }
     */
    public static MemorySegment PyErr_BadInternalCall$address() {
        return PyErr_BadInternalCall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyErr_BadInternalCall()
     * }
     */
    public static void PyErr_BadInternalCall() {
        var mh$ = PyErr_BadInternalCall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyErr_BadInternalCall");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyErr_BadInternalCall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyErr_BadInternalCall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _PyErr_BadInternalCall(const char *filename, int lineno)
     * }
     */
    public static FunctionDescriptor _PyErr_BadInternalCall$descriptor() {
        return _PyErr_BadInternalCall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _PyErr_BadInternalCall(const char *filename, int lineno)
     * }
     */
    public static MethodHandle _PyErr_BadInternalCall$handle() {
        return _PyErr_BadInternalCall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _PyErr_BadInternalCall(const char *filename, int lineno)
     * }
     */
    public static MemorySegment _PyErr_BadInternalCall$address() {
        return _PyErr_BadInternalCall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _PyErr_BadInternalCall(const char *filename, int lineno)
     * }
     */
    public static void _PyErr_BadInternalCall(MemorySegment filename, int lineno) {
        var mh$ = _PyErr_BadInternalCall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyErr_BadInternalCall", filename, lineno);
            }
            mh$.invokeExact(filename, lineno);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyErr_NewException {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_NewException");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyErr_NewException(const char *name, PyObject *base, PyObject *dict)
     * }
     */
    public static FunctionDescriptor PyErr_NewException$descriptor() {
        return PyErr_NewException.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyErr_NewException(const char *name, PyObject *base, PyObject *dict)
     * }
     */
    public static MethodHandle PyErr_NewException$handle() {
        return PyErr_NewException.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyErr_NewException(const char *name, PyObject *base, PyObject *dict)
     * }
     */
    public static MemorySegment PyErr_NewException$address() {
        return PyErr_NewException.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyErr_NewException(const char *name, PyObject *base, PyObject *dict)
     * }
     */
    public static MemorySegment PyErr_NewException(MemorySegment name, MemorySegment base, MemorySegment dict) {
        var mh$ = PyErr_NewException.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyErr_NewException", name, base, dict);
            }
            return (MemorySegment)mh$.invokeExact(name, base, dict);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyErr_NewExceptionWithDoc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_NewExceptionWithDoc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyErr_NewExceptionWithDoc(const char *name, const char *doc, PyObject *base, PyObject *dict)
     * }
     */
    public static FunctionDescriptor PyErr_NewExceptionWithDoc$descriptor() {
        return PyErr_NewExceptionWithDoc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyErr_NewExceptionWithDoc(const char *name, const char *doc, PyObject *base, PyObject *dict)
     * }
     */
    public static MethodHandle PyErr_NewExceptionWithDoc$handle() {
        return PyErr_NewExceptionWithDoc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyErr_NewExceptionWithDoc(const char *name, const char *doc, PyObject *base, PyObject *dict)
     * }
     */
    public static MemorySegment PyErr_NewExceptionWithDoc$address() {
        return PyErr_NewExceptionWithDoc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyErr_NewExceptionWithDoc(const char *name, const char *doc, PyObject *base, PyObject *dict)
     * }
     */
    public static MemorySegment PyErr_NewExceptionWithDoc(MemorySegment name, MemorySegment doc, MemorySegment base, MemorySegment dict) {
        var mh$ = PyErr_NewExceptionWithDoc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyErr_NewExceptionWithDoc", name, doc, base, dict);
            }
            return (MemorySegment)mh$.invokeExact(name, doc, base, dict);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyErr_WriteUnraisable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_WriteUnraisable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyErr_WriteUnraisable(PyObject *)
     * }
     */
    public static FunctionDescriptor PyErr_WriteUnraisable$descriptor() {
        return PyErr_WriteUnraisable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyErr_WriteUnraisable(PyObject *)
     * }
     */
    public static MethodHandle PyErr_WriteUnraisable$handle() {
        return PyErr_WriteUnraisable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyErr_WriteUnraisable(PyObject *)
     * }
     */
    public static MemorySegment PyErr_WriteUnraisable$address() {
        return PyErr_WriteUnraisable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyErr_WriteUnraisable(PyObject *)
     * }
     */
    public static void PyErr_WriteUnraisable(MemorySegment x0) {
        var mh$ = PyErr_WriteUnraisable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyErr_WriteUnraisable", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyErr_CheckSignals {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_CheckSignals");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyErr_CheckSignals()
     * }
     */
    public static FunctionDescriptor PyErr_CheckSignals$descriptor() {
        return PyErr_CheckSignals.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyErr_CheckSignals()
     * }
     */
    public static MethodHandle PyErr_CheckSignals$handle() {
        return PyErr_CheckSignals.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyErr_CheckSignals()
     * }
     */
    public static MemorySegment PyErr_CheckSignals$address() {
        return PyErr_CheckSignals.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyErr_CheckSignals()
     * }
     */
    public static int PyErr_CheckSignals() {
        var mh$ = PyErr_CheckSignals.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyErr_CheckSignals");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyErr_SetInterrupt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_SetInterrupt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyErr_SetInterrupt()
     * }
     */
    public static FunctionDescriptor PyErr_SetInterrupt$descriptor() {
        return PyErr_SetInterrupt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyErr_SetInterrupt()
     * }
     */
    public static MethodHandle PyErr_SetInterrupt$handle() {
        return PyErr_SetInterrupt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyErr_SetInterrupt()
     * }
     */
    public static MemorySegment PyErr_SetInterrupt$address() {
        return PyErr_SetInterrupt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyErr_SetInterrupt()
     * }
     */
    public static void PyErr_SetInterrupt() {
        var mh$ = PyErr_SetInterrupt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyErr_SetInterrupt");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyErr_SetInterruptEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_SetInterruptEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyErr_SetInterruptEx(int signum)
     * }
     */
    public static FunctionDescriptor PyErr_SetInterruptEx$descriptor() {
        return PyErr_SetInterruptEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyErr_SetInterruptEx(int signum)
     * }
     */
    public static MethodHandle PyErr_SetInterruptEx$handle() {
        return PyErr_SetInterruptEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyErr_SetInterruptEx(int signum)
     * }
     */
    public static MemorySegment PyErr_SetInterruptEx$address() {
        return PyErr_SetInterruptEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyErr_SetInterruptEx(int signum)
     * }
     */
    public static int PyErr_SetInterruptEx(int signum) {
        var mh$ = PyErr_SetInterruptEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyErr_SetInterruptEx", signum);
            }
            return (int)mh$.invokeExact(signum);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyErr_SyntaxLocation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_SyntaxLocation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyErr_SyntaxLocation(const char *filename, int lineno)
     * }
     */
    public static FunctionDescriptor PyErr_SyntaxLocation$descriptor() {
        return PyErr_SyntaxLocation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyErr_SyntaxLocation(const char *filename, int lineno)
     * }
     */
    public static MethodHandle PyErr_SyntaxLocation$handle() {
        return PyErr_SyntaxLocation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyErr_SyntaxLocation(const char *filename, int lineno)
     * }
     */
    public static MemorySegment PyErr_SyntaxLocation$address() {
        return PyErr_SyntaxLocation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyErr_SyntaxLocation(const char *filename, int lineno)
     * }
     */
    public static void PyErr_SyntaxLocation(MemorySegment filename, int lineno) {
        var mh$ = PyErr_SyntaxLocation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyErr_SyntaxLocation", filename, lineno);
            }
            mh$.invokeExact(filename, lineno);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyErr_SyntaxLocationEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_SyntaxLocationEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyErr_SyntaxLocationEx(const char *filename, int lineno, int col_offset)
     * }
     */
    public static FunctionDescriptor PyErr_SyntaxLocationEx$descriptor() {
        return PyErr_SyntaxLocationEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyErr_SyntaxLocationEx(const char *filename, int lineno, int col_offset)
     * }
     */
    public static MethodHandle PyErr_SyntaxLocationEx$handle() {
        return PyErr_SyntaxLocationEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyErr_SyntaxLocationEx(const char *filename, int lineno, int col_offset)
     * }
     */
    public static MemorySegment PyErr_SyntaxLocationEx$address() {
        return PyErr_SyntaxLocationEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyErr_SyntaxLocationEx(const char *filename, int lineno, int col_offset)
     * }
     */
    public static void PyErr_SyntaxLocationEx(MemorySegment filename, int lineno, int col_offset) {
        var mh$ = PyErr_SyntaxLocationEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyErr_SyntaxLocationEx", filename, lineno, col_offset);
            }
            mh$.invokeExact(filename, lineno, col_offset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyErr_ProgramText {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_ProgramText");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyErr_ProgramText(const char *filename, int lineno)
     * }
     */
    public static FunctionDescriptor PyErr_ProgramText$descriptor() {
        return PyErr_ProgramText.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyErr_ProgramText(const char *filename, int lineno)
     * }
     */
    public static MethodHandle PyErr_ProgramText$handle() {
        return PyErr_ProgramText.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyErr_ProgramText(const char *filename, int lineno)
     * }
     */
    public static MemorySegment PyErr_ProgramText$address() {
        return PyErr_ProgramText.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyErr_ProgramText(const char *filename, int lineno)
     * }
     */
    public static MemorySegment PyErr_ProgramText(MemorySegment filename, int lineno) {
        var mh$ = PyErr_ProgramText.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyErr_ProgramText", filename, lineno);
            }
            return (MemorySegment)mh$.invokeExact(filename, lineno);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicodeDecodeError_Create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_LONG_LONG,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicodeDecodeError_Create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicodeDecodeError_Create(const char *encoding, const char *object, Py_ssize_t length, Py_ssize_t start, Py_ssize_t end, const char *reason)
     * }
     */
    public static FunctionDescriptor PyUnicodeDecodeError_Create$descriptor() {
        return PyUnicodeDecodeError_Create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicodeDecodeError_Create(const char *encoding, const char *object, Py_ssize_t length, Py_ssize_t start, Py_ssize_t end, const char *reason)
     * }
     */
    public static MethodHandle PyUnicodeDecodeError_Create$handle() {
        return PyUnicodeDecodeError_Create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicodeDecodeError_Create(const char *encoding, const char *object, Py_ssize_t length, Py_ssize_t start, Py_ssize_t end, const char *reason)
     * }
     */
    public static MemorySegment PyUnicodeDecodeError_Create$address() {
        return PyUnicodeDecodeError_Create.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicodeDecodeError_Create(const char *encoding, const char *object, Py_ssize_t length, Py_ssize_t start, Py_ssize_t end, const char *reason)
     * }
     */
    public static MemorySegment PyUnicodeDecodeError_Create(MemorySegment encoding, MemorySegment object, long length, long start, long end, MemorySegment reason) {
        var mh$ = PyUnicodeDecodeError_Create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicodeDecodeError_Create", encoding, object, length, start, end, reason);
            }
            return (MemorySegment)mh$.invokeExact(encoding, object, length, start, end, reason);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicodeEncodeError_GetEncoding {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicodeEncodeError_GetEncoding");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicodeEncodeError_GetEncoding(PyObject *)
     * }
     */
    public static FunctionDescriptor PyUnicodeEncodeError_GetEncoding$descriptor() {
        return PyUnicodeEncodeError_GetEncoding.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicodeEncodeError_GetEncoding(PyObject *)
     * }
     */
    public static MethodHandle PyUnicodeEncodeError_GetEncoding$handle() {
        return PyUnicodeEncodeError_GetEncoding.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicodeEncodeError_GetEncoding(PyObject *)
     * }
     */
    public static MemorySegment PyUnicodeEncodeError_GetEncoding$address() {
        return PyUnicodeEncodeError_GetEncoding.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicodeEncodeError_GetEncoding(PyObject *)
     * }
     */
    public static MemorySegment PyUnicodeEncodeError_GetEncoding(MemorySegment x0) {
        var mh$ = PyUnicodeEncodeError_GetEncoding.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicodeEncodeError_GetEncoding", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicodeDecodeError_GetEncoding {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicodeDecodeError_GetEncoding");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicodeDecodeError_GetEncoding(PyObject *)
     * }
     */
    public static FunctionDescriptor PyUnicodeDecodeError_GetEncoding$descriptor() {
        return PyUnicodeDecodeError_GetEncoding.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicodeDecodeError_GetEncoding(PyObject *)
     * }
     */
    public static MethodHandle PyUnicodeDecodeError_GetEncoding$handle() {
        return PyUnicodeDecodeError_GetEncoding.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicodeDecodeError_GetEncoding(PyObject *)
     * }
     */
    public static MemorySegment PyUnicodeDecodeError_GetEncoding$address() {
        return PyUnicodeDecodeError_GetEncoding.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicodeDecodeError_GetEncoding(PyObject *)
     * }
     */
    public static MemorySegment PyUnicodeDecodeError_GetEncoding(MemorySegment x0) {
        var mh$ = PyUnicodeDecodeError_GetEncoding.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicodeDecodeError_GetEncoding", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicodeEncodeError_GetObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicodeEncodeError_GetObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicodeEncodeError_GetObject(PyObject *)
     * }
     */
    public static FunctionDescriptor PyUnicodeEncodeError_GetObject$descriptor() {
        return PyUnicodeEncodeError_GetObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicodeEncodeError_GetObject(PyObject *)
     * }
     */
    public static MethodHandle PyUnicodeEncodeError_GetObject$handle() {
        return PyUnicodeEncodeError_GetObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicodeEncodeError_GetObject(PyObject *)
     * }
     */
    public static MemorySegment PyUnicodeEncodeError_GetObject$address() {
        return PyUnicodeEncodeError_GetObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicodeEncodeError_GetObject(PyObject *)
     * }
     */
    public static MemorySegment PyUnicodeEncodeError_GetObject(MemorySegment x0) {
        var mh$ = PyUnicodeEncodeError_GetObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicodeEncodeError_GetObject", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicodeDecodeError_GetObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicodeDecodeError_GetObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicodeDecodeError_GetObject(PyObject *)
     * }
     */
    public static FunctionDescriptor PyUnicodeDecodeError_GetObject$descriptor() {
        return PyUnicodeDecodeError_GetObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicodeDecodeError_GetObject(PyObject *)
     * }
     */
    public static MethodHandle PyUnicodeDecodeError_GetObject$handle() {
        return PyUnicodeDecodeError_GetObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicodeDecodeError_GetObject(PyObject *)
     * }
     */
    public static MemorySegment PyUnicodeDecodeError_GetObject$address() {
        return PyUnicodeDecodeError_GetObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicodeDecodeError_GetObject(PyObject *)
     * }
     */
    public static MemorySegment PyUnicodeDecodeError_GetObject(MemorySegment x0) {
        var mh$ = PyUnicodeDecodeError_GetObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicodeDecodeError_GetObject", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicodeTranslateError_GetObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicodeTranslateError_GetObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicodeTranslateError_GetObject(PyObject *)
     * }
     */
    public static FunctionDescriptor PyUnicodeTranslateError_GetObject$descriptor() {
        return PyUnicodeTranslateError_GetObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicodeTranslateError_GetObject(PyObject *)
     * }
     */
    public static MethodHandle PyUnicodeTranslateError_GetObject$handle() {
        return PyUnicodeTranslateError_GetObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicodeTranslateError_GetObject(PyObject *)
     * }
     */
    public static MemorySegment PyUnicodeTranslateError_GetObject$address() {
        return PyUnicodeTranslateError_GetObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicodeTranslateError_GetObject(PyObject *)
     * }
     */
    public static MemorySegment PyUnicodeTranslateError_GetObject(MemorySegment x0) {
        var mh$ = PyUnicodeTranslateError_GetObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicodeTranslateError_GetObject", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicodeEncodeError_GetStart {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicodeEncodeError_GetStart");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyUnicodeEncodeError_GetStart(PyObject *, Py_ssize_t *)
     * }
     */
    public static FunctionDescriptor PyUnicodeEncodeError_GetStart$descriptor() {
        return PyUnicodeEncodeError_GetStart.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyUnicodeEncodeError_GetStart(PyObject *, Py_ssize_t *)
     * }
     */
    public static MethodHandle PyUnicodeEncodeError_GetStart$handle() {
        return PyUnicodeEncodeError_GetStart.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyUnicodeEncodeError_GetStart(PyObject *, Py_ssize_t *)
     * }
     */
    public static MemorySegment PyUnicodeEncodeError_GetStart$address() {
        return PyUnicodeEncodeError_GetStart.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyUnicodeEncodeError_GetStart(PyObject *, Py_ssize_t *)
     * }
     */
    public static int PyUnicodeEncodeError_GetStart(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyUnicodeEncodeError_GetStart.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicodeEncodeError_GetStart", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicodeDecodeError_GetStart {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicodeDecodeError_GetStart");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyUnicodeDecodeError_GetStart(PyObject *, Py_ssize_t *)
     * }
     */
    public static FunctionDescriptor PyUnicodeDecodeError_GetStart$descriptor() {
        return PyUnicodeDecodeError_GetStart.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyUnicodeDecodeError_GetStart(PyObject *, Py_ssize_t *)
     * }
     */
    public static MethodHandle PyUnicodeDecodeError_GetStart$handle() {
        return PyUnicodeDecodeError_GetStart.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyUnicodeDecodeError_GetStart(PyObject *, Py_ssize_t *)
     * }
     */
    public static MemorySegment PyUnicodeDecodeError_GetStart$address() {
        return PyUnicodeDecodeError_GetStart.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyUnicodeDecodeError_GetStart(PyObject *, Py_ssize_t *)
     * }
     */
    public static int PyUnicodeDecodeError_GetStart(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyUnicodeDecodeError_GetStart.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicodeDecodeError_GetStart", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicodeTranslateError_GetStart {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicodeTranslateError_GetStart");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyUnicodeTranslateError_GetStart(PyObject *, Py_ssize_t *)
     * }
     */
    public static FunctionDescriptor PyUnicodeTranslateError_GetStart$descriptor() {
        return PyUnicodeTranslateError_GetStart.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyUnicodeTranslateError_GetStart(PyObject *, Py_ssize_t *)
     * }
     */
    public static MethodHandle PyUnicodeTranslateError_GetStart$handle() {
        return PyUnicodeTranslateError_GetStart.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyUnicodeTranslateError_GetStart(PyObject *, Py_ssize_t *)
     * }
     */
    public static MemorySegment PyUnicodeTranslateError_GetStart$address() {
        return PyUnicodeTranslateError_GetStart.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyUnicodeTranslateError_GetStart(PyObject *, Py_ssize_t *)
     * }
     */
    public static int PyUnicodeTranslateError_GetStart(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyUnicodeTranslateError_GetStart.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicodeTranslateError_GetStart", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicodeEncodeError_SetStart {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicodeEncodeError_SetStart");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyUnicodeEncodeError_SetStart(PyObject *, Py_ssize_t)
     * }
     */
    public static FunctionDescriptor PyUnicodeEncodeError_SetStart$descriptor() {
        return PyUnicodeEncodeError_SetStart.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyUnicodeEncodeError_SetStart(PyObject *, Py_ssize_t)
     * }
     */
    public static MethodHandle PyUnicodeEncodeError_SetStart$handle() {
        return PyUnicodeEncodeError_SetStart.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyUnicodeEncodeError_SetStart(PyObject *, Py_ssize_t)
     * }
     */
    public static MemorySegment PyUnicodeEncodeError_SetStart$address() {
        return PyUnicodeEncodeError_SetStart.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyUnicodeEncodeError_SetStart(PyObject *, Py_ssize_t)
     * }
     */
    public static int PyUnicodeEncodeError_SetStart(MemorySegment x0, long x1) {
        var mh$ = PyUnicodeEncodeError_SetStart.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicodeEncodeError_SetStart", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicodeDecodeError_SetStart {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicodeDecodeError_SetStart");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyUnicodeDecodeError_SetStart(PyObject *, Py_ssize_t)
     * }
     */
    public static FunctionDescriptor PyUnicodeDecodeError_SetStart$descriptor() {
        return PyUnicodeDecodeError_SetStart.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyUnicodeDecodeError_SetStart(PyObject *, Py_ssize_t)
     * }
     */
    public static MethodHandle PyUnicodeDecodeError_SetStart$handle() {
        return PyUnicodeDecodeError_SetStart.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyUnicodeDecodeError_SetStart(PyObject *, Py_ssize_t)
     * }
     */
    public static MemorySegment PyUnicodeDecodeError_SetStart$address() {
        return PyUnicodeDecodeError_SetStart.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyUnicodeDecodeError_SetStart(PyObject *, Py_ssize_t)
     * }
     */
    public static int PyUnicodeDecodeError_SetStart(MemorySegment x0, long x1) {
        var mh$ = PyUnicodeDecodeError_SetStart.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicodeDecodeError_SetStart", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicodeTranslateError_SetStart {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicodeTranslateError_SetStart");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyUnicodeTranslateError_SetStart(PyObject *, Py_ssize_t)
     * }
     */
    public static FunctionDescriptor PyUnicodeTranslateError_SetStart$descriptor() {
        return PyUnicodeTranslateError_SetStart.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyUnicodeTranslateError_SetStart(PyObject *, Py_ssize_t)
     * }
     */
    public static MethodHandle PyUnicodeTranslateError_SetStart$handle() {
        return PyUnicodeTranslateError_SetStart.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyUnicodeTranslateError_SetStart(PyObject *, Py_ssize_t)
     * }
     */
    public static MemorySegment PyUnicodeTranslateError_SetStart$address() {
        return PyUnicodeTranslateError_SetStart.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyUnicodeTranslateError_SetStart(PyObject *, Py_ssize_t)
     * }
     */
    public static int PyUnicodeTranslateError_SetStart(MemorySegment x0, long x1) {
        var mh$ = PyUnicodeTranslateError_SetStart.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicodeTranslateError_SetStart", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicodeEncodeError_GetEnd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicodeEncodeError_GetEnd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyUnicodeEncodeError_GetEnd(PyObject *, Py_ssize_t *)
     * }
     */
    public static FunctionDescriptor PyUnicodeEncodeError_GetEnd$descriptor() {
        return PyUnicodeEncodeError_GetEnd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyUnicodeEncodeError_GetEnd(PyObject *, Py_ssize_t *)
     * }
     */
    public static MethodHandle PyUnicodeEncodeError_GetEnd$handle() {
        return PyUnicodeEncodeError_GetEnd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyUnicodeEncodeError_GetEnd(PyObject *, Py_ssize_t *)
     * }
     */
    public static MemorySegment PyUnicodeEncodeError_GetEnd$address() {
        return PyUnicodeEncodeError_GetEnd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyUnicodeEncodeError_GetEnd(PyObject *, Py_ssize_t *)
     * }
     */
    public static int PyUnicodeEncodeError_GetEnd(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyUnicodeEncodeError_GetEnd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicodeEncodeError_GetEnd", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicodeDecodeError_GetEnd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicodeDecodeError_GetEnd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyUnicodeDecodeError_GetEnd(PyObject *, Py_ssize_t *)
     * }
     */
    public static FunctionDescriptor PyUnicodeDecodeError_GetEnd$descriptor() {
        return PyUnicodeDecodeError_GetEnd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyUnicodeDecodeError_GetEnd(PyObject *, Py_ssize_t *)
     * }
     */
    public static MethodHandle PyUnicodeDecodeError_GetEnd$handle() {
        return PyUnicodeDecodeError_GetEnd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyUnicodeDecodeError_GetEnd(PyObject *, Py_ssize_t *)
     * }
     */
    public static MemorySegment PyUnicodeDecodeError_GetEnd$address() {
        return PyUnicodeDecodeError_GetEnd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyUnicodeDecodeError_GetEnd(PyObject *, Py_ssize_t *)
     * }
     */
    public static int PyUnicodeDecodeError_GetEnd(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyUnicodeDecodeError_GetEnd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicodeDecodeError_GetEnd", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicodeTranslateError_GetEnd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicodeTranslateError_GetEnd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyUnicodeTranslateError_GetEnd(PyObject *, Py_ssize_t *)
     * }
     */
    public static FunctionDescriptor PyUnicodeTranslateError_GetEnd$descriptor() {
        return PyUnicodeTranslateError_GetEnd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyUnicodeTranslateError_GetEnd(PyObject *, Py_ssize_t *)
     * }
     */
    public static MethodHandle PyUnicodeTranslateError_GetEnd$handle() {
        return PyUnicodeTranslateError_GetEnd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyUnicodeTranslateError_GetEnd(PyObject *, Py_ssize_t *)
     * }
     */
    public static MemorySegment PyUnicodeTranslateError_GetEnd$address() {
        return PyUnicodeTranslateError_GetEnd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyUnicodeTranslateError_GetEnd(PyObject *, Py_ssize_t *)
     * }
     */
    public static int PyUnicodeTranslateError_GetEnd(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyUnicodeTranslateError_GetEnd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicodeTranslateError_GetEnd", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicodeEncodeError_SetEnd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicodeEncodeError_SetEnd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyUnicodeEncodeError_SetEnd(PyObject *, Py_ssize_t)
     * }
     */
    public static FunctionDescriptor PyUnicodeEncodeError_SetEnd$descriptor() {
        return PyUnicodeEncodeError_SetEnd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyUnicodeEncodeError_SetEnd(PyObject *, Py_ssize_t)
     * }
     */
    public static MethodHandle PyUnicodeEncodeError_SetEnd$handle() {
        return PyUnicodeEncodeError_SetEnd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyUnicodeEncodeError_SetEnd(PyObject *, Py_ssize_t)
     * }
     */
    public static MemorySegment PyUnicodeEncodeError_SetEnd$address() {
        return PyUnicodeEncodeError_SetEnd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyUnicodeEncodeError_SetEnd(PyObject *, Py_ssize_t)
     * }
     */
    public static int PyUnicodeEncodeError_SetEnd(MemorySegment x0, long x1) {
        var mh$ = PyUnicodeEncodeError_SetEnd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicodeEncodeError_SetEnd", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicodeDecodeError_SetEnd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicodeDecodeError_SetEnd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyUnicodeDecodeError_SetEnd(PyObject *, Py_ssize_t)
     * }
     */
    public static FunctionDescriptor PyUnicodeDecodeError_SetEnd$descriptor() {
        return PyUnicodeDecodeError_SetEnd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyUnicodeDecodeError_SetEnd(PyObject *, Py_ssize_t)
     * }
     */
    public static MethodHandle PyUnicodeDecodeError_SetEnd$handle() {
        return PyUnicodeDecodeError_SetEnd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyUnicodeDecodeError_SetEnd(PyObject *, Py_ssize_t)
     * }
     */
    public static MemorySegment PyUnicodeDecodeError_SetEnd$address() {
        return PyUnicodeDecodeError_SetEnd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyUnicodeDecodeError_SetEnd(PyObject *, Py_ssize_t)
     * }
     */
    public static int PyUnicodeDecodeError_SetEnd(MemorySegment x0, long x1) {
        var mh$ = PyUnicodeDecodeError_SetEnd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicodeDecodeError_SetEnd", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicodeTranslateError_SetEnd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicodeTranslateError_SetEnd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyUnicodeTranslateError_SetEnd(PyObject *, Py_ssize_t)
     * }
     */
    public static FunctionDescriptor PyUnicodeTranslateError_SetEnd$descriptor() {
        return PyUnicodeTranslateError_SetEnd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyUnicodeTranslateError_SetEnd(PyObject *, Py_ssize_t)
     * }
     */
    public static MethodHandle PyUnicodeTranslateError_SetEnd$handle() {
        return PyUnicodeTranslateError_SetEnd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyUnicodeTranslateError_SetEnd(PyObject *, Py_ssize_t)
     * }
     */
    public static MemorySegment PyUnicodeTranslateError_SetEnd$address() {
        return PyUnicodeTranslateError_SetEnd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyUnicodeTranslateError_SetEnd(PyObject *, Py_ssize_t)
     * }
     */
    public static int PyUnicodeTranslateError_SetEnd(MemorySegment x0, long x1) {
        var mh$ = PyUnicodeTranslateError_SetEnd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicodeTranslateError_SetEnd", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicodeEncodeError_GetReason {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicodeEncodeError_GetReason");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicodeEncodeError_GetReason(PyObject *)
     * }
     */
    public static FunctionDescriptor PyUnicodeEncodeError_GetReason$descriptor() {
        return PyUnicodeEncodeError_GetReason.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicodeEncodeError_GetReason(PyObject *)
     * }
     */
    public static MethodHandle PyUnicodeEncodeError_GetReason$handle() {
        return PyUnicodeEncodeError_GetReason.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicodeEncodeError_GetReason(PyObject *)
     * }
     */
    public static MemorySegment PyUnicodeEncodeError_GetReason$address() {
        return PyUnicodeEncodeError_GetReason.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicodeEncodeError_GetReason(PyObject *)
     * }
     */
    public static MemorySegment PyUnicodeEncodeError_GetReason(MemorySegment x0) {
        var mh$ = PyUnicodeEncodeError_GetReason.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicodeEncodeError_GetReason", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicodeDecodeError_GetReason {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicodeDecodeError_GetReason");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicodeDecodeError_GetReason(PyObject *)
     * }
     */
    public static FunctionDescriptor PyUnicodeDecodeError_GetReason$descriptor() {
        return PyUnicodeDecodeError_GetReason.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicodeDecodeError_GetReason(PyObject *)
     * }
     */
    public static MethodHandle PyUnicodeDecodeError_GetReason$handle() {
        return PyUnicodeDecodeError_GetReason.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicodeDecodeError_GetReason(PyObject *)
     * }
     */
    public static MemorySegment PyUnicodeDecodeError_GetReason$address() {
        return PyUnicodeDecodeError_GetReason.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicodeDecodeError_GetReason(PyObject *)
     * }
     */
    public static MemorySegment PyUnicodeDecodeError_GetReason(MemorySegment x0) {
        var mh$ = PyUnicodeDecodeError_GetReason.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicodeDecodeError_GetReason", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicodeTranslateError_GetReason {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicodeTranslateError_GetReason");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicodeTranslateError_GetReason(PyObject *)
     * }
     */
    public static FunctionDescriptor PyUnicodeTranslateError_GetReason$descriptor() {
        return PyUnicodeTranslateError_GetReason.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicodeTranslateError_GetReason(PyObject *)
     * }
     */
    public static MethodHandle PyUnicodeTranslateError_GetReason$handle() {
        return PyUnicodeTranslateError_GetReason.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicodeTranslateError_GetReason(PyObject *)
     * }
     */
    public static MemorySegment PyUnicodeTranslateError_GetReason$address() {
        return PyUnicodeTranslateError_GetReason.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicodeTranslateError_GetReason(PyObject *)
     * }
     */
    public static MemorySegment PyUnicodeTranslateError_GetReason(MemorySegment x0) {
        var mh$ = PyUnicodeTranslateError_GetReason.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicodeTranslateError_GetReason", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicodeEncodeError_SetReason {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicodeEncodeError_SetReason");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyUnicodeEncodeError_SetReason(PyObject *exc, const char *reason)
     * }
     */
    public static FunctionDescriptor PyUnicodeEncodeError_SetReason$descriptor() {
        return PyUnicodeEncodeError_SetReason.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyUnicodeEncodeError_SetReason(PyObject *exc, const char *reason)
     * }
     */
    public static MethodHandle PyUnicodeEncodeError_SetReason$handle() {
        return PyUnicodeEncodeError_SetReason.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyUnicodeEncodeError_SetReason(PyObject *exc, const char *reason)
     * }
     */
    public static MemorySegment PyUnicodeEncodeError_SetReason$address() {
        return PyUnicodeEncodeError_SetReason.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyUnicodeEncodeError_SetReason(PyObject *exc, const char *reason)
     * }
     */
    public static int PyUnicodeEncodeError_SetReason(MemorySegment exc, MemorySegment reason) {
        var mh$ = PyUnicodeEncodeError_SetReason.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicodeEncodeError_SetReason", exc, reason);
            }
            return (int)mh$.invokeExact(exc, reason);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicodeDecodeError_SetReason {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicodeDecodeError_SetReason");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyUnicodeDecodeError_SetReason(PyObject *exc, const char *reason)
     * }
     */
    public static FunctionDescriptor PyUnicodeDecodeError_SetReason$descriptor() {
        return PyUnicodeDecodeError_SetReason.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyUnicodeDecodeError_SetReason(PyObject *exc, const char *reason)
     * }
     */
    public static MethodHandle PyUnicodeDecodeError_SetReason$handle() {
        return PyUnicodeDecodeError_SetReason.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyUnicodeDecodeError_SetReason(PyObject *exc, const char *reason)
     * }
     */
    public static MemorySegment PyUnicodeDecodeError_SetReason$address() {
        return PyUnicodeDecodeError_SetReason.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyUnicodeDecodeError_SetReason(PyObject *exc, const char *reason)
     * }
     */
    public static int PyUnicodeDecodeError_SetReason(MemorySegment exc, MemorySegment reason) {
        var mh$ = PyUnicodeDecodeError_SetReason.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicodeDecodeError_SetReason", exc, reason);
            }
            return (int)mh$.invokeExact(exc, reason);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicodeTranslateError_SetReason {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicodeTranslateError_SetReason");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyUnicodeTranslateError_SetReason(PyObject *exc, const char *reason)
     * }
     */
    public static FunctionDescriptor PyUnicodeTranslateError_SetReason$descriptor() {
        return PyUnicodeTranslateError_SetReason.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyUnicodeTranslateError_SetReason(PyObject *exc, const char *reason)
     * }
     */
    public static MethodHandle PyUnicodeTranslateError_SetReason$handle() {
        return PyUnicodeTranslateError_SetReason.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyUnicodeTranslateError_SetReason(PyObject *exc, const char *reason)
     * }
     */
    public static MemorySegment PyUnicodeTranslateError_SetReason$address() {
        return PyUnicodeTranslateError_SetReason.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyUnicodeTranslateError_SetReason(PyObject *exc, const char *reason)
     * }
     */
    public static int PyUnicodeTranslateError_SetReason(MemorySegment exc, MemorySegment reason) {
        var mh$ = PyUnicodeTranslateError_SetReason.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicodeTranslateError_SetReason", exc, reason);
            }
            return (int)mh$.invokeExact(exc, reason);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int PyOS_snprintf(char *str, size_t size, const char *format, ...)
     * }
     */
    public static class PyOS_snprintf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_INT,
                Python_h.C_POINTER,
                Python_h.C_LONG_LONG,
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("PyOS_snprintf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private PyOS_snprintf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int PyOS_snprintf(char *str, size_t size, const char *format, ...)
         * }
         */
        public static PyOS_snprintf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new PyOS_snprintf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment str, long size, MemorySegment format, Object... x3) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("PyOS_snprintf", str, size, format, x3);
                }
                return (int)spreader.invokeExact(str, size, format, x3);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class PyOS_vsnprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyOS_vsnprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyOS_vsnprintf(char *str, size_t size, const char *format, va_list va)
     * }
     */
    public static FunctionDescriptor PyOS_vsnprintf$descriptor() {
        return PyOS_vsnprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyOS_vsnprintf(char *str, size_t size, const char *format, va_list va)
     * }
     */
    public static MethodHandle PyOS_vsnprintf$handle() {
        return PyOS_vsnprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyOS_vsnprintf(char *str, size_t size, const char *format, va_list va)
     * }
     */
    public static MemorySegment PyOS_vsnprintf$address() {
        return PyOS_vsnprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyOS_vsnprintf(char *str, size_t size, const char *format, va_list va)
     * }
     */
    public static int PyOS_vsnprintf(MemorySegment str, long size, MemorySegment format, MemorySegment va) {
        var mh$ = PyOS_vsnprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyOS_vsnprintf", str, size, format, va);
            }
            return (int)mh$.invokeExact(str, size, format, va);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef void *PyThread_type_lock
     * }
     */
    public static final AddressLayout PyThread_type_lock = Python_h.C_POINTER;
    private static final int PY_LOCK_FAILURE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum PyLockStatus.PY_LOCK_FAILURE = 0
     * }
     */
    public static int PY_LOCK_FAILURE() {
        return PY_LOCK_FAILURE;
    }
    private static final int PY_LOCK_ACQUIRED = (int)1L;
    /**
     * {@snippet lang=c :
     * enum PyLockStatus.PY_LOCK_ACQUIRED = 1
     * }
     */
    public static int PY_LOCK_ACQUIRED() {
        return PY_LOCK_ACQUIRED;
    }
    private static final int PY_LOCK_INTR = (int)2L;
    /**
     * {@snippet lang=c :
     * enum PyLockStatus.PY_LOCK_INTR = 2
     * }
     */
    public static int PY_LOCK_INTR() {
        return PY_LOCK_INTR;
    }

    private static class PyThread_init_thread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyThread_init_thread");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyThread_init_thread()
     * }
     */
    public static FunctionDescriptor PyThread_init_thread$descriptor() {
        return PyThread_init_thread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyThread_init_thread()
     * }
     */
    public static MethodHandle PyThread_init_thread$handle() {
        return PyThread_init_thread.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyThread_init_thread()
     * }
     */
    public static MemorySegment PyThread_init_thread$address() {
        return PyThread_init_thread.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyThread_init_thread()
     * }
     */
    public static void PyThread_init_thread() {
        var mh$ = PyThread_init_thread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyThread_init_thread");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyThread_start_new_thread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyThread_start_new_thread");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long PyThread_start_new_thread(void (*)(void *), void *)
     * }
     */
    public static FunctionDescriptor PyThread_start_new_thread$descriptor() {
        return PyThread_start_new_thread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long PyThread_start_new_thread(void (*)(void *), void *)
     * }
     */
    public static MethodHandle PyThread_start_new_thread$handle() {
        return PyThread_start_new_thread.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long PyThread_start_new_thread(void (*)(void *), void *)
     * }
     */
    public static MemorySegment PyThread_start_new_thread$address() {
        return PyThread_start_new_thread.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long PyThread_start_new_thread(void (*)(void *), void *)
     * }
     */
    public static int PyThread_start_new_thread(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyThread_start_new_thread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyThread_start_new_thread", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyThread_exit_thread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyThread_exit_thread");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyThread_exit_thread()
     * }
     */
    public static FunctionDescriptor PyThread_exit_thread$descriptor() {
        return PyThread_exit_thread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyThread_exit_thread()
     * }
     */
    public static MethodHandle PyThread_exit_thread$handle() {
        return PyThread_exit_thread.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyThread_exit_thread()
     * }
     */
    public static MemorySegment PyThread_exit_thread$address() {
        return PyThread_exit_thread.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyThread_exit_thread()
     * }
     */
    public static void PyThread_exit_thread() {
        var mh$ = PyThread_exit_thread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyThread_exit_thread");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyThread_get_thread_ident {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyThread_get_thread_ident");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long PyThread_get_thread_ident()
     * }
     */
    public static FunctionDescriptor PyThread_get_thread_ident$descriptor() {
        return PyThread_get_thread_ident.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long PyThread_get_thread_ident()
     * }
     */
    public static MethodHandle PyThread_get_thread_ident$handle() {
        return PyThread_get_thread_ident.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long PyThread_get_thread_ident()
     * }
     */
    public static MemorySegment PyThread_get_thread_ident$address() {
        return PyThread_get_thread_ident.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long PyThread_get_thread_ident()
     * }
     */
    public static int PyThread_get_thread_ident() {
        var mh$ = PyThread_get_thread_ident.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyThread_get_thread_ident");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyThread_get_thread_native_id {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyThread_get_thread_native_id");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long PyThread_get_thread_native_id()
     * }
     */
    public static FunctionDescriptor PyThread_get_thread_native_id$descriptor() {
        return PyThread_get_thread_native_id.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long PyThread_get_thread_native_id()
     * }
     */
    public static MethodHandle PyThread_get_thread_native_id$handle() {
        return PyThread_get_thread_native_id.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long PyThread_get_thread_native_id()
     * }
     */
    public static MemorySegment PyThread_get_thread_native_id$address() {
        return PyThread_get_thread_native_id.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long PyThread_get_thread_native_id()
     * }
     */
    public static int PyThread_get_thread_native_id() {
        var mh$ = PyThread_get_thread_native_id.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyThread_get_thread_native_id");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyThread_allocate_lock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyThread_allocate_lock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyThread_type_lock PyThread_allocate_lock()
     * }
     */
    public static FunctionDescriptor PyThread_allocate_lock$descriptor() {
        return PyThread_allocate_lock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyThread_type_lock PyThread_allocate_lock()
     * }
     */
    public static MethodHandle PyThread_allocate_lock$handle() {
        return PyThread_allocate_lock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyThread_type_lock PyThread_allocate_lock()
     * }
     */
    public static MemorySegment PyThread_allocate_lock$address() {
        return PyThread_allocate_lock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyThread_type_lock PyThread_allocate_lock()
     * }
     */
    public static MemorySegment PyThread_allocate_lock() {
        var mh$ = PyThread_allocate_lock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyThread_allocate_lock");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyThread_free_lock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyThread_free_lock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyThread_free_lock(PyThread_type_lock)
     * }
     */
    public static FunctionDescriptor PyThread_free_lock$descriptor() {
        return PyThread_free_lock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyThread_free_lock(PyThread_type_lock)
     * }
     */
    public static MethodHandle PyThread_free_lock$handle() {
        return PyThread_free_lock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyThread_free_lock(PyThread_type_lock)
     * }
     */
    public static MemorySegment PyThread_free_lock$address() {
        return PyThread_free_lock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyThread_free_lock(PyThread_type_lock)
     * }
     */
    public static void PyThread_free_lock(MemorySegment x0) {
        var mh$ = PyThread_free_lock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyThread_free_lock", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyThread_acquire_lock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyThread_acquire_lock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyThread_acquire_lock(PyThread_type_lock, int)
     * }
     */
    public static FunctionDescriptor PyThread_acquire_lock$descriptor() {
        return PyThread_acquire_lock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyThread_acquire_lock(PyThread_type_lock, int)
     * }
     */
    public static MethodHandle PyThread_acquire_lock$handle() {
        return PyThread_acquire_lock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyThread_acquire_lock(PyThread_type_lock, int)
     * }
     */
    public static MemorySegment PyThread_acquire_lock$address() {
        return PyThread_acquire_lock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyThread_acquire_lock(PyThread_type_lock, int)
     * }
     */
    public static int PyThread_acquire_lock(MemorySegment x0, int x1) {
        var mh$ = PyThread_acquire_lock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyThread_acquire_lock", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyThread_acquire_lock_timed {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyThread_acquire_lock_timed");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyLockStatus PyThread_acquire_lock_timed(PyThread_type_lock, long long microseconds, int intr_flag)
     * }
     */
    public static FunctionDescriptor PyThread_acquire_lock_timed$descriptor() {
        return PyThread_acquire_lock_timed.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyLockStatus PyThread_acquire_lock_timed(PyThread_type_lock, long long microseconds, int intr_flag)
     * }
     */
    public static MethodHandle PyThread_acquire_lock_timed$handle() {
        return PyThread_acquire_lock_timed.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyLockStatus PyThread_acquire_lock_timed(PyThread_type_lock, long long microseconds, int intr_flag)
     * }
     */
    public static MemorySegment PyThread_acquire_lock_timed$address() {
        return PyThread_acquire_lock_timed.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyLockStatus PyThread_acquire_lock_timed(PyThread_type_lock, long long microseconds, int intr_flag)
     * }
     */
    public static int PyThread_acquire_lock_timed(MemorySegment x0, long microseconds, int intr_flag) {
        var mh$ = PyThread_acquire_lock_timed.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyThread_acquire_lock_timed", x0, microseconds, intr_flag);
            }
            return (int)mh$.invokeExact(x0, microseconds, intr_flag);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyThread_release_lock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyThread_release_lock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyThread_release_lock(PyThread_type_lock)
     * }
     */
    public static FunctionDescriptor PyThread_release_lock$descriptor() {
        return PyThread_release_lock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyThread_release_lock(PyThread_type_lock)
     * }
     */
    public static MethodHandle PyThread_release_lock$handle() {
        return PyThread_release_lock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyThread_release_lock(PyThread_type_lock)
     * }
     */
    public static MemorySegment PyThread_release_lock$address() {
        return PyThread_release_lock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyThread_release_lock(PyThread_type_lock)
     * }
     */
    public static void PyThread_release_lock(MemorySegment x0) {
        var mh$ = PyThread_release_lock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyThread_release_lock", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyThread_get_stacksize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyThread_get_stacksize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t PyThread_get_stacksize()
     * }
     */
    public static FunctionDescriptor PyThread_get_stacksize$descriptor() {
        return PyThread_get_stacksize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t PyThread_get_stacksize()
     * }
     */
    public static MethodHandle PyThread_get_stacksize$handle() {
        return PyThread_get_stacksize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t PyThread_get_stacksize()
     * }
     */
    public static MemorySegment PyThread_get_stacksize$address() {
        return PyThread_get_stacksize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t PyThread_get_stacksize()
     * }
     */
    public static long PyThread_get_stacksize() {
        var mh$ = PyThread_get_stacksize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyThread_get_stacksize");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyThread_set_stacksize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyThread_set_stacksize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyThread_set_stacksize(size_t)
     * }
     */
    public static FunctionDescriptor PyThread_set_stacksize$descriptor() {
        return PyThread_set_stacksize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyThread_set_stacksize(size_t)
     * }
     */
    public static MethodHandle PyThread_set_stacksize$handle() {
        return PyThread_set_stacksize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyThread_set_stacksize(size_t)
     * }
     */
    public static MemorySegment PyThread_set_stacksize$address() {
        return PyThread_set_stacksize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyThread_set_stacksize(size_t)
     * }
     */
    public static int PyThread_set_stacksize(long x0) {
        var mh$ = PyThread_set_stacksize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyThread_set_stacksize", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyThread_GetInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyThread_GetInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyThread_GetInfo()
     * }
     */
    public static FunctionDescriptor PyThread_GetInfo$descriptor() {
        return PyThread_GetInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyThread_GetInfo()
     * }
     */
    public static MethodHandle PyThread_GetInfo$handle() {
        return PyThread_GetInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyThread_GetInfo()
     * }
     */
    public static MemorySegment PyThread_GetInfo$address() {
        return PyThread_GetInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyThread_GetInfo()
     * }
     */
    public static MemorySegment PyThread_GetInfo() {
        var mh$ = PyThread_GetInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyThread_GetInfo");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyThread_create_key {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyThread_create_key");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyThread_create_key()
     * }
     */
    public static FunctionDescriptor PyThread_create_key$descriptor() {
        return PyThread_create_key.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyThread_create_key()
     * }
     */
    public static MethodHandle PyThread_create_key$handle() {
        return PyThread_create_key.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyThread_create_key()
     * }
     */
    public static MemorySegment PyThread_create_key$address() {
        return PyThread_create_key.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyThread_create_key()
     * }
     */
    public static int PyThread_create_key() {
        var mh$ = PyThread_create_key.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyThread_create_key");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyThread_delete_key {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyThread_delete_key");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyThread_delete_key(int key)
     * }
     */
    public static FunctionDescriptor PyThread_delete_key$descriptor() {
        return PyThread_delete_key.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyThread_delete_key(int key)
     * }
     */
    public static MethodHandle PyThread_delete_key$handle() {
        return PyThread_delete_key.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyThread_delete_key(int key)
     * }
     */
    public static MemorySegment PyThread_delete_key$address() {
        return PyThread_delete_key.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyThread_delete_key(int key)
     * }
     */
    public static void PyThread_delete_key(int key) {
        var mh$ = PyThread_delete_key.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyThread_delete_key", key);
            }
            mh$.invokeExact(key);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyThread_set_key_value {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyThread_set_key_value");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyThread_set_key_value(int key, void *value)
     * }
     */
    public static FunctionDescriptor PyThread_set_key_value$descriptor() {
        return PyThread_set_key_value.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyThread_set_key_value(int key, void *value)
     * }
     */
    public static MethodHandle PyThread_set_key_value$handle() {
        return PyThread_set_key_value.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyThread_set_key_value(int key, void *value)
     * }
     */
    public static MemorySegment PyThread_set_key_value$address() {
        return PyThread_set_key_value.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyThread_set_key_value(int key, void *value)
     * }
     */
    public static int PyThread_set_key_value(int key, MemorySegment value) {
        var mh$ = PyThread_set_key_value.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyThread_set_key_value", key, value);
            }
            return (int)mh$.invokeExact(key, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyThread_get_key_value {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyThread_get_key_value");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *PyThread_get_key_value(int key)
     * }
     */
    public static FunctionDescriptor PyThread_get_key_value$descriptor() {
        return PyThread_get_key_value.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *PyThread_get_key_value(int key)
     * }
     */
    public static MethodHandle PyThread_get_key_value$handle() {
        return PyThread_get_key_value.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *PyThread_get_key_value(int key)
     * }
     */
    public static MemorySegment PyThread_get_key_value$address() {
        return PyThread_get_key_value.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *PyThread_get_key_value(int key)
     * }
     */
    public static MemorySegment PyThread_get_key_value(int key) {
        var mh$ = PyThread_get_key_value.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyThread_get_key_value", key);
            }
            return (MemorySegment)mh$.invokeExact(key);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyThread_delete_key_value {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyThread_delete_key_value");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyThread_delete_key_value(int key)
     * }
     */
    public static FunctionDescriptor PyThread_delete_key_value$descriptor() {
        return PyThread_delete_key_value.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyThread_delete_key_value(int key)
     * }
     */
    public static MethodHandle PyThread_delete_key_value$handle() {
        return PyThread_delete_key_value.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyThread_delete_key_value(int key)
     * }
     */
    public static MemorySegment PyThread_delete_key_value$address() {
        return PyThread_delete_key_value.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyThread_delete_key_value(int key)
     * }
     */
    public static void PyThread_delete_key_value(int key) {
        var mh$ = PyThread_delete_key_value.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyThread_delete_key_value", key);
            }
            mh$.invokeExact(key);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyThread_ReInitTLS {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyThread_ReInitTLS");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyThread_ReInitTLS()
     * }
     */
    public static FunctionDescriptor PyThread_ReInitTLS$descriptor() {
        return PyThread_ReInitTLS.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyThread_ReInitTLS()
     * }
     */
    public static MethodHandle PyThread_ReInitTLS$handle() {
        return PyThread_ReInitTLS.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyThread_ReInitTLS()
     * }
     */
    public static MemorySegment PyThread_ReInitTLS$address() {
        return PyThread_ReInitTLS.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyThread_ReInitTLS()
     * }
     */
    public static void PyThread_ReInitTLS() {
        var mh$ = PyThread_ReInitTLS.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyThread_ReInitTLS");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyThread_tss_alloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyThread_tss_alloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_tss_t *PyThread_tss_alloc()
     * }
     */
    public static FunctionDescriptor PyThread_tss_alloc$descriptor() {
        return PyThread_tss_alloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_tss_t *PyThread_tss_alloc()
     * }
     */
    public static MethodHandle PyThread_tss_alloc$handle() {
        return PyThread_tss_alloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_tss_t *PyThread_tss_alloc()
     * }
     */
    public static MemorySegment PyThread_tss_alloc$address() {
        return PyThread_tss_alloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_tss_t *PyThread_tss_alloc()
     * }
     */
    public static MemorySegment PyThread_tss_alloc() {
        var mh$ = PyThread_tss_alloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyThread_tss_alloc");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyThread_tss_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyThread_tss_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyThread_tss_free(Py_tss_t *key)
     * }
     */
    public static FunctionDescriptor PyThread_tss_free$descriptor() {
        return PyThread_tss_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyThread_tss_free(Py_tss_t *key)
     * }
     */
    public static MethodHandle PyThread_tss_free$handle() {
        return PyThread_tss_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyThread_tss_free(Py_tss_t *key)
     * }
     */
    public static MemorySegment PyThread_tss_free$address() {
        return PyThread_tss_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyThread_tss_free(Py_tss_t *key)
     * }
     */
    public static void PyThread_tss_free(MemorySegment key) {
        var mh$ = PyThread_tss_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyThread_tss_free", key);
            }
            mh$.invokeExact(key);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyThread_tss_is_created {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyThread_tss_is_created");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyThread_tss_is_created(Py_tss_t *key)
     * }
     */
    public static FunctionDescriptor PyThread_tss_is_created$descriptor() {
        return PyThread_tss_is_created.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyThread_tss_is_created(Py_tss_t *key)
     * }
     */
    public static MethodHandle PyThread_tss_is_created$handle() {
        return PyThread_tss_is_created.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyThread_tss_is_created(Py_tss_t *key)
     * }
     */
    public static MemorySegment PyThread_tss_is_created$address() {
        return PyThread_tss_is_created.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyThread_tss_is_created(Py_tss_t *key)
     * }
     */
    public static int PyThread_tss_is_created(MemorySegment key) {
        var mh$ = PyThread_tss_is_created.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyThread_tss_is_created", key);
            }
            return (int)mh$.invokeExact(key);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyThread_tss_create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyThread_tss_create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyThread_tss_create(Py_tss_t *key)
     * }
     */
    public static FunctionDescriptor PyThread_tss_create$descriptor() {
        return PyThread_tss_create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyThread_tss_create(Py_tss_t *key)
     * }
     */
    public static MethodHandle PyThread_tss_create$handle() {
        return PyThread_tss_create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyThread_tss_create(Py_tss_t *key)
     * }
     */
    public static MemorySegment PyThread_tss_create$address() {
        return PyThread_tss_create.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyThread_tss_create(Py_tss_t *key)
     * }
     */
    public static int PyThread_tss_create(MemorySegment key) {
        var mh$ = PyThread_tss_create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyThread_tss_create", key);
            }
            return (int)mh$.invokeExact(key);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyThread_tss_delete {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyThread_tss_delete");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyThread_tss_delete(Py_tss_t *key)
     * }
     */
    public static FunctionDescriptor PyThread_tss_delete$descriptor() {
        return PyThread_tss_delete.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyThread_tss_delete(Py_tss_t *key)
     * }
     */
    public static MethodHandle PyThread_tss_delete$handle() {
        return PyThread_tss_delete.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyThread_tss_delete(Py_tss_t *key)
     * }
     */
    public static MemorySegment PyThread_tss_delete$address() {
        return PyThread_tss_delete.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyThread_tss_delete(Py_tss_t *key)
     * }
     */
    public static void PyThread_tss_delete(MemorySegment key) {
        var mh$ = PyThread_tss_delete.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyThread_tss_delete", key);
            }
            mh$.invokeExact(key);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyThread_tss_set {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyThread_tss_set");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyThread_tss_set(Py_tss_t *key, void *value)
     * }
     */
    public static FunctionDescriptor PyThread_tss_set$descriptor() {
        return PyThread_tss_set.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyThread_tss_set(Py_tss_t *key, void *value)
     * }
     */
    public static MethodHandle PyThread_tss_set$handle() {
        return PyThread_tss_set.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyThread_tss_set(Py_tss_t *key, void *value)
     * }
     */
    public static MemorySegment PyThread_tss_set$address() {
        return PyThread_tss_set.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyThread_tss_set(Py_tss_t *key, void *value)
     * }
     */
    public static int PyThread_tss_set(MemorySegment key, MemorySegment value) {
        var mh$ = PyThread_tss_set.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyThread_tss_set", key, value);
            }
            return (int)mh$.invokeExact(key, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyThread_tss_get {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyThread_tss_get");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *PyThread_tss_get(Py_tss_t *key)
     * }
     */
    public static FunctionDescriptor PyThread_tss_get$descriptor() {
        return PyThread_tss_get.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *PyThread_tss_get(Py_tss_t *key)
     * }
     */
    public static MethodHandle PyThread_tss_get$handle() {
        return PyThread_tss_get.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *PyThread_tss_get(Py_tss_t *key)
     * }
     */
    public static MemorySegment PyThread_tss_get$address() {
        return PyThread_tss_get.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *PyThread_tss_get(Py_tss_t *key)
     * }
     */
    public static MemorySegment PyThread_tss_get(MemorySegment key) {
        var mh$ = PyThread_tss_get.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyThread_tss_get", key);
            }
            return (MemorySegment)mh$.invokeExact(key);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int PyArg_Parse(PyObject *, const char *, ...)
     * }
     */
    public static class PyArg_Parse {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_INT,
                Python_h.C_POINTER,
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("PyArg_Parse");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private PyArg_Parse(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int PyArg_Parse(PyObject *, const char *, ...)
         * }
         */
        public static PyArg_Parse makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new PyArg_Parse(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment x0, MemorySegment x1, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("PyArg_Parse", x0, x1, x2);
                }
                return (int)spreader.invokeExact(x0, x1, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int PyArg_ParseTuple(PyObject *, const char *, ...)
     * }
     */
    public static class PyArg_ParseTuple {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_INT,
                Python_h.C_POINTER,
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("PyArg_ParseTuple");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private PyArg_ParseTuple(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int PyArg_ParseTuple(PyObject *, const char *, ...)
         * }
         */
        public static PyArg_ParseTuple makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new PyArg_ParseTuple(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment x0, MemorySegment x1, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("PyArg_ParseTuple", x0, x1, x2);
                }
                return (int)spreader.invokeExact(x0, x1, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int PyArg_ParseTupleAndKeywords(PyObject *, PyObject *, const char *, char **, ...)
     * }
     */
    public static class PyArg_ParseTupleAndKeywords {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_INT,
                Python_h.C_POINTER,
                Python_h.C_POINTER,
                Python_h.C_POINTER,
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("PyArg_ParseTupleAndKeywords");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private PyArg_ParseTupleAndKeywords(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int PyArg_ParseTupleAndKeywords(PyObject *, PyObject *, const char *, char **, ...)
         * }
         */
        public static PyArg_ParseTupleAndKeywords makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new PyArg_ParseTupleAndKeywords(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, Object... x4) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("PyArg_ParseTupleAndKeywords", x0, x1, x2, x3, x4);
                }
                return (int)spreader.invokeExact(x0, x1, x2, x3, x4);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class PyArg_VaParse {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyArg_VaParse");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyArg_VaParse(PyObject *, const char *, va_list)
     * }
     */
    public static FunctionDescriptor PyArg_VaParse$descriptor() {
        return PyArg_VaParse.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyArg_VaParse(PyObject *, const char *, va_list)
     * }
     */
    public static MethodHandle PyArg_VaParse$handle() {
        return PyArg_VaParse.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyArg_VaParse(PyObject *, const char *, va_list)
     * }
     */
    public static MemorySegment PyArg_VaParse$address() {
        return PyArg_VaParse.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyArg_VaParse(PyObject *, const char *, va_list)
     * }
     */
    public static int PyArg_VaParse(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = PyArg_VaParse.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyArg_VaParse", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyArg_VaParseTupleAndKeywords {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyArg_VaParseTupleAndKeywords");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyArg_VaParseTupleAndKeywords(PyObject *, PyObject *, const char *, char **, va_list)
     * }
     */
    public static FunctionDescriptor PyArg_VaParseTupleAndKeywords$descriptor() {
        return PyArg_VaParseTupleAndKeywords.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyArg_VaParseTupleAndKeywords(PyObject *, PyObject *, const char *, char **, va_list)
     * }
     */
    public static MethodHandle PyArg_VaParseTupleAndKeywords$handle() {
        return PyArg_VaParseTupleAndKeywords.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyArg_VaParseTupleAndKeywords(PyObject *, PyObject *, const char *, char **, va_list)
     * }
     */
    public static MemorySegment PyArg_VaParseTupleAndKeywords$address() {
        return PyArg_VaParseTupleAndKeywords.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyArg_VaParseTupleAndKeywords(PyObject *, PyObject *, const char *, char **, va_list)
     * }
     */
    public static int PyArg_VaParseTupleAndKeywords(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = PyArg_VaParseTupleAndKeywords.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyArg_VaParseTupleAndKeywords", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyArg_ValidateKeywordArguments {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyArg_ValidateKeywordArguments");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyArg_ValidateKeywordArguments(PyObject *)
     * }
     */
    public static FunctionDescriptor PyArg_ValidateKeywordArguments$descriptor() {
        return PyArg_ValidateKeywordArguments.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyArg_ValidateKeywordArguments(PyObject *)
     * }
     */
    public static MethodHandle PyArg_ValidateKeywordArguments$handle() {
        return PyArg_ValidateKeywordArguments.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyArg_ValidateKeywordArguments(PyObject *)
     * }
     */
    public static MemorySegment PyArg_ValidateKeywordArguments$address() {
        return PyArg_ValidateKeywordArguments.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyArg_ValidateKeywordArguments(PyObject *)
     * }
     */
    public static int PyArg_ValidateKeywordArguments(MemorySegment x0) {
        var mh$ = PyArg_ValidateKeywordArguments.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyArg_ValidateKeywordArguments", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int PyArg_UnpackTuple(PyObject *, const char *, Py_ssize_t, Py_ssize_t, ...)
     * }
     */
    public static class PyArg_UnpackTuple {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_INT,
                Python_h.C_POINTER,
                Python_h.C_POINTER,
                Python_h.C_LONG_LONG,
                Python_h.C_LONG_LONG
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("PyArg_UnpackTuple");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private PyArg_UnpackTuple(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int PyArg_UnpackTuple(PyObject *, const char *, Py_ssize_t, Py_ssize_t, ...)
         * }
         */
        public static PyArg_UnpackTuple makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new PyArg_UnpackTuple(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment x0, MemorySegment x1, long x2, long x3, Object... x4) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("PyArg_UnpackTuple", x0, x1, x2, x3, x4);
                }
                return (int)spreader.invokeExact(x0, x1, x2, x3, x4);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * PyObject *Py_BuildValue(const char *, ...)
     * }
     */
    public static class Py_BuildValue {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_POINTER,
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("Py_BuildValue");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private Py_BuildValue(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * PyObject *Py_BuildValue(const char *, ...)
         * }
         */
        public static Py_BuildValue makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new Py_BuildValue(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public MemorySegment apply(MemorySegment x0, Object... x1) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("Py_BuildValue", x0, x1);
                }
                return (MemorySegment)spreader.invokeExact(x0, x1);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * PyObject *_Py_BuildValue_SizeT(const char *, ...)
     * }
     */
    public static class _Py_BuildValue_SizeT {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_POINTER,
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("_Py_BuildValue_SizeT");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private _Py_BuildValue_SizeT(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * PyObject *_Py_BuildValue_SizeT(const char *, ...)
         * }
         */
        public static _Py_BuildValue_SizeT makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new _Py_BuildValue_SizeT(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public MemorySegment apply(MemorySegment x0, Object... x1) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("_Py_BuildValue_SizeT", x0, x1);
                }
                return (MemorySegment)spreader.invokeExact(x0, x1);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class Py_VaBuildValue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_VaBuildValue");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *Py_VaBuildValue(const char *, va_list)
     * }
     */
    public static FunctionDescriptor Py_VaBuildValue$descriptor() {
        return Py_VaBuildValue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *Py_VaBuildValue(const char *, va_list)
     * }
     */
    public static MethodHandle Py_VaBuildValue$handle() {
        return Py_VaBuildValue.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *Py_VaBuildValue(const char *, va_list)
     * }
     */
    public static MemorySegment Py_VaBuildValue$address() {
        return Py_VaBuildValue.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *Py_VaBuildValue(const char *, va_list)
     * }
     */
    public static MemorySegment Py_VaBuildValue(MemorySegment x0, MemorySegment x1) {
        var mh$ = Py_VaBuildValue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_VaBuildValue", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
}

