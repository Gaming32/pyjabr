// Generated by jextract

package io.github.gaming32.pyjabr.lowlevel.cpython;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

public class Python_h_2 {

    Python_h_2() {
        // Should not be called directly
    }

    static final Arena LIBRARY_ARENA = Arena.ofAuto();
    static final boolean TRACE_DOWNCALLS = Boolean.getBoolean("jextract.trace.downcalls");

    static void traceDowncall(String name, Object... args) {
         String traceArgs = Arrays.stream(args)
                       .map(Object::toString)
                       .collect(Collectors.joining(", "));
         System.out.printf("%s(%s)\n", name, traceArgs);
    }

    static MemorySegment findOrThrow(String symbol) {
        return SYMBOL_LOOKUP.find(symbol)
            .orElseThrow(() -> new UnsatisfiedLinkError("unresolved symbol: " + symbol));
    }

    static MethodHandle upcallHandle(Class<?> fi, String name, FunctionDescriptor fdesc) {
        try {
            return MethodHandles.lookup().findVirtual(fi, name, fdesc.toMethodType());
        } catch (ReflectiveOperationException ex) {
            throw new AssertionError(ex);
        }
    }

    static MemoryLayout align(MemoryLayout layout, long align) {
        return switch (layout) {
            case PaddingLayout p -> p;
            case ValueLayout v -> v.withByteAlignment(align);
            case GroupLayout g -> {
                MemoryLayout[] alignedMembers = g.memberLayouts().stream()
                        .map(m -> align(m, align)).toArray(MemoryLayout[]::new);
                yield g instanceof StructLayout ?
                        MemoryLayout.structLayout(alignedMembers) : MemoryLayout.unionLayout(alignedMembers);
            }
            case SequenceLayout s -> MemoryLayout.sequenceLayout(s.elementCount(), align(s.elementLayout(), align));
        };
    }

    static final SymbolLookup SYMBOL_LOOKUP = SymbolLookup.libraryLookup(System.mapLibraryName("python3"), LIBRARY_ARENA)
            .or(SymbolLookup.loaderLookup())
            .or(Linker.nativeLinker().defaultLookup());

    public static final ValueLayout.OfBoolean C_BOOL = ValueLayout.JAVA_BOOLEAN;
    public static final ValueLayout.OfByte C_CHAR = ValueLayout.JAVA_BYTE;
    public static final ValueLayout.OfShort C_SHORT = ValueLayout.JAVA_SHORT;
    public static final ValueLayout.OfInt C_INT = ValueLayout.JAVA_INT;
    public static final ValueLayout.OfLong C_LONG_LONG = ValueLayout.JAVA_LONG;
    public static final ValueLayout.OfFloat C_FLOAT = ValueLayout.JAVA_FLOAT;
    public static final ValueLayout.OfDouble C_DOUBLE = ValueLayout.JAVA_DOUBLE;
    public static final AddressLayout C_POINTER = ValueLayout.ADDRESS
            .withTargetLayout(MemoryLayout.sequenceLayout(java.lang.Long.MAX_VALUE, JAVA_BYTE));
    public static final ValueLayout.OfInt C_LONG = ValueLayout.JAVA_INT;
    public static final ValueLayout.OfDouble C_LONG_DOUBLE = ValueLayout.JAVA_DOUBLE;
    private static final int PY_RELEASE_LEVEL_ALPHA = (int)10L;
    /**
     * {@snippet lang=c :
     * #define PY_RELEASE_LEVEL_ALPHA 10
     * }
     */
    public static int PY_RELEASE_LEVEL_ALPHA() {
        return PY_RELEASE_LEVEL_ALPHA;
    }
    private static final int PY_RELEASE_LEVEL_BETA = (int)11L;
    /**
     * {@snippet lang=c :
     * #define PY_RELEASE_LEVEL_BETA 11
     * }
     */
    public static int PY_RELEASE_LEVEL_BETA() {
        return PY_RELEASE_LEVEL_BETA;
    }
    private static final int PY_RELEASE_LEVEL_GAMMA = (int)12L;
    /**
     * {@snippet lang=c :
     * #define PY_RELEASE_LEVEL_GAMMA 12
     * }
     */
    public static int PY_RELEASE_LEVEL_GAMMA() {
        return PY_RELEASE_LEVEL_GAMMA;
    }
    private static final int PY_RELEASE_LEVEL_FINAL = (int)15L;
    /**
     * {@snippet lang=c :
     * #define PY_RELEASE_LEVEL_FINAL 15
     * }
     */
    public static int PY_RELEASE_LEVEL_FINAL() {
        return PY_RELEASE_LEVEL_FINAL;
    }
    private static final int PY_MAJOR_VERSION = (int)3L;
    /**
     * {@snippet lang=c :
     * #define PY_MAJOR_VERSION 3
     * }
     */
    public static int PY_MAJOR_VERSION() {
        return PY_MAJOR_VERSION;
    }
    private static final int PY_MINOR_VERSION = (int)12L;
    /**
     * {@snippet lang=c :
     * #define PY_MINOR_VERSION 12
     * }
     */
    public static int PY_MINOR_VERSION() {
        return PY_MINOR_VERSION;
    }
    private static final int PY_MICRO_VERSION = (int)1L;
    /**
     * {@snippet lang=c :
     * #define PY_MICRO_VERSION 1
     * }
     */
    public static int PY_MICRO_VERSION() {
        return PY_MICRO_VERSION;
    }
    private static final int PY_RELEASE_SERIAL = (int)0L;
    /**
     * {@snippet lang=c :
     * #define PY_RELEASE_SERIAL 0
     * }
     */
    public static int PY_RELEASE_SERIAL() {
        return PY_RELEASE_SERIAL;
    }
    private static final int _CRT_SECURE_NO_DEPRECATE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _CRT_SECURE_NO_DEPRECATE 1
     * }
     */
    public static int _CRT_SECURE_NO_DEPRECATE() {
        return _CRT_SECURE_NO_DEPRECATE;
    }
    private static final int _CRT_NONSTDC_NO_DEPRECATE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _CRT_NONSTDC_NO_DEPRECATE 1
     * }
     */
    public static int _CRT_NONSTDC_NO_DEPRECATE() {
        return _CRT_NONSTDC_NO_DEPRECATE;
    }
    private static final int _VCRT_COMPILER_PREPROCESSOR = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _VCRT_COMPILER_PREPROCESSOR 1
     * }
     */
    public static int _VCRT_COMPILER_PREPROCESSOR() {
        return _VCRT_COMPILER_PREPROCESSOR;
    }
    private static final int _SAL_VERSION = (int)20L;
    /**
     * {@snippet lang=c :
     * #define _SAL_VERSION 20
     * }
     */
    public static int _SAL_VERSION() {
        return _SAL_VERSION;
    }
    private static final int __SAL_H_VERSION = (int)180000000L;
    /**
     * {@snippet lang=c :
     * #define __SAL_H_VERSION 180000000
     * }
     */
    public static int __SAL_H_VERSION() {
        return __SAL_H_VERSION;
    }
    private static final int _USE_DECLSPECS_FOR_SAL = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _USE_DECLSPECS_FOR_SAL 0
     * }
     */
    public static int _USE_DECLSPECS_FOR_SAL() {
        return _USE_DECLSPECS_FOR_SAL;
    }
    private static final int _USE_ATTRIBUTES_FOR_SAL = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _USE_ATTRIBUTES_FOR_SAL 0
     * }
     */
    public static int _USE_ATTRIBUTES_FOR_SAL() {
        return _USE_ATTRIBUTES_FOR_SAL;
    }
    private static final int _CRT_PACKING = (int)8L;
    /**
     * {@snippet lang=c :
     * #define _CRT_PACKING 8
     * }
     */
    public static int _CRT_PACKING() {
        return _CRT_PACKING;
    }
    private static final int _HAS_EXCEPTIONS = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _HAS_EXCEPTIONS 1
     * }
     */
    public static int _HAS_EXCEPTIONS() {
        return _HAS_EXCEPTIONS;
    }
    private static final int _HAS_CXX17 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _HAS_CXX17 0
     * }
     */
    public static int _HAS_CXX17() {
        return _HAS_CXX17;
    }
    private static final int _HAS_CXX20 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _HAS_CXX20 0
     * }
     */
    public static int _HAS_CXX20() {
        return _HAS_CXX20;
    }
    private static final int _HAS_CXX23 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _HAS_CXX23 0
     * }
     */
    public static int _HAS_CXX23() {
        return _HAS_CXX23;
    }
    private static final int _HAS_NODISCARD = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _HAS_NODISCARD 0
     * }
     */
    public static int _HAS_NODISCARD() {
        return _HAS_NODISCARD;
    }
    private static final int _ARGMAX = (int)100L;
    /**
     * {@snippet lang=c :
     * #define _ARGMAX 100
     * }
     */
    public static int _ARGMAX() {
        return _ARGMAX;
    }
    private static final int _CRT_INT_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define _CRT_INT_MAX 2147483647
     * }
     */
    public static int _CRT_INT_MAX() {
        return _CRT_INT_MAX;
    }
    private static final int _CRT_FUNCTIONS_REQUIRED = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _CRT_FUNCTIONS_REQUIRED 1
     * }
     */
    public static int _CRT_FUNCTIONS_REQUIRED() {
        return _CRT_FUNCTIONS_REQUIRED;
    }
    private static final int _CRT_HAS_CXX17 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _CRT_HAS_CXX17 0
     * }
     */
    public static int _CRT_HAS_CXX17() {
        return _CRT_HAS_CXX17;
    }
    private static final int _ARM_WINAPI_PARTITION_DESKTOP_SDK_AVAILABLE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _ARM_WINAPI_PARTITION_DESKTOP_SDK_AVAILABLE 1
     * }
     */
    public static int _ARM_WINAPI_PARTITION_DESKTOP_SDK_AVAILABLE() {
        return _ARM_WINAPI_PARTITION_DESKTOP_SDK_AVAILABLE;
    }
    private static final int _CRT_BUILD_DESKTOP_APP = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _CRT_BUILD_DESKTOP_APP 1
     * }
     */
    public static int _CRT_BUILD_DESKTOP_APP() {
        return _CRT_BUILD_DESKTOP_APP;
    }
    private static final int _CRT_INTERNAL_NONSTDC_NAMES = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _CRT_INTERNAL_NONSTDC_NAMES 1
     * }
     */
    public static int _CRT_INTERNAL_NONSTDC_NAMES() {
        return _CRT_INTERNAL_NONSTDC_NAMES;
    }
    private static final int __STDC_WANT_SECURE_LIB__ = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __STDC_WANT_SECURE_LIB__ 1
     * }
     */
    public static int __STDC_WANT_SECURE_LIB__() {
        return __STDC_WANT_SECURE_LIB__;
    }
    private static final int _SECURECRT_FILL_BUFFER_PATTERN = (int)254L;
    /**
     * {@snippet lang=c :
     * #define _SECURECRT_FILL_BUFFER_PATTERN 254
     * }
     */
    public static int _SECURECRT_FILL_BUFFER_PATTERN() {
        return _SECURECRT_FILL_BUFFER_PATTERN;
    }
    private static final int _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES 0
     * }
     */
    public static int _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES() {
        return _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES;
    }
    private static final int _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT 0
     * }
     */
    public static int _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT() {
        return _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT;
    }
    private static final int _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES 1
     * }
     */
    public static int _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES() {
        return _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES;
    }
    private static final int _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_MEMORY = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_MEMORY 0
     * }
     */
    public static int _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_MEMORY() {
        return _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_MEMORY;
    }
    private static final int _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES_MEMORY = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES_MEMORY 0
     * }
     */
    public static int _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES_MEMORY() {
        return _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES_MEMORY;
    }
    private static final int _SH_DENYRW = (int)16L;
    /**
     * {@snippet lang=c :
     * #define _SH_DENYRW 16
     * }
     */
    public static int _SH_DENYRW() {
        return _SH_DENYRW;
    }
    private static final int _SH_DENYWR = (int)32L;
    /**
     * {@snippet lang=c :
     * #define _SH_DENYWR 32
     * }
     */
    public static int _SH_DENYWR() {
        return _SH_DENYWR;
    }
    private static final int _SH_DENYRD = (int)48L;
    /**
     * {@snippet lang=c :
     * #define _SH_DENYRD 48
     * }
     */
    public static int _SH_DENYRD() {
        return _SH_DENYRD;
    }
    private static final int _SH_DENYNO = (int)64L;
    /**
     * {@snippet lang=c :
     * #define _SH_DENYNO 64
     * }
     */
    public static int _SH_DENYNO() {
        return _SH_DENYNO;
    }
    private static final int _SH_SECURE = (int)128L;
    /**
     * {@snippet lang=c :
     * #define _SH_SECURE 128
     * }
     */
    public static int _SH_SECURE() {
        return _SH_SECURE;
    }
    private static final int _A_NORMAL = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _A_NORMAL 0
     * }
     */
    public static int _A_NORMAL() {
        return _A_NORMAL;
    }
    private static final int _A_RDONLY = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _A_RDONLY 1
     * }
     */
    public static int _A_RDONLY() {
        return _A_RDONLY;
    }
    private static final int _A_HIDDEN = (int)2L;
    /**
     * {@snippet lang=c :
     * #define _A_HIDDEN 2
     * }
     */
    public static int _A_HIDDEN() {
        return _A_HIDDEN;
    }
    private static final int _A_SYSTEM = (int)4L;
    /**
     * {@snippet lang=c :
     * #define _A_SYSTEM 4
     * }
     */
    public static int _A_SYSTEM() {
        return _A_SYSTEM;
    }
    private static final int _A_SUBDIR = (int)16L;
    /**
     * {@snippet lang=c :
     * #define _A_SUBDIR 16
     * }
     */
    public static int _A_SUBDIR() {
        return _A_SUBDIR;
    }
    private static final int _A_ARCH = (int)32L;
    /**
     * {@snippet lang=c :
     * #define _A_ARCH 32
     * }
     */
    public static int _A_ARCH() {
        return _A_ARCH;
    }
    private static final int LONG_BIT = (int)32L;
    /**
     * {@snippet lang=c :
     * #define LONG_BIT 32
     * }
     */
    public static int LONG_BIT() {
        return LONG_BIT;
    }
    private static final int WORD_BIT = (int)32L;
    /**
     * {@snippet lang=c :
     * #define WORD_BIT 32
     * }
     */
    public static int WORD_BIT() {
        return WORD_BIT;
    }
    private static final int PY_SUPPORT_TIER = (int)0L;
    /**
     * {@snippet lang=c :
     * #define PY_SUPPORT_TIER 0
     * }
     */
    public static int PY_SUPPORT_TIER() {
        return PY_SUPPORT_TIER;
    }
    private static final int Py_WINVER = (int)1538L;
    /**
     * {@snippet lang=c :
     * #define Py_WINVER 1538
     * }
     */
    public static int Py_WINVER() {
        return Py_WINVER;
    }
    private static final int HAVE_PY_SSIZE_T = (int)1L;
    /**
     * {@snippet lang=c :
     * #define HAVE_PY_SSIZE_T 1
     * }
     */
    public static int HAVE_PY_SSIZE_T() {
        return HAVE_PY_SSIZE_T;
    }
    private static final int BUFSIZ = (int)512L;
    /**
     * {@snippet lang=c :
     * #define BUFSIZ 512
     * }
     */
    public static int BUFSIZ() {
        return BUFSIZ;
    }
    private static final int _NSTREAM_ = (int)512L;
    /**
     * {@snippet lang=c :
     * #define _NSTREAM_ 512
     * }
     */
    public static int _NSTREAM_() {
        return _NSTREAM_;
    }
    private static final int _IOB_ENTRIES = (int)3L;
    /**
     * {@snippet lang=c :
     * #define _IOB_ENTRIES 3
     * }
     */
    public static int _IOB_ENTRIES() {
        return _IOB_ENTRIES;
    }
    private static final int _IOFBF = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _IOFBF 0
     * }
     */
    public static int _IOFBF() {
        return _IOFBF;
    }
    private static final int _IOLBF = (int)64L;
    /**
     * {@snippet lang=c :
     * #define _IOLBF 64
     * }
     */
    public static int _IOLBF() {
        return _IOLBF;
    }
    private static final int _IONBF = (int)4L;
    /**
     * {@snippet lang=c :
     * #define _IONBF 4
     * }
     */
    public static int _IONBF() {
        return _IONBF;
    }
    private static final int L_tmpnam = (int)260L;
    /**
     * {@snippet lang=c :
     * #define L_tmpnam 260
     * }
     */
    public static int L_tmpnam() {
        return L_tmpnam;
    }
    private static final int SEEK_CUR = (int)1L;
    /**
     * {@snippet lang=c :
     * #define SEEK_CUR 1
     * }
     */
    public static int SEEK_CUR() {
        return SEEK_CUR;
    }
    private static final int SEEK_END = (int)2L;
    /**
     * {@snippet lang=c :
     * #define SEEK_END 2
     * }
     */
    public static int SEEK_END() {
        return SEEK_END;
    }
    private static final int SEEK_SET = (int)0L;
    /**
     * {@snippet lang=c :
     * #define SEEK_SET 0
     * }
     */
    public static int SEEK_SET() {
        return SEEK_SET;
    }
    private static final int FILENAME_MAX = (int)260L;
    /**
     * {@snippet lang=c :
     * #define FILENAME_MAX 260
     * }
     */
    public static int FILENAME_MAX() {
        return FILENAME_MAX;
    }
    private static final int FOPEN_MAX = (int)20L;
    /**
     * {@snippet lang=c :
     * #define FOPEN_MAX 20
     * }
     */
    public static int FOPEN_MAX() {
        return FOPEN_MAX;
    }
    private static final int _SYS_OPEN = (int)20L;
    /**
     * {@snippet lang=c :
     * #define _SYS_OPEN 20
     * }
     */
    public static int _SYS_OPEN() {
        return _SYS_OPEN;
    }
    private static final int Py_ENABLE_SHARED = (int)1L;
    /**
     * {@snippet lang=c :
     * #define Py_ENABLE_SHARED 1
     * }
     */
    public static int Py_ENABLE_SHARED() {
        return Py_ENABLE_SHARED;
    }
    private static final int SIZEOF_VOID_P = (int)8L;
    /**
     * {@snippet lang=c :
     * #define SIZEOF_VOID_P 8
     * }
     */
    public static int SIZEOF_VOID_P() {
        return SIZEOF_VOID_P;
    }
    private static final int SIZEOF_TIME_T = (int)8L;
    /**
     * {@snippet lang=c :
     * #define SIZEOF_TIME_T 8
     * }
     */
    public static int SIZEOF_TIME_T() {
        return SIZEOF_TIME_T;
    }
    private static final int SIZEOF_OFF_T = (int)4L;
    /**
     * {@snippet lang=c :
     * #define SIZEOF_OFF_T 4
     * }
     */
    public static int SIZEOF_OFF_T() {
        return SIZEOF_OFF_T;
    }
    private static final int SIZEOF_FPOS_T = (int)8L;
    /**
     * {@snippet lang=c :
     * #define SIZEOF_FPOS_T 8
     * }
     */
    public static int SIZEOF_FPOS_T() {
        return SIZEOF_FPOS_T;
    }
    private static final int SIZEOF_HKEY = (int)8L;
    /**
     * {@snippet lang=c :
     * #define SIZEOF_HKEY 8
     * }
     */
    public static int SIZEOF_HKEY() {
        return SIZEOF_HKEY;
    }
    private static final int SIZEOF_SIZE_T = (int)8L;
    /**
     * {@snippet lang=c :
     * #define SIZEOF_SIZE_T 8
     * }
     */
    public static int SIZEOF_SIZE_T() {
        return SIZEOF_SIZE_T;
    }
    private static final int ALIGNOF_SIZE_T = (int)8L;
    /**
     * {@snippet lang=c :
     * #define ALIGNOF_SIZE_T 8
     * }
     */
    public static int ALIGNOF_SIZE_T() {
        return ALIGNOF_SIZE_T;
    }
    private static final int ALIGNOF_MAX_ALIGN_T = (int)8L;
    /**
     * {@snippet lang=c :
     * #define ALIGNOF_MAX_ALIGN_T 8
     * }
     */
    public static int ALIGNOF_MAX_ALIGN_T() {
        return ALIGNOF_MAX_ALIGN_T;
    }
    private static final int SIZEOF_SHORT = (int)2L;
    /**
     * {@snippet lang=c :
     * #define SIZEOF_SHORT 2
     * }
     */
    public static int SIZEOF_SHORT() {
        return SIZEOF_SHORT;
    }
    private static final int SIZEOF_INT = (int)4L;
    /**
     * {@snippet lang=c :
     * #define SIZEOF_INT 4
     * }
     */
    public static int SIZEOF_INT() {
        return SIZEOF_INT;
    }
    private static final int SIZEOF_LONG = (int)4L;
    /**
     * {@snippet lang=c :
     * #define SIZEOF_LONG 4
     * }
     */
    public static int SIZEOF_LONG() {
        return SIZEOF_LONG;
    }
    private static final int ALIGNOF_LONG = (int)4L;
    /**
     * {@snippet lang=c :
     * #define ALIGNOF_LONG 4
     * }
     */
    public static int ALIGNOF_LONG() {
        return ALIGNOF_LONG;
    }
    private static final int SIZEOF_LONG_LONG = (int)8L;
    /**
     * {@snippet lang=c :
     * #define SIZEOF_LONG_LONG 8
     * }
     */
    public static int SIZEOF_LONG_LONG() {
        return SIZEOF_LONG_LONG;
    }
    private static final int SIZEOF_DOUBLE = (int)8L;
    /**
     * {@snippet lang=c :
     * #define SIZEOF_DOUBLE 8
     * }
     */
    public static int SIZEOF_DOUBLE() {
        return SIZEOF_DOUBLE;
    }
    private static final int SIZEOF_FLOAT = (int)4L;
    /**
     * {@snippet lang=c :
     * #define SIZEOF_FLOAT 4
     * }
     */
    public static int SIZEOF_FLOAT() {
        return SIZEOF_FLOAT;
    }
    private static final int HAVE_UINTPTR_T = (int)1L;
    /**
     * {@snippet lang=c :
     * #define HAVE_UINTPTR_T 1
     * }
     */
    public static int HAVE_UINTPTR_T() {
        return HAVE_UINTPTR_T;
    }
    private static final int HAVE_INTPTR_T = (int)1L;
    /**
     * {@snippet lang=c :
     * #define HAVE_INTPTR_T 1
     * }
     */
    public static int HAVE_INTPTR_T() {
        return HAVE_INTPTR_T;
    }
    private static final int HAVE_CONIO_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define HAVE_CONIO_H 1
     * }
     */
    public static int HAVE_CONIO_H() {
        return HAVE_CONIO_H;
    }
    private static final int HAVE_DIRECT_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define HAVE_DIRECT_H 1
     * }
     */
    public static int HAVE_DIRECT_H() {
        return HAVE_DIRECT_H;
    }
    private static final int HAVE_DECL_TZNAME = (int)1L;
    /**
     * {@snippet lang=c :
     * #define HAVE_DECL_TZNAME 1
     * }
     */
    public static int HAVE_DECL_TZNAME() {
        return HAVE_DECL_TZNAME;
    }
    private static final int STDC_HEADERS = (int)1L;
    /**
     * {@snippet lang=c :
     * #define STDC_HEADERS 1
     * }
     */
    public static int STDC_HEADERS() {
        return STDC_HEADERS;
    }
    private static final int WITH_DECIMAL_CONTEXTVAR = (int)1L;
    /**
     * {@snippet lang=c :
     * #define WITH_DECIMAL_CONTEXTVAR 1
     * }
     */
    public static int WITH_DECIMAL_CONTEXTVAR() {
        return WITH_DECIMAL_CONTEXTVAR;
    }
    private static final int WITH_DOC_STRINGS = (int)1L;
    /**
     * {@snippet lang=c :
     * #define WITH_DOC_STRINGS 1
     * }
     */
    public static int WITH_DOC_STRINGS() {
        return WITH_DOC_STRINGS;
    }
    private static final int WITH_PYMALLOC = (int)1L;
    /**
     * {@snippet lang=c :
     * #define WITH_PYMALLOC 1
     * }
     */
    public static int WITH_PYMALLOC() {
        return WITH_PYMALLOC;
    }
    private static final int WITH_FREELISTS = (int)1L;
    /**
     * {@snippet lang=c :
     * #define WITH_FREELISTS 1
     * }
     */
    public static int WITH_FREELISTS() {
        return WITH_FREELISTS;
    }
    private static final int HAVE_SHUTDOWN = (int)1L;
    /**
     * {@snippet lang=c :
     * #define HAVE_SHUTDOWN 1
     * }
     */
    public static int HAVE_SHUTDOWN() {
        return HAVE_SHUTDOWN;
    }
    private static final int HAVE_UMASK = (int)1L;
    /**
     * {@snippet lang=c :
     * #define HAVE_UMASK 1
     * }
     */
    public static int HAVE_UMASK() {
        return HAVE_UMASK;
    }
    private static final int HAVE_WCSFTIME = (int)1L;
    /**
     * {@snippet lang=c :
     * #define HAVE_WCSFTIME 1
     * }
     */
    public static int HAVE_WCSFTIME() {
        return HAVE_WCSFTIME;
    }
    private static final int HAVE_WCSCOLL = (int)1L;
    /**
     * {@snippet lang=c :
     * #define HAVE_WCSCOLL 1
     * }
     */
    public static int HAVE_WCSCOLL() {
        return HAVE_WCSCOLL;
    }
    private static final int HAVE_WCSXFRM = (int)1L;
    /**
     * {@snippet lang=c :
     * #define HAVE_WCSXFRM 1
     * }
     */
    public static int HAVE_WCSXFRM() {
        return HAVE_WCSXFRM;
    }
    private static final int HAVE_ZLIB_COPY = (int)1L;
    /**
     * {@snippet lang=c :
     * #define HAVE_ZLIB_COPY 1
     * }
     */
    public static int HAVE_ZLIB_COPY() {
        return HAVE_ZLIB_COPY;
    }
    private static final int HAVE_ERRNO_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define HAVE_ERRNO_H 1
     * }
     */
    public static int HAVE_ERRNO_H() {
        return HAVE_ERRNO_H;
    }
    private static final int HAVE_FCNTL_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define HAVE_FCNTL_H 1
     * }
     */
    public static int HAVE_FCNTL_H() {
        return HAVE_FCNTL_H;
    }
    private static final int HAVE_PROCESS_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define HAVE_PROCESS_H 1
     * }
     */
    public static int HAVE_PROCESS_H() {
        return HAVE_PROCESS_H;
    }
    private static final int HAVE_SIGNAL_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define HAVE_SIGNAL_H 1
     * }
     */
    public static int HAVE_SIGNAL_H() {
        return HAVE_SIGNAL_H;
    }
    private static final int HAVE_STDDEF_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define HAVE_STDDEF_H 1
     * }
     */
    public static int HAVE_STDDEF_H() {
        return HAVE_STDDEF_H;
    }
    private static final int HAVE_SYS_STAT_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define HAVE_SYS_STAT_H 1
     * }
     */
    public static int HAVE_SYS_STAT_H() {
        return HAVE_SYS_STAT_H;
    }
    private static final int HAVE_SYS_TYPES_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define HAVE_SYS_TYPES_H 1
     * }
     */
    public static int HAVE_SYS_TYPES_H() {
        return HAVE_SYS_TYPES_H;
    }
    private static final int HAVE_WCHAR_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define HAVE_WCHAR_H 1
     * }
     */
    public static int HAVE_WCHAR_H() {
        return HAVE_WCHAR_H;
    }
    private static final int SIZEOF_WCHAR_T = (int)2L;
    /**
     * {@snippet lang=c :
     * #define SIZEOF_WCHAR_T 2
     * }
     */
    public static int SIZEOF_WCHAR_T() {
        return SIZEOF_WCHAR_T;
    }
    private static final int SIZEOF__BOOL = (int)1L;
    /**
     * {@snippet lang=c :
     * #define SIZEOF__BOOL 1
     * }
     */
    public static int SIZEOF__BOOL() {
        return SIZEOF__BOOL;
    }
    private static final int HAVE_LIBNSL = (int)1L;
    /**
     * {@snippet lang=c :
     * #define HAVE_LIBNSL 1
     * }
     */
    public static int HAVE_LIBNSL() {
        return HAVE_LIBNSL;
    }
    private static final int HAVE_LIBSOCKET = (int)1L;
    /**
     * {@snippet lang=c :
     * #define HAVE_LIBSOCKET 1
     * }
     */
    public static int HAVE_LIBSOCKET() {
        return HAVE_LIBSOCKET;
    }
    private static final int DOUBLE_IS_LITTLE_ENDIAN_IEEE754 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define DOUBLE_IS_LITTLE_ENDIAN_IEEE754 1
     * }
     */
    public static int DOUBLE_IS_LITTLE_ENDIAN_IEEE754() {
        return DOUBLE_IS_LITTLE_ENDIAN_IEEE754;
    }
    private static final int HAVE_ERF = (int)1L;
    /**
     * {@snippet lang=c :
     * #define HAVE_ERF 1
     * }
     */
    public static int HAVE_ERF() {
        return HAVE_ERF;
    }
    private static final int HAVE_ERFC = (int)1L;
    /**
     * {@snippet lang=c :
     * #define HAVE_ERFC 1
     * }
     */
    public static int HAVE_ERFC() {
        return HAVE_ERFC;
    }
    private static final int HAVE_GETHOSTNAME = (int)1L;
    /**
     * {@snippet lang=c :
     * #define HAVE_GETHOSTNAME 1
     * }
     */
    public static int HAVE_GETHOSTNAME() {
        return HAVE_GETHOSTNAME;
    }
    private static final int HAVE_GETHOSTBYADDR = (int)1L;
    /**
     * {@snippet lang=c :
     * #define HAVE_GETHOSTBYADDR 1
     * }
     */
    public static int HAVE_GETHOSTBYADDR() {
        return HAVE_GETHOSTBYADDR;
    }
    private static final int HAVE_GETHOSTBYNAME = (int)1L;
    /**
     * {@snippet lang=c :
     * #define HAVE_GETHOSTBYNAME 1
     * }
     */
    public static int HAVE_GETHOSTBYNAME() {
        return HAVE_GETHOSTBYNAME;
    }
    private static final int HAVE_GETPROTOBYNAME = (int)1L;
    /**
     * {@snippet lang=c :
     * #define HAVE_GETPROTOBYNAME 1
     * }
     */
    public static int HAVE_GETPROTOBYNAME() {
        return HAVE_GETPROTOBYNAME;
    }
    private static final int HAVE_GETSERVBYNAME = (int)1L;
    /**
     * {@snippet lang=c :
     * #define HAVE_GETSERVBYNAME 1
     * }
     */
    public static int HAVE_GETSERVBYNAME() {
        return HAVE_GETSERVBYNAME;
    }
    private static final int HAVE_GETSERVBYPORT = (int)1L;
    /**
     * {@snippet lang=c :
     * #define HAVE_GETSERVBYPORT 1
     * }
     */
    public static int HAVE_GETSERVBYPORT() {
        return HAVE_GETSERVBYPORT;
    }
    private static final int HAVE_INET_PTON = (int)1L;
    /**
     * {@snippet lang=c :
     * #define HAVE_INET_PTON 1
     * }
     */
    public static int HAVE_INET_PTON() {
        return HAVE_INET_PTON;
    }
    private static final int HAVE_INET_NTOA = (int)1L;
    /**
     * {@snippet lang=c :
     * #define HAVE_INET_NTOA 1
     * }
     */
    public static int HAVE_INET_NTOA() {
        return HAVE_INET_NTOA;
    }
    private static final int HAVE_ACCEPT = (int)1L;
    /**
     * {@snippet lang=c :
     * #define HAVE_ACCEPT 1
     * }
     */
    public static int HAVE_ACCEPT() {
        return HAVE_ACCEPT;
    }
    private static final int HAVE_BIND = (int)1L;
    /**
     * {@snippet lang=c :
     * #define HAVE_BIND 1
     * }
     */
    public static int HAVE_BIND() {
        return HAVE_BIND;
    }
    private static final int HAVE_CONNECT = (int)1L;
    /**
     * {@snippet lang=c :
     * #define HAVE_CONNECT 1
     * }
     */
    public static int HAVE_CONNECT() {
        return HAVE_CONNECT;
    }
    private static final int HAVE_GETSOCKNAME = (int)1L;
    /**
     * {@snippet lang=c :
     * #define HAVE_GETSOCKNAME 1
     * }
     */
    public static int HAVE_GETSOCKNAME() {
        return HAVE_GETSOCKNAME;
    }
    private static final int HAVE_LISTEN = (int)1L;
    /**
     * {@snippet lang=c :
     * #define HAVE_LISTEN 1
     * }
     */
    public static int HAVE_LISTEN() {
        return HAVE_LISTEN;
    }
    private static final int HAVE_RECVFROM = (int)1L;
    /**
     * {@snippet lang=c :
     * #define HAVE_RECVFROM 1
     * }
     */
    public static int HAVE_RECVFROM() {
        return HAVE_RECVFROM;
    }
    private static final int HAVE_SENDTO = (int)1L;
    /**
     * {@snippet lang=c :
     * #define HAVE_SENDTO 1
     * }
     */
    public static int HAVE_SENDTO() {
        return HAVE_SENDTO;
    }
    private static final int HAVE_SETSOCKOPT = (int)1L;
    /**
     * {@snippet lang=c :
     * #define HAVE_SETSOCKOPT 1
     * }
     */
    public static int HAVE_SETSOCKOPT() {
        return HAVE_SETSOCKOPT;
    }
    private static final int HAVE_SOCKET = (int)1L;
    /**
     * {@snippet lang=c :
     * #define HAVE_SOCKET 1
     * }
     */
    public static int HAVE_SOCKET() {
        return HAVE_SOCKET;
    }
    private static final int HAVE_DUP = (int)1L;
    /**
     * {@snippet lang=c :
     * #define HAVE_DUP 1
     * }
     */
    public static int HAVE_DUP() {
        return HAVE_DUP;
    }
    private static final int HAVE_X509_VERIFY_PARAM_SET1_HOST = (int)1L;
    /**
     * {@snippet lang=c :
     * #define HAVE_X509_VERIFY_PARAM_SET1_HOST 1
     * }
     */
    public static int HAVE_X509_VERIFY_PARAM_SET1_HOST() {
        return HAVE_X509_VERIFY_PARAM_SET1_HOST;
    }
    private static final int EPERM = (int)1L;
    /**
     * {@snippet lang=c :
     * #define EPERM 1
     * }
     */
    public static int EPERM() {
        return EPERM;
    }
    private static final int ENOENT = (int)2L;
    /**
     * {@snippet lang=c :
     * #define ENOENT 2
     * }
     */
    public static int ENOENT() {
        return ENOENT;
    }
    private static final int ESRCH = (int)3L;
    /**
     * {@snippet lang=c :
     * #define ESRCH 3
     * }
     */
    public static int ESRCH() {
        return ESRCH;
    }
    private static final int EINTR = (int)4L;
    /**
     * {@snippet lang=c :
     * #define EINTR 4
     * }
     */
    public static int EINTR() {
        return EINTR;
    }
    private static final int EIO = (int)5L;
    /**
     * {@snippet lang=c :
     * #define EIO 5
     * }
     */
    public static int EIO() {
        return EIO;
    }
    private static final int ENXIO = (int)6L;
    /**
     * {@snippet lang=c :
     * #define ENXIO 6
     * }
     */
    public static int ENXIO() {
        return ENXIO;
    }
    private static final int E2BIG = (int)7L;
    /**
     * {@snippet lang=c :
     * #define E2BIG 7
     * }
     */
    public static int E2BIG() {
        return E2BIG;
    }
    private static final int ENOEXEC = (int)8L;
    /**
     * {@snippet lang=c :
     * #define ENOEXEC 8
     * }
     */
    public static int ENOEXEC() {
        return ENOEXEC;
    }
    private static final int EBADF = (int)9L;
    /**
     * {@snippet lang=c :
     * #define EBADF 9
     * }
     */
    public static int EBADF() {
        return EBADF;
    }
    private static final int ECHILD = (int)10L;
    /**
     * {@snippet lang=c :
     * #define ECHILD 10
     * }
     */
    public static int ECHILD() {
        return ECHILD;
    }
    private static final int EAGAIN = (int)11L;
    /**
     * {@snippet lang=c :
     * #define EAGAIN 11
     * }
     */
    public static int EAGAIN() {
        return EAGAIN;
    }
    private static final int ENOMEM = (int)12L;
    /**
     * {@snippet lang=c :
     * #define ENOMEM 12
     * }
     */
    public static int ENOMEM() {
        return ENOMEM;
    }
    private static final int EACCES = (int)13L;
    /**
     * {@snippet lang=c :
     * #define EACCES 13
     * }
     */
    public static int EACCES() {
        return EACCES;
    }
    private static final int EFAULT = (int)14L;
    /**
     * {@snippet lang=c :
     * #define EFAULT 14
     * }
     */
    public static int EFAULT() {
        return EFAULT;
    }
    private static final int EBUSY = (int)16L;
    /**
     * {@snippet lang=c :
     * #define EBUSY 16
     * }
     */
    public static int EBUSY() {
        return EBUSY;
    }
    private static final int EEXIST = (int)17L;
    /**
     * {@snippet lang=c :
     * #define EEXIST 17
     * }
     */
    public static int EEXIST() {
        return EEXIST;
    }
    private static final int EXDEV = (int)18L;
    /**
     * {@snippet lang=c :
     * #define EXDEV 18
     * }
     */
    public static int EXDEV() {
        return EXDEV;
    }
    private static final int ENODEV = (int)19L;
    /**
     * {@snippet lang=c :
     * #define ENODEV 19
     * }
     */
    public static int ENODEV() {
        return ENODEV;
    }
    private static final int ENOTDIR = (int)20L;
    /**
     * {@snippet lang=c :
     * #define ENOTDIR 20
     * }
     */
    public static int ENOTDIR() {
        return ENOTDIR;
    }
    private static final int EISDIR = (int)21L;
    /**
     * {@snippet lang=c :
     * #define EISDIR 21
     * }
     */
    public static int EISDIR() {
        return EISDIR;
    }
    private static final int ENFILE = (int)23L;
    /**
     * {@snippet lang=c :
     * #define ENFILE 23
     * }
     */
    public static int ENFILE() {
        return ENFILE;
    }
    private static final int EMFILE = (int)24L;
    /**
     * {@snippet lang=c :
     * #define EMFILE 24
     * }
     */
    public static int EMFILE() {
        return EMFILE;
    }
    private static final int ENOTTY = (int)25L;
    /**
     * {@snippet lang=c :
     * #define ENOTTY 25
     * }
     */
    public static int ENOTTY() {
        return ENOTTY;
    }
    private static final int EFBIG = (int)27L;
    /**
     * {@snippet lang=c :
     * #define EFBIG 27
     * }
     */
    public static int EFBIG() {
        return EFBIG;
    }
    private static final int ENOSPC = (int)28L;
    /**
     * {@snippet lang=c :
     * #define ENOSPC 28
     * }
     */
    public static int ENOSPC() {
        return ENOSPC;
    }
    private static final int ESPIPE = (int)29L;
    /**
     * {@snippet lang=c :
     * #define ESPIPE 29
     * }
     */
    public static int ESPIPE() {
        return ESPIPE;
    }
    private static final int EROFS = (int)30L;
    /**
     * {@snippet lang=c :
     * #define EROFS 30
     * }
     */
    public static int EROFS() {
        return EROFS;
    }
    private static final int EMLINK = (int)31L;
    /**
     * {@snippet lang=c :
     * #define EMLINK 31
     * }
     */
    public static int EMLINK() {
        return EMLINK;
    }
    private static final int EPIPE = (int)32L;
    /**
     * {@snippet lang=c :
     * #define EPIPE 32
     * }
     */
    public static int EPIPE() {
        return EPIPE;
    }
    private static final int EDOM = (int)33L;
    /**
     * {@snippet lang=c :
     * #define EDOM 33
     * }
     */
    public static int EDOM() {
        return EDOM;
    }
    private static final int EDEADLK = (int)36L;
    /**
     * {@snippet lang=c :
     * #define EDEADLK 36
     * }
     */
    public static int EDEADLK() {
        return EDEADLK;
    }
    private static final int ENAMETOOLONG = (int)38L;
    /**
     * {@snippet lang=c :
     * #define ENAMETOOLONG 38
     * }
     */
    public static int ENAMETOOLONG() {
        return ENAMETOOLONG;
    }
    private static final int ENOLCK = (int)39L;
    /**
     * {@snippet lang=c :
     * #define ENOLCK 39
     * }
     */
    public static int ENOLCK() {
        return ENOLCK;
    }
    private static final int ENOSYS = (int)40L;
    /**
     * {@snippet lang=c :
     * #define ENOSYS 40
     * }
     */
    public static int ENOSYS() {
        return ENOSYS;
    }
    private static final int ENOTEMPTY = (int)41L;
    /**
     * {@snippet lang=c :
     * #define ENOTEMPTY 41
     * }
     */
    public static int ENOTEMPTY() {
        return ENOTEMPTY;
    }
    private static final int EINVAL = (int)22L;
    /**
     * {@snippet lang=c :
     * #define EINVAL 22
     * }
     */
    public static int EINVAL() {
        return EINVAL;
    }
    private static final int ERANGE = (int)34L;
    /**
     * {@snippet lang=c :
     * #define ERANGE 34
     * }
     */
    public static int ERANGE() {
        return ERANGE;
    }
    private static final int EILSEQ = (int)42L;
    /**
     * {@snippet lang=c :
     * #define EILSEQ 42
     * }
     */
    public static int EILSEQ() {
        return EILSEQ;
    }
    private static final int STRUNCATE = (int)80L;
    /**
     * {@snippet lang=c :
     * #define STRUNCATE 80
     * }
     */
    public static int STRUNCATE() {
        return STRUNCATE;
    }
    private static final int EADDRINUSE = (int)100L;
    /**
     * {@snippet lang=c :
     * #define EADDRINUSE 100
     * }
     */
    public static int EADDRINUSE() {
        return EADDRINUSE;
    }
    private static final int EADDRNOTAVAIL = (int)101L;
    /**
     * {@snippet lang=c :
     * #define EADDRNOTAVAIL 101
     * }
     */
    public static int EADDRNOTAVAIL() {
        return EADDRNOTAVAIL;
    }
    private static final int EAFNOSUPPORT = (int)102L;
    /**
     * {@snippet lang=c :
     * #define EAFNOSUPPORT 102
     * }
     */
    public static int EAFNOSUPPORT() {
        return EAFNOSUPPORT;
    }
    private static final int EALREADY = (int)103L;
    /**
     * {@snippet lang=c :
     * #define EALREADY 103
     * }
     */
    public static int EALREADY() {
        return EALREADY;
    }
    private static final int EBADMSG = (int)104L;
    /**
     * {@snippet lang=c :
     * #define EBADMSG 104
     * }
     */
    public static int EBADMSG() {
        return EBADMSG;
    }
    private static final int ECANCELED = (int)105L;
    /**
     * {@snippet lang=c :
     * #define ECANCELED 105
     * }
     */
    public static int ECANCELED() {
        return ECANCELED;
    }
    private static final int ECONNABORTED = (int)106L;
    /**
     * {@snippet lang=c :
     * #define ECONNABORTED 106
     * }
     */
    public static int ECONNABORTED() {
        return ECONNABORTED;
    }
    private static final int ECONNREFUSED = (int)107L;
    /**
     * {@snippet lang=c :
     * #define ECONNREFUSED 107
     * }
     */
    public static int ECONNREFUSED() {
        return ECONNREFUSED;
    }
    private static final int ECONNRESET = (int)108L;
    /**
     * {@snippet lang=c :
     * #define ECONNRESET 108
     * }
     */
    public static int ECONNRESET() {
        return ECONNRESET;
    }
    private static final int EDESTADDRREQ = (int)109L;
    /**
     * {@snippet lang=c :
     * #define EDESTADDRREQ 109
     * }
     */
    public static int EDESTADDRREQ() {
        return EDESTADDRREQ;
    }
    private static final int EHOSTUNREACH = (int)110L;
    /**
     * {@snippet lang=c :
     * #define EHOSTUNREACH 110
     * }
     */
    public static int EHOSTUNREACH() {
        return EHOSTUNREACH;
    }
    private static final int EIDRM = (int)111L;
    /**
     * {@snippet lang=c :
     * #define EIDRM 111
     * }
     */
    public static int EIDRM() {
        return EIDRM;
    }
    private static final int EINPROGRESS = (int)112L;
    /**
     * {@snippet lang=c :
     * #define EINPROGRESS 112
     * }
     */
    public static int EINPROGRESS() {
        return EINPROGRESS;
    }
    private static final int EISCONN = (int)113L;
    /**
     * {@snippet lang=c :
     * #define EISCONN 113
     * }
     */
    public static int EISCONN() {
        return EISCONN;
    }
    private static final int ELOOP = (int)114L;
    /**
     * {@snippet lang=c :
     * #define ELOOP 114
     * }
     */
    public static int ELOOP() {
        return ELOOP;
    }
    private static final int EMSGSIZE = (int)115L;
    /**
     * {@snippet lang=c :
     * #define EMSGSIZE 115
     * }
     */
    public static int EMSGSIZE() {
        return EMSGSIZE;
    }
    private static final int ENETDOWN = (int)116L;
    /**
     * {@snippet lang=c :
     * #define ENETDOWN 116
     * }
     */
    public static int ENETDOWN() {
        return ENETDOWN;
    }
    private static final int ENETRESET = (int)117L;
    /**
     * {@snippet lang=c :
     * #define ENETRESET 117
     * }
     */
    public static int ENETRESET() {
        return ENETRESET;
    }
    private static final int ENETUNREACH = (int)118L;
    /**
     * {@snippet lang=c :
     * #define ENETUNREACH 118
     * }
     */
    public static int ENETUNREACH() {
        return ENETUNREACH;
    }
    private static final int ENOBUFS = (int)119L;
    /**
     * {@snippet lang=c :
     * #define ENOBUFS 119
     * }
     */
    public static int ENOBUFS() {
        return ENOBUFS;
    }
    private static final int ENODATA = (int)120L;
    /**
     * {@snippet lang=c :
     * #define ENODATA 120
     * }
     */
    public static int ENODATA() {
        return ENODATA;
    }
    private static final int ENOLINK = (int)121L;
    /**
     * {@snippet lang=c :
     * #define ENOLINK 121
     * }
     */
    public static int ENOLINK() {
        return ENOLINK;
    }
    private static final int ENOMSG = (int)122L;
    /**
     * {@snippet lang=c :
     * #define ENOMSG 122
     * }
     */
    public static int ENOMSG() {
        return ENOMSG;
    }
    private static final int ENOPROTOOPT = (int)123L;
    /**
     * {@snippet lang=c :
     * #define ENOPROTOOPT 123
     * }
     */
    public static int ENOPROTOOPT() {
        return ENOPROTOOPT;
    }
    private static final int ENOSR = (int)124L;
    /**
     * {@snippet lang=c :
     * #define ENOSR 124
     * }
     */
    public static int ENOSR() {
        return ENOSR;
    }
    private static final int ENOSTR = (int)125L;
    /**
     * {@snippet lang=c :
     * #define ENOSTR 125
     * }
     */
    public static int ENOSTR() {
        return ENOSTR;
    }
    private static final int ENOTCONN = (int)126L;
    /**
     * {@snippet lang=c :
     * #define ENOTCONN 126
     * }
     */
    public static int ENOTCONN() {
        return ENOTCONN;
    }
    private static final int ENOTRECOVERABLE = (int)127L;
    /**
     * {@snippet lang=c :
     * #define ENOTRECOVERABLE 127
     * }
     */
    public static int ENOTRECOVERABLE() {
        return ENOTRECOVERABLE;
    }
    private static final int ENOTSOCK = (int)128L;
    /**
     * {@snippet lang=c :
     * #define ENOTSOCK 128
     * }
     */
    public static int ENOTSOCK() {
        return ENOTSOCK;
    }
    private static final int ENOTSUP = (int)129L;
    /**
     * {@snippet lang=c :
     * #define ENOTSUP 129
     * }
     */
    public static int ENOTSUP() {
        return ENOTSUP;
    }
    private static final int EOPNOTSUPP = (int)130L;
    /**
     * {@snippet lang=c :
     * #define EOPNOTSUPP 130
     * }
     */
    public static int EOPNOTSUPP() {
        return EOPNOTSUPP;
    }
    private static final int EOTHER = (int)131L;
    /**
     * {@snippet lang=c :
     * #define EOTHER 131
     * }
     */
    public static int EOTHER() {
        return EOTHER;
    }
    private static final int EOVERFLOW = (int)132L;
    /**
     * {@snippet lang=c :
     * #define EOVERFLOW 132
     * }
     */
    public static int EOVERFLOW() {
        return EOVERFLOW;
    }
    private static final int EOWNERDEAD = (int)133L;
    /**
     * {@snippet lang=c :
     * #define EOWNERDEAD 133
     * }
     */
    public static int EOWNERDEAD() {
        return EOWNERDEAD;
    }
    private static final int EPROTO = (int)134L;
    /**
     * {@snippet lang=c :
     * #define EPROTO 134
     * }
     */
    public static int EPROTO() {
        return EPROTO;
    }
    private static final int EPROTONOSUPPORT = (int)135L;
    /**
     * {@snippet lang=c :
     * #define EPROTONOSUPPORT 135
     * }
     */
    public static int EPROTONOSUPPORT() {
        return EPROTONOSUPPORT;
    }
    private static final int EPROTOTYPE = (int)136L;
    /**
     * {@snippet lang=c :
     * #define EPROTOTYPE 136
     * }
     */
    public static int EPROTOTYPE() {
        return EPROTOTYPE;
    }
    private static final int ETIME = (int)137L;
    /**
     * {@snippet lang=c :
     * #define ETIME 137
     * }
     */
    public static int ETIME() {
        return ETIME;
    }
    private static final int ETIMEDOUT = (int)138L;
    /**
     * {@snippet lang=c :
     * #define ETIMEDOUT 138
     * }
     */
    public static int ETIMEDOUT() {
        return ETIMEDOUT;
    }
    private static final int ETXTBSY = (int)139L;
    /**
     * {@snippet lang=c :
     * #define ETXTBSY 139
     * }
     */
    public static int ETXTBSY() {
        return ETXTBSY;
    }
    private static final int EWOULDBLOCK = (int)140L;
    /**
     * {@snippet lang=c :
     * #define EWOULDBLOCK 140
     * }
     */
    public static int EWOULDBLOCK() {
        return EWOULDBLOCK;
    }
    private static final int _UPPER = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _UPPER 1
     * }
     */
    public static int _UPPER() {
        return _UPPER;
    }
    private static final int _LOWER = (int)2L;
    /**
     * {@snippet lang=c :
     * #define _LOWER 2
     * }
     */
    public static int _LOWER() {
        return _LOWER;
    }
    private static final int _DIGIT = (int)4L;
    /**
     * {@snippet lang=c :
     * #define _DIGIT 4
     * }
     */
    public static int _DIGIT() {
        return _DIGIT;
    }
    private static final int _SPACE = (int)8L;
    /**
     * {@snippet lang=c :
     * #define _SPACE 8
     * }
     */
    public static int _SPACE() {
        return _SPACE;
    }
    private static final int _PUNCT = (int)16L;
    /**
     * {@snippet lang=c :
     * #define _PUNCT 16
     * }
     */
    public static int _PUNCT() {
        return _PUNCT;
    }
    private static final int _CONTROL = (int)32L;
    /**
     * {@snippet lang=c :
     * #define _CONTROL 32
     * }
     */
    public static int _CONTROL() {
        return _CONTROL;
    }
    private static final int _BLANK = (int)64L;
    /**
     * {@snippet lang=c :
     * #define _BLANK 64
     * }
     */
    public static int _BLANK() {
        return _BLANK;
    }
    private static final int _HEX = (int)128L;
    /**
     * {@snippet lang=c :
     * #define _HEX 128
     * }
     */
    public static int _HEX() {
        return _HEX;
    }
    private static final int _LEADBYTE = (int)32768L;
    /**
     * {@snippet lang=c :
     * #define _LEADBYTE 32768
     * }
     */
    public static int _LEADBYTE() {
        return _LEADBYTE;
    }
    private static final int _S_IFMT = (int)61440L;
    /**
     * {@snippet lang=c :
     * #define _S_IFMT 61440
     * }
     */
    public static int _S_IFMT() {
        return _S_IFMT;
    }
    private static final int _S_IFDIR = (int)16384L;
    /**
     * {@snippet lang=c :
     * #define _S_IFDIR 16384
     * }
     */
    public static int _S_IFDIR() {
        return _S_IFDIR;
    }
    private static final int _S_IFCHR = (int)8192L;
    /**
     * {@snippet lang=c :
     * #define _S_IFCHR 8192
     * }
     */
    public static int _S_IFCHR() {
        return _S_IFCHR;
    }
    private static final int _S_IFIFO = (int)4096L;
    /**
     * {@snippet lang=c :
     * #define _S_IFIFO 4096
     * }
     */
    public static int _S_IFIFO() {
        return _S_IFIFO;
    }
    private static final int _S_IFREG = (int)32768L;
    /**
     * {@snippet lang=c :
     * #define _S_IFREG 32768
     * }
     */
    public static int _S_IFREG() {
        return _S_IFREG;
    }
    private static final int _S_IREAD = (int)256L;
    /**
     * {@snippet lang=c :
     * #define _S_IREAD 256
     * }
     */
    public static int _S_IREAD() {
        return _S_IREAD;
    }
    private static final int _S_IWRITE = (int)128L;
    /**
     * {@snippet lang=c :
     * #define _S_IWRITE 128
     * }
     */
    public static int _S_IWRITE() {
        return _S_IWRITE;
    }
    private static final int _S_IEXEC = (int)64L;
    /**
     * {@snippet lang=c :
     * #define _S_IEXEC 64
     * }
     */
    public static int _S_IEXEC() {
        return _S_IEXEC;
    }
    private static final int WCHAR_MIN = (int)0L;
    /**
     * {@snippet lang=c :
     * #define WCHAR_MIN 0
     * }
     */
    public static int WCHAR_MIN() {
        return WCHAR_MIN;
    }
    private static final int WCHAR_MAX = (int)65535L;
    /**
     * {@snippet lang=c :
     * #define WCHAR_MAX 65535
     * }
     */
    public static int WCHAR_MAX() {
        return WCHAR_MAX;
    }
    private static final int WINT_MIN = (int)0L;
    /**
     * {@snippet lang=c :
     * #define WINT_MIN 0
     * }
     */
    public static int WINT_MIN() {
        return WINT_MIN;
    }
    private static final int WINT_MAX = (int)65535L;
    /**
     * {@snippet lang=c :
     * #define WINT_MAX 65535
     * }
     */
    public static int WINT_MAX() {
        return WINT_MAX;
    }
    private static final int CHAR_BIT = (int)8L;
    /**
     * {@snippet lang=c :
     * #define CHAR_BIT 8
     * }
     */
    public static int CHAR_BIT() {
        return CHAR_BIT;
    }
    private static final int SCHAR_MAX = (int)127L;
    /**
     * {@snippet lang=c :
     * #define SCHAR_MAX 127
     * }
     */
    public static int SCHAR_MAX() {
        return SCHAR_MAX;
    }
    private static final int UCHAR_MAX = (int)255L;
    /**
     * {@snippet lang=c :
     * #define UCHAR_MAX 255
     * }
     */
    public static int UCHAR_MAX() {
        return UCHAR_MAX;
    }
    private static final int MB_LEN_MAX = (int)5L;
    /**
     * {@snippet lang=c :
     * #define MB_LEN_MAX 5
     * }
     */
    public static int MB_LEN_MAX() {
        return MB_LEN_MAX;
    }
    private static final int SHRT_MAX = (int)32767L;
    /**
     * {@snippet lang=c :
     * #define SHRT_MAX 32767
     * }
     */
    public static int SHRT_MAX() {
        return SHRT_MAX;
    }
    private static final int USHRT_MAX = (int)65535L;
    /**
     * {@snippet lang=c :
     * #define USHRT_MAX 65535
     * }
     */
    public static int USHRT_MAX() {
        return USHRT_MAX;
    }
    private static final int INT_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define INT_MAX 2147483647
     * }
     */
    public static int INT_MAX() {
        return INT_MAX;
    }
    private static final int HAVE_LONG_LONG = (int)1L;
    /**
     * {@snippet lang=c :
     * #define HAVE_LONG_LONG 1
     * }
     */
    public static int HAVE_LONG_LONG() {
        return HAVE_LONG_LONG;
    }
    private static final int PYLONG_BITS_IN_DIGIT = (int)30L;
    /**
     * {@snippet lang=c :
     * #define PYLONG_BITS_IN_DIGIT 30
     * }
     */
    public static int PYLONG_BITS_IN_DIGIT() {
        return PYLONG_BITS_IN_DIGIT;
    }
    private static final int _DOMAIN = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _DOMAIN 1
     * }
     */
    public static int _DOMAIN() {
        return _DOMAIN;
    }
    private static final int _SING = (int)2L;
    /**
     * {@snippet lang=c :
     * #define _SING 2
     * }
     */
    public static int _SING() {
        return _SING;
    }
    private static final int _OVERFLOW = (int)3L;
    /**
     * {@snippet lang=c :
     * #define _OVERFLOW 3
     * }
     */
    public static int _OVERFLOW() {
        return _OVERFLOW;
    }
    private static final int _UNDERFLOW = (int)4L;
    /**
     * {@snippet lang=c :
     * #define _UNDERFLOW 4
     * }
     */
    public static int _UNDERFLOW() {
        return _UNDERFLOW;
    }
    private static final int _TLOSS = (int)5L;
    /**
     * {@snippet lang=c :
     * #define _TLOSS 5
     * }
     */
    public static int _TLOSS() {
        return _TLOSS;
    }
    private static final int _PLOSS = (int)6L;
    /**
     * {@snippet lang=c :
     * #define _PLOSS 6
     * }
     */
    public static int _PLOSS() {
        return _PLOSS;
    }
    private static final int _INFCODE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _INFCODE 1
     * }
     */
    public static int _INFCODE() {
        return _INFCODE;
    }
    private static final int _NANCODE = (int)2L;
    /**
     * {@snippet lang=c :
     * #define _NANCODE 2
     * }
     */
    public static int _NANCODE() {
        return _NANCODE;
    }
    private static final int FP_ZERO = (int)0L;
    /**
     * {@snippet lang=c :
     * #define FP_ZERO 0
     * }
     */
    public static int FP_ZERO() {
        return FP_ZERO;
    }
    private static final int _C2 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _C2 1
     * }
     */
    public static int _C2() {
        return _C2;
    }
    private static final int FP_ILOGBNAN = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define FP_ILOGBNAN 2147483647
     * }
     */
    public static int FP_ILOGBNAN() {
        return FP_ILOGBNAN;
    }
    private static final int MATH_ERRNO = (int)1L;
    /**
     * {@snippet lang=c :
     * #define MATH_ERRNO 1
     * }
     */
    public static int MATH_ERRNO() {
        return MATH_ERRNO;
    }
    private static final int MATH_ERREXCEPT = (int)2L;
    /**
     * {@snippet lang=c :
     * #define MATH_ERREXCEPT 2
     * }
     */
    public static int MATH_ERREXCEPT() {
        return MATH_ERREXCEPT;
    }
    private static final int _FE_DIVBYZERO = (int)4L;
    /**
     * {@snippet lang=c :
     * #define _FE_DIVBYZERO 4
     * }
     */
    public static int _FE_DIVBYZERO() {
        return _FE_DIVBYZERO;
    }
    private static final int _FE_INEXACT = (int)32L;
    /**
     * {@snippet lang=c :
     * #define _FE_INEXACT 32
     * }
     */
    public static int _FE_INEXACT() {
        return _FE_INEXACT;
    }
    private static final int _FE_INVALID = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _FE_INVALID 1
     * }
     */
    public static int _FE_INVALID() {
        return _FE_INVALID;
    }
    private static final int _FE_OVERFLOW = (int)8L;
    /**
     * {@snippet lang=c :
     * #define _FE_OVERFLOW 8
     * }
     */
    public static int _FE_OVERFLOW() {
        return _FE_OVERFLOW;
    }
    private static final int _FE_UNDERFLOW = (int)16L;
    /**
     * {@snippet lang=c :
     * #define _FE_UNDERFLOW 16
     * }
     */
    public static int _FE_UNDERFLOW() {
        return _FE_UNDERFLOW;
    }
    private static final int _D0_C = (int)3L;
    /**
     * {@snippet lang=c :
     * #define _D0_C 3
     * }
     */
    public static int _D0_C() {
        return _D0_C;
    }
    private static final int _D1_C = (int)2L;
    /**
     * {@snippet lang=c :
     * #define _D1_C 2
     * }
     */
    public static int _D1_C() {
        return _D1_C;
    }
    private static final int _D2_C = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _D2_C 1
     * }
     */
    public static int _D2_C() {
        return _D2_C;
    }
    private static final int _D3_C = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _D3_C 0
     * }
     */
    public static int _D3_C() {
        return _D3_C;
    }
    private static final int _DBIAS = (int)1022L;
    /**
     * {@snippet lang=c :
     * #define _DBIAS 1022
     * }
     */
    public static int _DBIAS() {
        return _DBIAS;
    }
    private static final int _DOFF = (int)4L;
    /**
     * {@snippet lang=c :
     * #define _DOFF 4
     * }
     */
    public static int _DOFF() {
        return _DOFF;
    }
    private static final int _F0_C = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _F0_C 1
     * }
     */
    public static int _F0_C() {
        return _F0_C;
    }
    private static final int _F1_C = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _F1_C 0
     * }
     */
    public static int _F1_C() {
        return _F1_C;
    }
    private static final int _FBIAS = (int)126L;
    /**
     * {@snippet lang=c :
     * #define _FBIAS 126
     * }
     */
    public static int _FBIAS() {
        return _FBIAS;
    }
    private static final int _FOFF = (int)7L;
    /**
     * {@snippet lang=c :
     * #define _FOFF 7
     * }
     */
    public static int _FOFF() {
        return _FOFF;
    }
    private static final int _FRND = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _FRND 1
     * }
     */
    public static int _FRND() {
        return _FRND;
    }
    private static final int _L0_C = (int)3L;
    /**
     * {@snippet lang=c :
     * #define _L0_C 3
     * }
     */
    public static int _L0_C() {
        return _L0_C;
    }
    private static final int _L1_C = (int)2L;
    /**
     * {@snippet lang=c :
     * #define _L1_C 2
     * }
     */
    public static int _L1_C() {
        return _L1_C;
    }
    private static final int _L2_C = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _L2_C 1
     * }
     */
    public static int _L2_C() {
        return _L2_C;
    }
    private static final int _L3_C = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _L3_C 0
     * }
     */
    public static int _L3_C() {
        return _L3_C;
    }
    private static final int _LBIAS = (int)1022L;
    /**
     * {@snippet lang=c :
     * #define _LBIAS 1022
     * }
     */
    public static int _LBIAS() {
        return _LBIAS;
    }
    private static final int _LOFF = (int)4L;
    /**
     * {@snippet lang=c :
     * #define _LOFF 4
     * }
     */
    public static int _LOFF() {
        return _LOFF;
    }
    private static final int _FP_LT = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _FP_LT 1
     * }
     */
    public static int _FP_LT() {
        return _FP_LT;
    }
    private static final int _FP_EQ = (int)2L;
    /**
     * {@snippet lang=c :
     * #define _FP_EQ 2
     * }
     */
    public static int _FP_EQ() {
        return _FP_EQ;
    }
    private static final int _FP_GT = (int)4L;
    /**
     * {@snippet lang=c :
     * #define _FP_GT 4
     * }
     */
    public static int _FP_GT() {
        return _FP_GT;
    }
    private static final int TIME_UTC = (int)1L;
    /**
     * {@snippet lang=c :
     * #define TIME_UTC 1
     * }
     */
    public static int TIME_UTC() {
        return TIME_UTC;
    }
    private static final int S_IFLNK = (int)40960L;
    /**
     * {@snippet lang=c :
     * #define S_IFLNK 40960
     * }
     */
    public static int S_IFLNK() {
        return S_IFLNK;
    }
    private static final int PY_BIG_ENDIAN = (int)0L;
    /**
     * {@snippet lang=c :
     * #define PY_BIG_ENDIAN 0
     * }
     */
    public static int PY_BIG_ENDIAN() {
        return PY_BIG_ENDIAN;
    }
    private static final int PY_LITTLE_ENDIAN = (int)1L;
    /**
     * {@snippet lang=c :
     * #define PY_LITTLE_ENDIAN 1
     * }
     */
    public static int PY_LITTLE_ENDIAN() {
        return PY_LITTLE_ENDIAN;
    }
    private static final int PyBUF_MAX_NDIM = (int)64L;
    /**
     * {@snippet lang=c :
     * #define PyBUF_MAX_NDIM 64
     * }
     */
    public static int PyBUF_MAX_NDIM() {
        return PyBUF_MAX_NDIM;
    }
    private static final int PyBUF_SIMPLE = (int)0L;
    /**
     * {@snippet lang=c :
     * #define PyBUF_SIMPLE 0
     * }
     */
    public static int PyBUF_SIMPLE() {
        return PyBUF_SIMPLE;
    }
    private static final int PyBUF_WRITABLE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define PyBUF_WRITABLE 1
     * }
     */
    public static int PyBUF_WRITABLE() {
        return PyBUF_WRITABLE;
    }
    private static final int PyBUF_FORMAT = (int)4L;
    /**
     * {@snippet lang=c :
     * #define PyBUF_FORMAT 4
     * }
     */
    public static int PyBUF_FORMAT() {
        return PyBUF_FORMAT;
    }
    private static final int PyBUF_ND = (int)8L;
    /**
     * {@snippet lang=c :
     * #define PyBUF_ND 8
     * }
     */
    public static int PyBUF_ND() {
        return PyBUF_ND;
    }
    private static final int PyBUF_READ = (int)256L;
    /**
     * {@snippet lang=c :
     * #define PyBUF_READ 256
     * }
     */
    public static int PyBUF_READ() {
        return PyBUF_READ;
    }
    private static final int PyBUF_WRITE = (int)512L;
    /**
     * {@snippet lang=c :
     * #define PyBUF_WRITE 512
     * }
     */
    public static int PyBUF_WRITE() {
        return PyBUF_WRITE;
    }
    private static final int Py_PRINT_RAW = (int)1L;
    /**
     * {@snippet lang=c :
     * #define Py_PRINT_RAW 1
     * }
     */
    public static int Py_PRINT_RAW() {
        return Py_PRINT_RAW;
    }
    private static final int Py_TPFLAGS_HAVE_STACKLESS_EXTENSION = (int)0L;
    /**
     * {@snippet lang=c :
     * #define Py_TPFLAGS_HAVE_STACKLESS_EXTENSION 0
     * }
     */
    public static int Py_TPFLAGS_HAVE_STACKLESS_EXTENSION() {
        return Py_TPFLAGS_HAVE_STACKLESS_EXTENSION;
    }
    private static final int Py_LT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define Py_LT 0
     * }
     */
    public static int Py_LT() {
        return Py_LT;
    }
    private static final int Py_LE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define Py_LE 1
     * }
     */
    public static int Py_LE() {
        return Py_LE;
    }
    private static final int Py_EQ = (int)2L;
    /**
     * {@snippet lang=c :
     * #define Py_EQ 2
     * }
     */
    public static int Py_EQ() {
        return Py_EQ;
    }
    private static final int Py_NE = (int)3L;
    /**
     * {@snippet lang=c :
     * #define Py_NE 3
     * }
     */
    public static int Py_NE() {
        return Py_NE;
    }
    private static final int Py_GT = (int)4L;
    /**
     * {@snippet lang=c :
     * #define Py_GT 4
     * }
     */
    public static int Py_GT() {
        return Py_GT;
    }
    private static final int Py_GE = (int)5L;
    /**
     * {@snippet lang=c :
     * #define Py_GE 5
     * }
     */
    public static int Py_GE() {
        return Py_GE;
    }
    private static final int Py_bf_getbuffer = (int)1L;
    /**
     * {@snippet lang=c :
     * #define Py_bf_getbuffer 1
     * }
     */
    public static int Py_bf_getbuffer() {
        return Py_bf_getbuffer;
    }
    private static final int Py_bf_releasebuffer = (int)2L;
    /**
     * {@snippet lang=c :
     * #define Py_bf_releasebuffer 2
     * }
     */
    public static int Py_bf_releasebuffer() {
        return Py_bf_releasebuffer;
    }
    private static final int Py_mp_ass_subscript = (int)3L;
    /**
     * {@snippet lang=c :
     * #define Py_mp_ass_subscript 3
     * }
     */
    public static int Py_mp_ass_subscript() {
        return Py_mp_ass_subscript;
    }
    private static final int Py_mp_length = (int)4L;
    /**
     * {@snippet lang=c :
     * #define Py_mp_length 4
     * }
     */
    public static int Py_mp_length() {
        return Py_mp_length;
    }
    private static final int Py_mp_subscript = (int)5L;
    /**
     * {@snippet lang=c :
     * #define Py_mp_subscript 5
     * }
     */
    public static int Py_mp_subscript() {
        return Py_mp_subscript;
    }
    private static final int Py_nb_absolute = (int)6L;
    /**
     * {@snippet lang=c :
     * #define Py_nb_absolute 6
     * }
     */
    public static int Py_nb_absolute() {
        return Py_nb_absolute;
    }
    private static final int Py_nb_add = (int)7L;
    /**
     * {@snippet lang=c :
     * #define Py_nb_add 7
     * }
     */
    public static int Py_nb_add() {
        return Py_nb_add;
    }
    private static final int Py_nb_and = (int)8L;
    /**
     * {@snippet lang=c :
     * #define Py_nb_and 8
     * }
     */
    public static int Py_nb_and() {
        return Py_nb_and;
    }
    private static final int Py_nb_bool = (int)9L;
    /**
     * {@snippet lang=c :
     * #define Py_nb_bool 9
     * }
     */
    public static int Py_nb_bool() {
        return Py_nb_bool;
    }
    private static final int Py_nb_divmod = (int)10L;
    /**
     * {@snippet lang=c :
     * #define Py_nb_divmod 10
     * }
     */
    public static int Py_nb_divmod() {
        return Py_nb_divmod;
    }
    private static final int Py_nb_float = (int)11L;
    /**
     * {@snippet lang=c :
     * #define Py_nb_float 11
     * }
     */
    public static int Py_nb_float() {
        return Py_nb_float;
    }
    private static final int Py_nb_floor_divide = (int)12L;
    /**
     * {@snippet lang=c :
     * #define Py_nb_floor_divide 12
     * }
     */
    public static int Py_nb_floor_divide() {
        return Py_nb_floor_divide;
    }
    private static final int Py_nb_index = (int)13L;
    /**
     * {@snippet lang=c :
     * #define Py_nb_index 13
     * }
     */
    public static int Py_nb_index() {
        return Py_nb_index;
    }
    private static final int Py_nb_inplace_add = (int)14L;
    /**
     * {@snippet lang=c :
     * #define Py_nb_inplace_add 14
     * }
     */
    public static int Py_nb_inplace_add() {
        return Py_nb_inplace_add;
    }
    private static final int Py_nb_inplace_and = (int)15L;
    /**
     * {@snippet lang=c :
     * #define Py_nb_inplace_and 15
     * }
     */
    public static int Py_nb_inplace_and() {
        return Py_nb_inplace_and;
    }
    private static final int Py_nb_inplace_floor_divide = (int)16L;
    /**
     * {@snippet lang=c :
     * #define Py_nb_inplace_floor_divide 16
     * }
     */
    public static int Py_nb_inplace_floor_divide() {
        return Py_nb_inplace_floor_divide;
    }
    private static final int Py_nb_inplace_lshift = (int)17L;
    /**
     * {@snippet lang=c :
     * #define Py_nb_inplace_lshift 17
     * }
     */
    public static int Py_nb_inplace_lshift() {
        return Py_nb_inplace_lshift;
    }
    private static final int Py_nb_inplace_multiply = (int)18L;
    /**
     * {@snippet lang=c :
     * #define Py_nb_inplace_multiply 18
     * }
     */
    public static int Py_nb_inplace_multiply() {
        return Py_nb_inplace_multiply;
    }
    private static final int Py_nb_inplace_or = (int)19L;
    /**
     * {@snippet lang=c :
     * #define Py_nb_inplace_or 19
     * }
     */
    public static int Py_nb_inplace_or() {
        return Py_nb_inplace_or;
    }
    private static final int Py_nb_inplace_power = (int)20L;
    /**
     * {@snippet lang=c :
     * #define Py_nb_inplace_power 20
     * }
     */
    public static int Py_nb_inplace_power() {
        return Py_nb_inplace_power;
    }
    private static final int Py_nb_inplace_remainder = (int)21L;
    /**
     * {@snippet lang=c :
     * #define Py_nb_inplace_remainder 21
     * }
     */
    public static int Py_nb_inplace_remainder() {
        return Py_nb_inplace_remainder;
    }
    private static final int Py_nb_inplace_rshift = (int)22L;
    /**
     * {@snippet lang=c :
     * #define Py_nb_inplace_rshift 22
     * }
     */
    public static int Py_nb_inplace_rshift() {
        return Py_nb_inplace_rshift;
    }
    private static final int Py_nb_inplace_subtract = (int)23L;
    /**
     * {@snippet lang=c :
     * #define Py_nb_inplace_subtract 23
     * }
     */
    public static int Py_nb_inplace_subtract() {
        return Py_nb_inplace_subtract;
    }
    private static final int Py_nb_inplace_true_divide = (int)24L;
    /**
     * {@snippet lang=c :
     * #define Py_nb_inplace_true_divide 24
     * }
     */
    public static int Py_nb_inplace_true_divide() {
        return Py_nb_inplace_true_divide;
    }
    private static final int Py_nb_inplace_xor = (int)25L;
    /**
     * {@snippet lang=c :
     * #define Py_nb_inplace_xor 25
     * }
     */
    public static int Py_nb_inplace_xor() {
        return Py_nb_inplace_xor;
    }
    private static final int Py_nb_int = (int)26L;
    /**
     * {@snippet lang=c :
     * #define Py_nb_int 26
     * }
     */
    public static int Py_nb_int() {
        return Py_nb_int;
    }
    private static final int Py_nb_invert = (int)27L;
    /**
     * {@snippet lang=c :
     * #define Py_nb_invert 27
     * }
     */
    public static int Py_nb_invert() {
        return Py_nb_invert;
    }
    private static final int Py_nb_lshift = (int)28L;
    /**
     * {@snippet lang=c :
     * #define Py_nb_lshift 28
     * }
     */
    public static int Py_nb_lshift() {
        return Py_nb_lshift;
    }
    private static final int Py_nb_multiply = (int)29L;
    /**
     * {@snippet lang=c :
     * #define Py_nb_multiply 29
     * }
     */
    public static int Py_nb_multiply() {
        return Py_nb_multiply;
    }
    private static final int Py_nb_negative = (int)30L;
    /**
     * {@snippet lang=c :
     * #define Py_nb_negative 30
     * }
     */
    public static int Py_nb_negative() {
        return Py_nb_negative;
    }
    private static final int Py_nb_or = (int)31L;
    /**
     * {@snippet lang=c :
     * #define Py_nb_or 31
     * }
     */
    public static int Py_nb_or() {
        return Py_nb_or;
    }
    private static final int Py_nb_positive = (int)32L;
    /**
     * {@snippet lang=c :
     * #define Py_nb_positive 32
     * }
     */
    public static int Py_nb_positive() {
        return Py_nb_positive;
    }
    private static final int Py_nb_power = (int)33L;
    /**
     * {@snippet lang=c :
     * #define Py_nb_power 33
     * }
     */
    public static int Py_nb_power() {
        return Py_nb_power;
    }
    private static final int Py_nb_remainder = (int)34L;
    /**
     * {@snippet lang=c :
     * #define Py_nb_remainder 34
     * }
     */
    public static int Py_nb_remainder() {
        return Py_nb_remainder;
    }
    private static final int Py_nb_rshift = (int)35L;
    /**
     * {@snippet lang=c :
     * #define Py_nb_rshift 35
     * }
     */
    public static int Py_nb_rshift() {
        return Py_nb_rshift;
    }
    private static final int Py_nb_subtract = (int)36L;
    /**
     * {@snippet lang=c :
     * #define Py_nb_subtract 36
     * }
     */
    public static int Py_nb_subtract() {
        return Py_nb_subtract;
    }
    private static final int Py_nb_true_divide = (int)37L;
    /**
     * {@snippet lang=c :
     * #define Py_nb_true_divide 37
     * }
     */
    public static int Py_nb_true_divide() {
        return Py_nb_true_divide;
    }
    private static final int Py_nb_xor = (int)38L;
    /**
     * {@snippet lang=c :
     * #define Py_nb_xor 38
     * }
     */
    public static int Py_nb_xor() {
        return Py_nb_xor;
    }
    private static final int Py_sq_ass_item = (int)39L;
    /**
     * {@snippet lang=c :
     * #define Py_sq_ass_item 39
     * }
     */
    public static int Py_sq_ass_item() {
        return Py_sq_ass_item;
    }
    private static final int Py_sq_concat = (int)40L;
    /**
     * {@snippet lang=c :
     * #define Py_sq_concat 40
     * }
     */
    public static int Py_sq_concat() {
        return Py_sq_concat;
    }
    private static final int Py_sq_contains = (int)41L;
    /**
     * {@snippet lang=c :
     * #define Py_sq_contains 41
     * }
     */
    public static int Py_sq_contains() {
        return Py_sq_contains;
    }
    private static final int Py_sq_inplace_concat = (int)42L;
    /**
     * {@snippet lang=c :
     * #define Py_sq_inplace_concat 42
     * }
     */
    public static int Py_sq_inplace_concat() {
        return Py_sq_inplace_concat;
    }
    private static final int Py_sq_inplace_repeat = (int)43L;
    /**
     * {@snippet lang=c :
     * #define Py_sq_inplace_repeat 43
     * }
     */
    public static int Py_sq_inplace_repeat() {
        return Py_sq_inplace_repeat;
    }
    private static final int Py_sq_item = (int)44L;
    /**
     * {@snippet lang=c :
     * #define Py_sq_item 44
     * }
     */
    public static int Py_sq_item() {
        return Py_sq_item;
    }
    private static final int Py_sq_length = (int)45L;
    /**
     * {@snippet lang=c :
     * #define Py_sq_length 45
     * }
     */
    public static int Py_sq_length() {
        return Py_sq_length;
    }
    private static final int Py_sq_repeat = (int)46L;
    /**
     * {@snippet lang=c :
     * #define Py_sq_repeat 46
     * }
     */
    public static int Py_sq_repeat() {
        return Py_sq_repeat;
    }
    private static final int Py_tp_alloc = (int)47L;
    /**
     * {@snippet lang=c :
     * #define Py_tp_alloc 47
     * }
     */
    public static int Py_tp_alloc() {
        return Py_tp_alloc;
    }
    private static final int Py_tp_base = (int)48L;
    /**
     * {@snippet lang=c :
     * #define Py_tp_base 48
     * }
     */
    public static int Py_tp_base() {
        return Py_tp_base;
    }
    private static final int Py_tp_bases = (int)49L;
    /**
     * {@snippet lang=c :
     * #define Py_tp_bases 49
     * }
     */
    public static int Py_tp_bases() {
        return Py_tp_bases;
    }
    private static final int Py_tp_call = (int)50L;
    /**
     * {@snippet lang=c :
     * #define Py_tp_call 50
     * }
     */
    public static int Py_tp_call() {
        return Py_tp_call;
    }
    private static final int Py_tp_clear = (int)51L;
    /**
     * {@snippet lang=c :
     * #define Py_tp_clear 51
     * }
     */
    public static int Py_tp_clear() {
        return Py_tp_clear;
    }
    private static final int Py_tp_dealloc = (int)52L;
    /**
     * {@snippet lang=c :
     * #define Py_tp_dealloc 52
     * }
     */
    public static int Py_tp_dealloc() {
        return Py_tp_dealloc;
    }
    private static final int Py_tp_del = (int)53L;
    /**
     * {@snippet lang=c :
     * #define Py_tp_del 53
     * }
     */
    public static int Py_tp_del() {
        return Py_tp_del;
    }
    private static final int Py_tp_descr_get = (int)54L;
    /**
     * {@snippet lang=c :
     * #define Py_tp_descr_get 54
     * }
     */
    public static int Py_tp_descr_get() {
        return Py_tp_descr_get;
    }
    private static final int Py_tp_descr_set = (int)55L;
    /**
     * {@snippet lang=c :
     * #define Py_tp_descr_set 55
     * }
     */
    public static int Py_tp_descr_set() {
        return Py_tp_descr_set;
    }
    private static final int Py_tp_doc = (int)56L;
    /**
     * {@snippet lang=c :
     * #define Py_tp_doc 56
     * }
     */
    public static int Py_tp_doc() {
        return Py_tp_doc;
    }
    private static final int Py_tp_getattr = (int)57L;
    /**
     * {@snippet lang=c :
     * #define Py_tp_getattr 57
     * }
     */
    public static int Py_tp_getattr() {
        return Py_tp_getattr;
    }
    private static final int Py_tp_getattro = (int)58L;
    /**
     * {@snippet lang=c :
     * #define Py_tp_getattro 58
     * }
     */
    public static int Py_tp_getattro() {
        return Py_tp_getattro;
    }
    private static final int Py_tp_hash = (int)59L;
    /**
     * {@snippet lang=c :
     * #define Py_tp_hash 59
     * }
     */
    public static int Py_tp_hash() {
        return Py_tp_hash;
    }
    private static final int Py_tp_init = (int)60L;
    /**
     * {@snippet lang=c :
     * #define Py_tp_init 60
     * }
     */
    public static int Py_tp_init() {
        return Py_tp_init;
    }
    private static final int Py_tp_is_gc = (int)61L;
    /**
     * {@snippet lang=c :
     * #define Py_tp_is_gc 61
     * }
     */
    public static int Py_tp_is_gc() {
        return Py_tp_is_gc;
    }
    private static final int Py_tp_iter = (int)62L;
    /**
     * {@snippet lang=c :
     * #define Py_tp_iter 62
     * }
     */
    public static int Py_tp_iter() {
        return Py_tp_iter;
    }
    private static final int Py_tp_iternext = (int)63L;
    /**
     * {@snippet lang=c :
     * #define Py_tp_iternext 63
     * }
     */
    public static int Py_tp_iternext() {
        return Py_tp_iternext;
    }
    private static final int Py_tp_methods = (int)64L;
    /**
     * {@snippet lang=c :
     * #define Py_tp_methods 64
     * }
     */
    public static int Py_tp_methods() {
        return Py_tp_methods;
    }
    private static final int Py_tp_new = (int)65L;
    /**
     * {@snippet lang=c :
     * #define Py_tp_new 65
     * }
     */
    public static int Py_tp_new() {
        return Py_tp_new;
    }
    private static final int Py_tp_repr = (int)66L;
    /**
     * {@snippet lang=c :
     * #define Py_tp_repr 66
     * }
     */
    public static int Py_tp_repr() {
        return Py_tp_repr;
    }
    private static final int Py_tp_richcompare = (int)67L;
    /**
     * {@snippet lang=c :
     * #define Py_tp_richcompare 67
     * }
     */
    public static int Py_tp_richcompare() {
        return Py_tp_richcompare;
    }
    private static final int Py_tp_setattr = (int)68L;
    /**
     * {@snippet lang=c :
     * #define Py_tp_setattr 68
     * }
     */
    public static int Py_tp_setattr() {
        return Py_tp_setattr;
    }
    private static final int Py_tp_setattro = (int)69L;
    /**
     * {@snippet lang=c :
     * #define Py_tp_setattro 69
     * }
     */
    public static int Py_tp_setattro() {
        return Py_tp_setattro;
    }
    private static final int Py_tp_str = (int)70L;
    /**
     * {@snippet lang=c :
     * #define Py_tp_str 70
     * }
     */
    public static int Py_tp_str() {
        return Py_tp_str;
    }
    private static final int Py_tp_traverse = (int)71L;
    /**
     * {@snippet lang=c :
     * #define Py_tp_traverse 71
     * }
     */
    public static int Py_tp_traverse() {
        return Py_tp_traverse;
    }
    private static final int Py_tp_members = (int)72L;
    /**
     * {@snippet lang=c :
     * #define Py_tp_members 72
     * }
     */
    public static int Py_tp_members() {
        return Py_tp_members;
    }
    private static final int Py_tp_getset = (int)73L;
    /**
     * {@snippet lang=c :
     * #define Py_tp_getset 73
     * }
     */
    public static int Py_tp_getset() {
        return Py_tp_getset;
    }
    private static final int Py_tp_free = (int)74L;
    /**
     * {@snippet lang=c :
     * #define Py_tp_free 74
     * }
     */
    public static int Py_tp_free() {
        return Py_tp_free;
    }
    private static final int Py_nb_matrix_multiply = (int)75L;
    /**
     * {@snippet lang=c :
     * #define Py_nb_matrix_multiply 75
     * }
     */
    public static int Py_nb_matrix_multiply() {
        return Py_nb_matrix_multiply;
    }
    private static final int Py_nb_inplace_matrix_multiply = (int)76L;
    /**
     * {@snippet lang=c :
     * #define Py_nb_inplace_matrix_multiply 76
     * }
     */
    public static int Py_nb_inplace_matrix_multiply() {
        return Py_nb_inplace_matrix_multiply;
    }
    private static final int Py_am_await = (int)77L;
    /**
     * {@snippet lang=c :
     * #define Py_am_await 77
     * }
     */
    public static int Py_am_await() {
        return Py_am_await;
    }
    private static final int Py_am_aiter = (int)78L;
    /**
     * {@snippet lang=c :
     * #define Py_am_aiter 78
     * }
     */
    public static int Py_am_aiter() {
        return Py_am_aiter;
    }
    private static final int Py_am_anext = (int)79L;
    /**
     * {@snippet lang=c :
     * #define Py_am_anext 79
     * }
     */
    public static int Py_am_anext() {
        return Py_am_anext;
    }
    private static final int Py_tp_finalize = (int)80L;
    /**
     * {@snippet lang=c :
     * #define Py_tp_finalize 80
     * }
     */
    public static int Py_tp_finalize() {
        return Py_tp_finalize;
    }
    private static final int Py_am_send = (int)81L;
    /**
     * {@snippet lang=c :
     * #define Py_am_send 81
     * }
     */
    public static int Py_am_send() {
        return Py_am_send;
    }
    private static final int _PyHASH_BITS = (int)61L;
    /**
     * {@snippet lang=c :
     * #define _PyHASH_BITS 61
     * }
     */
    public static int _PyHASH_BITS() {
        return _PyHASH_BITS;
    }
    private static final int _PyHASH_INF = (int)314159L;
    /**
     * {@snippet lang=c :
     * #define _PyHASH_INF 314159
     * }
     */
    public static int _PyHASH_INF() {
        return _PyHASH_INF;
    }
    private static final int Py_HASH_CUTOFF = (int)0L;
    /**
     * {@snippet lang=c :
     * #define Py_HASH_CUTOFF 0
     * }
     */
    public static int Py_HASH_CUTOFF() {
        return Py_HASH_CUTOFF;
    }
    private static final int Py_HASH_EXTERNAL = (int)0L;
    /**
     * {@snippet lang=c :
     * #define Py_HASH_EXTERNAL 0
     * }
     */
    public static int Py_HASH_EXTERNAL() {
        return Py_HASH_EXTERNAL;
    }
    private static final int Py_HASH_SIPHASH24 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define Py_HASH_SIPHASH24 1
     * }
     */
    public static int Py_HASH_SIPHASH24() {
        return Py_HASH_SIPHASH24;
    }
    private static final int Py_HASH_FNV = (int)2L;
    /**
     * {@snippet lang=c :
     * #define Py_HASH_FNV 2
     * }
     */
    public static int Py_HASH_FNV() {
        return Py_HASH_FNV;
    }
    private static final int Py_HASH_SIPHASH13 = (int)3L;
    /**
     * {@snippet lang=c :
     * #define Py_HASH_SIPHASH13 3
     * }
     */
    public static int Py_HASH_SIPHASH13() {
        return Py_HASH_SIPHASH13;
    }
    private static final int __GNUC_VA_LIST = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __GNUC_VA_LIST 1
     * }
     */
    public static int __GNUC_VA_LIST() {
        return __GNUC_VA_LIST;
    }
    private static final int METH_VARARGS = (int)1L;
    /**
     * {@snippet lang=c :
     * #define METH_VARARGS 1
     * }
     */
    public static int METH_VARARGS() {
        return METH_VARARGS;
    }
    private static final int METH_KEYWORDS = (int)2L;
    /**
     * {@snippet lang=c :
     * #define METH_KEYWORDS 2
     * }
     */
    public static int METH_KEYWORDS() {
        return METH_KEYWORDS;
    }
    private static final int METH_NOARGS = (int)4L;
    /**
     * {@snippet lang=c :
     * #define METH_NOARGS 4
     * }
     */
    public static int METH_NOARGS() {
        return METH_NOARGS;
    }
    private static final int METH_O = (int)8L;
    /**
     * {@snippet lang=c :
     * #define METH_O 8
     * }
     */
    public static int METH_O() {
        return METH_O;
    }
    private static final int METH_CLASS = (int)16L;
    /**
     * {@snippet lang=c :
     * #define METH_CLASS 16
     * }
     */
    public static int METH_CLASS() {
        return METH_CLASS;
    }
    private static final int METH_STATIC = (int)32L;
    /**
     * {@snippet lang=c :
     * #define METH_STATIC 32
     * }
     */
    public static int METH_STATIC() {
        return METH_STATIC;
    }
    private static final int METH_COEXIST = (int)64L;
    /**
     * {@snippet lang=c :
     * #define METH_COEXIST 64
     * }
     */
    public static int METH_COEXIST() {
        return METH_COEXIST;
    }
    private static final int METH_FASTCALL = (int)128L;
    /**
     * {@snippet lang=c :
     * #define METH_FASTCALL 128
     * }
     */
    public static int METH_FASTCALL() {
        return METH_FASTCALL;
    }
    private static final int METH_STACKLESS = (int)0L;
    /**
     * {@snippet lang=c :
     * #define METH_STACKLESS 0
     * }
     */
    public static int METH_STACKLESS() {
        return METH_STACKLESS;
    }
    private static final int METH_METHOD = (int)512L;
    /**
     * {@snippet lang=c :
     * #define METH_METHOD 512
     * }
     */
    public static int METH_METHOD() {
        return METH_METHOD;
    }
    private static final int Py_mod_create = (int)1L;
    /**
     * {@snippet lang=c :
     * #define Py_mod_create 1
     * }
     */
    public static int Py_mod_create() {
        return Py_mod_create;
    }
    private static final int Py_mod_exec = (int)2L;
    /**
     * {@snippet lang=c :
     * #define Py_mod_exec 2
     * }
     */
    public static int Py_mod_exec() {
        return Py_mod_exec;
    }
    private static final int Py_mod_multiple_interpreters = (int)3L;
    /**
     * {@snippet lang=c :
     * #define Py_mod_multiple_interpreters 3
     * }
     */
    public static int Py_mod_multiple_interpreters() {
        return Py_mod_multiple_interpreters;
    }
    private static final int MAX_CO_EXTRA_USERS = (int)255L;
    /**
     * {@snippet lang=c :
     * #define MAX_CO_EXTRA_USERS 255
     * }
     */
    public static int MAX_CO_EXTRA_USERS() {
        return MAX_CO_EXTRA_USERS;
    }
    private static final int Py_T_SHORT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define Py_T_SHORT 0
     * }
     */
    public static int Py_T_SHORT() {
        return Py_T_SHORT;
    }
    private static final int Py_T_INT = (int)1L;
    /**
     * {@snippet lang=c :
     * #define Py_T_INT 1
     * }
     */
    public static int Py_T_INT() {
        return Py_T_INT;
    }
    private static final int Py_T_LONG = (int)2L;
    /**
     * {@snippet lang=c :
     * #define Py_T_LONG 2
     * }
     */
    public static int Py_T_LONG() {
        return Py_T_LONG;
    }
    private static final int Py_T_FLOAT = (int)3L;
    /**
     * {@snippet lang=c :
     * #define Py_T_FLOAT 3
     * }
     */
    public static int Py_T_FLOAT() {
        return Py_T_FLOAT;
    }
    private static final int Py_T_DOUBLE = (int)4L;
    /**
     * {@snippet lang=c :
     * #define Py_T_DOUBLE 4
     * }
     */
    public static int Py_T_DOUBLE() {
        return Py_T_DOUBLE;
    }
    private static final int Py_T_STRING = (int)5L;
    /**
     * {@snippet lang=c :
     * #define Py_T_STRING 5
     * }
     */
    public static int Py_T_STRING() {
        return Py_T_STRING;
    }
    private static final int _Py_T_OBJECT = (int)6L;
    /**
     * {@snippet lang=c :
     * #define _Py_T_OBJECT 6
     * }
     */
    public static int _Py_T_OBJECT() {
        return _Py_T_OBJECT;
    }
    private static final int Py_T_CHAR = (int)7L;
    /**
     * {@snippet lang=c :
     * #define Py_T_CHAR 7
     * }
     */
    public static int Py_T_CHAR() {
        return Py_T_CHAR;
    }
    private static final int Py_T_BYTE = (int)8L;
    /**
     * {@snippet lang=c :
     * #define Py_T_BYTE 8
     * }
     */
    public static int Py_T_BYTE() {
        return Py_T_BYTE;
    }
    private static final int Py_T_UBYTE = (int)9L;
    /**
     * {@snippet lang=c :
     * #define Py_T_UBYTE 9
     * }
     */
    public static int Py_T_UBYTE() {
        return Py_T_UBYTE;
    }
    private static final int Py_T_USHORT = (int)10L;
    /**
     * {@snippet lang=c :
     * #define Py_T_USHORT 10
     * }
     */
    public static int Py_T_USHORT() {
        return Py_T_USHORT;
    }
    private static final int Py_T_UINT = (int)11L;
    /**
     * {@snippet lang=c :
     * #define Py_T_UINT 11
     * }
     */
    public static int Py_T_UINT() {
        return Py_T_UINT;
    }
    private static final int Py_T_ULONG = (int)12L;
    /**
     * {@snippet lang=c :
     * #define Py_T_ULONG 12
     * }
     */
    public static int Py_T_ULONG() {
        return Py_T_ULONG;
    }
    private static final int Py_T_STRING_INPLACE = (int)13L;
    /**
     * {@snippet lang=c :
     * #define Py_T_STRING_INPLACE 13
     * }
     */
    public static int Py_T_STRING_INPLACE() {
        return Py_T_STRING_INPLACE;
    }
    private static final int Py_T_BOOL = (int)14L;
    /**
     * {@snippet lang=c :
     * #define Py_T_BOOL 14
     * }
     */
    public static int Py_T_BOOL() {
        return Py_T_BOOL;
    }
    private static final int Py_T_OBJECT_EX = (int)16L;
    /**
     * {@snippet lang=c :
     * #define Py_T_OBJECT_EX 16
     * }
     */
    public static int Py_T_OBJECT_EX() {
        return Py_T_OBJECT_EX;
    }
    private static final int Py_T_LONGLONG = (int)17L;
    /**
     * {@snippet lang=c :
     * #define Py_T_LONGLONG 17
     * }
     */
    public static int Py_T_LONGLONG() {
        return Py_T_LONGLONG;
    }
    private static final int Py_T_ULONGLONG = (int)18L;
    /**
     * {@snippet lang=c :
     * #define Py_T_ULONGLONG 18
     * }
     */
    public static int Py_T_ULONGLONG() {
        return Py_T_ULONGLONG;
    }
    private static final int Py_T_PYSSIZET = (int)19L;
    /**
     * {@snippet lang=c :
     * #define Py_T_PYSSIZET 19
     * }
     */
    public static int Py_T_PYSSIZET() {
        return Py_T_PYSSIZET;
    }
    private static final int _Py_T_NONE = (int)20L;
    /**
     * {@snippet lang=c :
     * #define _Py_T_NONE 20
     * }
     */
    public static int _Py_T_NONE() {
        return _Py_T_NONE;
    }
    private static final int Py_READONLY = (int)1L;
    /**
     * {@snippet lang=c :
     * #define Py_READONLY 1
     * }
     */
    public static int Py_READONLY() {
        return Py_READONLY;
    }
    private static final int Py_AUDIT_READ = (int)2L;
    /**
     * {@snippet lang=c :
     * #define Py_AUDIT_READ 2
     * }
     */
    public static int Py_AUDIT_READ() {
        return Py_AUDIT_READ;
    }
    private static final int _Py_WRITE_RESTRICTED = (int)4L;
    /**
     * {@snippet lang=c :
     * #define _Py_WRITE_RESTRICTED 4
     * }
     */
    public static int _Py_WRITE_RESTRICTED() {
        return _Py_WRITE_RESTRICTED;
    }
    private static final int Py_RELATIVE_OFFSET = (int)8L;
    /**
     * {@snippet lang=c :
     * #define Py_RELATIVE_OFFSET 8
     * }
     */
    public static int Py_RELATIVE_OFFSET() {
        return Py_RELATIVE_OFFSET;
    }
    private static final int WAIT_LOCK = (int)1L;
    /**
     * {@snippet lang=c :
     * #define WAIT_LOCK 1
     * }
     */
    public static int WAIT_LOCK() {
        return WAIT_LOCK;
    }
    private static final int NOWAIT_LOCK = (int)0L;
    /**
     * {@snippet lang=c :
     * #define NOWAIT_LOCK 0
     * }
     */
    public static int NOWAIT_LOCK() {
        return NOWAIT_LOCK;
    }
    private static final int Py_CLEANUP_SUPPORTED = (int)131072L;
    /**
     * {@snippet lang=c :
     * #define Py_CLEANUP_SUPPORTED 131072
     * }
     */
    public static int Py_CLEANUP_SUPPORTED() {
        return Py_CLEANUP_SUPPORTED;
    }
    private static final int PYTHON_API_VERSION = (int)1013L;
    /**
     * {@snippet lang=c :
     * #define PYTHON_API_VERSION 1013
     * }
     */
    public static int PYTHON_API_VERSION() {
        return PYTHON_API_VERSION;
    }
    private static final int PYTHON_ABI_VERSION = (int)3L;
    /**
     * {@snippet lang=c :
     * #define PYTHON_ABI_VERSION 3
     * }
     */
    public static int PYTHON_ABI_VERSION() {
        return PYTHON_ABI_VERSION;
    }
    private static final int Py_single_input = (int)256L;
    /**
     * {@snippet lang=c :
     * #define Py_single_input 256
     * }
     */
    public static int Py_single_input() {
        return Py_single_input;
    }
    private static final int Py_file_input = (int)257L;
    /**
     * {@snippet lang=c :
     * #define Py_file_input 257
     * }
     */
    public static int Py_file_input() {
        return Py_file_input;
    }
    private static final int Py_eval_input = (int)258L;
    /**
     * {@snippet lang=c :
     * #define Py_eval_input 258
     * }
     */
    public static int Py_eval_input() {
        return Py_eval_input;
    }
    private static final int Py_func_type_input = (int)345L;
    /**
     * {@snippet lang=c :
     * #define Py_func_type_input 345
     * }
     */
    public static int Py_func_type_input() {
        return Py_func_type_input;
    }
    private static final int PYOS_STACK_MARGIN = (int)2048L;
    /**
     * {@snippet lang=c :
     * #define PYOS_STACK_MARGIN 2048
     * }
     */
    public static int PYOS_STACK_MARGIN() {
        return PYOS_STACK_MARGIN;
    }
    private static final int FVC_MASK = (int)3L;
    /**
     * {@snippet lang=c :
     * #define FVC_MASK 3
     * }
     */
    public static int FVC_MASK() {
        return FVC_MASK;
    }
    private static final int FVC_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * #define FVC_NONE 0
     * }
     */
    public static int FVC_NONE() {
        return FVC_NONE;
    }
    private static final int FVC_STR = (int)1L;
    /**
     * {@snippet lang=c :
     * #define FVC_STR 1
     * }
     */
    public static int FVC_STR() {
        return FVC_STR;
    }
    private static final int FVC_REPR = (int)2L;
    /**
     * {@snippet lang=c :
     * #define FVC_REPR 2
     * }
     */
    public static int FVC_REPR() {
        return FVC_REPR;
    }
    private static final int FVC_ASCII = (int)3L;
    /**
     * {@snippet lang=c :
     * #define FVC_ASCII 3
     * }
     */
    public static int FVC_ASCII() {
        return FVC_ASCII;
    }
    private static final int FVS_MASK = (int)4L;
    /**
     * {@snippet lang=c :
     * #define FVS_MASK 4
     * }
     */
    public static int FVS_MASK() {
        return FVS_MASK;
    }
    private static final int FVS_HAVE_SPEC = (int)4L;
    /**
     * {@snippet lang=c :
     * #define FVS_HAVE_SPEC 4
     * }
     */
    public static int FVS_HAVE_SPEC() {
        return FVS_HAVE_SPEC;
    }
    private static final int Py_DTSF_SIGN = (int)1L;
    /**
     * {@snippet lang=c :
     * #define Py_DTSF_SIGN 1
     * }
     */
    public static int Py_DTSF_SIGN() {
        return Py_DTSF_SIGN;
    }
    private static final int Py_DTSF_ADD_DOT_0 = (int)2L;
    /**
     * {@snippet lang=c :
     * #define Py_DTSF_ADD_DOT_0 2
     * }
     */
    public static int Py_DTSF_ADD_DOT_0() {
        return Py_DTSF_ADD_DOT_0;
    }
    private static final int Py_DTSF_ALT = (int)4L;
    /**
     * {@snippet lang=c :
     * #define Py_DTSF_ALT 4
     * }
     */
    public static int Py_DTSF_ALT() {
        return Py_DTSF_ALT;
    }
    private static final int Py_DTSF_NO_NEG_0 = (int)8L;
    /**
     * {@snippet lang=c :
     * #define Py_DTSF_NO_NEG_0 8
     * }
     */
    public static int Py_DTSF_NO_NEG_0() {
        return Py_DTSF_NO_NEG_0;
    }
    private static final int Py_DTST_FINITE = (int)0L;
    /**
     * {@snippet lang=c :
     * #define Py_DTST_FINITE 0
     * }
     */
    public static int Py_DTST_FINITE() {
        return Py_DTST_FINITE;
    }
    private static final int Py_DTST_INFINITE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define Py_DTST_INFINITE 1
     * }
     */
    public static int Py_DTST_INFINITE() {
        return Py_DTST_INFINITE;
    }
    private static final int Py_DTST_NAN = (int)2L;
    /**
     * {@snippet lang=c :
     * #define Py_DTST_NAN 2
     * }
     */
    public static int Py_DTST_NAN() {
        return Py_DTST_NAN;
    }
    /**
     * {@snippet lang=c :
     * typedef unsigned long long uintptr_t
     * }
     */
    public static final OfLong uintptr_t = Python_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef char *va_list
     * }
     */
    public static final AddressLayout va_list = Python_h.C_POINTER;

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * void __va_start(va_list *, ...)
     * }
     */
    public static class __va_start {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.ofVoid(
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("__va_start");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private __va_start(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * void __va_start(va_list *, ...)
         * }
         */
        public static __va_start makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new __va_start(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public void apply(MemorySegment x0, Object... x1) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("__va_start", x0, x1);
                }
                spreader.invokeExact(x0, x1);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }
    /**
     * {@snippet lang=c :
     * typedef unsigned long long size_t
     * }
     */
    public static final OfLong size_t = Python_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef long long ptrdiff_t
     * }
     */
    public static final OfLong ptrdiff_t = Python_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef long long intptr_t
     * }
     */
    public static final OfLong intptr_t = Python_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef _Bool __vcrt_bool
     * }
     */
    public static final OfBoolean __vcrt_bool = Python_h.C_BOOL;
    /**
     * {@snippet lang=c :
     * typedef unsigned short wchar_t
     * }
     */
    public static final OfShort wchar_t = Python_h.C_SHORT;

    private static class __security_init_cookie {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("__security_init_cookie");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __security_init_cookie()
     * }
     */
    public static FunctionDescriptor __security_init_cookie$descriptor() {
        return __security_init_cookie.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __security_init_cookie()
     * }
     */
    public static MethodHandle __security_init_cookie$handle() {
        return __security_init_cookie.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __security_init_cookie()
     * }
     */
    public static MemorySegment __security_init_cookie$address() {
        return __security_init_cookie.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __security_init_cookie()
     * }
     */
    public static void __security_init_cookie() {
        var mh$ = __security_init_cookie.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__security_init_cookie");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __security_check_cookie {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("__security_check_cookie");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __security_check_cookie(uintptr_t _StackCookie)
     * }
     */
    public static FunctionDescriptor __security_check_cookie$descriptor() {
        return __security_check_cookie.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __security_check_cookie(uintptr_t _StackCookie)
     * }
     */
    public static MethodHandle __security_check_cookie$handle() {
        return __security_check_cookie.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __security_check_cookie(uintptr_t _StackCookie)
     * }
     */
    public static MemorySegment __security_check_cookie$address() {
        return __security_check_cookie.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __security_check_cookie(uintptr_t _StackCookie)
     * }
     */
    public static void __security_check_cookie(long _StackCookie) {
        var mh$ = __security_check_cookie.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__security_check_cookie", _StackCookie);
            }
            mh$.invokeExact(_StackCookie);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __report_gsfailure {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("__report_gsfailure");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __report_gsfailure(uintptr_t _StackCookie)
     * }
     */
    public static FunctionDescriptor __report_gsfailure$descriptor() {
        return __report_gsfailure.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __report_gsfailure(uintptr_t _StackCookie)
     * }
     */
    public static MethodHandle __report_gsfailure$handle() {
        return __report_gsfailure.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __report_gsfailure(uintptr_t _StackCookie)
     * }
     */
    public static MemorySegment __report_gsfailure$address() {
        return __report_gsfailure.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __report_gsfailure(uintptr_t _StackCookie)
     * }
     */
    public static void __report_gsfailure(long _StackCookie) {
        var mh$ = __report_gsfailure.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__report_gsfailure", _StackCookie);
            }
            mh$.invokeExact(_StackCookie);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __security_cookie$constants {
        public static final OfLong LAYOUT = Python_h.C_LONG_LONG;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("__security_cookie").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern uintptr_t __security_cookie
     * }
     */
    public static OfLong __security_cookie$layout() {
        return __security_cookie$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern uintptr_t __security_cookie
     * }
     */
    public static MemorySegment __security_cookie$segment() {
        return __security_cookie$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern uintptr_t __security_cookie
     * }
     */
    public static long __security_cookie() {
        return __security_cookie$constants.SEGMENT.get(__security_cookie$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern uintptr_t __security_cookie
     * }
     */
    public static void __security_cookie(long varValue) {
        __security_cookie$constants.SEGMENT.set(__security_cookie$constants.LAYOUT, 0L, varValue);
    }
    /**
     * {@snippet lang=c :
     * typedef _Bool __crt_bool
     * }
     */
    public static final OfBoolean __crt_bool = Python_h.C_BOOL;

    private static class _invalid_parameter_noinfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_invalid_parameter_noinfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _invalid_parameter_noinfo()
     * }
     */
    public static FunctionDescriptor _invalid_parameter_noinfo$descriptor() {
        return _invalid_parameter_noinfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _invalid_parameter_noinfo()
     * }
     */
    public static MethodHandle _invalid_parameter_noinfo$handle() {
        return _invalid_parameter_noinfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _invalid_parameter_noinfo()
     * }
     */
    public static MemorySegment _invalid_parameter_noinfo$address() {
        return _invalid_parameter_noinfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _invalid_parameter_noinfo()
     * }
     */
    public static void _invalid_parameter_noinfo() {
        var mh$ = _invalid_parameter_noinfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_invalid_parameter_noinfo");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _invalid_parameter_noinfo_noreturn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_invalid_parameter_noinfo_noreturn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _invalid_parameter_noinfo_noreturn()
     * }
     */
    public static FunctionDescriptor _invalid_parameter_noinfo_noreturn$descriptor() {
        return _invalid_parameter_noinfo_noreturn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _invalid_parameter_noinfo_noreturn()
     * }
     */
    public static MethodHandle _invalid_parameter_noinfo_noreturn$handle() {
        return _invalid_parameter_noinfo_noreturn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _invalid_parameter_noinfo_noreturn()
     * }
     */
    public static MemorySegment _invalid_parameter_noinfo_noreturn$address() {
        return _invalid_parameter_noinfo_noreturn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _invalid_parameter_noinfo_noreturn()
     * }
     */
    public static void _invalid_parameter_noinfo_noreturn() {
        var mh$ = _invalid_parameter_noinfo_noreturn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_invalid_parameter_noinfo_noreturn");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _invoke_watson {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_invoke_watson");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _invoke_watson(const wchar_t *_Expression, const wchar_t *_FunctionName, const wchar_t *_FileName, unsigned int _LineNo, uintptr_t _Reserved)
     * }
     */
    public static FunctionDescriptor _invoke_watson$descriptor() {
        return _invoke_watson.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _invoke_watson(const wchar_t *_Expression, const wchar_t *_FunctionName, const wchar_t *_FileName, unsigned int _LineNo, uintptr_t _Reserved)
     * }
     */
    public static MethodHandle _invoke_watson$handle() {
        return _invoke_watson.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _invoke_watson(const wchar_t *_Expression, const wchar_t *_FunctionName, const wchar_t *_FileName, unsigned int _LineNo, uintptr_t _Reserved)
     * }
     */
    public static MemorySegment _invoke_watson$address() {
        return _invoke_watson.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _invoke_watson(const wchar_t *_Expression, const wchar_t *_FunctionName, const wchar_t *_FileName, unsigned int _LineNo, uintptr_t _Reserved)
     * }
     */
    public static void _invoke_watson(MemorySegment _Expression, MemorySegment _FunctionName, MemorySegment _FileName, int _LineNo, long _Reserved) {
        var mh$ = _invoke_watson.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_invoke_watson", _Expression, _FunctionName, _FileName, _LineNo, _Reserved);
            }
            mh$.invokeExact(_Expression, _FunctionName, _FileName, _LineNo, _Reserved);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef int errno_t
     * }
     */
    public static final OfInt errno_t = Python_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned short wint_t
     * }
     */
    public static final OfShort wint_t = Python_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned short wctype_t
     * }
     */
    public static final OfShort wctype_t = Python_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef long __time32_t
     * }
     */
    public static final OfInt __time32_t = Python_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long long __time64_t
     * }
     */
    public static final OfLong __time64_t = Python_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __crt_locale_pointers *_locale_t
     * }
     */
    public static final AddressLayout _locale_t = Python_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef __time64_t time_t
     * }
     */
    public static final OfLong time_t = Python_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef size_t rsize_t
     * }
     */
    public static final OfLong rsize_t = Python_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long _fsize_t
     * }
     */
    public static final OfInt _fsize_t = Python_h.C_LONG;

    private static class _waccess {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_waccess");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _waccess(const wchar_t *_FileName, int _AccessMode)
     * }
     */
    public static FunctionDescriptor _waccess$descriptor() {
        return _waccess.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _waccess(const wchar_t *_FileName, int _AccessMode)
     * }
     */
    public static MethodHandle _waccess$handle() {
        return _waccess.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _waccess(const wchar_t *_FileName, int _AccessMode)
     * }
     */
    public static MemorySegment _waccess$address() {
        return _waccess.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _waccess(const wchar_t *_FileName, int _AccessMode)
     * }
     */
    public static int _waccess(MemorySegment _FileName, int _AccessMode) {
        var mh$ = _waccess.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_waccess", _FileName, _AccessMode);
            }
            return (int)mh$.invokeExact(_FileName, _AccessMode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _waccess_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_waccess_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _waccess_s(const wchar_t *_FileName, int _AccessMode)
     * }
     */
    public static FunctionDescriptor _waccess_s$descriptor() {
        return _waccess_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _waccess_s(const wchar_t *_FileName, int _AccessMode)
     * }
     */
    public static MethodHandle _waccess_s$handle() {
        return _waccess_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _waccess_s(const wchar_t *_FileName, int _AccessMode)
     * }
     */
    public static MemorySegment _waccess_s$address() {
        return _waccess_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _waccess_s(const wchar_t *_FileName, int _AccessMode)
     * }
     */
    public static int _waccess_s(MemorySegment _FileName, int _AccessMode) {
        var mh$ = _waccess_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_waccess_s", _FileName, _AccessMode);
            }
            return (int)mh$.invokeExact(_FileName, _AccessMode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wchmod {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wchmod");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _wchmod(const wchar_t *_FileName, int _Mode)
     * }
     */
    public static FunctionDescriptor _wchmod$descriptor() {
        return _wchmod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _wchmod(const wchar_t *_FileName, int _Mode)
     * }
     */
    public static MethodHandle _wchmod$handle() {
        return _wchmod.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _wchmod(const wchar_t *_FileName, int _Mode)
     * }
     */
    public static MemorySegment _wchmod$address() {
        return _wchmod.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _wchmod(const wchar_t *_FileName, int _Mode)
     * }
     */
    public static int _wchmod(MemorySegment _FileName, int _Mode) {
        var mh$ = _wchmod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wchmod", _FileName, _Mode);
            }
            return (int)mh$.invokeExact(_FileName, _Mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcreat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wcreat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _wcreat(const wchar_t *_FileName, int _PermissionMode)
     * }
     */
    public static FunctionDescriptor _wcreat$descriptor() {
        return _wcreat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _wcreat(const wchar_t *_FileName, int _PermissionMode)
     * }
     */
    public static MethodHandle _wcreat$handle() {
        return _wcreat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _wcreat(const wchar_t *_FileName, int _PermissionMode)
     * }
     */
    public static MemorySegment _wcreat$address() {
        return _wcreat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _wcreat(const wchar_t *_FileName, int _PermissionMode)
     * }
     */
    public static int _wcreat(MemorySegment _FileName, int _PermissionMode) {
        var mh$ = _wcreat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcreat", _FileName, _PermissionMode);
            }
            return (int)mh$.invokeExact(_FileName, _PermissionMode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wfindfirst32 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wfindfirst32");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * intptr_t _wfindfirst32(const wchar_t *_FileName, struct _wfinddata32_t *_FindData)
     * }
     */
    public static FunctionDescriptor _wfindfirst32$descriptor() {
        return _wfindfirst32.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * intptr_t _wfindfirst32(const wchar_t *_FileName, struct _wfinddata32_t *_FindData)
     * }
     */
    public static MethodHandle _wfindfirst32$handle() {
        return _wfindfirst32.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * intptr_t _wfindfirst32(const wchar_t *_FileName, struct _wfinddata32_t *_FindData)
     * }
     */
    public static MemorySegment _wfindfirst32$address() {
        return _wfindfirst32.ADDR;
    }

    /**
     * {@snippet lang=c :
     * intptr_t _wfindfirst32(const wchar_t *_FileName, struct _wfinddata32_t *_FindData)
     * }
     */
    public static long _wfindfirst32(MemorySegment _FileName, MemorySegment _FindData) {
        var mh$ = _wfindfirst32.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wfindfirst32", _FileName, _FindData);
            }
            return (long)mh$.invokeExact(_FileName, _FindData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wfindnext32 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wfindnext32");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _wfindnext32(intptr_t _FindHandle, struct _wfinddata32_t *_FindData)
     * }
     */
    public static FunctionDescriptor _wfindnext32$descriptor() {
        return _wfindnext32.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _wfindnext32(intptr_t _FindHandle, struct _wfinddata32_t *_FindData)
     * }
     */
    public static MethodHandle _wfindnext32$handle() {
        return _wfindnext32.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _wfindnext32(intptr_t _FindHandle, struct _wfinddata32_t *_FindData)
     * }
     */
    public static MemorySegment _wfindnext32$address() {
        return _wfindnext32.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _wfindnext32(intptr_t _FindHandle, struct _wfinddata32_t *_FindData)
     * }
     */
    public static int _wfindnext32(long _FindHandle, MemorySegment _FindData) {
        var mh$ = _wfindnext32.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wfindnext32", _FindHandle, _FindData);
            }
            return (int)mh$.invokeExact(_FindHandle, _FindData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wunlink {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wunlink");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _wunlink(const wchar_t *_FileName)
     * }
     */
    public static FunctionDescriptor _wunlink$descriptor() {
        return _wunlink.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _wunlink(const wchar_t *_FileName)
     * }
     */
    public static MethodHandle _wunlink$handle() {
        return _wunlink.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _wunlink(const wchar_t *_FileName)
     * }
     */
    public static MemorySegment _wunlink$address() {
        return _wunlink.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _wunlink(const wchar_t *_FileName)
     * }
     */
    public static int _wunlink(MemorySegment _FileName) {
        var mh$ = _wunlink.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wunlink", _FileName);
            }
            return (int)mh$.invokeExact(_FileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wrename {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wrename");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _wrename(const wchar_t *_OldFileName, const wchar_t *_NewFileName)
     * }
     */
    public static FunctionDescriptor _wrename$descriptor() {
        return _wrename.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _wrename(const wchar_t *_OldFileName, const wchar_t *_NewFileName)
     * }
     */
    public static MethodHandle _wrename$handle() {
        return _wrename.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _wrename(const wchar_t *_OldFileName, const wchar_t *_NewFileName)
     * }
     */
    public static MemorySegment _wrename$address() {
        return _wrename.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _wrename(const wchar_t *_OldFileName, const wchar_t *_NewFileName)
     * }
     */
    public static int _wrename(MemorySegment _OldFileName, MemorySegment _NewFileName) {
        var mh$ = _wrename.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wrename", _OldFileName, _NewFileName);
            }
            return (int)mh$.invokeExact(_OldFileName, _NewFileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wmktemp_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wmktemp_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _wmktemp_s(wchar_t *_TemplateName, size_t _SizeInWords)
     * }
     */
    public static FunctionDescriptor _wmktemp_s$descriptor() {
        return _wmktemp_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _wmktemp_s(wchar_t *_TemplateName, size_t _SizeInWords)
     * }
     */
    public static MethodHandle _wmktemp_s$handle() {
        return _wmktemp_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _wmktemp_s(wchar_t *_TemplateName, size_t _SizeInWords)
     * }
     */
    public static MemorySegment _wmktemp_s$address() {
        return _wmktemp_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _wmktemp_s(wchar_t *_TemplateName, size_t _SizeInWords)
     * }
     */
    public static int _wmktemp_s(MemorySegment _TemplateName, long _SizeInWords) {
        var mh$ = _wmktemp_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wmktemp_s", _TemplateName, _SizeInWords);
            }
            return (int)mh$.invokeExact(_TemplateName, _SizeInWords);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wmktemp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wmktemp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *_wmktemp(wchar_t *_TemplateName)
     * }
     */
    public static FunctionDescriptor _wmktemp$descriptor() {
        return _wmktemp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *_wmktemp(wchar_t *_TemplateName)
     * }
     */
    public static MethodHandle _wmktemp$handle() {
        return _wmktemp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *_wmktemp(wchar_t *_TemplateName)
     * }
     */
    public static MemorySegment _wmktemp$address() {
        return _wmktemp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *_wmktemp(wchar_t *_TemplateName)
     * }
     */
    public static MemorySegment _wmktemp(MemorySegment _TemplateName) {
        var mh$ = _wmktemp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wmktemp", _TemplateName);
            }
            return (MemorySegment)mh$.invokeExact(_TemplateName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wfindfirst32i64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wfindfirst32i64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * intptr_t _wfindfirst32i64(const wchar_t *_FileName, struct _wfinddata32i64_t *_FindData)
     * }
     */
    public static FunctionDescriptor _wfindfirst32i64$descriptor() {
        return _wfindfirst32i64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * intptr_t _wfindfirst32i64(const wchar_t *_FileName, struct _wfinddata32i64_t *_FindData)
     * }
     */
    public static MethodHandle _wfindfirst32i64$handle() {
        return _wfindfirst32i64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * intptr_t _wfindfirst32i64(const wchar_t *_FileName, struct _wfinddata32i64_t *_FindData)
     * }
     */
    public static MemorySegment _wfindfirst32i64$address() {
        return _wfindfirst32i64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * intptr_t _wfindfirst32i64(const wchar_t *_FileName, struct _wfinddata32i64_t *_FindData)
     * }
     */
    public static long _wfindfirst32i64(MemorySegment _FileName, MemorySegment _FindData) {
        var mh$ = _wfindfirst32i64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wfindfirst32i64", _FileName, _FindData);
            }
            return (long)mh$.invokeExact(_FileName, _FindData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wfindfirst64i32 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wfindfirst64i32");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * intptr_t _wfindfirst64i32(const wchar_t *_FileName, struct _wfinddata64i32_t *_FindData)
     * }
     */
    public static FunctionDescriptor _wfindfirst64i32$descriptor() {
        return _wfindfirst64i32.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * intptr_t _wfindfirst64i32(const wchar_t *_FileName, struct _wfinddata64i32_t *_FindData)
     * }
     */
    public static MethodHandle _wfindfirst64i32$handle() {
        return _wfindfirst64i32.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * intptr_t _wfindfirst64i32(const wchar_t *_FileName, struct _wfinddata64i32_t *_FindData)
     * }
     */
    public static MemorySegment _wfindfirst64i32$address() {
        return _wfindfirst64i32.ADDR;
    }

    /**
     * {@snippet lang=c :
     * intptr_t _wfindfirst64i32(const wchar_t *_FileName, struct _wfinddata64i32_t *_FindData)
     * }
     */
    public static long _wfindfirst64i32(MemorySegment _FileName, MemorySegment _FindData) {
        var mh$ = _wfindfirst64i32.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wfindfirst64i32", _FileName, _FindData);
            }
            return (long)mh$.invokeExact(_FileName, _FindData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wfindfirst64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wfindfirst64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * intptr_t _wfindfirst64(const wchar_t *_FileName, struct _wfinddata64_t *_FindData)
     * }
     */
    public static FunctionDescriptor _wfindfirst64$descriptor() {
        return _wfindfirst64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * intptr_t _wfindfirst64(const wchar_t *_FileName, struct _wfinddata64_t *_FindData)
     * }
     */
    public static MethodHandle _wfindfirst64$handle() {
        return _wfindfirst64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * intptr_t _wfindfirst64(const wchar_t *_FileName, struct _wfinddata64_t *_FindData)
     * }
     */
    public static MemorySegment _wfindfirst64$address() {
        return _wfindfirst64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * intptr_t _wfindfirst64(const wchar_t *_FileName, struct _wfinddata64_t *_FindData)
     * }
     */
    public static long _wfindfirst64(MemorySegment _FileName, MemorySegment _FindData) {
        var mh$ = _wfindfirst64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wfindfirst64", _FileName, _FindData);
            }
            return (long)mh$.invokeExact(_FileName, _FindData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wfindnext32i64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wfindnext32i64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _wfindnext32i64(intptr_t _FindHandle, struct _wfinddata32i64_t *_FindData)
     * }
     */
    public static FunctionDescriptor _wfindnext32i64$descriptor() {
        return _wfindnext32i64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _wfindnext32i64(intptr_t _FindHandle, struct _wfinddata32i64_t *_FindData)
     * }
     */
    public static MethodHandle _wfindnext32i64$handle() {
        return _wfindnext32i64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _wfindnext32i64(intptr_t _FindHandle, struct _wfinddata32i64_t *_FindData)
     * }
     */
    public static MemorySegment _wfindnext32i64$address() {
        return _wfindnext32i64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _wfindnext32i64(intptr_t _FindHandle, struct _wfinddata32i64_t *_FindData)
     * }
     */
    public static int _wfindnext32i64(long _FindHandle, MemorySegment _FindData) {
        var mh$ = _wfindnext32i64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wfindnext32i64", _FindHandle, _FindData);
            }
            return (int)mh$.invokeExact(_FindHandle, _FindData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wfindnext64i32 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wfindnext64i32");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _wfindnext64i32(intptr_t _FindHandle, struct _wfinddata64i32_t *_FindData)
     * }
     */
    public static FunctionDescriptor _wfindnext64i32$descriptor() {
        return _wfindnext64i32.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _wfindnext64i32(intptr_t _FindHandle, struct _wfinddata64i32_t *_FindData)
     * }
     */
    public static MethodHandle _wfindnext64i32$handle() {
        return _wfindnext64i32.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _wfindnext64i32(intptr_t _FindHandle, struct _wfinddata64i32_t *_FindData)
     * }
     */
    public static MemorySegment _wfindnext64i32$address() {
        return _wfindnext64i32.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _wfindnext64i32(intptr_t _FindHandle, struct _wfinddata64i32_t *_FindData)
     * }
     */
    public static int _wfindnext64i32(long _FindHandle, MemorySegment _FindData) {
        var mh$ = _wfindnext64i32.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wfindnext64i32", _FindHandle, _FindData);
            }
            return (int)mh$.invokeExact(_FindHandle, _FindData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wfindnext64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wfindnext64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _wfindnext64(intptr_t _FindHandle, struct _wfinddata64_t *_FindData)
     * }
     */
    public static FunctionDescriptor _wfindnext64$descriptor() {
        return _wfindnext64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _wfindnext64(intptr_t _FindHandle, struct _wfinddata64_t *_FindData)
     * }
     */
    public static MethodHandle _wfindnext64$handle() {
        return _wfindnext64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _wfindnext64(intptr_t _FindHandle, struct _wfinddata64_t *_FindData)
     * }
     */
    public static MemorySegment _wfindnext64$address() {
        return _wfindnext64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _wfindnext64(intptr_t _FindHandle, struct _wfinddata64_t *_FindData)
     * }
     */
    public static int _wfindnext64(long _FindHandle, MemorySegment _FindData) {
        var mh$ = _wfindnext64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wfindnext64", _FindHandle, _FindData);
            }
            return (int)mh$.invokeExact(_FindHandle, _FindData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wsopen_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wsopen_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _wsopen_s(int *_FileHandle, const wchar_t *_FileName, int _OpenFlag, int _ShareFlag, int _PermissionFlag)
     * }
     */
    public static FunctionDescriptor _wsopen_s$descriptor() {
        return _wsopen_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _wsopen_s(int *_FileHandle, const wchar_t *_FileName, int _OpenFlag, int _ShareFlag, int _PermissionFlag)
     * }
     */
    public static MethodHandle _wsopen_s$handle() {
        return _wsopen_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _wsopen_s(int *_FileHandle, const wchar_t *_FileName, int _OpenFlag, int _ShareFlag, int _PermissionFlag)
     * }
     */
    public static MemorySegment _wsopen_s$address() {
        return _wsopen_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _wsopen_s(int *_FileHandle, const wchar_t *_FileName, int _OpenFlag, int _ShareFlag, int _PermissionFlag)
     * }
     */
    public static int _wsopen_s(MemorySegment _FileHandle, MemorySegment _FileName, int _OpenFlag, int _ShareFlag, int _PermissionFlag) {
        var mh$ = _wsopen_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wsopen_s", _FileHandle, _FileName, _OpenFlag, _ShareFlag, _PermissionFlag);
            }
            return (int)mh$.invokeExact(_FileHandle, _FileName, _OpenFlag, _ShareFlag, _PermissionFlag);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wsopen_dispatch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wsopen_dispatch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _wsopen_dispatch(const wchar_t *_FileName, int _OFlag, int _ShFlag, int _PMode, int *_PFileHandle, int _BSecure)
     * }
     */
    public static FunctionDescriptor _wsopen_dispatch$descriptor() {
        return _wsopen_dispatch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _wsopen_dispatch(const wchar_t *_FileName, int _OFlag, int _ShFlag, int _PMode, int *_PFileHandle, int _BSecure)
     * }
     */
    public static MethodHandle _wsopen_dispatch$handle() {
        return _wsopen_dispatch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _wsopen_dispatch(const wchar_t *_FileName, int _OFlag, int _ShFlag, int _PMode, int *_PFileHandle, int _BSecure)
     * }
     */
    public static MemorySegment _wsopen_dispatch$address() {
        return _wsopen_dispatch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _wsopen_dispatch(const wchar_t *_FileName, int _OFlag, int _ShFlag, int _PMode, int *_PFileHandle, int _BSecure)
     * }
     */
    public static int _wsopen_dispatch(MemorySegment _FileName, int _OFlag, int _ShFlag, int _PMode, MemorySegment _PFileHandle, int _BSecure) {
        var mh$ = _wsopen_dispatch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wsopen_dispatch", _FileName, _OFlag, _ShFlag, _PMode, _PFileHandle, _BSecure);
            }
            return (int)mh$.invokeExact(_FileName, _OFlag, _ShFlag, _PMode, _PFileHandle, _BSecure);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int _wopen(const wchar_t *_FileName, int _OpenFlag, ...)
     * }
     */
    public static class _wopen {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_INT,
                Python_h.C_POINTER,
                Python_h.C_INT
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("_wopen");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private _wopen(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int _wopen(const wchar_t *_FileName, int _OpenFlag, ...)
         * }
         */
        public static _wopen makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new _wopen(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment _FileName, int _OpenFlag, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("_wopen", _FileName, _OpenFlag, x2);
                }
                return (int)spreader.invokeExact(_FileName, _OpenFlag, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int _wsopen(const wchar_t *_FileName, int _OpenFlag, int _ShareFlag, ...)
     * }
     */
    public static class _wsopen {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_INT,
                Python_h.C_POINTER,
                Python_h.C_INT,
                Python_h.C_INT
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("_wsopen");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private _wsopen(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int _wsopen(const wchar_t *_FileName, int _OpenFlag, int _ShareFlag, ...)
         * }
         */
        public static _wsopen makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new _wsopen(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment _FileName, int _OpenFlag, int _ShareFlag, Object... x3) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("_wsopen", _FileName, _OpenFlag, _ShareFlag, x3);
                }
                return (int)spreader.invokeExact(_FileName, _OpenFlag, _ShareFlag, x3);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class _access {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_access");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _access(const char *_FileName, int _AccessMode)
     * }
     */
    public static FunctionDescriptor _access$descriptor() {
        return _access.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _access(const char *_FileName, int _AccessMode)
     * }
     */
    public static MethodHandle _access$handle() {
        return _access.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _access(const char *_FileName, int _AccessMode)
     * }
     */
    public static MemorySegment _access$address() {
        return _access.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _access(const char *_FileName, int _AccessMode)
     * }
     */
    public static int _access(MemorySegment _FileName, int _AccessMode) {
        var mh$ = _access.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_access", _FileName, _AccessMode);
            }
            return (int)mh$.invokeExact(_FileName, _AccessMode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _access_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_access_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _access_s(const char *_FileName, int _AccessMode)
     * }
     */
    public static FunctionDescriptor _access_s$descriptor() {
        return _access_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _access_s(const char *_FileName, int _AccessMode)
     * }
     */
    public static MethodHandle _access_s$handle() {
        return _access_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _access_s(const char *_FileName, int _AccessMode)
     * }
     */
    public static MemorySegment _access_s$address() {
        return _access_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _access_s(const char *_FileName, int _AccessMode)
     * }
     */
    public static int _access_s(MemorySegment _FileName, int _AccessMode) {
        var mh$ = _access_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_access_s", _FileName, _AccessMode);
            }
            return (int)mh$.invokeExact(_FileName, _AccessMode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _chmod {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_chmod");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _chmod(const char *_FileName, int _Mode)
     * }
     */
    public static FunctionDescriptor _chmod$descriptor() {
        return _chmod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _chmod(const char *_FileName, int _Mode)
     * }
     */
    public static MethodHandle _chmod$handle() {
        return _chmod.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _chmod(const char *_FileName, int _Mode)
     * }
     */
    public static MemorySegment _chmod$address() {
        return _chmod.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _chmod(const char *_FileName, int _Mode)
     * }
     */
    public static int _chmod(MemorySegment _FileName, int _Mode) {
        var mh$ = _chmod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_chmod", _FileName, _Mode);
            }
            return (int)mh$.invokeExact(_FileName, _Mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _chsize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_chsize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _chsize(int _FileHandle, long _Size)
     * }
     */
    public static FunctionDescriptor _chsize$descriptor() {
        return _chsize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _chsize(int _FileHandle, long _Size)
     * }
     */
    public static MethodHandle _chsize$handle() {
        return _chsize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _chsize(int _FileHandle, long _Size)
     * }
     */
    public static MemorySegment _chsize$address() {
        return _chsize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _chsize(int _FileHandle, long _Size)
     * }
     */
    public static int _chsize(int _FileHandle, int _Size) {
        var mh$ = _chsize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_chsize", _FileHandle, _Size);
            }
            return (int)mh$.invokeExact(_FileHandle, _Size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _chsize_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_chsize_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _chsize_s(int _FileHandle, long long _Size)
     * }
     */
    public static FunctionDescriptor _chsize_s$descriptor() {
        return _chsize_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _chsize_s(int _FileHandle, long long _Size)
     * }
     */
    public static MethodHandle _chsize_s$handle() {
        return _chsize_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _chsize_s(int _FileHandle, long long _Size)
     * }
     */
    public static MemorySegment _chsize_s$address() {
        return _chsize_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _chsize_s(int _FileHandle, long long _Size)
     * }
     */
    public static int _chsize_s(int _FileHandle, long _Size) {
        var mh$ = _chsize_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_chsize_s", _FileHandle, _Size);
            }
            return (int)mh$.invokeExact(_FileHandle, _Size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _close {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_close");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _close(int _FileHandle)
     * }
     */
    public static FunctionDescriptor _close$descriptor() {
        return _close.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _close(int _FileHandle)
     * }
     */
    public static MethodHandle _close$handle() {
        return _close.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _close(int _FileHandle)
     * }
     */
    public static MemorySegment _close$address() {
        return _close.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _close(int _FileHandle)
     * }
     */
    public static int _close(int _FileHandle) {
        var mh$ = _close.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_close", _FileHandle);
            }
            return (int)mh$.invokeExact(_FileHandle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _commit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_commit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _commit(int _FileHandle)
     * }
     */
    public static FunctionDescriptor _commit$descriptor() {
        return _commit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _commit(int _FileHandle)
     * }
     */
    public static MethodHandle _commit$handle() {
        return _commit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _commit(int _FileHandle)
     * }
     */
    public static MemorySegment _commit$address() {
        return _commit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _commit(int _FileHandle)
     * }
     */
    public static int _commit(int _FileHandle) {
        var mh$ = _commit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_commit", _FileHandle);
            }
            return (int)mh$.invokeExact(_FileHandle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _creat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_creat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _creat(const char *_FileName, int _PermissionMode)
     * }
     */
    public static FunctionDescriptor _creat$descriptor() {
        return _creat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _creat(const char *_FileName, int _PermissionMode)
     * }
     */
    public static MethodHandle _creat$handle() {
        return _creat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _creat(const char *_FileName, int _PermissionMode)
     * }
     */
    public static MemorySegment _creat$address() {
        return _creat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _creat(const char *_FileName, int _PermissionMode)
     * }
     */
    public static int _creat(MemorySegment _FileName, int _PermissionMode) {
        var mh$ = _creat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_creat", _FileName, _PermissionMode);
            }
            return (int)mh$.invokeExact(_FileName, _PermissionMode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _dup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_dup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _dup(int _FileHandle)
     * }
     */
    public static FunctionDescriptor _dup$descriptor() {
        return _dup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _dup(int _FileHandle)
     * }
     */
    public static MethodHandle _dup$handle() {
        return _dup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _dup(int _FileHandle)
     * }
     */
    public static MemorySegment _dup$address() {
        return _dup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _dup(int _FileHandle)
     * }
     */
    public static int _dup(int _FileHandle) {
        var mh$ = _dup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_dup", _FileHandle);
            }
            return (int)mh$.invokeExact(_FileHandle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _dup2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_dup2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _dup2(int _FileHandleSrc, int _FileHandleDst)
     * }
     */
    public static FunctionDescriptor _dup2$descriptor() {
        return _dup2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _dup2(int _FileHandleSrc, int _FileHandleDst)
     * }
     */
    public static MethodHandle _dup2$handle() {
        return _dup2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _dup2(int _FileHandleSrc, int _FileHandleDst)
     * }
     */
    public static MemorySegment _dup2$address() {
        return _dup2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _dup2(int _FileHandleSrc, int _FileHandleDst)
     * }
     */
    public static int _dup2(int _FileHandleSrc, int _FileHandleDst) {
        var mh$ = _dup2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_dup2", _FileHandleSrc, _FileHandleDst);
            }
            return (int)mh$.invokeExact(_FileHandleSrc, _FileHandleDst);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _eof {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_eof");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _eof(int _FileHandle)
     * }
     */
    public static FunctionDescriptor _eof$descriptor() {
        return _eof.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _eof(int _FileHandle)
     * }
     */
    public static MethodHandle _eof$handle() {
        return _eof.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _eof(int _FileHandle)
     * }
     */
    public static MemorySegment _eof$address() {
        return _eof.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _eof(int _FileHandle)
     * }
     */
    public static int _eof(int _FileHandle) {
        var mh$ = _eof.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_eof", _FileHandle);
            }
            return (int)mh$.invokeExact(_FileHandle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _filelength {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_filelength");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long _filelength(int _FileHandle)
     * }
     */
    public static FunctionDescriptor _filelength$descriptor() {
        return _filelength.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long _filelength(int _FileHandle)
     * }
     */
    public static MethodHandle _filelength$handle() {
        return _filelength.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long _filelength(int _FileHandle)
     * }
     */
    public static MemorySegment _filelength$address() {
        return _filelength.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long _filelength(int _FileHandle)
     * }
     */
    public static int _filelength(int _FileHandle) {
        var mh$ = _filelength.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_filelength", _FileHandle);
            }
            return (int)mh$.invokeExact(_FileHandle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _findfirst32 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_findfirst32");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * intptr_t _findfirst32(const char *_FileName, struct _finddata32_t *_FindData)
     * }
     */
    public static FunctionDescriptor _findfirst32$descriptor() {
        return _findfirst32.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * intptr_t _findfirst32(const char *_FileName, struct _finddata32_t *_FindData)
     * }
     */
    public static MethodHandle _findfirst32$handle() {
        return _findfirst32.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * intptr_t _findfirst32(const char *_FileName, struct _finddata32_t *_FindData)
     * }
     */
    public static MemorySegment _findfirst32$address() {
        return _findfirst32.ADDR;
    }

    /**
     * {@snippet lang=c :
     * intptr_t _findfirst32(const char *_FileName, struct _finddata32_t *_FindData)
     * }
     */
    public static long _findfirst32(MemorySegment _FileName, MemorySegment _FindData) {
        var mh$ = _findfirst32.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_findfirst32", _FileName, _FindData);
            }
            return (long)mh$.invokeExact(_FileName, _FindData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _findnext32 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_findnext32");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _findnext32(intptr_t _FindHandle, struct _finddata32_t *_FindData)
     * }
     */
    public static FunctionDescriptor _findnext32$descriptor() {
        return _findnext32.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _findnext32(intptr_t _FindHandle, struct _finddata32_t *_FindData)
     * }
     */
    public static MethodHandle _findnext32$handle() {
        return _findnext32.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _findnext32(intptr_t _FindHandle, struct _finddata32_t *_FindData)
     * }
     */
    public static MemorySegment _findnext32$address() {
        return _findnext32.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _findnext32(intptr_t _FindHandle, struct _finddata32_t *_FindData)
     * }
     */
    public static int _findnext32(long _FindHandle, MemorySegment _FindData) {
        var mh$ = _findnext32.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_findnext32", _FindHandle, _FindData);
            }
            return (int)mh$.invokeExact(_FindHandle, _FindData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _findclose {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_findclose");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _findclose(intptr_t _FindHandle)
     * }
     */
    public static FunctionDescriptor _findclose$descriptor() {
        return _findclose.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _findclose(intptr_t _FindHandle)
     * }
     */
    public static MethodHandle _findclose$handle() {
        return _findclose.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _findclose(intptr_t _FindHandle)
     * }
     */
    public static MemorySegment _findclose$address() {
        return _findclose.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _findclose(intptr_t _FindHandle)
     * }
     */
    public static int _findclose(long _FindHandle) {
        var mh$ = _findclose.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_findclose", _FindHandle);
            }
            return (int)mh$.invokeExact(_FindHandle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _get_osfhandle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_get_osfhandle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * intptr_t _get_osfhandle(int _FileHandle)
     * }
     */
    public static FunctionDescriptor _get_osfhandle$descriptor() {
        return _get_osfhandle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * intptr_t _get_osfhandle(int _FileHandle)
     * }
     */
    public static MethodHandle _get_osfhandle$handle() {
        return _get_osfhandle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * intptr_t _get_osfhandle(int _FileHandle)
     * }
     */
    public static MemorySegment _get_osfhandle$address() {
        return _get_osfhandle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * intptr_t _get_osfhandle(int _FileHandle)
     * }
     */
    public static long _get_osfhandle(int _FileHandle) {
        var mh$ = _get_osfhandle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_get_osfhandle", _FileHandle);
            }
            return (long)mh$.invokeExact(_FileHandle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _isatty {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_isatty");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _isatty(int _FileHandle)
     * }
     */
    public static FunctionDescriptor _isatty$descriptor() {
        return _isatty.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _isatty(int _FileHandle)
     * }
     */
    public static MethodHandle _isatty$handle() {
        return _isatty.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _isatty(int _FileHandle)
     * }
     */
    public static MemorySegment _isatty$address() {
        return _isatty.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _isatty(int _FileHandle)
     * }
     */
    public static int _isatty(int _FileHandle) {
        var mh$ = _isatty.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_isatty", _FileHandle);
            }
            return (int)mh$.invokeExact(_FileHandle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _locking {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_locking");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _locking(int _FileHandle, int _LockMode, long _NumOfBytes)
     * }
     */
    public static FunctionDescriptor _locking$descriptor() {
        return _locking.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _locking(int _FileHandle, int _LockMode, long _NumOfBytes)
     * }
     */
    public static MethodHandle _locking$handle() {
        return _locking.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _locking(int _FileHandle, int _LockMode, long _NumOfBytes)
     * }
     */
    public static MemorySegment _locking$address() {
        return _locking.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _locking(int _FileHandle, int _LockMode, long _NumOfBytes)
     * }
     */
    public static int _locking(int _FileHandle, int _LockMode, int _NumOfBytes) {
        var mh$ = _locking.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_locking", _FileHandle, _LockMode, _NumOfBytes);
            }
            return (int)mh$.invokeExact(_FileHandle, _LockMode, _NumOfBytes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _lseek {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_INT,
            Python_h.C_LONG,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_lseek");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long _lseek(int _FileHandle, long _Offset, int _Origin)
     * }
     */
    public static FunctionDescriptor _lseek$descriptor() {
        return _lseek.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long _lseek(int _FileHandle, long _Offset, int _Origin)
     * }
     */
    public static MethodHandle _lseek$handle() {
        return _lseek.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long _lseek(int _FileHandle, long _Offset, int _Origin)
     * }
     */
    public static MemorySegment _lseek$address() {
        return _lseek.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long _lseek(int _FileHandle, long _Offset, int _Origin)
     * }
     */
    public static int _lseek(int _FileHandle, int _Offset, int _Origin) {
        var mh$ = _lseek.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_lseek", _FileHandle, _Offset, _Origin);
            }
            return (int)mh$.invokeExact(_FileHandle, _Offset, _Origin);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _mktemp_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_mktemp_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _mktemp_s(char *_TemplateName, size_t _Size)
     * }
     */
    public static FunctionDescriptor _mktemp_s$descriptor() {
        return _mktemp_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _mktemp_s(char *_TemplateName, size_t _Size)
     * }
     */
    public static MethodHandle _mktemp_s$handle() {
        return _mktemp_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _mktemp_s(char *_TemplateName, size_t _Size)
     * }
     */
    public static MemorySegment _mktemp_s$address() {
        return _mktemp_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _mktemp_s(char *_TemplateName, size_t _Size)
     * }
     */
    public static int _mktemp_s(MemorySegment _TemplateName, long _Size) {
        var mh$ = _mktemp_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_mktemp_s", _TemplateName, _Size);
            }
            return (int)mh$.invokeExact(_TemplateName, _Size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _mktemp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_mktemp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *_mktemp(char *_TemplateName)
     * }
     */
    public static FunctionDescriptor _mktemp$descriptor() {
        return _mktemp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *_mktemp(char *_TemplateName)
     * }
     */
    public static MethodHandle _mktemp$handle() {
        return _mktemp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *_mktemp(char *_TemplateName)
     * }
     */
    public static MemorySegment _mktemp$address() {
        return _mktemp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *_mktemp(char *_TemplateName)
     * }
     */
    public static MemorySegment _mktemp(MemorySegment _TemplateName) {
        var mh$ = _mktemp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_mktemp", _TemplateName);
            }
            return (MemorySegment)mh$.invokeExact(_TemplateName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _open_osfhandle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_LONG_LONG,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_open_osfhandle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _open_osfhandle(intptr_t _OSFileHandle, int _Flags)
     * }
     */
    public static FunctionDescriptor _open_osfhandle$descriptor() {
        return _open_osfhandle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _open_osfhandle(intptr_t _OSFileHandle, int _Flags)
     * }
     */
    public static MethodHandle _open_osfhandle$handle() {
        return _open_osfhandle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _open_osfhandle(intptr_t _OSFileHandle, int _Flags)
     * }
     */
    public static MemorySegment _open_osfhandle$address() {
        return _open_osfhandle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _open_osfhandle(intptr_t _OSFileHandle, int _Flags)
     * }
     */
    public static int _open_osfhandle(long _OSFileHandle, int _Flags) {
        var mh$ = _open_osfhandle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_open_osfhandle", _OSFileHandle, _Flags);
            }
            return (int)mh$.invokeExact(_OSFileHandle, _Flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _pipe {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_pipe");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _pipe(int *_PtHandles, unsigned int _PipeSize, int _TextMode)
     * }
     */
    public static FunctionDescriptor _pipe$descriptor() {
        return _pipe.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _pipe(int *_PtHandles, unsigned int _PipeSize, int _TextMode)
     * }
     */
    public static MethodHandle _pipe$handle() {
        return _pipe.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _pipe(int *_PtHandles, unsigned int _PipeSize, int _TextMode)
     * }
     */
    public static MemorySegment _pipe$address() {
        return _pipe.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _pipe(int *_PtHandles, unsigned int _PipeSize, int _TextMode)
     * }
     */
    public static int _pipe(MemorySegment _PtHandles, int _PipeSize, int _TextMode) {
        var mh$ = _pipe.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_pipe", _PtHandles, _PipeSize, _TextMode);
            }
            return (int)mh$.invokeExact(_PtHandles, _PipeSize, _TextMode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _read {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_read");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _read(int _FileHandle, void *_DstBuf, unsigned int _MaxCharCount)
     * }
     */
    public static FunctionDescriptor _read$descriptor() {
        return _read.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _read(int _FileHandle, void *_DstBuf, unsigned int _MaxCharCount)
     * }
     */
    public static MethodHandle _read$handle() {
        return _read.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _read(int _FileHandle, void *_DstBuf, unsigned int _MaxCharCount)
     * }
     */
    public static MemorySegment _read$address() {
        return _read.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _read(int _FileHandle, void *_DstBuf, unsigned int _MaxCharCount)
     * }
     */
    public static int _read(int _FileHandle, MemorySegment _DstBuf, int _MaxCharCount) {
        var mh$ = _read.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_read", _FileHandle, _DstBuf, _MaxCharCount);
            }
            return (int)mh$.invokeExact(_FileHandle, _DstBuf, _MaxCharCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class remove {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("remove");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int remove(const char *_FileName)
     * }
     */
    public static FunctionDescriptor remove$descriptor() {
        return remove.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int remove(const char *_FileName)
     * }
     */
    public static MethodHandle remove$handle() {
        return remove.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int remove(const char *_FileName)
     * }
     */
    public static MemorySegment remove$address() {
        return remove.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int remove(const char *_FileName)
     * }
     */
    public static int remove(MemorySegment _FileName) {
        var mh$ = remove.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("remove", _FileName);
            }
            return (int)mh$.invokeExact(_FileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rename {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("rename");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int rename(const char *_OldFilename, const char *_NewFilename)
     * }
     */
    public static FunctionDescriptor rename$descriptor() {
        return rename.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int rename(const char *_OldFilename, const char *_NewFilename)
     * }
     */
    public static MethodHandle rename$handle() {
        return rename.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int rename(const char *_OldFilename, const char *_NewFilename)
     * }
     */
    public static MemorySegment rename$address() {
        return rename.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int rename(const char *_OldFilename, const char *_NewFilename)
     * }
     */
    public static int rename(MemorySegment _OldFilename, MemorySegment _NewFilename) {
        var mh$ = rename.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rename", _OldFilename, _NewFilename);
            }
            return (int)mh$.invokeExact(_OldFilename, _NewFilename);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _unlink {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_unlink");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _unlink(const char *_FileName)
     * }
     */
    public static FunctionDescriptor _unlink$descriptor() {
        return _unlink.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _unlink(const char *_FileName)
     * }
     */
    public static MethodHandle _unlink$handle() {
        return _unlink.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _unlink(const char *_FileName)
     * }
     */
    public static MemorySegment _unlink$address() {
        return _unlink.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _unlink(const char *_FileName)
     * }
     */
    public static int _unlink(MemorySegment _FileName) {
        var mh$ = _unlink.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_unlink", _FileName);
            }
            return (int)mh$.invokeExact(_FileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _setmode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_setmode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _setmode(int _FileHandle, int _Mode)
     * }
     */
    public static FunctionDescriptor _setmode$descriptor() {
        return _setmode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _setmode(int _FileHandle, int _Mode)
     * }
     */
    public static MethodHandle _setmode$handle() {
        return _setmode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _setmode(int _FileHandle, int _Mode)
     * }
     */
    public static MemorySegment _setmode$address() {
        return _setmode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _setmode(int _FileHandle, int _Mode)
     * }
     */
    public static int _setmode(int _FileHandle, int _Mode) {
        var mh$ = _setmode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_setmode", _FileHandle, _Mode);
            }
            return (int)mh$.invokeExact(_FileHandle, _Mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _tell {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_tell");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long _tell(int _FileHandle)
     * }
     */
    public static FunctionDescriptor _tell$descriptor() {
        return _tell.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long _tell(int _FileHandle)
     * }
     */
    public static MethodHandle _tell$handle() {
        return _tell.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long _tell(int _FileHandle)
     * }
     */
    public static MemorySegment _tell$address() {
        return _tell.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long _tell(int _FileHandle)
     * }
     */
    public static int _tell(int _FileHandle) {
        var mh$ = _tell.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_tell", _FileHandle);
            }
            return (int)mh$.invokeExact(_FileHandle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _umask {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_umask");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _umask(int _Mode)
     * }
     */
    public static FunctionDescriptor _umask$descriptor() {
        return _umask.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _umask(int _Mode)
     * }
     */
    public static MethodHandle _umask$handle() {
        return _umask.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _umask(int _Mode)
     * }
     */
    public static MemorySegment _umask$address() {
        return _umask.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _umask(int _Mode)
     * }
     */
    public static int _umask(int _Mode) {
        var mh$ = _umask.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_umask", _Mode);
            }
            return (int)mh$.invokeExact(_Mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _umask_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_umask_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _umask_s(int _NewMode, int *_OldMode)
     * }
     */
    public static FunctionDescriptor _umask_s$descriptor() {
        return _umask_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _umask_s(int _NewMode, int *_OldMode)
     * }
     */
    public static MethodHandle _umask_s$handle() {
        return _umask_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _umask_s(int _NewMode, int *_OldMode)
     * }
     */
    public static MemorySegment _umask_s$address() {
        return _umask_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _umask_s(int _NewMode, int *_OldMode)
     * }
     */
    public static int _umask_s(int _NewMode, MemorySegment _OldMode) {
        var mh$ = _umask_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_umask_s", _NewMode, _OldMode);
            }
            return (int)mh$.invokeExact(_NewMode, _OldMode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _write {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_write");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _write(int _FileHandle, const void *_Buf, unsigned int _MaxCharCount)
     * }
     */
    public static FunctionDescriptor _write$descriptor() {
        return _write.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _write(int _FileHandle, const void *_Buf, unsigned int _MaxCharCount)
     * }
     */
    public static MethodHandle _write$handle() {
        return _write.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _write(int _FileHandle, const void *_Buf, unsigned int _MaxCharCount)
     * }
     */
    public static MemorySegment _write$address() {
        return _write.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _write(int _FileHandle, const void *_Buf, unsigned int _MaxCharCount)
     * }
     */
    public static int _write(int _FileHandle, MemorySegment _Buf, int _MaxCharCount) {
        var mh$ = _write.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_write", _FileHandle, _Buf, _MaxCharCount);
            }
            return (int)mh$.invokeExact(_FileHandle, _Buf, _MaxCharCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _filelengthi64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_filelengthi64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long _filelengthi64(int _FileHandle)
     * }
     */
    public static FunctionDescriptor _filelengthi64$descriptor() {
        return _filelengthi64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long _filelengthi64(int _FileHandle)
     * }
     */
    public static MethodHandle _filelengthi64$handle() {
        return _filelengthi64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long _filelengthi64(int _FileHandle)
     * }
     */
    public static MemorySegment _filelengthi64$address() {
        return _filelengthi64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long _filelengthi64(int _FileHandle)
     * }
     */
    public static long _filelengthi64(int _FileHandle) {
        var mh$ = _filelengthi64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_filelengthi64", _FileHandle);
            }
            return (long)mh$.invokeExact(_FileHandle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _findfirst32i64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_findfirst32i64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * intptr_t _findfirst32i64(const char *_FileName, struct _finddata32i64_t *_FindData)
     * }
     */
    public static FunctionDescriptor _findfirst32i64$descriptor() {
        return _findfirst32i64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * intptr_t _findfirst32i64(const char *_FileName, struct _finddata32i64_t *_FindData)
     * }
     */
    public static MethodHandle _findfirst32i64$handle() {
        return _findfirst32i64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * intptr_t _findfirst32i64(const char *_FileName, struct _finddata32i64_t *_FindData)
     * }
     */
    public static MemorySegment _findfirst32i64$address() {
        return _findfirst32i64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * intptr_t _findfirst32i64(const char *_FileName, struct _finddata32i64_t *_FindData)
     * }
     */
    public static long _findfirst32i64(MemorySegment _FileName, MemorySegment _FindData) {
        var mh$ = _findfirst32i64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_findfirst32i64", _FileName, _FindData);
            }
            return (long)mh$.invokeExact(_FileName, _FindData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _findfirst64i32 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_findfirst64i32");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * intptr_t _findfirst64i32(const char *_FileName, struct _finddata64i32_t *_FindData)
     * }
     */
    public static FunctionDescriptor _findfirst64i32$descriptor() {
        return _findfirst64i32.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * intptr_t _findfirst64i32(const char *_FileName, struct _finddata64i32_t *_FindData)
     * }
     */
    public static MethodHandle _findfirst64i32$handle() {
        return _findfirst64i32.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * intptr_t _findfirst64i32(const char *_FileName, struct _finddata64i32_t *_FindData)
     * }
     */
    public static MemorySegment _findfirst64i32$address() {
        return _findfirst64i32.ADDR;
    }

    /**
     * {@snippet lang=c :
     * intptr_t _findfirst64i32(const char *_FileName, struct _finddata64i32_t *_FindData)
     * }
     */
    public static long _findfirst64i32(MemorySegment _FileName, MemorySegment _FindData) {
        var mh$ = _findfirst64i32.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_findfirst64i32", _FileName, _FindData);
            }
            return (long)mh$.invokeExact(_FileName, _FindData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _findfirst64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_findfirst64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * intptr_t _findfirst64(const char *_FileName, struct __finddata64_t *_FindData)
     * }
     */
    public static FunctionDescriptor _findfirst64$descriptor() {
        return _findfirst64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * intptr_t _findfirst64(const char *_FileName, struct __finddata64_t *_FindData)
     * }
     */
    public static MethodHandle _findfirst64$handle() {
        return _findfirst64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * intptr_t _findfirst64(const char *_FileName, struct __finddata64_t *_FindData)
     * }
     */
    public static MemorySegment _findfirst64$address() {
        return _findfirst64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * intptr_t _findfirst64(const char *_FileName, struct __finddata64_t *_FindData)
     * }
     */
    public static long _findfirst64(MemorySegment _FileName, MemorySegment _FindData) {
        var mh$ = _findfirst64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_findfirst64", _FileName, _FindData);
            }
            return (long)mh$.invokeExact(_FileName, _FindData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _findnext32i64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_findnext32i64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _findnext32i64(intptr_t _FindHandle, struct _finddata32i64_t *_FindData)
     * }
     */
    public static FunctionDescriptor _findnext32i64$descriptor() {
        return _findnext32i64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _findnext32i64(intptr_t _FindHandle, struct _finddata32i64_t *_FindData)
     * }
     */
    public static MethodHandle _findnext32i64$handle() {
        return _findnext32i64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _findnext32i64(intptr_t _FindHandle, struct _finddata32i64_t *_FindData)
     * }
     */
    public static MemorySegment _findnext32i64$address() {
        return _findnext32i64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _findnext32i64(intptr_t _FindHandle, struct _finddata32i64_t *_FindData)
     * }
     */
    public static int _findnext32i64(long _FindHandle, MemorySegment _FindData) {
        var mh$ = _findnext32i64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_findnext32i64", _FindHandle, _FindData);
            }
            return (int)mh$.invokeExact(_FindHandle, _FindData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _findnext64i32 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_findnext64i32");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _findnext64i32(intptr_t _FindHandle, struct _finddata64i32_t *_FindData)
     * }
     */
    public static FunctionDescriptor _findnext64i32$descriptor() {
        return _findnext64i32.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _findnext64i32(intptr_t _FindHandle, struct _finddata64i32_t *_FindData)
     * }
     */
    public static MethodHandle _findnext64i32$handle() {
        return _findnext64i32.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _findnext64i32(intptr_t _FindHandle, struct _finddata64i32_t *_FindData)
     * }
     */
    public static MemorySegment _findnext64i32$address() {
        return _findnext64i32.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _findnext64i32(intptr_t _FindHandle, struct _finddata64i32_t *_FindData)
     * }
     */
    public static int _findnext64i32(long _FindHandle, MemorySegment _FindData) {
        var mh$ = _findnext64i32.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_findnext64i32", _FindHandle, _FindData);
            }
            return (int)mh$.invokeExact(_FindHandle, _FindData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _findnext64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_findnext64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _findnext64(intptr_t _FindHandle, struct __finddata64_t *_FindData)
     * }
     */
    public static FunctionDescriptor _findnext64$descriptor() {
        return _findnext64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _findnext64(intptr_t _FindHandle, struct __finddata64_t *_FindData)
     * }
     */
    public static MethodHandle _findnext64$handle() {
        return _findnext64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _findnext64(intptr_t _FindHandle, struct __finddata64_t *_FindData)
     * }
     */
    public static MemorySegment _findnext64$address() {
        return _findnext64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _findnext64(intptr_t _FindHandle, struct __finddata64_t *_FindData)
     * }
     */
    public static int _findnext64(long _FindHandle, MemorySegment _FindData) {
        var mh$ = _findnext64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_findnext64", _FindHandle, _FindData);
            }
            return (int)mh$.invokeExact(_FindHandle, _FindData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _lseeki64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_INT,
            Python_h.C_LONG_LONG,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_lseeki64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long _lseeki64(int _FileHandle, long long _Offset, int _Origin)
     * }
     */
    public static FunctionDescriptor _lseeki64$descriptor() {
        return _lseeki64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long _lseeki64(int _FileHandle, long long _Offset, int _Origin)
     * }
     */
    public static MethodHandle _lseeki64$handle() {
        return _lseeki64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long _lseeki64(int _FileHandle, long long _Offset, int _Origin)
     * }
     */
    public static MemorySegment _lseeki64$address() {
        return _lseeki64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long _lseeki64(int _FileHandle, long long _Offset, int _Origin)
     * }
     */
    public static long _lseeki64(int _FileHandle, long _Offset, int _Origin) {
        var mh$ = _lseeki64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_lseeki64", _FileHandle, _Offset, _Origin);
            }
            return (long)mh$.invokeExact(_FileHandle, _Offset, _Origin);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _telli64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_telli64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long _telli64(int _FileHandle)
     * }
     */
    public static FunctionDescriptor _telli64$descriptor() {
        return _telli64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long _telli64(int _FileHandle)
     * }
     */
    public static MethodHandle _telli64$handle() {
        return _telli64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long _telli64(int _FileHandle)
     * }
     */
    public static MemorySegment _telli64$address() {
        return _telli64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long _telli64(int _FileHandle)
     * }
     */
    public static long _telli64(int _FileHandle) {
        var mh$ = _telli64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_telli64", _FileHandle);
            }
            return (long)mh$.invokeExact(_FileHandle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _sopen_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_sopen_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _sopen_s(int *_FileHandle, const char *_FileName, int _OpenFlag, int _ShareFlag, int _PermissionMode)
     * }
     */
    public static FunctionDescriptor _sopen_s$descriptor() {
        return _sopen_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _sopen_s(int *_FileHandle, const char *_FileName, int _OpenFlag, int _ShareFlag, int _PermissionMode)
     * }
     */
    public static MethodHandle _sopen_s$handle() {
        return _sopen_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _sopen_s(int *_FileHandle, const char *_FileName, int _OpenFlag, int _ShareFlag, int _PermissionMode)
     * }
     */
    public static MemorySegment _sopen_s$address() {
        return _sopen_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _sopen_s(int *_FileHandle, const char *_FileName, int _OpenFlag, int _ShareFlag, int _PermissionMode)
     * }
     */
    public static int _sopen_s(MemorySegment _FileHandle, MemorySegment _FileName, int _OpenFlag, int _ShareFlag, int _PermissionMode) {
        var mh$ = _sopen_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_sopen_s", _FileHandle, _FileName, _OpenFlag, _ShareFlag, _PermissionMode);
            }
            return (int)mh$.invokeExact(_FileHandle, _FileName, _OpenFlag, _ShareFlag, _PermissionMode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _sopen_s_nolock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_sopen_s_nolock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _sopen_s_nolock(int *_FileHandle, const char *_FileName, int _OpenFlag, int _ShareFlag, int _PermissionMode)
     * }
     */
    public static FunctionDescriptor _sopen_s_nolock$descriptor() {
        return _sopen_s_nolock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _sopen_s_nolock(int *_FileHandle, const char *_FileName, int _OpenFlag, int _ShareFlag, int _PermissionMode)
     * }
     */
    public static MethodHandle _sopen_s_nolock$handle() {
        return _sopen_s_nolock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _sopen_s_nolock(int *_FileHandle, const char *_FileName, int _OpenFlag, int _ShareFlag, int _PermissionMode)
     * }
     */
    public static MemorySegment _sopen_s_nolock$address() {
        return _sopen_s_nolock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _sopen_s_nolock(int *_FileHandle, const char *_FileName, int _OpenFlag, int _ShareFlag, int _PermissionMode)
     * }
     */
    public static int _sopen_s_nolock(MemorySegment _FileHandle, MemorySegment _FileName, int _OpenFlag, int _ShareFlag, int _PermissionMode) {
        var mh$ = _sopen_s_nolock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_sopen_s_nolock", _FileHandle, _FileName, _OpenFlag, _ShareFlag, _PermissionMode);
            }
            return (int)mh$.invokeExact(_FileHandle, _FileName, _OpenFlag, _ShareFlag, _PermissionMode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _sopen_dispatch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_sopen_dispatch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _sopen_dispatch(const char *_FileName, int _OFlag, int _ShFlag, int _PMode, int *_PFileHandle, int _BSecure)
     * }
     */
    public static FunctionDescriptor _sopen_dispatch$descriptor() {
        return _sopen_dispatch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _sopen_dispatch(const char *_FileName, int _OFlag, int _ShFlag, int _PMode, int *_PFileHandle, int _BSecure)
     * }
     */
    public static MethodHandle _sopen_dispatch$handle() {
        return _sopen_dispatch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _sopen_dispatch(const char *_FileName, int _OFlag, int _ShFlag, int _PMode, int *_PFileHandle, int _BSecure)
     * }
     */
    public static MemorySegment _sopen_dispatch$address() {
        return _sopen_dispatch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _sopen_dispatch(const char *_FileName, int _OFlag, int _ShFlag, int _PMode, int *_PFileHandle, int _BSecure)
     * }
     */
    public static int _sopen_dispatch(MemorySegment _FileName, int _OFlag, int _ShFlag, int _PMode, MemorySegment _PFileHandle, int _BSecure) {
        var mh$ = _sopen_dispatch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_sopen_dispatch", _FileName, _OFlag, _ShFlag, _PMode, _PFileHandle, _BSecure);
            }
            return (int)mh$.invokeExact(_FileName, _OFlag, _ShFlag, _PMode, _PFileHandle, _BSecure);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int _open(const char *_FileName, int _OpenFlag, ...)
     * }
     */
    public static class _open {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_INT,
                Python_h.C_POINTER,
                Python_h.C_INT
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("_open");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private _open(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int _open(const char *_FileName, int _OpenFlag, ...)
         * }
         */
        public static _open makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new _open(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment _FileName, int _OpenFlag, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("_open", _FileName, _OpenFlag, x2);
                }
                return (int)spreader.invokeExact(_FileName, _OpenFlag, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int _sopen(const char *_FileName, int _OpenFlag, int _ShareFlag, ...)
     * }
     */
    public static class _sopen {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_INT,
                Python_h.C_POINTER,
                Python_h.C_INT,
                Python_h.C_INT
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("_sopen");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private _sopen(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int _sopen(const char *_FileName, int _OpenFlag, int _ShareFlag, ...)
         * }
         */
        public static _sopen makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new _sopen(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment _FileName, int _OpenFlag, int _ShareFlag, Object... x3) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("_sopen", _FileName, _OpenFlag, _ShareFlag, x3);
                }
                return (int)spreader.invokeExact(_FileName, _OpenFlag, _ShareFlag, x3);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class access {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("access");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int access(const char *_FileName, int _AccessMode)
     * }
     */
    public static FunctionDescriptor access$descriptor() {
        return access.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int access(const char *_FileName, int _AccessMode)
     * }
     */
    public static MethodHandle access$handle() {
        return access.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int access(const char *_FileName, int _AccessMode)
     * }
     */
    public static MemorySegment access$address() {
        return access.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int access(const char *_FileName, int _AccessMode)
     * }
     */
    public static int access(MemorySegment _FileName, int _AccessMode) {
        var mh$ = access.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("access", _FileName, _AccessMode);
            }
            return (int)mh$.invokeExact(_FileName, _AccessMode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chmod {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("chmod");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int chmod(const char *_FileName, int _AccessMode)
     * }
     */
    public static FunctionDescriptor chmod$descriptor() {
        return chmod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int chmod(const char *_FileName, int _AccessMode)
     * }
     */
    public static MethodHandle chmod$handle() {
        return chmod.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int chmod(const char *_FileName, int _AccessMode)
     * }
     */
    public static MemorySegment chmod$address() {
        return chmod.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int chmod(const char *_FileName, int _AccessMode)
     * }
     */
    public static int chmod(MemorySegment _FileName, int _AccessMode) {
        var mh$ = chmod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chmod", _FileName, _AccessMode);
            }
            return (int)mh$.invokeExact(_FileName, _AccessMode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chsize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("chsize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int chsize(int _FileHandle, long _Size)
     * }
     */
    public static FunctionDescriptor chsize$descriptor() {
        return chsize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int chsize(int _FileHandle, long _Size)
     * }
     */
    public static MethodHandle chsize$handle() {
        return chsize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int chsize(int _FileHandle, long _Size)
     * }
     */
    public static MemorySegment chsize$address() {
        return chsize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int chsize(int _FileHandle, long _Size)
     * }
     */
    public static int chsize(int _FileHandle, int _Size) {
        var mh$ = chsize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chsize", _FileHandle, _Size);
            }
            return (int)mh$.invokeExact(_FileHandle, _Size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class close {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("close");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int close(int _FileHandle)
     * }
     */
    public static FunctionDescriptor close$descriptor() {
        return close.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int close(int _FileHandle)
     * }
     */
    public static MethodHandle close$handle() {
        return close.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int close(int _FileHandle)
     * }
     */
    public static MemorySegment close$address() {
        return close.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int close(int _FileHandle)
     * }
     */
    public static int close(int _FileHandle) {
        var mh$ = close.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("close", _FileHandle);
            }
            return (int)mh$.invokeExact(_FileHandle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class creat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("creat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int creat(const char *_FileName, int _PermissionMode)
     * }
     */
    public static FunctionDescriptor creat$descriptor() {
        return creat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int creat(const char *_FileName, int _PermissionMode)
     * }
     */
    public static MethodHandle creat$handle() {
        return creat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int creat(const char *_FileName, int _PermissionMode)
     * }
     */
    public static MemorySegment creat$address() {
        return creat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int creat(const char *_FileName, int _PermissionMode)
     * }
     */
    public static int creat(MemorySegment _FileName, int _PermissionMode) {
        var mh$ = creat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("creat", _FileName, _PermissionMode);
            }
            return (int)mh$.invokeExact(_FileName, _PermissionMode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("dup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dup(int _FileHandle)
     * }
     */
    public static FunctionDescriptor dup$descriptor() {
        return dup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dup(int _FileHandle)
     * }
     */
    public static MethodHandle dup$handle() {
        return dup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dup(int _FileHandle)
     * }
     */
    public static MemorySegment dup$address() {
        return dup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dup(int _FileHandle)
     * }
     */
    public static int dup(int _FileHandle) {
        var mh$ = dup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dup", _FileHandle);
            }
            return (int)mh$.invokeExact(_FileHandle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dup2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("dup2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dup2(int _FileHandleSrc, int _FileHandleDst)
     * }
     */
    public static FunctionDescriptor dup2$descriptor() {
        return dup2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dup2(int _FileHandleSrc, int _FileHandleDst)
     * }
     */
    public static MethodHandle dup2$handle() {
        return dup2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dup2(int _FileHandleSrc, int _FileHandleDst)
     * }
     */
    public static MemorySegment dup2$address() {
        return dup2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dup2(int _FileHandleSrc, int _FileHandleDst)
     * }
     */
    public static int dup2(int _FileHandleSrc, int _FileHandleDst) {
        var mh$ = dup2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dup2", _FileHandleSrc, _FileHandleDst);
            }
            return (int)mh$.invokeExact(_FileHandleSrc, _FileHandleDst);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class eof {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("eof");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int eof(int _FileHandle)
     * }
     */
    public static FunctionDescriptor eof$descriptor() {
        return eof.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int eof(int _FileHandle)
     * }
     */
    public static MethodHandle eof$handle() {
        return eof.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int eof(int _FileHandle)
     * }
     */
    public static MemorySegment eof$address() {
        return eof.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int eof(int _FileHandle)
     * }
     */
    public static int eof(int _FileHandle) {
        var mh$ = eof.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("eof", _FileHandle);
            }
            return (int)mh$.invokeExact(_FileHandle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class filelength {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("filelength");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long filelength(int _FileHandle)
     * }
     */
    public static FunctionDescriptor filelength$descriptor() {
        return filelength.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long filelength(int _FileHandle)
     * }
     */
    public static MethodHandle filelength$handle() {
        return filelength.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long filelength(int _FileHandle)
     * }
     */
    public static MemorySegment filelength$address() {
        return filelength.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long filelength(int _FileHandle)
     * }
     */
    public static int filelength(int _FileHandle) {
        var mh$ = filelength.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("filelength", _FileHandle);
            }
            return (int)mh$.invokeExact(_FileHandle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class isatty {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("isatty");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int isatty(int _FileHandle)
     * }
     */
    public static FunctionDescriptor isatty$descriptor() {
        return isatty.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int isatty(int _FileHandle)
     * }
     */
    public static MethodHandle isatty$handle() {
        return isatty.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int isatty(int _FileHandle)
     * }
     */
    public static MemorySegment isatty$address() {
        return isatty.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int isatty(int _FileHandle)
     * }
     */
    public static int isatty(int _FileHandle) {
        var mh$ = isatty.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("isatty", _FileHandle);
            }
            return (int)mh$.invokeExact(_FileHandle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class locking {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("locking");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int locking(int _FileHandle, int _LockMode, long _NumOfBytes)
     * }
     */
    public static FunctionDescriptor locking$descriptor() {
        return locking.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int locking(int _FileHandle, int _LockMode, long _NumOfBytes)
     * }
     */
    public static MethodHandle locking$handle() {
        return locking.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int locking(int _FileHandle, int _LockMode, long _NumOfBytes)
     * }
     */
    public static MemorySegment locking$address() {
        return locking.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int locking(int _FileHandle, int _LockMode, long _NumOfBytes)
     * }
     */
    public static int locking(int _FileHandle, int _LockMode, int _NumOfBytes) {
        var mh$ = locking.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("locking", _FileHandle, _LockMode, _NumOfBytes);
            }
            return (int)mh$.invokeExact(_FileHandle, _LockMode, _NumOfBytes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lseek {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_INT,
            Python_h.C_LONG,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("lseek");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long lseek(int _FileHandle, long _Offset, int _Origin)
     * }
     */
    public static FunctionDescriptor lseek$descriptor() {
        return lseek.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long lseek(int _FileHandle, long _Offset, int _Origin)
     * }
     */
    public static MethodHandle lseek$handle() {
        return lseek.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long lseek(int _FileHandle, long _Offset, int _Origin)
     * }
     */
    public static MemorySegment lseek$address() {
        return lseek.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long lseek(int _FileHandle, long _Offset, int _Origin)
     * }
     */
    public static int lseek(int _FileHandle, int _Offset, int _Origin) {
        var mh$ = lseek.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lseek", _FileHandle, _Offset, _Origin);
            }
            return (int)mh$.invokeExact(_FileHandle, _Offset, _Origin);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mktemp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("mktemp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *mktemp(char *_TemplateName)
     * }
     */
    public static FunctionDescriptor mktemp$descriptor() {
        return mktemp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *mktemp(char *_TemplateName)
     * }
     */
    public static MethodHandle mktemp$handle() {
        return mktemp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *mktemp(char *_TemplateName)
     * }
     */
    public static MemorySegment mktemp$address() {
        return mktemp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *mktemp(char *_TemplateName)
     * }
     */
    public static MemorySegment mktemp(MemorySegment _TemplateName) {
        var mh$ = mktemp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mktemp", _TemplateName);
            }
            return (MemorySegment)mh$.invokeExact(_TemplateName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int open(const char *_FileName, int _OpenFlag, ...)
     * }
     */
    public static class open {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_INT,
                Python_h.C_POINTER,
                Python_h.C_INT
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("open");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private open(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int open(const char *_FileName, int _OpenFlag, ...)
         * }
         */
        public static open makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new open(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment _FileName, int _OpenFlag, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("open", _FileName, _OpenFlag, x2);
                }
                return (int)spreader.invokeExact(_FileName, _OpenFlag, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class read {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("read");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int read(int _FileHandle, void *_DstBuf, unsigned int _MaxCharCount)
     * }
     */
    public static FunctionDescriptor read$descriptor() {
        return read.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int read(int _FileHandle, void *_DstBuf, unsigned int _MaxCharCount)
     * }
     */
    public static MethodHandle read$handle() {
        return read.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int read(int _FileHandle, void *_DstBuf, unsigned int _MaxCharCount)
     * }
     */
    public static MemorySegment read$address() {
        return read.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int read(int _FileHandle, void *_DstBuf, unsigned int _MaxCharCount)
     * }
     */
    public static int read(int _FileHandle, MemorySegment _DstBuf, int _MaxCharCount) {
        var mh$ = read.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("read", _FileHandle, _DstBuf, _MaxCharCount);
            }
            return (int)mh$.invokeExact(_FileHandle, _DstBuf, _MaxCharCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setmode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("setmode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setmode(int _FileHandle, int _Mode)
     * }
     */
    public static FunctionDescriptor setmode$descriptor() {
        return setmode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setmode(int _FileHandle, int _Mode)
     * }
     */
    public static MethodHandle setmode$handle() {
        return setmode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setmode(int _FileHandle, int _Mode)
     * }
     */
    public static MemorySegment setmode$address() {
        return setmode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setmode(int _FileHandle, int _Mode)
     * }
     */
    public static int setmode(int _FileHandle, int _Mode) {
        var mh$ = setmode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setmode", _FileHandle, _Mode);
            }
            return (int)mh$.invokeExact(_FileHandle, _Mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int sopen(const char *_FileName, int _OpenFlag, int _ShareFlag, ...)
     * }
     */
    public static class sopen {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_INT,
                Python_h.C_POINTER,
                Python_h.C_INT,
                Python_h.C_INT
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("sopen");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private sopen(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int sopen(const char *_FileName, int _OpenFlag, int _ShareFlag, ...)
         * }
         */
        public static sopen makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new sopen(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment _FileName, int _OpenFlag, int _ShareFlag, Object... x3) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("sopen", _FileName, _OpenFlag, _ShareFlag, x3);
                }
                return (int)spreader.invokeExact(_FileName, _OpenFlag, _ShareFlag, x3);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class tell {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("tell");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long tell(int _FileHandle)
     * }
     */
    public static FunctionDescriptor tell$descriptor() {
        return tell.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long tell(int _FileHandle)
     * }
     */
    public static MethodHandle tell$handle() {
        return tell.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long tell(int _FileHandle)
     * }
     */
    public static MemorySegment tell$address() {
        return tell.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long tell(int _FileHandle)
     * }
     */
    public static int tell(int _FileHandle) {
        var mh$ = tell.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tell", _FileHandle);
            }
            return (int)mh$.invokeExact(_FileHandle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class umask {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("umask");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int umask(int _Mode)
     * }
     */
    public static FunctionDescriptor umask$descriptor() {
        return umask.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int umask(int _Mode)
     * }
     */
    public static MethodHandle umask$handle() {
        return umask.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int umask(int _Mode)
     * }
     */
    public static MemorySegment umask$address() {
        return umask.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int umask(int _Mode)
     * }
     */
    public static int umask(int _Mode) {
        var mh$ = umask.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("umask", _Mode);
            }
            return (int)mh$.invokeExact(_Mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class unlink {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("unlink");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int unlink(const char *_FileName)
     * }
     */
    public static FunctionDescriptor unlink$descriptor() {
        return unlink.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int unlink(const char *_FileName)
     * }
     */
    public static MethodHandle unlink$handle() {
        return unlink.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int unlink(const char *_FileName)
     * }
     */
    public static MemorySegment unlink$address() {
        return unlink.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int unlink(const char *_FileName)
     * }
     */
    public static int unlink(MemorySegment _FileName) {
        var mh$ = unlink.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("unlink", _FileName);
            }
            return (int)mh$.invokeExact(_FileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class write {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("write");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int write(int _FileHandle, const void *_Buf, unsigned int _MaxCharCount)
     * }
     */
    public static FunctionDescriptor write$descriptor() {
        return write.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int write(int _FileHandle, const void *_Buf, unsigned int _MaxCharCount)
     * }
     */
    public static MethodHandle write$handle() {
        return write.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int write(int _FileHandle, const void *_Buf, unsigned int _MaxCharCount)
     * }
     */
    public static MemorySegment write$address() {
        return write.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int write(int _FileHandle, const void *_Buf, unsigned int _MaxCharCount)
     * }
     */
    public static int write(int _FileHandle, MemorySegment _Buf, int _MaxCharCount) {
        var mh$ = write.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("write", _FileHandle, _Buf, _MaxCharCount);
            }
            return (int)mh$.invokeExact(_FileHandle, _Buf, _MaxCharCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef long long Py_ssize_t
     * }
     */
    public static final OfLong Py_ssize_t = Python_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef int pid_t
     * }
     */
    public static final OfInt pid_t = Python_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long long POINTER_64_INT
     * }
     */
    public static final OfLong POINTER_64_INT = Python_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef signed char INT8
     * }
     */
    public static final OfByte INT8 = Python_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef signed char *PINT8
     * }
     */
    public static final AddressLayout PINT8 = Python_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef short INT16
     * }
     */
    public static final OfShort INT16 = Python_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef short *PINT16
     * }
     */
    public static final AddressLayout PINT16 = Python_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef int INT32
     * }
     */
    public static final OfInt INT32 = Python_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int *PINT32
     * }
     */
    public static final AddressLayout PINT32 = Python_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef long long INT64
     * }
     */
    public static final OfLong INT64 = Python_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef long long *PINT64
     * }
     */
    public static final AddressLayout PINT64 = Python_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef unsigned char UINT8
     * }
     */
    public static final OfByte UINT8 = Python_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned char *PUINT8
     * }
     */
    public static final AddressLayout PUINT8 = Python_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef unsigned short UINT16
     * }
     */
    public static final OfShort UINT16 = Python_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned short *PUINT16
     * }
     */
    public static final AddressLayout PUINT16 = Python_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef unsigned int UINT32
     * }
     */
    public static final OfInt UINT32 = Python_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int *PUINT32
     * }
     */
    public static final AddressLayout PUINT32 = Python_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef unsigned long long UINT64
     * }
     */
    public static final OfLong UINT64 = Python_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long long *PUINT64
     * }
     */
    public static final AddressLayout PUINT64 = Python_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef int LONG32
     * }
     */
    public static final OfInt LONG32 = Python_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int *PLONG32
     * }
     */
    public static final AddressLayout PLONG32 = Python_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef unsigned int ULONG32
     * }
     */
    public static final OfInt ULONG32 = Python_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int *PULONG32
     * }
     */
    public static final AddressLayout PULONG32 = Python_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef unsigned int DWORD32
     * }
     */
    public static final OfInt DWORD32 = Python_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int *PDWORD32
     * }
     */
    public static final AddressLayout PDWORD32 = Python_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef long long INT_PTR
     * }
     */
    public static final OfLong INT_PTR = Python_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef long long *PINT_PTR
     * }
     */
    public static final AddressLayout PINT_PTR = Python_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef unsigned long long UINT_PTR
     * }
     */
    public static final OfLong UINT_PTR = Python_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long long *PUINT_PTR
     * }
     */
    public static final AddressLayout PUINT_PTR = Python_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef long long LONG_PTR
     * }
     */
    public static final OfLong LONG_PTR = Python_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef long long *PLONG_PTR
     * }
     */
    public static final AddressLayout PLONG_PTR = Python_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef unsigned long long ULONG_PTR
     * }
     */
    public static final OfLong ULONG_PTR = Python_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long long *PULONG_PTR
     * }
     */
    public static final AddressLayout PULONG_PTR = Python_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef long long SHANDLE_PTR
     * }
     */
    public static final OfLong SHANDLE_PTR = Python_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long long HANDLE_PTR
     * }
     */
    public static final OfLong HANDLE_PTR = Python_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int UHALF_PTR
     * }
     */
    public static final OfInt UHALF_PTR = Python_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int *PUHALF_PTR
     * }
     */
    public static final AddressLayout PUHALF_PTR = Python_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef int HALF_PTR
     * }
     */
    public static final OfInt HALF_PTR = Python_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int *PHALF_PTR
     * }
     */
    public static final AddressLayout PHALF_PTR = Python_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef ULONG_PTR SIZE_T
     * }
     */
    public static final OfLong SIZE_T$0 = Python_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef ULONG_PTR *PSIZE_T
     * }
     */
    public static final AddressLayout PSIZE_T = Python_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LONG_PTR SSIZE_T
     * }
     */
    public static final OfLong SSIZE_T = Python_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef LONG_PTR *PSSIZE_T
     * }
     */
    public static final AddressLayout PSSIZE_T = Python_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef ULONG_PTR DWORD_PTR
     * }
     */
    public static final OfLong DWORD_PTR = Python_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef ULONG_PTR *PDWORD_PTR
     * }
     */
    public static final AddressLayout PDWORD_PTR = Python_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef long long LONG64
     * }
     */
    public static final OfLong LONG64 = Python_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef long long *PLONG64
     * }
     */
    public static final AddressLayout PLONG64 = Python_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef unsigned long long ULONG64
     * }
     */
    public static final OfLong ULONG64 = Python_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long long *PULONG64
     * }
     */
    public static final AddressLayout PULONG64 = Python_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef unsigned long long DWORD64
     * }
     */
    public static final OfLong DWORD64 = Python_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long long *PDWORD64
     * }
     */
    public static final AddressLayout PDWORD64 = Python_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef ULONG_PTR KAFFINITY
     * }
     */
    public static final OfLong KAFFINITY = Python_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef KAFFINITY *PKAFFINITY
     * }
     */
    public static final AddressLayout PKAFFINITY = Python_h.C_POINTER;

    private static class __acrt_iob_func {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("__acrt_iob_func");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FILE *__acrt_iob_func(unsigned int _Ix)
     * }
     */
    public static FunctionDescriptor __acrt_iob_func$descriptor() {
        return __acrt_iob_func.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FILE *__acrt_iob_func(unsigned int _Ix)
     * }
     */
    public static MethodHandle __acrt_iob_func$handle() {
        return __acrt_iob_func.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FILE *__acrt_iob_func(unsigned int _Ix)
     * }
     */
    public static MemorySegment __acrt_iob_func$address() {
        return __acrt_iob_func.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FILE *__acrt_iob_func(unsigned int _Ix)
     * }
     */
    public static MemorySegment __acrt_iob_func(int _Ix) {
        var mh$ = __acrt_iob_func.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__acrt_iob_func", _Ix);
            }
            return (MemorySegment)mh$.invokeExact(_Ix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fgetwc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_SHORT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fgetwc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wint_t fgetwc(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor fgetwc$descriptor() {
        return fgetwc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wint_t fgetwc(FILE *_Stream)
     * }
     */
    public static MethodHandle fgetwc$handle() {
        return fgetwc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wint_t fgetwc(FILE *_Stream)
     * }
     */
    public static MemorySegment fgetwc$address() {
        return fgetwc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wint_t fgetwc(FILE *_Stream)
     * }
     */
    public static short fgetwc(MemorySegment _Stream) {
        var mh$ = fgetwc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fgetwc", _Stream);
            }
            return (short)mh$.invokeExact(_Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fgetwchar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_SHORT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_fgetwchar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wint_t _fgetwchar()
     * }
     */
    public static FunctionDescriptor _fgetwchar$descriptor() {
        return _fgetwchar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wint_t _fgetwchar()
     * }
     */
    public static MethodHandle _fgetwchar$handle() {
        return _fgetwchar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wint_t _fgetwchar()
     * }
     */
    public static MemorySegment _fgetwchar$address() {
        return _fgetwchar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wint_t _fgetwchar()
     * }
     */
    public static short _fgetwchar() {
        var mh$ = _fgetwchar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fgetwchar");
            }
            return (short)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fputwc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_SHORT,
            Python_h.C_SHORT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fputwc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wint_t fputwc(wchar_t _Character, FILE *_Stream)
     * }
     */
    public static FunctionDescriptor fputwc$descriptor() {
        return fputwc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wint_t fputwc(wchar_t _Character, FILE *_Stream)
     * }
     */
    public static MethodHandle fputwc$handle() {
        return fputwc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wint_t fputwc(wchar_t _Character, FILE *_Stream)
     * }
     */
    public static MemorySegment fputwc$address() {
        return fputwc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wint_t fputwc(wchar_t _Character, FILE *_Stream)
     * }
     */
    public static short fputwc(short _Character, MemorySegment _Stream) {
        var mh$ = fputwc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fputwc", _Character, _Stream);
            }
            return (short)mh$.invokeExact(_Character, _Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fputwchar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_SHORT,
            Python_h.C_SHORT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_fputwchar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wint_t _fputwchar(wchar_t _Character)
     * }
     */
    public static FunctionDescriptor _fputwchar$descriptor() {
        return _fputwchar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wint_t _fputwchar(wchar_t _Character)
     * }
     */
    public static MethodHandle _fputwchar$handle() {
        return _fputwchar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wint_t _fputwchar(wchar_t _Character)
     * }
     */
    public static MemorySegment _fputwchar$address() {
        return _fputwchar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wint_t _fputwchar(wchar_t _Character)
     * }
     */
    public static short _fputwchar(short _Character) {
        var mh$ = _fputwchar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fputwchar", _Character);
            }
            return (short)mh$.invokeExact(_Character);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getwc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_SHORT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("getwc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wint_t getwc(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor getwc$descriptor() {
        return getwc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wint_t getwc(FILE *_Stream)
     * }
     */
    public static MethodHandle getwc$handle() {
        return getwc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wint_t getwc(FILE *_Stream)
     * }
     */
    public static MemorySegment getwc$address() {
        return getwc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wint_t getwc(FILE *_Stream)
     * }
     */
    public static short getwc(MemorySegment _Stream) {
        var mh$ = getwc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getwc", _Stream);
            }
            return (short)mh$.invokeExact(_Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getwchar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_SHORT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("getwchar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wint_t getwchar()
     * }
     */
    public static FunctionDescriptor getwchar$descriptor() {
        return getwchar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wint_t getwchar()
     * }
     */
    public static MethodHandle getwchar$handle() {
        return getwchar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wint_t getwchar()
     * }
     */
    public static MemorySegment getwchar$address() {
        return getwchar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wint_t getwchar()
     * }
     */
    public static short getwchar() {
        var mh$ = getwchar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getwchar");
            }
            return (short)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fgetws {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fgetws");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *fgetws(wchar_t *_Buffer, int _BufferCount, FILE *_Stream)
     * }
     */
    public static FunctionDescriptor fgetws$descriptor() {
        return fgetws.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *fgetws(wchar_t *_Buffer, int _BufferCount, FILE *_Stream)
     * }
     */
    public static MethodHandle fgetws$handle() {
        return fgetws.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *fgetws(wchar_t *_Buffer, int _BufferCount, FILE *_Stream)
     * }
     */
    public static MemorySegment fgetws$address() {
        return fgetws.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *fgetws(wchar_t *_Buffer, int _BufferCount, FILE *_Stream)
     * }
     */
    public static MemorySegment fgetws(MemorySegment _Buffer, int _BufferCount, MemorySegment _Stream) {
        var mh$ = fgetws.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fgetws", _Buffer, _BufferCount, _Stream);
            }
            return (MemorySegment)mh$.invokeExact(_Buffer, _BufferCount, _Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fputws {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fputws");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fputws(const wchar_t *_Buffer, FILE *_Stream)
     * }
     */
    public static FunctionDescriptor fputws$descriptor() {
        return fputws.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fputws(const wchar_t *_Buffer, FILE *_Stream)
     * }
     */
    public static MethodHandle fputws$handle() {
        return fputws.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fputws(const wchar_t *_Buffer, FILE *_Stream)
     * }
     */
    public static MemorySegment fputws$address() {
        return fputws.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fputws(const wchar_t *_Buffer, FILE *_Stream)
     * }
     */
    public static int fputws(MemorySegment _Buffer, MemorySegment _Stream) {
        var mh$ = fputws.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fputws", _Buffer, _Stream);
            }
            return (int)mh$.invokeExact(_Buffer, _Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _getws_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_getws_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *_getws_s(wchar_t *_Buffer, size_t _BufferCount)
     * }
     */
    public static FunctionDescriptor _getws_s$descriptor() {
        return _getws_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *_getws_s(wchar_t *_Buffer, size_t _BufferCount)
     * }
     */
    public static MethodHandle _getws_s$handle() {
        return _getws_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *_getws_s(wchar_t *_Buffer, size_t _BufferCount)
     * }
     */
    public static MemorySegment _getws_s$address() {
        return _getws_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *_getws_s(wchar_t *_Buffer, size_t _BufferCount)
     * }
     */
    public static MemorySegment _getws_s(MemorySegment _Buffer, long _BufferCount) {
        var mh$ = _getws_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_getws_s", _Buffer, _BufferCount);
            }
            return (MemorySegment)mh$.invokeExact(_Buffer, _BufferCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putwc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_SHORT,
            Python_h.C_SHORT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("putwc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wint_t putwc(wchar_t _Character, FILE *_Stream)
     * }
     */
    public static FunctionDescriptor putwc$descriptor() {
        return putwc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wint_t putwc(wchar_t _Character, FILE *_Stream)
     * }
     */
    public static MethodHandle putwc$handle() {
        return putwc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wint_t putwc(wchar_t _Character, FILE *_Stream)
     * }
     */
    public static MemorySegment putwc$address() {
        return putwc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wint_t putwc(wchar_t _Character, FILE *_Stream)
     * }
     */
    public static short putwc(short _Character, MemorySegment _Stream) {
        var mh$ = putwc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putwc", _Character, _Stream);
            }
            return (short)mh$.invokeExact(_Character, _Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putwchar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_SHORT,
            Python_h.C_SHORT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("putwchar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wint_t putwchar(wchar_t _Character)
     * }
     */
    public static FunctionDescriptor putwchar$descriptor() {
        return putwchar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wint_t putwchar(wchar_t _Character)
     * }
     */
    public static MethodHandle putwchar$handle() {
        return putwchar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wint_t putwchar(wchar_t _Character)
     * }
     */
    public static MemorySegment putwchar$address() {
        return putwchar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wint_t putwchar(wchar_t _Character)
     * }
     */
    public static short putwchar(short _Character) {
        var mh$ = putwchar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putwchar", _Character);
            }
            return (short)mh$.invokeExact(_Character);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _putws {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_putws");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _putws(const wchar_t *_Buffer)
     * }
     */
    public static FunctionDescriptor _putws$descriptor() {
        return _putws.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _putws(const wchar_t *_Buffer)
     * }
     */
    public static MethodHandle _putws$handle() {
        return _putws.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _putws(const wchar_t *_Buffer)
     * }
     */
    public static MemorySegment _putws$address() {
        return _putws.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _putws(const wchar_t *_Buffer)
     * }
     */
    public static int _putws(MemorySegment _Buffer) {
        var mh$ = _putws.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_putws", _Buffer);
            }
            return (int)mh$.invokeExact(_Buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ungetwc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_SHORT,
            Python_h.C_SHORT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("ungetwc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wint_t ungetwc(wint_t _Character, FILE *_Stream)
     * }
     */
    public static FunctionDescriptor ungetwc$descriptor() {
        return ungetwc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wint_t ungetwc(wint_t _Character, FILE *_Stream)
     * }
     */
    public static MethodHandle ungetwc$handle() {
        return ungetwc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wint_t ungetwc(wint_t _Character, FILE *_Stream)
     * }
     */
    public static MemorySegment ungetwc$address() {
        return ungetwc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wint_t ungetwc(wint_t _Character, FILE *_Stream)
     * }
     */
    public static short ungetwc(short _Character, MemorySegment _Stream) {
        var mh$ = ungetwc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ungetwc", _Character, _Stream);
            }
            return (short)mh$.invokeExact(_Character, _Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wfdopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wfdopen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FILE *_wfdopen(int _FileHandle, const wchar_t *_Mode)
     * }
     */
    public static FunctionDescriptor _wfdopen$descriptor() {
        return _wfdopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FILE *_wfdopen(int _FileHandle, const wchar_t *_Mode)
     * }
     */
    public static MethodHandle _wfdopen$handle() {
        return _wfdopen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FILE *_wfdopen(int _FileHandle, const wchar_t *_Mode)
     * }
     */
    public static MemorySegment _wfdopen$address() {
        return _wfdopen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FILE *_wfdopen(int _FileHandle, const wchar_t *_Mode)
     * }
     */
    public static MemorySegment _wfdopen(int _FileHandle, MemorySegment _Mode) {
        var mh$ = _wfdopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wfdopen", _FileHandle, _Mode);
            }
            return (MemorySegment)mh$.invokeExact(_FileHandle, _Mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wfopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wfopen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FILE *_wfopen(const wchar_t *_FileName, const wchar_t *_Mode)
     * }
     */
    public static FunctionDescriptor _wfopen$descriptor() {
        return _wfopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FILE *_wfopen(const wchar_t *_FileName, const wchar_t *_Mode)
     * }
     */
    public static MethodHandle _wfopen$handle() {
        return _wfopen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FILE *_wfopen(const wchar_t *_FileName, const wchar_t *_Mode)
     * }
     */
    public static MemorySegment _wfopen$address() {
        return _wfopen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FILE *_wfopen(const wchar_t *_FileName, const wchar_t *_Mode)
     * }
     */
    public static MemorySegment _wfopen(MemorySegment _FileName, MemorySegment _Mode) {
        var mh$ = _wfopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wfopen", _FileName, _Mode);
            }
            return (MemorySegment)mh$.invokeExact(_FileName, _Mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wfopen_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wfopen_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _wfopen_s(FILE **_Stream, const wchar_t *_FileName, const wchar_t *_Mode)
     * }
     */
    public static FunctionDescriptor _wfopen_s$descriptor() {
        return _wfopen_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _wfopen_s(FILE **_Stream, const wchar_t *_FileName, const wchar_t *_Mode)
     * }
     */
    public static MethodHandle _wfopen_s$handle() {
        return _wfopen_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _wfopen_s(FILE **_Stream, const wchar_t *_FileName, const wchar_t *_Mode)
     * }
     */
    public static MemorySegment _wfopen_s$address() {
        return _wfopen_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _wfopen_s(FILE **_Stream, const wchar_t *_FileName, const wchar_t *_Mode)
     * }
     */
    public static int _wfopen_s(MemorySegment _Stream, MemorySegment _FileName, MemorySegment _Mode) {
        var mh$ = _wfopen_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wfopen_s", _Stream, _FileName, _Mode);
            }
            return (int)mh$.invokeExact(_Stream, _FileName, _Mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wfreopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wfreopen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FILE *_wfreopen(const wchar_t *_FileName, const wchar_t *_Mode, FILE *_OldStream)
     * }
     */
    public static FunctionDescriptor _wfreopen$descriptor() {
        return _wfreopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FILE *_wfreopen(const wchar_t *_FileName, const wchar_t *_Mode, FILE *_OldStream)
     * }
     */
    public static MethodHandle _wfreopen$handle() {
        return _wfreopen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FILE *_wfreopen(const wchar_t *_FileName, const wchar_t *_Mode, FILE *_OldStream)
     * }
     */
    public static MemorySegment _wfreopen$address() {
        return _wfreopen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FILE *_wfreopen(const wchar_t *_FileName, const wchar_t *_Mode, FILE *_OldStream)
     * }
     */
    public static MemorySegment _wfreopen(MemorySegment _FileName, MemorySegment _Mode, MemorySegment _OldStream) {
        var mh$ = _wfreopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wfreopen", _FileName, _Mode, _OldStream);
            }
            return (MemorySegment)mh$.invokeExact(_FileName, _Mode, _OldStream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wfreopen_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wfreopen_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _wfreopen_s(FILE **_Stream, const wchar_t *_FileName, const wchar_t *_Mode, FILE *_OldStream)
     * }
     */
    public static FunctionDescriptor _wfreopen_s$descriptor() {
        return _wfreopen_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _wfreopen_s(FILE **_Stream, const wchar_t *_FileName, const wchar_t *_Mode, FILE *_OldStream)
     * }
     */
    public static MethodHandle _wfreopen_s$handle() {
        return _wfreopen_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _wfreopen_s(FILE **_Stream, const wchar_t *_FileName, const wchar_t *_Mode, FILE *_OldStream)
     * }
     */
    public static MemorySegment _wfreopen_s$address() {
        return _wfreopen_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _wfreopen_s(FILE **_Stream, const wchar_t *_FileName, const wchar_t *_Mode, FILE *_OldStream)
     * }
     */
    public static int _wfreopen_s(MemorySegment _Stream, MemorySegment _FileName, MemorySegment _Mode, MemorySegment _OldStream) {
        var mh$ = _wfreopen_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wfreopen_s", _Stream, _FileName, _Mode, _OldStream);
            }
            return (int)mh$.invokeExact(_Stream, _FileName, _Mode, _OldStream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wfsopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wfsopen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FILE *_wfsopen(const wchar_t *_FileName, const wchar_t *_Mode, int _ShFlag)
     * }
     */
    public static FunctionDescriptor _wfsopen$descriptor() {
        return _wfsopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FILE *_wfsopen(const wchar_t *_FileName, const wchar_t *_Mode, int _ShFlag)
     * }
     */
    public static MethodHandle _wfsopen$handle() {
        return _wfsopen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FILE *_wfsopen(const wchar_t *_FileName, const wchar_t *_Mode, int _ShFlag)
     * }
     */
    public static MemorySegment _wfsopen$address() {
        return _wfsopen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FILE *_wfsopen(const wchar_t *_FileName, const wchar_t *_Mode, int _ShFlag)
     * }
     */
    public static MemorySegment _wfsopen(MemorySegment _FileName, MemorySegment _Mode, int _ShFlag) {
        var mh$ = _wfsopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wfsopen", _FileName, _Mode, _ShFlag);
            }
            return (MemorySegment)mh$.invokeExact(_FileName, _Mode, _ShFlag);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wperror {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wperror");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _wperror(const wchar_t *_ErrorMessage)
     * }
     */
    public static FunctionDescriptor _wperror$descriptor() {
        return _wperror.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _wperror(const wchar_t *_ErrorMessage)
     * }
     */
    public static MethodHandle _wperror$handle() {
        return _wperror.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _wperror(const wchar_t *_ErrorMessage)
     * }
     */
    public static MemorySegment _wperror$address() {
        return _wperror.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _wperror(const wchar_t *_ErrorMessage)
     * }
     */
    public static void _wperror(MemorySegment _ErrorMessage) {
        var mh$ = _wperror.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wperror", _ErrorMessage);
            }
            mh$.invokeExact(_ErrorMessage);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wpopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wpopen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FILE *_wpopen(const wchar_t *_Command, const wchar_t *_Mode)
     * }
     */
    public static FunctionDescriptor _wpopen$descriptor() {
        return _wpopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FILE *_wpopen(const wchar_t *_Command, const wchar_t *_Mode)
     * }
     */
    public static MethodHandle _wpopen$handle() {
        return _wpopen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FILE *_wpopen(const wchar_t *_Command, const wchar_t *_Mode)
     * }
     */
    public static MemorySegment _wpopen$address() {
        return _wpopen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FILE *_wpopen(const wchar_t *_Command, const wchar_t *_Mode)
     * }
     */
    public static MemorySegment _wpopen(MemorySegment _Command, MemorySegment _Mode) {
        var mh$ = _wpopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wpopen", _Command, _Mode);
            }
            return (MemorySegment)mh$.invokeExact(_Command, _Mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wremove {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wremove");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _wremove(const wchar_t *_FileName)
     * }
     */
    public static FunctionDescriptor _wremove$descriptor() {
        return _wremove.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _wremove(const wchar_t *_FileName)
     * }
     */
    public static MethodHandle _wremove$handle() {
        return _wremove.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _wremove(const wchar_t *_FileName)
     * }
     */
    public static MemorySegment _wremove$address() {
        return _wremove.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _wremove(const wchar_t *_FileName)
     * }
     */
    public static int _wremove(MemorySegment _FileName) {
        var mh$ = _wremove.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wremove", _FileName);
            }
            return (int)mh$.invokeExact(_FileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wtempnam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wtempnam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *_wtempnam(const wchar_t *_Directory, const wchar_t *_FilePrefix)
     * }
     */
    public static FunctionDescriptor _wtempnam$descriptor() {
        return _wtempnam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *_wtempnam(const wchar_t *_Directory, const wchar_t *_FilePrefix)
     * }
     */
    public static MethodHandle _wtempnam$handle() {
        return _wtempnam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *_wtempnam(const wchar_t *_Directory, const wchar_t *_FilePrefix)
     * }
     */
    public static MemorySegment _wtempnam$address() {
        return _wtempnam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *_wtempnam(const wchar_t *_Directory, const wchar_t *_FilePrefix)
     * }
     */
    public static MemorySegment _wtempnam(MemorySegment _Directory, MemorySegment _FilePrefix) {
        var mh$ = _wtempnam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wtempnam", _Directory, _FilePrefix);
            }
            return (MemorySegment)mh$.invokeExact(_Directory, _FilePrefix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wtmpnam_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wtmpnam_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _wtmpnam_s(wchar_t *_Buffer, size_t _BufferCount)
     * }
     */
    public static FunctionDescriptor _wtmpnam_s$descriptor() {
        return _wtmpnam_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _wtmpnam_s(wchar_t *_Buffer, size_t _BufferCount)
     * }
     */
    public static MethodHandle _wtmpnam_s$handle() {
        return _wtmpnam_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _wtmpnam_s(wchar_t *_Buffer, size_t _BufferCount)
     * }
     */
    public static MemorySegment _wtmpnam_s$address() {
        return _wtmpnam_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _wtmpnam_s(wchar_t *_Buffer, size_t _BufferCount)
     * }
     */
    public static int _wtmpnam_s(MemorySegment _Buffer, long _BufferCount) {
        var mh$ = _wtmpnam_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wtmpnam_s", _Buffer, _BufferCount);
            }
            return (int)mh$.invokeExact(_Buffer, _BufferCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wtmpnam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wtmpnam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *_wtmpnam(wchar_t *_Buffer)
     * }
     */
    public static FunctionDescriptor _wtmpnam$descriptor() {
        return _wtmpnam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *_wtmpnam(wchar_t *_Buffer)
     * }
     */
    public static MethodHandle _wtmpnam$handle() {
        return _wtmpnam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *_wtmpnam(wchar_t *_Buffer)
     * }
     */
    public static MemorySegment _wtmpnam$address() {
        return _wtmpnam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *_wtmpnam(wchar_t *_Buffer)
     * }
     */
    public static MemorySegment _wtmpnam(MemorySegment _Buffer) {
        var mh$ = _wtmpnam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wtmpnam", _Buffer);
            }
            return (MemorySegment)mh$.invokeExact(_Buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fgetwc_nolock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_SHORT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_fgetwc_nolock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wint_t _fgetwc_nolock(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor _fgetwc_nolock$descriptor() {
        return _fgetwc_nolock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wint_t _fgetwc_nolock(FILE *_Stream)
     * }
     */
    public static MethodHandle _fgetwc_nolock$handle() {
        return _fgetwc_nolock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wint_t _fgetwc_nolock(FILE *_Stream)
     * }
     */
    public static MemorySegment _fgetwc_nolock$address() {
        return _fgetwc_nolock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wint_t _fgetwc_nolock(FILE *_Stream)
     * }
     */
    public static short _fgetwc_nolock(MemorySegment _Stream) {
        var mh$ = _fgetwc_nolock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fgetwc_nolock", _Stream);
            }
            return (short)mh$.invokeExact(_Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fputwc_nolock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_SHORT,
            Python_h.C_SHORT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_fputwc_nolock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wint_t _fputwc_nolock(wchar_t _Character, FILE *_Stream)
     * }
     */
    public static FunctionDescriptor _fputwc_nolock$descriptor() {
        return _fputwc_nolock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wint_t _fputwc_nolock(wchar_t _Character, FILE *_Stream)
     * }
     */
    public static MethodHandle _fputwc_nolock$handle() {
        return _fputwc_nolock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wint_t _fputwc_nolock(wchar_t _Character, FILE *_Stream)
     * }
     */
    public static MemorySegment _fputwc_nolock$address() {
        return _fputwc_nolock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wint_t _fputwc_nolock(wchar_t _Character, FILE *_Stream)
     * }
     */
    public static short _fputwc_nolock(short _Character, MemorySegment _Stream) {
        var mh$ = _fputwc_nolock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fputwc_nolock", _Character, _Stream);
            }
            return (short)mh$.invokeExact(_Character, _Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _getwc_nolock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_SHORT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_getwc_nolock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wint_t _getwc_nolock(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor _getwc_nolock$descriptor() {
        return _getwc_nolock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wint_t _getwc_nolock(FILE *_Stream)
     * }
     */
    public static MethodHandle _getwc_nolock$handle() {
        return _getwc_nolock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wint_t _getwc_nolock(FILE *_Stream)
     * }
     */
    public static MemorySegment _getwc_nolock$address() {
        return _getwc_nolock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wint_t _getwc_nolock(FILE *_Stream)
     * }
     */
    public static short _getwc_nolock(MemorySegment _Stream) {
        var mh$ = _getwc_nolock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_getwc_nolock", _Stream);
            }
            return (short)mh$.invokeExact(_Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _putwc_nolock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_SHORT,
            Python_h.C_SHORT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_putwc_nolock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wint_t _putwc_nolock(wchar_t _Character, FILE *_Stream)
     * }
     */
    public static FunctionDescriptor _putwc_nolock$descriptor() {
        return _putwc_nolock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wint_t _putwc_nolock(wchar_t _Character, FILE *_Stream)
     * }
     */
    public static MethodHandle _putwc_nolock$handle() {
        return _putwc_nolock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wint_t _putwc_nolock(wchar_t _Character, FILE *_Stream)
     * }
     */
    public static MemorySegment _putwc_nolock$address() {
        return _putwc_nolock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wint_t _putwc_nolock(wchar_t _Character, FILE *_Stream)
     * }
     */
    public static short _putwc_nolock(short _Character, MemorySegment _Stream) {
        var mh$ = _putwc_nolock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_putwc_nolock", _Character, _Stream);
            }
            return (short)mh$.invokeExact(_Character, _Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ungetwc_nolock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_SHORT,
            Python_h.C_SHORT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_ungetwc_nolock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wint_t _ungetwc_nolock(wint_t _Character, FILE *_Stream)
     * }
     */
    public static FunctionDescriptor _ungetwc_nolock$descriptor() {
        return _ungetwc_nolock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wint_t _ungetwc_nolock(wint_t _Character, FILE *_Stream)
     * }
     */
    public static MethodHandle _ungetwc_nolock$handle() {
        return _ungetwc_nolock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wint_t _ungetwc_nolock(wint_t _Character, FILE *_Stream)
     * }
     */
    public static MemorySegment _ungetwc_nolock$address() {
        return _ungetwc_nolock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wint_t _ungetwc_nolock(wint_t _Character, FILE *_Stream)
     * }
     */
    public static short _ungetwc_nolock(short _Character, MemorySegment _Stream) {
        var mh$ = _ungetwc_nolock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ungetwc_nolock", _Character, _Stream);
            }
            return (short)mh$.invokeExact(_Character, _Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __stdio_common_vfwprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("__stdio_common_vfwprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __stdio_common_vfwprintf(unsigned long long _Options, FILE *_Stream, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static FunctionDescriptor __stdio_common_vfwprintf$descriptor() {
        return __stdio_common_vfwprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __stdio_common_vfwprintf(unsigned long long _Options, FILE *_Stream, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MethodHandle __stdio_common_vfwprintf$handle() {
        return __stdio_common_vfwprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __stdio_common_vfwprintf(unsigned long long _Options, FILE *_Stream, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MemorySegment __stdio_common_vfwprintf$address() {
        return __stdio_common_vfwprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __stdio_common_vfwprintf(unsigned long long _Options, FILE *_Stream, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static int __stdio_common_vfwprintf(long _Options, MemorySegment _Stream, MemorySegment _Format, MemorySegment _Locale, MemorySegment _ArgList) {
        var mh$ = __stdio_common_vfwprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__stdio_common_vfwprintf", _Options, _Stream, _Format, _Locale, _ArgList);
            }
            return (int)mh$.invokeExact(_Options, _Stream, _Format, _Locale, _ArgList);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __stdio_common_vfwprintf_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("__stdio_common_vfwprintf_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __stdio_common_vfwprintf_s(unsigned long long _Options, FILE *_Stream, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static FunctionDescriptor __stdio_common_vfwprintf_s$descriptor() {
        return __stdio_common_vfwprintf_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __stdio_common_vfwprintf_s(unsigned long long _Options, FILE *_Stream, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MethodHandle __stdio_common_vfwprintf_s$handle() {
        return __stdio_common_vfwprintf_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __stdio_common_vfwprintf_s(unsigned long long _Options, FILE *_Stream, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MemorySegment __stdio_common_vfwprintf_s$address() {
        return __stdio_common_vfwprintf_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __stdio_common_vfwprintf_s(unsigned long long _Options, FILE *_Stream, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static int __stdio_common_vfwprintf_s(long _Options, MemorySegment _Stream, MemorySegment _Format, MemorySegment _Locale, MemorySegment _ArgList) {
        var mh$ = __stdio_common_vfwprintf_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__stdio_common_vfwprintf_s", _Options, _Stream, _Format, _Locale, _ArgList);
            }
            return (int)mh$.invokeExact(_Options, _Stream, _Format, _Locale, _ArgList);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __stdio_common_vfwprintf_p {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("__stdio_common_vfwprintf_p");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __stdio_common_vfwprintf_p(unsigned long long _Options, FILE *_Stream, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static FunctionDescriptor __stdio_common_vfwprintf_p$descriptor() {
        return __stdio_common_vfwprintf_p.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __stdio_common_vfwprintf_p(unsigned long long _Options, FILE *_Stream, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MethodHandle __stdio_common_vfwprintf_p$handle() {
        return __stdio_common_vfwprintf_p.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __stdio_common_vfwprintf_p(unsigned long long _Options, FILE *_Stream, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MemorySegment __stdio_common_vfwprintf_p$address() {
        return __stdio_common_vfwprintf_p.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __stdio_common_vfwprintf_p(unsigned long long _Options, FILE *_Stream, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static int __stdio_common_vfwprintf_p(long _Options, MemorySegment _Stream, MemorySegment _Format, MemorySegment _Locale, MemorySegment _ArgList) {
        var mh$ = __stdio_common_vfwprintf_p.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__stdio_common_vfwprintf_p", _Options, _Stream, _Format, _Locale, _ArgList);
            }
            return (int)mh$.invokeExact(_Options, _Stream, _Format, _Locale, _ArgList);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __stdio_common_vfwscanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("__stdio_common_vfwscanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __stdio_common_vfwscanf(unsigned long long _Options, FILE *_Stream, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static FunctionDescriptor __stdio_common_vfwscanf$descriptor() {
        return __stdio_common_vfwscanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __stdio_common_vfwscanf(unsigned long long _Options, FILE *_Stream, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MethodHandle __stdio_common_vfwscanf$handle() {
        return __stdio_common_vfwscanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __stdio_common_vfwscanf(unsigned long long _Options, FILE *_Stream, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MemorySegment __stdio_common_vfwscanf$address() {
        return __stdio_common_vfwscanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __stdio_common_vfwscanf(unsigned long long _Options, FILE *_Stream, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static int __stdio_common_vfwscanf(long _Options, MemorySegment _Stream, MemorySegment _Format, MemorySegment _Locale, MemorySegment _ArgList) {
        var mh$ = __stdio_common_vfwscanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__stdio_common_vfwscanf", _Options, _Stream, _Format, _Locale, _ArgList);
            }
            return (int)mh$.invokeExact(_Options, _Stream, _Format, _Locale, _ArgList);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __stdio_common_vswprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("__stdio_common_vswprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __stdio_common_vswprintf(unsigned long long _Options, wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static FunctionDescriptor __stdio_common_vswprintf$descriptor() {
        return __stdio_common_vswprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __stdio_common_vswprintf(unsigned long long _Options, wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MethodHandle __stdio_common_vswprintf$handle() {
        return __stdio_common_vswprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __stdio_common_vswprintf(unsigned long long _Options, wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MemorySegment __stdio_common_vswprintf$address() {
        return __stdio_common_vswprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __stdio_common_vswprintf(unsigned long long _Options, wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static int __stdio_common_vswprintf(long _Options, MemorySegment _Buffer, long _BufferCount, MemorySegment _Format, MemorySegment _Locale, MemorySegment _ArgList) {
        var mh$ = __stdio_common_vswprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__stdio_common_vswprintf", _Options, _Buffer, _BufferCount, _Format, _Locale, _ArgList);
            }
            return (int)mh$.invokeExact(_Options, _Buffer, _BufferCount, _Format, _Locale, _ArgList);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __stdio_common_vswprintf_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("__stdio_common_vswprintf_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __stdio_common_vswprintf_s(unsigned long long _Options, wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static FunctionDescriptor __stdio_common_vswprintf_s$descriptor() {
        return __stdio_common_vswprintf_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __stdio_common_vswprintf_s(unsigned long long _Options, wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MethodHandle __stdio_common_vswprintf_s$handle() {
        return __stdio_common_vswprintf_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __stdio_common_vswprintf_s(unsigned long long _Options, wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MemorySegment __stdio_common_vswprintf_s$address() {
        return __stdio_common_vswprintf_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __stdio_common_vswprintf_s(unsigned long long _Options, wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static int __stdio_common_vswprintf_s(long _Options, MemorySegment _Buffer, long _BufferCount, MemorySegment _Format, MemorySegment _Locale, MemorySegment _ArgList) {
        var mh$ = __stdio_common_vswprintf_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__stdio_common_vswprintf_s", _Options, _Buffer, _BufferCount, _Format, _Locale, _ArgList);
            }
            return (int)mh$.invokeExact(_Options, _Buffer, _BufferCount, _Format, _Locale, _ArgList);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __stdio_common_vsnwprintf_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("__stdio_common_vsnwprintf_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __stdio_common_vsnwprintf_s(unsigned long long _Options, wchar_t *_Buffer, size_t _BufferCount, size_t _MaxCount, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static FunctionDescriptor __stdio_common_vsnwprintf_s$descriptor() {
        return __stdio_common_vsnwprintf_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __stdio_common_vsnwprintf_s(unsigned long long _Options, wchar_t *_Buffer, size_t _BufferCount, size_t _MaxCount, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MethodHandle __stdio_common_vsnwprintf_s$handle() {
        return __stdio_common_vsnwprintf_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __stdio_common_vsnwprintf_s(unsigned long long _Options, wchar_t *_Buffer, size_t _BufferCount, size_t _MaxCount, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MemorySegment __stdio_common_vsnwprintf_s$address() {
        return __stdio_common_vsnwprintf_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __stdio_common_vsnwprintf_s(unsigned long long _Options, wchar_t *_Buffer, size_t _BufferCount, size_t _MaxCount, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static int __stdio_common_vsnwprintf_s(long _Options, MemorySegment _Buffer, long _BufferCount, long _MaxCount, MemorySegment _Format, MemorySegment _Locale, MemorySegment _ArgList) {
        var mh$ = __stdio_common_vsnwprintf_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__stdio_common_vsnwprintf_s", _Options, _Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);
            }
            return (int)mh$.invokeExact(_Options, _Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __stdio_common_vswprintf_p {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("__stdio_common_vswprintf_p");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __stdio_common_vswprintf_p(unsigned long long _Options, wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static FunctionDescriptor __stdio_common_vswprintf_p$descriptor() {
        return __stdio_common_vswprintf_p.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __stdio_common_vswprintf_p(unsigned long long _Options, wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MethodHandle __stdio_common_vswprintf_p$handle() {
        return __stdio_common_vswprintf_p.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __stdio_common_vswprintf_p(unsigned long long _Options, wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MemorySegment __stdio_common_vswprintf_p$address() {
        return __stdio_common_vswprintf_p.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __stdio_common_vswprintf_p(unsigned long long _Options, wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static int __stdio_common_vswprintf_p(long _Options, MemorySegment _Buffer, long _BufferCount, MemorySegment _Format, MemorySegment _Locale, MemorySegment _ArgList) {
        var mh$ = __stdio_common_vswprintf_p.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__stdio_common_vswprintf_p", _Options, _Buffer, _BufferCount, _Format, _Locale, _ArgList);
            }
            return (int)mh$.invokeExact(_Options, _Buffer, _BufferCount, _Format, _Locale, _ArgList);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __stdio_common_vswscanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("__stdio_common_vswscanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __stdio_common_vswscanf(unsigned long long _Options, const wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static FunctionDescriptor __stdio_common_vswscanf$descriptor() {
        return __stdio_common_vswscanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __stdio_common_vswscanf(unsigned long long _Options, const wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MethodHandle __stdio_common_vswscanf$handle() {
        return __stdio_common_vswscanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __stdio_common_vswscanf(unsigned long long _Options, const wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MemorySegment __stdio_common_vswscanf$address() {
        return __stdio_common_vswscanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __stdio_common_vswscanf(unsigned long long _Options, const wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static int __stdio_common_vswscanf(long _Options, MemorySegment _Buffer, long _BufferCount, MemorySegment _Format, MemorySegment _Locale, MemorySegment _ArgList) {
        var mh$ = __stdio_common_vswscanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__stdio_common_vswscanf", _Options, _Buffer, _BufferCount, _Format, _Locale, _ArgList);
            }
            return (int)mh$.invokeExact(_Options, _Buffer, _BufferCount, _Format, _Locale, _ArgList);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef long long fpos_t
     * }
     */
    public static final OfLong fpos_t = Python_h.C_LONG_LONG;

    private static class _get_stream_buffer_pointers {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_get_stream_buffer_pointers");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _get_stream_buffer_pointers(FILE *_Stream, char ***_Base, char ***_Pointer, int **_Count)
     * }
     */
    public static FunctionDescriptor _get_stream_buffer_pointers$descriptor() {
        return _get_stream_buffer_pointers.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _get_stream_buffer_pointers(FILE *_Stream, char ***_Base, char ***_Pointer, int **_Count)
     * }
     */
    public static MethodHandle _get_stream_buffer_pointers$handle() {
        return _get_stream_buffer_pointers.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _get_stream_buffer_pointers(FILE *_Stream, char ***_Base, char ***_Pointer, int **_Count)
     * }
     */
    public static MemorySegment _get_stream_buffer_pointers$address() {
        return _get_stream_buffer_pointers.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _get_stream_buffer_pointers(FILE *_Stream, char ***_Base, char ***_Pointer, int **_Count)
     * }
     */
    public static int _get_stream_buffer_pointers(MemorySegment _Stream, MemorySegment _Base, MemorySegment _Pointer, MemorySegment _Count) {
        var mh$ = _get_stream_buffer_pointers.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_get_stream_buffer_pointers", _Stream, _Base, _Pointer, _Count);
            }
            return (int)mh$.invokeExact(_Stream, _Base, _Pointer, _Count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clearerr_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("clearerr_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t clearerr_s(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor clearerr_s$descriptor() {
        return clearerr_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t clearerr_s(FILE *_Stream)
     * }
     */
    public static MethodHandle clearerr_s$handle() {
        return clearerr_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t clearerr_s(FILE *_Stream)
     * }
     */
    public static MemorySegment clearerr_s$address() {
        return clearerr_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t clearerr_s(FILE *_Stream)
     * }
     */
    public static int clearerr_s(MemorySegment _Stream) {
        var mh$ = clearerr_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clearerr_s", _Stream);
            }
            return (int)mh$.invokeExact(_Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fopen_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fopen_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t fopen_s(FILE **_Stream, const char *_FileName, const char *_Mode)
     * }
     */
    public static FunctionDescriptor fopen_s$descriptor() {
        return fopen_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t fopen_s(FILE **_Stream, const char *_FileName, const char *_Mode)
     * }
     */
    public static MethodHandle fopen_s$handle() {
        return fopen_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t fopen_s(FILE **_Stream, const char *_FileName, const char *_Mode)
     * }
     */
    public static MemorySegment fopen_s$address() {
        return fopen_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t fopen_s(FILE **_Stream, const char *_FileName, const char *_Mode)
     * }
     */
    public static int fopen_s(MemorySegment _Stream, MemorySegment _FileName, MemorySegment _Mode) {
        var mh$ = fopen_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fopen_s", _Stream, _FileName, _Mode);
            }
            return (int)mh$.invokeExact(_Stream, _FileName, _Mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fread_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_LONG_LONG,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fread_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t fread_s(void *_Buffer, size_t _BufferSize, size_t _ElementSize, size_t _ElementCount, FILE *_Stream)
     * }
     */
    public static FunctionDescriptor fread_s$descriptor() {
        return fread_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t fread_s(void *_Buffer, size_t _BufferSize, size_t _ElementSize, size_t _ElementCount, FILE *_Stream)
     * }
     */
    public static MethodHandle fread_s$handle() {
        return fread_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t fread_s(void *_Buffer, size_t _BufferSize, size_t _ElementSize, size_t _ElementCount, FILE *_Stream)
     * }
     */
    public static MemorySegment fread_s$address() {
        return fread_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t fread_s(void *_Buffer, size_t _BufferSize, size_t _ElementSize, size_t _ElementCount, FILE *_Stream)
     * }
     */
    public static long fread_s(MemorySegment _Buffer, long _BufferSize, long _ElementSize, long _ElementCount, MemorySegment _Stream) {
        var mh$ = fread_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fread_s", _Buffer, _BufferSize, _ElementSize, _ElementCount, _Stream);
            }
            return (long)mh$.invokeExact(_Buffer, _BufferSize, _ElementSize, _ElementCount, _Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class freopen_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("freopen_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t freopen_s(FILE **_Stream, const char *_FileName, const char *_Mode, FILE *_OldStream)
     * }
     */
    public static FunctionDescriptor freopen_s$descriptor() {
        return freopen_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t freopen_s(FILE **_Stream, const char *_FileName, const char *_Mode, FILE *_OldStream)
     * }
     */
    public static MethodHandle freopen_s$handle() {
        return freopen_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t freopen_s(FILE **_Stream, const char *_FileName, const char *_Mode, FILE *_OldStream)
     * }
     */
    public static MemorySegment freopen_s$address() {
        return freopen_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t freopen_s(FILE **_Stream, const char *_FileName, const char *_Mode, FILE *_OldStream)
     * }
     */
    public static int freopen_s(MemorySegment _Stream, MemorySegment _FileName, MemorySegment _Mode, MemorySegment _OldStream) {
        var mh$ = freopen_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("freopen_s", _Stream, _FileName, _Mode, _OldStream);
            }
            return (int)mh$.invokeExact(_Stream, _FileName, _Mode, _OldStream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gets_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("gets_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *gets_s(char *_Buffer, rsize_t _Size)
     * }
     */
    public static FunctionDescriptor gets_s$descriptor() {
        return gets_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *gets_s(char *_Buffer, rsize_t _Size)
     * }
     */
    public static MethodHandle gets_s$handle() {
        return gets_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *gets_s(char *_Buffer, rsize_t _Size)
     * }
     */
    public static MemorySegment gets_s$address() {
        return gets_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *gets_s(char *_Buffer, rsize_t _Size)
     * }
     */
    public static MemorySegment gets_s(MemorySegment _Buffer, long _Size) {
        var mh$ = gets_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gets_s", _Buffer, _Size);
            }
            return (MemorySegment)mh$.invokeExact(_Buffer, _Size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tmpfile_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("tmpfile_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t tmpfile_s(FILE **_Stream)
     * }
     */
    public static FunctionDescriptor tmpfile_s$descriptor() {
        return tmpfile_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t tmpfile_s(FILE **_Stream)
     * }
     */
    public static MethodHandle tmpfile_s$handle() {
        return tmpfile_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t tmpfile_s(FILE **_Stream)
     * }
     */
    public static MemorySegment tmpfile_s$address() {
        return tmpfile_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t tmpfile_s(FILE **_Stream)
     * }
     */
    public static int tmpfile_s(MemorySegment _Stream) {
        var mh$ = tmpfile_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tmpfile_s", _Stream);
            }
            return (int)mh$.invokeExact(_Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tmpnam_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("tmpnam_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t tmpnam_s(char *_Buffer, rsize_t _Size)
     * }
     */
    public static FunctionDescriptor tmpnam_s$descriptor() {
        return tmpnam_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t tmpnam_s(char *_Buffer, rsize_t _Size)
     * }
     */
    public static MethodHandle tmpnam_s$handle() {
        return tmpnam_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t tmpnam_s(char *_Buffer, rsize_t _Size)
     * }
     */
    public static MemorySegment tmpnam_s$address() {
        return tmpnam_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t tmpnam_s(char *_Buffer, rsize_t _Size)
     * }
     */
    public static int tmpnam_s(MemorySegment _Buffer, long _Size) {
        var mh$ = tmpnam_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tmpnam_s", _Buffer, _Size);
            }
            return (int)mh$.invokeExact(_Buffer, _Size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clearerr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("clearerr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void clearerr(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor clearerr$descriptor() {
        return clearerr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void clearerr(FILE *_Stream)
     * }
     */
    public static MethodHandle clearerr$handle() {
        return clearerr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void clearerr(FILE *_Stream)
     * }
     */
    public static MemorySegment clearerr$address() {
        return clearerr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void clearerr(FILE *_Stream)
     * }
     */
    public static void clearerr(MemorySegment _Stream) {
        var mh$ = clearerr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clearerr", _Stream);
            }
            mh$.invokeExact(_Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fclose {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fclose");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fclose(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor fclose$descriptor() {
        return fclose.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fclose(FILE *_Stream)
     * }
     */
    public static MethodHandle fclose$handle() {
        return fclose.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fclose(FILE *_Stream)
     * }
     */
    public static MemorySegment fclose$address() {
        return fclose.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fclose(FILE *_Stream)
     * }
     */
    public static int fclose(MemorySegment _Stream) {
        var mh$ = fclose.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fclose", _Stream);
            }
            return (int)mh$.invokeExact(_Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fcloseall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_fcloseall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _fcloseall()
     * }
     */
    public static FunctionDescriptor _fcloseall$descriptor() {
        return _fcloseall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _fcloseall()
     * }
     */
    public static MethodHandle _fcloseall$handle() {
        return _fcloseall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _fcloseall()
     * }
     */
    public static MemorySegment _fcloseall$address() {
        return _fcloseall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _fcloseall()
     * }
     */
    public static int _fcloseall() {
        var mh$ = _fcloseall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fcloseall");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fdopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_fdopen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FILE *_fdopen(int _FileHandle, const char *_Mode)
     * }
     */
    public static FunctionDescriptor _fdopen$descriptor() {
        return _fdopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FILE *_fdopen(int _FileHandle, const char *_Mode)
     * }
     */
    public static MethodHandle _fdopen$handle() {
        return _fdopen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FILE *_fdopen(int _FileHandle, const char *_Mode)
     * }
     */
    public static MemorySegment _fdopen$address() {
        return _fdopen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FILE *_fdopen(int _FileHandle, const char *_Mode)
     * }
     */
    public static MemorySegment _fdopen(int _FileHandle, MemorySegment _Mode) {
        var mh$ = _fdopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fdopen", _FileHandle, _Mode);
            }
            return (MemorySegment)mh$.invokeExact(_FileHandle, _Mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class feof {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("feof");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int feof(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor feof$descriptor() {
        return feof.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int feof(FILE *_Stream)
     * }
     */
    public static MethodHandle feof$handle() {
        return feof.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int feof(FILE *_Stream)
     * }
     */
    public static MemorySegment feof$address() {
        return feof.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int feof(FILE *_Stream)
     * }
     */
    public static int feof(MemorySegment _Stream) {
        var mh$ = feof.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("feof", _Stream);
            }
            return (int)mh$.invokeExact(_Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ferror {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("ferror");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ferror(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor ferror$descriptor() {
        return ferror.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ferror(FILE *_Stream)
     * }
     */
    public static MethodHandle ferror$handle() {
        return ferror.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ferror(FILE *_Stream)
     * }
     */
    public static MemorySegment ferror$address() {
        return ferror.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ferror(FILE *_Stream)
     * }
     */
    public static int ferror(MemorySegment _Stream) {
        var mh$ = ferror.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ferror", _Stream);
            }
            return (int)mh$.invokeExact(_Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fflush {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fflush");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fflush(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor fflush$descriptor() {
        return fflush.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fflush(FILE *_Stream)
     * }
     */
    public static MethodHandle fflush$handle() {
        return fflush.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fflush(FILE *_Stream)
     * }
     */
    public static MemorySegment fflush$address() {
        return fflush.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fflush(FILE *_Stream)
     * }
     */
    public static int fflush(MemorySegment _Stream) {
        var mh$ = fflush.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fflush", _Stream);
            }
            return (int)mh$.invokeExact(_Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fgetc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fgetc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fgetc(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor fgetc$descriptor() {
        return fgetc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fgetc(FILE *_Stream)
     * }
     */
    public static MethodHandle fgetc$handle() {
        return fgetc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fgetc(FILE *_Stream)
     * }
     */
    public static MemorySegment fgetc$address() {
        return fgetc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fgetc(FILE *_Stream)
     * }
     */
    public static int fgetc(MemorySegment _Stream) {
        var mh$ = fgetc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fgetc", _Stream);
            }
            return (int)mh$.invokeExact(_Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fgetchar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_fgetchar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _fgetchar()
     * }
     */
    public static FunctionDescriptor _fgetchar$descriptor() {
        return _fgetchar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _fgetchar()
     * }
     */
    public static MethodHandle _fgetchar$handle() {
        return _fgetchar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _fgetchar()
     * }
     */
    public static MemorySegment _fgetchar$address() {
        return _fgetchar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _fgetchar()
     * }
     */
    public static int _fgetchar() {
        var mh$ = _fgetchar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fgetchar");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fgetpos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fgetpos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fgetpos(FILE *_Stream, fpos_t *_Position)
     * }
     */
    public static FunctionDescriptor fgetpos$descriptor() {
        return fgetpos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fgetpos(FILE *_Stream, fpos_t *_Position)
     * }
     */
    public static MethodHandle fgetpos$handle() {
        return fgetpos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fgetpos(FILE *_Stream, fpos_t *_Position)
     * }
     */
    public static MemorySegment fgetpos$address() {
        return fgetpos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fgetpos(FILE *_Stream, fpos_t *_Position)
     * }
     */
    public static int fgetpos(MemorySegment _Stream, MemorySegment _Position) {
        var mh$ = fgetpos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fgetpos", _Stream, _Position);
            }
            return (int)mh$.invokeExact(_Stream, _Position);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fgets {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fgets");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *fgets(char *_Buffer, int _MaxCount, FILE *_Stream)
     * }
     */
    public static FunctionDescriptor fgets$descriptor() {
        return fgets.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *fgets(char *_Buffer, int _MaxCount, FILE *_Stream)
     * }
     */
    public static MethodHandle fgets$handle() {
        return fgets.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *fgets(char *_Buffer, int _MaxCount, FILE *_Stream)
     * }
     */
    public static MemorySegment fgets$address() {
        return fgets.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *fgets(char *_Buffer, int _MaxCount, FILE *_Stream)
     * }
     */
    public static MemorySegment fgets(MemorySegment _Buffer, int _MaxCount, MemorySegment _Stream) {
        var mh$ = fgets.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fgets", _Buffer, _MaxCount, _Stream);
            }
            return (MemorySegment)mh$.invokeExact(_Buffer, _MaxCount, _Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fileno {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_fileno");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _fileno(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor _fileno$descriptor() {
        return _fileno.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _fileno(FILE *_Stream)
     * }
     */
    public static MethodHandle _fileno$handle() {
        return _fileno.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _fileno(FILE *_Stream)
     * }
     */
    public static MemorySegment _fileno$address() {
        return _fileno.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _fileno(FILE *_Stream)
     * }
     */
    public static int _fileno(MemorySegment _Stream) {
        var mh$ = _fileno.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fileno", _Stream);
            }
            return (int)mh$.invokeExact(_Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _flushall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_flushall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _flushall()
     * }
     */
    public static FunctionDescriptor _flushall$descriptor() {
        return _flushall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _flushall()
     * }
     */
    public static MethodHandle _flushall$handle() {
        return _flushall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _flushall()
     * }
     */
    public static MemorySegment _flushall$address() {
        return _flushall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _flushall()
     * }
     */
    public static int _flushall() {
        var mh$ = _flushall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_flushall");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fopen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FILE *fopen(const char *_FileName, const char *_Mode)
     * }
     */
    public static FunctionDescriptor fopen$descriptor() {
        return fopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FILE *fopen(const char *_FileName, const char *_Mode)
     * }
     */
    public static MethodHandle fopen$handle() {
        return fopen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FILE *fopen(const char *_FileName, const char *_Mode)
     * }
     */
    public static MemorySegment fopen$address() {
        return fopen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FILE *fopen(const char *_FileName, const char *_Mode)
     * }
     */
    public static MemorySegment fopen(MemorySegment _FileName, MemorySegment _Mode) {
        var mh$ = fopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fopen", _FileName, _Mode);
            }
            return (MemorySegment)mh$.invokeExact(_FileName, _Mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fputc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fputc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fputc(int _Character, FILE *_Stream)
     * }
     */
    public static FunctionDescriptor fputc$descriptor() {
        return fputc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fputc(int _Character, FILE *_Stream)
     * }
     */
    public static MethodHandle fputc$handle() {
        return fputc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fputc(int _Character, FILE *_Stream)
     * }
     */
    public static MemorySegment fputc$address() {
        return fputc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fputc(int _Character, FILE *_Stream)
     * }
     */
    public static int fputc(int _Character, MemorySegment _Stream) {
        var mh$ = fputc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fputc", _Character, _Stream);
            }
            return (int)mh$.invokeExact(_Character, _Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fputchar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_fputchar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _fputchar(int _Character)
     * }
     */
    public static FunctionDescriptor _fputchar$descriptor() {
        return _fputchar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _fputchar(int _Character)
     * }
     */
    public static MethodHandle _fputchar$handle() {
        return _fputchar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _fputchar(int _Character)
     * }
     */
    public static MemorySegment _fputchar$address() {
        return _fputchar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _fputchar(int _Character)
     * }
     */
    public static int _fputchar(int _Character) {
        var mh$ = _fputchar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fputchar", _Character);
            }
            return (int)mh$.invokeExact(_Character);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fputs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fputs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fputs(const char *_Buffer, FILE *_Stream)
     * }
     */
    public static FunctionDescriptor fputs$descriptor() {
        return fputs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fputs(const char *_Buffer, FILE *_Stream)
     * }
     */
    public static MethodHandle fputs$handle() {
        return fputs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fputs(const char *_Buffer, FILE *_Stream)
     * }
     */
    public static MemorySegment fputs$address() {
        return fputs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fputs(const char *_Buffer, FILE *_Stream)
     * }
     */
    public static int fputs(MemorySegment _Buffer, MemorySegment _Stream) {
        var mh$ = fputs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fputs", _Buffer, _Stream);
            }
            return (int)mh$.invokeExact(_Buffer, _Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fread");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long long fread(void *_Buffer, size_t _ElementSize, size_t _ElementCount, FILE *_Stream)
     * }
     */
    public static FunctionDescriptor fread$descriptor() {
        return fread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long long fread(void *_Buffer, size_t _ElementSize, size_t _ElementCount, FILE *_Stream)
     * }
     */
    public static MethodHandle fread$handle() {
        return fread.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long long fread(void *_Buffer, size_t _ElementSize, size_t _ElementCount, FILE *_Stream)
     * }
     */
    public static MemorySegment fread$address() {
        return fread.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long long fread(void *_Buffer, size_t _ElementSize, size_t _ElementCount, FILE *_Stream)
     * }
     */
    public static long fread(MemorySegment _Buffer, long _ElementSize, long _ElementCount, MemorySegment _Stream) {
        var mh$ = fread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fread", _Buffer, _ElementSize, _ElementCount, _Stream);
            }
            return (long)mh$.invokeExact(_Buffer, _ElementSize, _ElementCount, _Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class freopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("freopen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FILE *freopen(const char *_FileName, const char *_Mode, FILE *_Stream)
     * }
     */
    public static FunctionDescriptor freopen$descriptor() {
        return freopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FILE *freopen(const char *_FileName, const char *_Mode, FILE *_Stream)
     * }
     */
    public static MethodHandle freopen$handle() {
        return freopen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FILE *freopen(const char *_FileName, const char *_Mode, FILE *_Stream)
     * }
     */
    public static MemorySegment freopen$address() {
        return freopen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FILE *freopen(const char *_FileName, const char *_Mode, FILE *_Stream)
     * }
     */
    public static MemorySegment freopen(MemorySegment _FileName, MemorySegment _Mode, MemorySegment _Stream) {
        var mh$ = freopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("freopen", _FileName, _Mode, _Stream);
            }
            return (MemorySegment)mh$.invokeExact(_FileName, _Mode, _Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fsopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_fsopen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FILE *_fsopen(const char *_FileName, const char *_Mode, int _ShFlag)
     * }
     */
    public static FunctionDescriptor _fsopen$descriptor() {
        return _fsopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FILE *_fsopen(const char *_FileName, const char *_Mode, int _ShFlag)
     * }
     */
    public static MethodHandle _fsopen$handle() {
        return _fsopen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FILE *_fsopen(const char *_FileName, const char *_Mode, int _ShFlag)
     * }
     */
    public static MemorySegment _fsopen$address() {
        return _fsopen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FILE *_fsopen(const char *_FileName, const char *_Mode, int _ShFlag)
     * }
     */
    public static MemorySegment _fsopen(MemorySegment _FileName, MemorySegment _Mode, int _ShFlag) {
        var mh$ = _fsopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fsopen", _FileName, _Mode, _ShFlag);
            }
            return (MemorySegment)mh$.invokeExact(_FileName, _Mode, _ShFlag);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fsetpos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fsetpos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fsetpos(FILE *_Stream, const fpos_t *_Position)
     * }
     */
    public static FunctionDescriptor fsetpos$descriptor() {
        return fsetpos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fsetpos(FILE *_Stream, const fpos_t *_Position)
     * }
     */
    public static MethodHandle fsetpos$handle() {
        return fsetpos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fsetpos(FILE *_Stream, const fpos_t *_Position)
     * }
     */
    public static MemorySegment fsetpos$address() {
        return fsetpos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fsetpos(FILE *_Stream, const fpos_t *_Position)
     * }
     */
    public static int fsetpos(MemorySegment _Stream, MemorySegment _Position) {
        var mh$ = fsetpos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fsetpos", _Stream, _Position);
            }
            return (int)mh$.invokeExact(_Stream, _Position);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fseek {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fseek");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fseek(FILE *_Stream, long _Offset, int _Origin)
     * }
     */
    public static FunctionDescriptor fseek$descriptor() {
        return fseek.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fseek(FILE *_Stream, long _Offset, int _Origin)
     * }
     */
    public static MethodHandle fseek$handle() {
        return fseek.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fseek(FILE *_Stream, long _Offset, int _Origin)
     * }
     */
    public static MemorySegment fseek$address() {
        return fseek.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fseek(FILE *_Stream, long _Offset, int _Origin)
     * }
     */
    public static int fseek(MemorySegment _Stream, int _Offset, int _Origin) {
        var mh$ = fseek.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fseek", _Stream, _Offset, _Origin);
            }
            return (int)mh$.invokeExact(_Stream, _Offset, _Origin);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fseeki64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_fseeki64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _fseeki64(FILE *_Stream, long long _Offset, int _Origin)
     * }
     */
    public static FunctionDescriptor _fseeki64$descriptor() {
        return _fseeki64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _fseeki64(FILE *_Stream, long long _Offset, int _Origin)
     * }
     */
    public static MethodHandle _fseeki64$handle() {
        return _fseeki64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _fseeki64(FILE *_Stream, long long _Offset, int _Origin)
     * }
     */
    public static MemorySegment _fseeki64$address() {
        return _fseeki64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _fseeki64(FILE *_Stream, long long _Offset, int _Origin)
     * }
     */
    public static int _fseeki64(MemorySegment _Stream, long _Offset, int _Origin) {
        var mh$ = _fseeki64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fseeki64", _Stream, _Offset, _Origin);
            }
            return (int)mh$.invokeExact(_Stream, _Offset, _Origin);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ftell {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("ftell");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long ftell(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor ftell$descriptor() {
        return ftell.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long ftell(FILE *_Stream)
     * }
     */
    public static MethodHandle ftell$handle() {
        return ftell.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long ftell(FILE *_Stream)
     * }
     */
    public static MemorySegment ftell$address() {
        return ftell.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long ftell(FILE *_Stream)
     * }
     */
    public static int ftell(MemorySegment _Stream) {
        var mh$ = ftell.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ftell", _Stream);
            }
            return (int)mh$.invokeExact(_Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ftelli64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_ftelli64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long _ftelli64(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor _ftelli64$descriptor() {
        return _ftelli64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long _ftelli64(FILE *_Stream)
     * }
     */
    public static MethodHandle _ftelli64$handle() {
        return _ftelli64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long _ftelli64(FILE *_Stream)
     * }
     */
    public static MemorySegment _ftelli64$address() {
        return _ftelli64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long _ftelli64(FILE *_Stream)
     * }
     */
    public static long _ftelli64(MemorySegment _Stream) {
        var mh$ = _ftelli64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ftelli64", _Stream);
            }
            return (long)mh$.invokeExact(_Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fwrite {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fwrite");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long long fwrite(const void *_Buffer, size_t _ElementSize, size_t _ElementCount, FILE *_Stream)
     * }
     */
    public static FunctionDescriptor fwrite$descriptor() {
        return fwrite.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long long fwrite(const void *_Buffer, size_t _ElementSize, size_t _ElementCount, FILE *_Stream)
     * }
     */
    public static MethodHandle fwrite$handle() {
        return fwrite.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long long fwrite(const void *_Buffer, size_t _ElementSize, size_t _ElementCount, FILE *_Stream)
     * }
     */
    public static MemorySegment fwrite$address() {
        return fwrite.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long long fwrite(const void *_Buffer, size_t _ElementSize, size_t _ElementCount, FILE *_Stream)
     * }
     */
    public static long fwrite(MemorySegment _Buffer, long _ElementSize, long _ElementCount, MemorySegment _Stream) {
        var mh$ = fwrite.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fwrite", _Buffer, _ElementSize, _ElementCount, _Stream);
            }
            return (long)mh$.invokeExact(_Buffer, _ElementSize, _ElementCount, _Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("getc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getc(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor getc$descriptor() {
        return getc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getc(FILE *_Stream)
     * }
     */
    public static MethodHandle getc$handle() {
        return getc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getc(FILE *_Stream)
     * }
     */
    public static MemorySegment getc$address() {
        return getc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getc(FILE *_Stream)
     * }
     */
    public static int getc(MemorySegment _Stream) {
        var mh$ = getc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getc", _Stream);
            }
            return (int)mh$.invokeExact(_Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getchar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("getchar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getchar()
     * }
     */
    public static FunctionDescriptor getchar$descriptor() {
        return getchar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getchar()
     * }
     */
    public static MethodHandle getchar$handle() {
        return getchar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getchar()
     * }
     */
    public static MemorySegment getchar$address() {
        return getchar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getchar()
     * }
     */
    public static int getchar() {
        var mh$ = getchar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getchar");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _getmaxstdio {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_getmaxstdio");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _getmaxstdio()
     * }
     */
    public static FunctionDescriptor _getmaxstdio$descriptor() {
        return _getmaxstdio.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _getmaxstdio()
     * }
     */
    public static MethodHandle _getmaxstdio$handle() {
        return _getmaxstdio.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _getmaxstdio()
     * }
     */
    public static MemorySegment _getmaxstdio$address() {
        return _getmaxstdio.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _getmaxstdio()
     * }
     */
    public static int _getmaxstdio() {
        var mh$ = _getmaxstdio.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_getmaxstdio");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _getw {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_getw");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _getw(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor _getw$descriptor() {
        return _getw.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _getw(FILE *_Stream)
     * }
     */
    public static MethodHandle _getw$handle() {
        return _getw.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _getw(FILE *_Stream)
     * }
     */
    public static MemorySegment _getw$address() {
        return _getw.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _getw(FILE *_Stream)
     * }
     */
    public static int _getw(MemorySegment _Stream) {
        var mh$ = _getw.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_getw", _Stream);
            }
            return (int)mh$.invokeExact(_Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class perror {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("perror");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void perror(const char *_ErrorMessage)
     * }
     */
    public static FunctionDescriptor perror$descriptor() {
        return perror.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void perror(const char *_ErrorMessage)
     * }
     */
    public static MethodHandle perror$handle() {
        return perror.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void perror(const char *_ErrorMessage)
     * }
     */
    public static MemorySegment perror$address() {
        return perror.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void perror(const char *_ErrorMessage)
     * }
     */
    public static void perror(MemorySegment _ErrorMessage) {
        var mh$ = perror.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("perror", _ErrorMessage);
            }
            mh$.invokeExact(_ErrorMessage);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _pclose {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_pclose");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _pclose(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor _pclose$descriptor() {
        return _pclose.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _pclose(FILE *_Stream)
     * }
     */
    public static MethodHandle _pclose$handle() {
        return _pclose.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _pclose(FILE *_Stream)
     * }
     */
    public static MemorySegment _pclose$address() {
        return _pclose.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _pclose(FILE *_Stream)
     * }
     */
    public static int _pclose(MemorySegment _Stream) {
        var mh$ = _pclose.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_pclose", _Stream);
            }
            return (int)mh$.invokeExact(_Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _popen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_popen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FILE *_popen(const char *_Command, const char *_Mode)
     * }
     */
    public static FunctionDescriptor _popen$descriptor() {
        return _popen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FILE *_popen(const char *_Command, const char *_Mode)
     * }
     */
    public static MethodHandle _popen$handle() {
        return _popen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FILE *_popen(const char *_Command, const char *_Mode)
     * }
     */
    public static MemorySegment _popen$address() {
        return _popen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FILE *_popen(const char *_Command, const char *_Mode)
     * }
     */
    public static MemorySegment _popen(MemorySegment _Command, MemorySegment _Mode) {
        var mh$ = _popen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_popen", _Command, _Mode);
            }
            return (MemorySegment)mh$.invokeExact(_Command, _Mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("putc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int putc(int _Character, FILE *_Stream)
     * }
     */
    public static FunctionDescriptor putc$descriptor() {
        return putc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int putc(int _Character, FILE *_Stream)
     * }
     */
    public static MethodHandle putc$handle() {
        return putc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int putc(int _Character, FILE *_Stream)
     * }
     */
    public static MemorySegment putc$address() {
        return putc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int putc(int _Character, FILE *_Stream)
     * }
     */
    public static int putc(int _Character, MemorySegment _Stream) {
        var mh$ = putc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putc", _Character, _Stream);
            }
            return (int)mh$.invokeExact(_Character, _Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putchar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("putchar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int putchar(int _Character)
     * }
     */
    public static FunctionDescriptor putchar$descriptor() {
        return putchar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int putchar(int _Character)
     * }
     */
    public static MethodHandle putchar$handle() {
        return putchar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int putchar(int _Character)
     * }
     */
    public static MemorySegment putchar$address() {
        return putchar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int putchar(int _Character)
     * }
     */
    public static int putchar(int _Character) {
        var mh$ = putchar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putchar", _Character);
            }
            return (int)mh$.invokeExact(_Character);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class puts {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("puts");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int puts(const char *_Buffer)
     * }
     */
    public static FunctionDescriptor puts$descriptor() {
        return puts.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int puts(const char *_Buffer)
     * }
     */
    public static MethodHandle puts$handle() {
        return puts.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int puts(const char *_Buffer)
     * }
     */
    public static MemorySegment puts$address() {
        return puts.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int puts(const char *_Buffer)
     * }
     */
    public static int puts(MemorySegment _Buffer) {
        var mh$ = puts.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("puts", _Buffer);
            }
            return (int)mh$.invokeExact(_Buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _putw {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_putw");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _putw(int _Word, FILE *_Stream)
     * }
     */
    public static FunctionDescriptor _putw$descriptor() {
        return _putw.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _putw(int _Word, FILE *_Stream)
     * }
     */
    public static MethodHandle _putw$handle() {
        return _putw.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _putw(int _Word, FILE *_Stream)
     * }
     */
    public static MemorySegment _putw$address() {
        return _putw.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _putw(int _Word, FILE *_Stream)
     * }
     */
    public static int _putw(int _Word, MemorySegment _Stream) {
        var mh$ = _putw.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_putw", _Word, _Stream);
            }
            return (int)mh$.invokeExact(_Word, _Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rewind {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("rewind");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rewind(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor rewind$descriptor() {
        return rewind.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rewind(FILE *_Stream)
     * }
     */
    public static MethodHandle rewind$handle() {
        return rewind.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rewind(FILE *_Stream)
     * }
     */
    public static MemorySegment rewind$address() {
        return rewind.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rewind(FILE *_Stream)
     * }
     */
    public static void rewind(MemorySegment _Stream) {
        var mh$ = rewind.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rewind", _Stream);
            }
            mh$.invokeExact(_Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _rmtmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_rmtmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _rmtmp()
     * }
     */
    public static FunctionDescriptor _rmtmp$descriptor() {
        return _rmtmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _rmtmp()
     * }
     */
    public static MethodHandle _rmtmp$handle() {
        return _rmtmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _rmtmp()
     * }
     */
    public static MemorySegment _rmtmp$address() {
        return _rmtmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _rmtmp()
     * }
     */
    public static int _rmtmp() {
        var mh$ = _rmtmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_rmtmp");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setbuf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("setbuf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void setbuf(FILE *_Stream, char *_Buffer)
     * }
     */
    public static FunctionDescriptor setbuf$descriptor() {
        return setbuf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void setbuf(FILE *_Stream, char *_Buffer)
     * }
     */
    public static MethodHandle setbuf$handle() {
        return setbuf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void setbuf(FILE *_Stream, char *_Buffer)
     * }
     */
    public static MemorySegment setbuf$address() {
        return setbuf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void setbuf(FILE *_Stream, char *_Buffer)
     * }
     */
    public static void setbuf(MemorySegment _Stream, MemorySegment _Buffer) {
        var mh$ = setbuf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setbuf", _Stream, _Buffer);
            }
            mh$.invokeExact(_Stream, _Buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _setmaxstdio {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_setmaxstdio");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _setmaxstdio(int _Maximum)
     * }
     */
    public static FunctionDescriptor _setmaxstdio$descriptor() {
        return _setmaxstdio.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _setmaxstdio(int _Maximum)
     * }
     */
    public static MethodHandle _setmaxstdio$handle() {
        return _setmaxstdio.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _setmaxstdio(int _Maximum)
     * }
     */
    public static MemorySegment _setmaxstdio$address() {
        return _setmaxstdio.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _setmaxstdio(int _Maximum)
     * }
     */
    public static int _setmaxstdio(int _Maximum) {
        var mh$ = _setmaxstdio.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_setmaxstdio", _Maximum);
            }
            return (int)mh$.invokeExact(_Maximum);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setvbuf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("setvbuf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setvbuf(FILE *_Stream, char *_Buffer, int _Mode, size_t _Size)
     * }
     */
    public static FunctionDescriptor setvbuf$descriptor() {
        return setvbuf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setvbuf(FILE *_Stream, char *_Buffer, int _Mode, size_t _Size)
     * }
     */
    public static MethodHandle setvbuf$handle() {
        return setvbuf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setvbuf(FILE *_Stream, char *_Buffer, int _Mode, size_t _Size)
     * }
     */
    public static MemorySegment setvbuf$address() {
        return setvbuf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setvbuf(FILE *_Stream, char *_Buffer, int _Mode, size_t _Size)
     * }
     */
    public static int setvbuf(MemorySegment _Stream, MemorySegment _Buffer, int _Mode, long _Size) {
        var mh$ = setvbuf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setvbuf", _Stream, _Buffer, _Mode, _Size);
            }
            return (int)mh$.invokeExact(_Stream, _Buffer, _Mode, _Size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _tempnam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_tempnam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *_tempnam(const char *_DirectoryName, const char *_FilePrefix)
     * }
     */
    public static FunctionDescriptor _tempnam$descriptor() {
        return _tempnam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *_tempnam(const char *_DirectoryName, const char *_FilePrefix)
     * }
     */
    public static MethodHandle _tempnam$handle() {
        return _tempnam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *_tempnam(const char *_DirectoryName, const char *_FilePrefix)
     * }
     */
    public static MemorySegment _tempnam$address() {
        return _tempnam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *_tempnam(const char *_DirectoryName, const char *_FilePrefix)
     * }
     */
    public static MemorySegment _tempnam(MemorySegment _DirectoryName, MemorySegment _FilePrefix) {
        var mh$ = _tempnam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_tempnam", _DirectoryName, _FilePrefix);
            }
            return (MemorySegment)mh$.invokeExact(_DirectoryName, _FilePrefix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tmpfile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("tmpfile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FILE *tmpfile()
     * }
     */
    public static FunctionDescriptor tmpfile$descriptor() {
        return tmpfile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FILE *tmpfile()
     * }
     */
    public static MethodHandle tmpfile$handle() {
        return tmpfile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FILE *tmpfile()
     * }
     */
    public static MemorySegment tmpfile$address() {
        return tmpfile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FILE *tmpfile()
     * }
     */
    public static MemorySegment tmpfile() {
        var mh$ = tmpfile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tmpfile");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tmpnam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("tmpnam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *tmpnam(char *_Buffer)
     * }
     */
    public static FunctionDescriptor tmpnam$descriptor() {
        return tmpnam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *tmpnam(char *_Buffer)
     * }
     */
    public static MethodHandle tmpnam$handle() {
        return tmpnam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *tmpnam(char *_Buffer)
     * }
     */
    public static MemorySegment tmpnam$address() {
        return tmpnam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *tmpnam(char *_Buffer)
     * }
     */
    public static MemorySegment tmpnam(MemorySegment _Buffer) {
        var mh$ = tmpnam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tmpnam", _Buffer);
            }
            return (MemorySegment)mh$.invokeExact(_Buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ungetc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("ungetc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ungetc(int _Character, FILE *_Stream)
     * }
     */
    public static FunctionDescriptor ungetc$descriptor() {
        return ungetc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ungetc(int _Character, FILE *_Stream)
     * }
     */
    public static MethodHandle ungetc$handle() {
        return ungetc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ungetc(int _Character, FILE *_Stream)
     * }
     */
    public static MemorySegment ungetc$address() {
        return ungetc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ungetc(int _Character, FILE *_Stream)
     * }
     */
    public static int ungetc(int _Character, MemorySegment _Stream) {
        var mh$ = ungetc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ungetc", _Character, _Stream);
            }
            return (int)mh$.invokeExact(_Character, _Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _lock_file {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_lock_file");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _lock_file(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor _lock_file$descriptor() {
        return _lock_file.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _lock_file(FILE *_Stream)
     * }
     */
    public static MethodHandle _lock_file$handle() {
        return _lock_file.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _lock_file(FILE *_Stream)
     * }
     */
    public static MemorySegment _lock_file$address() {
        return _lock_file.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _lock_file(FILE *_Stream)
     * }
     */
    public static void _lock_file(MemorySegment _Stream) {
        var mh$ = _lock_file.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_lock_file", _Stream);
            }
            mh$.invokeExact(_Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _unlock_file {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_unlock_file");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _unlock_file(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor _unlock_file$descriptor() {
        return _unlock_file.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _unlock_file(FILE *_Stream)
     * }
     */
    public static MethodHandle _unlock_file$handle() {
        return _unlock_file.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _unlock_file(FILE *_Stream)
     * }
     */
    public static MemorySegment _unlock_file$address() {
        return _unlock_file.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _unlock_file(FILE *_Stream)
     * }
     */
    public static void _unlock_file(MemorySegment _Stream) {
        var mh$ = _unlock_file.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_unlock_file", _Stream);
            }
            mh$.invokeExact(_Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fclose_nolock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_fclose_nolock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _fclose_nolock(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor _fclose_nolock$descriptor() {
        return _fclose_nolock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _fclose_nolock(FILE *_Stream)
     * }
     */
    public static MethodHandle _fclose_nolock$handle() {
        return _fclose_nolock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _fclose_nolock(FILE *_Stream)
     * }
     */
    public static MemorySegment _fclose_nolock$address() {
        return _fclose_nolock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _fclose_nolock(FILE *_Stream)
     * }
     */
    public static int _fclose_nolock(MemorySegment _Stream) {
        var mh$ = _fclose_nolock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fclose_nolock", _Stream);
            }
            return (int)mh$.invokeExact(_Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fflush_nolock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_fflush_nolock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _fflush_nolock(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor _fflush_nolock$descriptor() {
        return _fflush_nolock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _fflush_nolock(FILE *_Stream)
     * }
     */
    public static MethodHandle _fflush_nolock$handle() {
        return _fflush_nolock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _fflush_nolock(FILE *_Stream)
     * }
     */
    public static MemorySegment _fflush_nolock$address() {
        return _fflush_nolock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _fflush_nolock(FILE *_Stream)
     * }
     */
    public static int _fflush_nolock(MemorySegment _Stream) {
        var mh$ = _fflush_nolock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fflush_nolock", _Stream);
            }
            return (int)mh$.invokeExact(_Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fgetc_nolock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_fgetc_nolock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _fgetc_nolock(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor _fgetc_nolock$descriptor() {
        return _fgetc_nolock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _fgetc_nolock(FILE *_Stream)
     * }
     */
    public static MethodHandle _fgetc_nolock$handle() {
        return _fgetc_nolock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _fgetc_nolock(FILE *_Stream)
     * }
     */
    public static MemorySegment _fgetc_nolock$address() {
        return _fgetc_nolock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _fgetc_nolock(FILE *_Stream)
     * }
     */
    public static int _fgetc_nolock(MemorySegment _Stream) {
        var mh$ = _fgetc_nolock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fgetc_nolock", _Stream);
            }
            return (int)mh$.invokeExact(_Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fputc_nolock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_fputc_nolock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _fputc_nolock(int _Character, FILE *_Stream)
     * }
     */
    public static FunctionDescriptor _fputc_nolock$descriptor() {
        return _fputc_nolock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _fputc_nolock(int _Character, FILE *_Stream)
     * }
     */
    public static MethodHandle _fputc_nolock$handle() {
        return _fputc_nolock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _fputc_nolock(int _Character, FILE *_Stream)
     * }
     */
    public static MemorySegment _fputc_nolock$address() {
        return _fputc_nolock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _fputc_nolock(int _Character, FILE *_Stream)
     * }
     */
    public static int _fputc_nolock(int _Character, MemorySegment _Stream) {
        var mh$ = _fputc_nolock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fputc_nolock", _Character, _Stream);
            }
            return (int)mh$.invokeExact(_Character, _Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fread_nolock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_fread_nolock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t _fread_nolock(void *_Buffer, size_t _ElementSize, size_t _ElementCount, FILE *_Stream)
     * }
     */
    public static FunctionDescriptor _fread_nolock$descriptor() {
        return _fread_nolock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t _fread_nolock(void *_Buffer, size_t _ElementSize, size_t _ElementCount, FILE *_Stream)
     * }
     */
    public static MethodHandle _fread_nolock$handle() {
        return _fread_nolock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t _fread_nolock(void *_Buffer, size_t _ElementSize, size_t _ElementCount, FILE *_Stream)
     * }
     */
    public static MemorySegment _fread_nolock$address() {
        return _fread_nolock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t _fread_nolock(void *_Buffer, size_t _ElementSize, size_t _ElementCount, FILE *_Stream)
     * }
     */
    public static long _fread_nolock(MemorySegment _Buffer, long _ElementSize, long _ElementCount, MemorySegment _Stream) {
        var mh$ = _fread_nolock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fread_nolock", _Buffer, _ElementSize, _ElementCount, _Stream);
            }
            return (long)mh$.invokeExact(_Buffer, _ElementSize, _ElementCount, _Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fread_nolock_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_LONG_LONG,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_fread_nolock_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t _fread_nolock_s(void *_Buffer, size_t _BufferSize, size_t _ElementSize, size_t _ElementCount, FILE *_Stream)
     * }
     */
    public static FunctionDescriptor _fread_nolock_s$descriptor() {
        return _fread_nolock_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t _fread_nolock_s(void *_Buffer, size_t _BufferSize, size_t _ElementSize, size_t _ElementCount, FILE *_Stream)
     * }
     */
    public static MethodHandle _fread_nolock_s$handle() {
        return _fread_nolock_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t _fread_nolock_s(void *_Buffer, size_t _BufferSize, size_t _ElementSize, size_t _ElementCount, FILE *_Stream)
     * }
     */
    public static MemorySegment _fread_nolock_s$address() {
        return _fread_nolock_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t _fread_nolock_s(void *_Buffer, size_t _BufferSize, size_t _ElementSize, size_t _ElementCount, FILE *_Stream)
     * }
     */
    public static long _fread_nolock_s(MemorySegment _Buffer, long _BufferSize, long _ElementSize, long _ElementCount, MemorySegment _Stream) {
        var mh$ = _fread_nolock_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fread_nolock_s", _Buffer, _BufferSize, _ElementSize, _ElementCount, _Stream);
            }
            return (long)mh$.invokeExact(_Buffer, _BufferSize, _ElementSize, _ElementCount, _Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fseek_nolock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_fseek_nolock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _fseek_nolock(FILE *_Stream, long _Offset, int _Origin)
     * }
     */
    public static FunctionDescriptor _fseek_nolock$descriptor() {
        return _fseek_nolock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _fseek_nolock(FILE *_Stream, long _Offset, int _Origin)
     * }
     */
    public static MethodHandle _fseek_nolock$handle() {
        return _fseek_nolock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _fseek_nolock(FILE *_Stream, long _Offset, int _Origin)
     * }
     */
    public static MemorySegment _fseek_nolock$address() {
        return _fseek_nolock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _fseek_nolock(FILE *_Stream, long _Offset, int _Origin)
     * }
     */
    public static int _fseek_nolock(MemorySegment _Stream, int _Offset, int _Origin) {
        var mh$ = _fseek_nolock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fseek_nolock", _Stream, _Offset, _Origin);
            }
            return (int)mh$.invokeExact(_Stream, _Offset, _Origin);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fseeki64_nolock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_fseeki64_nolock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _fseeki64_nolock(FILE *_Stream, long long _Offset, int _Origin)
     * }
     */
    public static FunctionDescriptor _fseeki64_nolock$descriptor() {
        return _fseeki64_nolock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _fseeki64_nolock(FILE *_Stream, long long _Offset, int _Origin)
     * }
     */
    public static MethodHandle _fseeki64_nolock$handle() {
        return _fseeki64_nolock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _fseeki64_nolock(FILE *_Stream, long long _Offset, int _Origin)
     * }
     */
    public static MemorySegment _fseeki64_nolock$address() {
        return _fseeki64_nolock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _fseeki64_nolock(FILE *_Stream, long long _Offset, int _Origin)
     * }
     */
    public static int _fseeki64_nolock(MemorySegment _Stream, long _Offset, int _Origin) {
        var mh$ = _fseeki64_nolock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fseeki64_nolock", _Stream, _Offset, _Origin);
            }
            return (int)mh$.invokeExact(_Stream, _Offset, _Origin);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ftell_nolock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_ftell_nolock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long _ftell_nolock(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor _ftell_nolock$descriptor() {
        return _ftell_nolock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long _ftell_nolock(FILE *_Stream)
     * }
     */
    public static MethodHandle _ftell_nolock$handle() {
        return _ftell_nolock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long _ftell_nolock(FILE *_Stream)
     * }
     */
    public static MemorySegment _ftell_nolock$address() {
        return _ftell_nolock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long _ftell_nolock(FILE *_Stream)
     * }
     */
    public static int _ftell_nolock(MemorySegment _Stream) {
        var mh$ = _ftell_nolock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ftell_nolock", _Stream);
            }
            return (int)mh$.invokeExact(_Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ftelli64_nolock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_ftelli64_nolock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long _ftelli64_nolock(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor _ftelli64_nolock$descriptor() {
        return _ftelli64_nolock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long _ftelli64_nolock(FILE *_Stream)
     * }
     */
    public static MethodHandle _ftelli64_nolock$handle() {
        return _ftelli64_nolock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long _ftelli64_nolock(FILE *_Stream)
     * }
     */
    public static MemorySegment _ftelli64_nolock$address() {
        return _ftelli64_nolock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long _ftelli64_nolock(FILE *_Stream)
     * }
     */
    public static long _ftelli64_nolock(MemorySegment _Stream) {
        var mh$ = _ftelli64_nolock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ftelli64_nolock", _Stream);
            }
            return (long)mh$.invokeExact(_Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fwrite_nolock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_fwrite_nolock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t _fwrite_nolock(const void *_Buffer, size_t _ElementSize, size_t _ElementCount, FILE *_Stream)
     * }
     */
    public static FunctionDescriptor _fwrite_nolock$descriptor() {
        return _fwrite_nolock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t _fwrite_nolock(const void *_Buffer, size_t _ElementSize, size_t _ElementCount, FILE *_Stream)
     * }
     */
    public static MethodHandle _fwrite_nolock$handle() {
        return _fwrite_nolock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t _fwrite_nolock(const void *_Buffer, size_t _ElementSize, size_t _ElementCount, FILE *_Stream)
     * }
     */
    public static MemorySegment _fwrite_nolock$address() {
        return _fwrite_nolock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t _fwrite_nolock(const void *_Buffer, size_t _ElementSize, size_t _ElementCount, FILE *_Stream)
     * }
     */
    public static long _fwrite_nolock(MemorySegment _Buffer, long _ElementSize, long _ElementCount, MemorySegment _Stream) {
        var mh$ = _fwrite_nolock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fwrite_nolock", _Buffer, _ElementSize, _ElementCount, _Stream);
            }
            return (long)mh$.invokeExact(_Buffer, _ElementSize, _ElementCount, _Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _getc_nolock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_getc_nolock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _getc_nolock(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor _getc_nolock$descriptor() {
        return _getc_nolock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _getc_nolock(FILE *_Stream)
     * }
     */
    public static MethodHandle _getc_nolock$handle() {
        return _getc_nolock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _getc_nolock(FILE *_Stream)
     * }
     */
    public static MemorySegment _getc_nolock$address() {
        return _getc_nolock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _getc_nolock(FILE *_Stream)
     * }
     */
    public static int _getc_nolock(MemorySegment _Stream) {
        var mh$ = _getc_nolock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_getc_nolock", _Stream);
            }
            return (int)mh$.invokeExact(_Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _putc_nolock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_putc_nolock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _putc_nolock(int _Character, FILE *_Stream)
     * }
     */
    public static FunctionDescriptor _putc_nolock$descriptor() {
        return _putc_nolock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _putc_nolock(int _Character, FILE *_Stream)
     * }
     */
    public static MethodHandle _putc_nolock$handle() {
        return _putc_nolock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _putc_nolock(int _Character, FILE *_Stream)
     * }
     */
    public static MemorySegment _putc_nolock$address() {
        return _putc_nolock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _putc_nolock(int _Character, FILE *_Stream)
     * }
     */
    public static int _putc_nolock(int _Character, MemorySegment _Stream) {
        var mh$ = _putc_nolock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_putc_nolock", _Character, _Stream);
            }
            return (int)mh$.invokeExact(_Character, _Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ungetc_nolock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_ungetc_nolock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _ungetc_nolock(int _Character, FILE *_Stream)
     * }
     */
    public static FunctionDescriptor _ungetc_nolock$descriptor() {
        return _ungetc_nolock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _ungetc_nolock(int _Character, FILE *_Stream)
     * }
     */
    public static MethodHandle _ungetc_nolock$handle() {
        return _ungetc_nolock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _ungetc_nolock(int _Character, FILE *_Stream)
     * }
     */
    public static MemorySegment _ungetc_nolock$address() {
        return _ungetc_nolock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _ungetc_nolock(int _Character, FILE *_Stream)
     * }
     */
    public static int _ungetc_nolock(int _Character, MemorySegment _Stream) {
        var mh$ = _ungetc_nolock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ungetc_nolock", _Character, _Stream);
            }
            return (int)mh$.invokeExact(_Character, _Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __p__commode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("__p__commode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int *__p__commode()
     * }
     */
    public static FunctionDescriptor __p__commode$descriptor() {
        return __p__commode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int *__p__commode()
     * }
     */
    public static MethodHandle __p__commode$handle() {
        return __p__commode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int *__p__commode()
     * }
     */
    public static MemorySegment __p__commode$address() {
        return __p__commode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int *__p__commode()
     * }
     */
    public static MemorySegment __p__commode() {
        var mh$ = __p__commode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__p__commode");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __stdio_common_vfprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("__stdio_common_vfprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __stdio_common_vfprintf(unsigned long long _Options, FILE *_Stream, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static FunctionDescriptor __stdio_common_vfprintf$descriptor() {
        return __stdio_common_vfprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __stdio_common_vfprintf(unsigned long long _Options, FILE *_Stream, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MethodHandle __stdio_common_vfprintf$handle() {
        return __stdio_common_vfprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __stdio_common_vfprintf(unsigned long long _Options, FILE *_Stream, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MemorySegment __stdio_common_vfprintf$address() {
        return __stdio_common_vfprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __stdio_common_vfprintf(unsigned long long _Options, FILE *_Stream, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static int __stdio_common_vfprintf(long _Options, MemorySegment _Stream, MemorySegment _Format, MemorySegment _Locale, MemorySegment _ArgList) {
        var mh$ = __stdio_common_vfprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__stdio_common_vfprintf", _Options, _Stream, _Format, _Locale, _ArgList);
            }
            return (int)mh$.invokeExact(_Options, _Stream, _Format, _Locale, _ArgList);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __stdio_common_vfprintf_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("__stdio_common_vfprintf_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __stdio_common_vfprintf_s(unsigned long long _Options, FILE *_Stream, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static FunctionDescriptor __stdio_common_vfprintf_s$descriptor() {
        return __stdio_common_vfprintf_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __stdio_common_vfprintf_s(unsigned long long _Options, FILE *_Stream, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MethodHandle __stdio_common_vfprintf_s$handle() {
        return __stdio_common_vfprintf_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __stdio_common_vfprintf_s(unsigned long long _Options, FILE *_Stream, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MemorySegment __stdio_common_vfprintf_s$address() {
        return __stdio_common_vfprintf_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __stdio_common_vfprintf_s(unsigned long long _Options, FILE *_Stream, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static int __stdio_common_vfprintf_s(long _Options, MemorySegment _Stream, MemorySegment _Format, MemorySegment _Locale, MemorySegment _ArgList) {
        var mh$ = __stdio_common_vfprintf_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__stdio_common_vfprintf_s", _Options, _Stream, _Format, _Locale, _ArgList);
            }
            return (int)mh$.invokeExact(_Options, _Stream, _Format, _Locale, _ArgList);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __stdio_common_vfprintf_p {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("__stdio_common_vfprintf_p");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __stdio_common_vfprintf_p(unsigned long long _Options, FILE *_Stream, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static FunctionDescriptor __stdio_common_vfprintf_p$descriptor() {
        return __stdio_common_vfprintf_p.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __stdio_common_vfprintf_p(unsigned long long _Options, FILE *_Stream, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MethodHandle __stdio_common_vfprintf_p$handle() {
        return __stdio_common_vfprintf_p.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __stdio_common_vfprintf_p(unsigned long long _Options, FILE *_Stream, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MemorySegment __stdio_common_vfprintf_p$address() {
        return __stdio_common_vfprintf_p.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __stdio_common_vfprintf_p(unsigned long long _Options, FILE *_Stream, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static int __stdio_common_vfprintf_p(long _Options, MemorySegment _Stream, MemorySegment _Format, MemorySegment _Locale, MemorySegment _ArgList) {
        var mh$ = __stdio_common_vfprintf_p.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__stdio_common_vfprintf_p", _Options, _Stream, _Format, _Locale, _ArgList);
            }
            return (int)mh$.invokeExact(_Options, _Stream, _Format, _Locale, _ArgList);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _set_printf_count_output {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_set_printf_count_output");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _set_printf_count_output(int _Value)
     * }
     */
    public static FunctionDescriptor _set_printf_count_output$descriptor() {
        return _set_printf_count_output.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _set_printf_count_output(int _Value)
     * }
     */
    public static MethodHandle _set_printf_count_output$handle() {
        return _set_printf_count_output.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _set_printf_count_output(int _Value)
     * }
     */
    public static MemorySegment _set_printf_count_output$address() {
        return _set_printf_count_output.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _set_printf_count_output(int _Value)
     * }
     */
    public static int _set_printf_count_output(int _Value) {
        var mh$ = _set_printf_count_output.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_set_printf_count_output", _Value);
            }
            return (int)mh$.invokeExact(_Value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _get_printf_count_output {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_get_printf_count_output");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _get_printf_count_output()
     * }
     */
    public static FunctionDescriptor _get_printf_count_output$descriptor() {
        return _get_printf_count_output.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _get_printf_count_output()
     * }
     */
    public static MethodHandle _get_printf_count_output$handle() {
        return _get_printf_count_output.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _get_printf_count_output()
     * }
     */
    public static MemorySegment _get_printf_count_output$address() {
        return _get_printf_count_output.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _get_printf_count_output()
     * }
     */
    public static int _get_printf_count_output() {
        var mh$ = _get_printf_count_output.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_get_printf_count_output");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __stdio_common_vfscanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("__stdio_common_vfscanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __stdio_common_vfscanf(unsigned long long _Options, FILE *_Stream, const char *_Format, _locale_t _Locale, va_list _Arglist)
     * }
     */
    public static FunctionDescriptor __stdio_common_vfscanf$descriptor() {
        return __stdio_common_vfscanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __stdio_common_vfscanf(unsigned long long _Options, FILE *_Stream, const char *_Format, _locale_t _Locale, va_list _Arglist)
     * }
     */
    public static MethodHandle __stdio_common_vfscanf$handle() {
        return __stdio_common_vfscanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __stdio_common_vfscanf(unsigned long long _Options, FILE *_Stream, const char *_Format, _locale_t _Locale, va_list _Arglist)
     * }
     */
    public static MemorySegment __stdio_common_vfscanf$address() {
        return __stdio_common_vfscanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __stdio_common_vfscanf(unsigned long long _Options, FILE *_Stream, const char *_Format, _locale_t _Locale, va_list _Arglist)
     * }
     */
    public static int __stdio_common_vfscanf(long _Options, MemorySegment _Stream, MemorySegment _Format, MemorySegment _Locale, MemorySegment _Arglist) {
        var mh$ = __stdio_common_vfscanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__stdio_common_vfscanf", _Options, _Stream, _Format, _Locale, _Arglist);
            }
            return (int)mh$.invokeExact(_Options, _Stream, _Format, _Locale, _Arglist);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __stdio_common_vsprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("__stdio_common_vsprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __stdio_common_vsprintf(unsigned long long _Options, char *_Buffer, size_t _BufferCount, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static FunctionDescriptor __stdio_common_vsprintf$descriptor() {
        return __stdio_common_vsprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __stdio_common_vsprintf(unsigned long long _Options, char *_Buffer, size_t _BufferCount, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MethodHandle __stdio_common_vsprintf$handle() {
        return __stdio_common_vsprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __stdio_common_vsprintf(unsigned long long _Options, char *_Buffer, size_t _BufferCount, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MemorySegment __stdio_common_vsprintf$address() {
        return __stdio_common_vsprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __stdio_common_vsprintf(unsigned long long _Options, char *_Buffer, size_t _BufferCount, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static int __stdio_common_vsprintf(long _Options, MemorySegment _Buffer, long _BufferCount, MemorySegment _Format, MemorySegment _Locale, MemorySegment _ArgList) {
        var mh$ = __stdio_common_vsprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__stdio_common_vsprintf", _Options, _Buffer, _BufferCount, _Format, _Locale, _ArgList);
            }
            return (int)mh$.invokeExact(_Options, _Buffer, _BufferCount, _Format, _Locale, _ArgList);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __stdio_common_vsprintf_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("__stdio_common_vsprintf_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __stdio_common_vsprintf_s(unsigned long long _Options, char *_Buffer, size_t _BufferCount, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static FunctionDescriptor __stdio_common_vsprintf_s$descriptor() {
        return __stdio_common_vsprintf_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __stdio_common_vsprintf_s(unsigned long long _Options, char *_Buffer, size_t _BufferCount, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MethodHandle __stdio_common_vsprintf_s$handle() {
        return __stdio_common_vsprintf_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __stdio_common_vsprintf_s(unsigned long long _Options, char *_Buffer, size_t _BufferCount, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MemorySegment __stdio_common_vsprintf_s$address() {
        return __stdio_common_vsprintf_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __stdio_common_vsprintf_s(unsigned long long _Options, char *_Buffer, size_t _BufferCount, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static int __stdio_common_vsprintf_s(long _Options, MemorySegment _Buffer, long _BufferCount, MemorySegment _Format, MemorySegment _Locale, MemorySegment _ArgList) {
        var mh$ = __stdio_common_vsprintf_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__stdio_common_vsprintf_s", _Options, _Buffer, _BufferCount, _Format, _Locale, _ArgList);
            }
            return (int)mh$.invokeExact(_Options, _Buffer, _BufferCount, _Format, _Locale, _ArgList);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __stdio_common_vsnprintf_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("__stdio_common_vsnprintf_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __stdio_common_vsnprintf_s(unsigned long long _Options, char *_Buffer, size_t _BufferCount, size_t _MaxCount, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static FunctionDescriptor __stdio_common_vsnprintf_s$descriptor() {
        return __stdio_common_vsnprintf_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __stdio_common_vsnprintf_s(unsigned long long _Options, char *_Buffer, size_t _BufferCount, size_t _MaxCount, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MethodHandle __stdio_common_vsnprintf_s$handle() {
        return __stdio_common_vsnprintf_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __stdio_common_vsnprintf_s(unsigned long long _Options, char *_Buffer, size_t _BufferCount, size_t _MaxCount, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MemorySegment __stdio_common_vsnprintf_s$address() {
        return __stdio_common_vsnprintf_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __stdio_common_vsnprintf_s(unsigned long long _Options, char *_Buffer, size_t _BufferCount, size_t _MaxCount, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static int __stdio_common_vsnprintf_s(long _Options, MemorySegment _Buffer, long _BufferCount, long _MaxCount, MemorySegment _Format, MemorySegment _Locale, MemorySegment _ArgList) {
        var mh$ = __stdio_common_vsnprintf_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__stdio_common_vsnprintf_s", _Options, _Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);
            }
            return (int)mh$.invokeExact(_Options, _Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __stdio_common_vsprintf_p {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("__stdio_common_vsprintf_p");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __stdio_common_vsprintf_p(unsigned long long _Options, char *_Buffer, size_t _BufferCount, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static FunctionDescriptor __stdio_common_vsprintf_p$descriptor() {
        return __stdio_common_vsprintf_p.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __stdio_common_vsprintf_p(unsigned long long _Options, char *_Buffer, size_t _BufferCount, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MethodHandle __stdio_common_vsprintf_p$handle() {
        return __stdio_common_vsprintf_p.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __stdio_common_vsprintf_p(unsigned long long _Options, char *_Buffer, size_t _BufferCount, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MemorySegment __stdio_common_vsprintf_p$address() {
        return __stdio_common_vsprintf_p.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __stdio_common_vsprintf_p(unsigned long long _Options, char *_Buffer, size_t _BufferCount, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static int __stdio_common_vsprintf_p(long _Options, MemorySegment _Buffer, long _BufferCount, MemorySegment _Format, MemorySegment _Locale, MemorySegment _ArgList) {
        var mh$ = __stdio_common_vsprintf_p.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__stdio_common_vsprintf_p", _Options, _Buffer, _BufferCount, _Format, _Locale, _ArgList);
            }
            return (int)mh$.invokeExact(_Options, _Buffer, _BufferCount, _Format, _Locale, _ArgList);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __stdio_common_vsscanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("__stdio_common_vsscanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __stdio_common_vsscanf(unsigned long long _Options, const char *_Buffer, size_t _BufferCount, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static FunctionDescriptor __stdio_common_vsscanf$descriptor() {
        return __stdio_common_vsscanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __stdio_common_vsscanf(unsigned long long _Options, const char *_Buffer, size_t _BufferCount, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MethodHandle __stdio_common_vsscanf$handle() {
        return __stdio_common_vsscanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __stdio_common_vsscanf(unsigned long long _Options, const char *_Buffer, size_t _BufferCount, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MemorySegment __stdio_common_vsscanf$address() {
        return __stdio_common_vsscanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __stdio_common_vsscanf(unsigned long long _Options, const char *_Buffer, size_t _BufferCount, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static int __stdio_common_vsscanf(long _Options, MemorySegment _Buffer, long _BufferCount, MemorySegment _Format, MemorySegment _Locale, MemorySegment _ArgList) {
        var mh$ = __stdio_common_vsscanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__stdio_common_vsscanf", _Options, _Buffer, _BufferCount, _Format, _Locale, _ArgList);
            }
            return (int)mh$.invokeExact(_Options, _Buffer, _BufferCount, _Format, _Locale, _ArgList);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tempnam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("tempnam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *tempnam(const char *_Directory, const char *_FilePrefix)
     * }
     */
    public static FunctionDescriptor tempnam$descriptor() {
        return tempnam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *tempnam(const char *_Directory, const char *_FilePrefix)
     * }
     */
    public static MethodHandle tempnam$handle() {
        return tempnam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *tempnam(const char *_Directory, const char *_FilePrefix)
     * }
     */
    public static MemorySegment tempnam$address() {
        return tempnam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *tempnam(const char *_Directory, const char *_FilePrefix)
     * }
     */
    public static MemorySegment tempnam(MemorySegment _Directory, MemorySegment _FilePrefix) {
        var mh$ = tempnam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tempnam", _Directory, _FilePrefix);
            }
            return (MemorySegment)mh$.invokeExact(_Directory, _FilePrefix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fcloseall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fcloseall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fcloseall()
     * }
     */
    public static FunctionDescriptor fcloseall$descriptor() {
        return fcloseall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fcloseall()
     * }
     */
    public static MethodHandle fcloseall$handle() {
        return fcloseall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fcloseall()
     * }
     */
    public static MemorySegment fcloseall$address() {
        return fcloseall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fcloseall()
     * }
     */
    public static int fcloseall() {
        var mh$ = fcloseall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fcloseall");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fdopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fdopen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FILE *fdopen(int _FileHandle, const char *_Format)
     * }
     */
    public static FunctionDescriptor fdopen$descriptor() {
        return fdopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FILE *fdopen(int _FileHandle, const char *_Format)
     * }
     */
    public static MethodHandle fdopen$handle() {
        return fdopen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FILE *fdopen(int _FileHandle, const char *_Format)
     * }
     */
    public static MemorySegment fdopen$address() {
        return fdopen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FILE *fdopen(int _FileHandle, const char *_Format)
     * }
     */
    public static MemorySegment fdopen(int _FileHandle, MemorySegment _Format) {
        var mh$ = fdopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fdopen", _FileHandle, _Format);
            }
            return (MemorySegment)mh$.invokeExact(_FileHandle, _Format);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fgetchar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fgetchar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fgetchar()
     * }
     */
    public static FunctionDescriptor fgetchar$descriptor() {
        return fgetchar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fgetchar()
     * }
     */
    public static MethodHandle fgetchar$handle() {
        return fgetchar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fgetchar()
     * }
     */
    public static MemorySegment fgetchar$address() {
        return fgetchar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fgetchar()
     * }
     */
    public static int fgetchar() {
        var mh$ = fgetchar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fgetchar");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fileno {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fileno");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fileno(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor fileno$descriptor() {
        return fileno.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fileno(FILE *_Stream)
     * }
     */
    public static MethodHandle fileno$handle() {
        return fileno.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fileno(FILE *_Stream)
     * }
     */
    public static MemorySegment fileno$address() {
        return fileno.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fileno(FILE *_Stream)
     * }
     */
    public static int fileno(MemorySegment _Stream) {
        var mh$ = fileno.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fileno", _Stream);
            }
            return (int)mh$.invokeExact(_Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flushall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("flushall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int flushall()
     * }
     */
    public static FunctionDescriptor flushall$descriptor() {
        return flushall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int flushall()
     * }
     */
    public static MethodHandle flushall$handle() {
        return flushall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int flushall()
     * }
     */
    public static MemorySegment flushall$address() {
        return flushall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int flushall()
     * }
     */
    public static int flushall() {
        var mh$ = flushall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flushall");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fputchar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fputchar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fputchar(int _Ch)
     * }
     */
    public static FunctionDescriptor fputchar$descriptor() {
        return fputchar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fputchar(int _Ch)
     * }
     */
    public static MethodHandle fputchar$handle() {
        return fputchar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fputchar(int _Ch)
     * }
     */
    public static MemorySegment fputchar$address() {
        return fputchar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fputchar(int _Ch)
     * }
     */
    public static int fputchar(int _Ch) {
        var mh$ = fputchar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fputchar", _Ch);
            }
            return (int)mh$.invokeExact(_Ch);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getw {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("getw");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getw(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor getw$descriptor() {
        return getw.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getw(FILE *_Stream)
     * }
     */
    public static MethodHandle getw$handle() {
        return getw.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getw(FILE *_Stream)
     * }
     */
    public static MemorySegment getw$address() {
        return getw.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getw(FILE *_Stream)
     * }
     */
    public static int getw(MemorySegment _Stream) {
        var mh$ = getw.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getw", _Stream);
            }
            return (int)mh$.invokeExact(_Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putw {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("putw");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int putw(int _Ch, FILE *_Stream)
     * }
     */
    public static FunctionDescriptor putw$descriptor() {
        return putw.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int putw(int _Ch, FILE *_Stream)
     * }
     */
    public static MethodHandle putw$handle() {
        return putw.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int putw(int _Ch, FILE *_Stream)
     * }
     */
    public static MemorySegment putw$address() {
        return putw.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int putw(int _Ch, FILE *_Stream)
     * }
     */
    public static int putw(int _Ch, MemorySegment _Stream) {
        var mh$ = putw.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putw", _Ch, _Stream);
            }
            return (int)mh$.invokeExact(_Ch, _Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rmtmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("rmtmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int rmtmp()
     * }
     */
    public static FunctionDescriptor rmtmp$descriptor() {
        return rmtmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int rmtmp()
     * }
     */
    public static MethodHandle rmtmp$handle() {
        return rmtmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int rmtmp()
     * }
     */
    public static MemorySegment rmtmp$address() {
        return rmtmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int rmtmp()
     * }
     */
    public static int rmtmp() {
        var mh$ = rmtmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rmtmp");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef double max_align_t
     * }
     */
    public static final OfDouble max_align_t = Python_h.C_DOUBLE;

    private static class _wassert {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wassert");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _wassert(const wchar_t *_Message, const wchar_t *_File, unsigned int _Line)
     * }
     */
    public static FunctionDescriptor _wassert$descriptor() {
        return _wassert.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _wassert(const wchar_t *_Message, const wchar_t *_File, unsigned int _Line)
     * }
     */
    public static MethodHandle _wassert$handle() {
        return _wassert.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _wassert(const wchar_t *_Message, const wchar_t *_File, unsigned int _Line)
     * }
     */
    public static MemorySegment _wassert$address() {
        return _wassert.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _wassert(const wchar_t *_Message, const wchar_t *_File, unsigned int _Line)
     * }
     */
    public static void _wassert(MemorySegment _Message, MemorySegment _File, int _Line) {
        var mh$ = _wassert.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wassert", _Message, _File, _Line);
            }
            mh$.invokeExact(_Message, _File, _Line);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _errno {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_errno");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int *_errno()
     * }
     */
    public static FunctionDescriptor _errno$descriptor() {
        return _errno.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int *_errno()
     * }
     */
    public static MethodHandle _errno$handle() {
        return _errno.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int *_errno()
     * }
     */
    public static MemorySegment _errno$address() {
        return _errno.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int *_errno()
     * }
     */
    public static MemorySegment _errno() {
        var mh$ = _errno.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_errno");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _set_errno {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_set_errno");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _set_errno(int _Value)
     * }
     */
    public static FunctionDescriptor _set_errno$descriptor() {
        return _set_errno.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _set_errno(int _Value)
     * }
     */
    public static MethodHandle _set_errno$handle() {
        return _set_errno.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _set_errno(int _Value)
     * }
     */
    public static MemorySegment _set_errno$address() {
        return _set_errno.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _set_errno(int _Value)
     * }
     */
    public static int _set_errno(int _Value) {
        var mh$ = _set_errno.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_set_errno", _Value);
            }
            return (int)mh$.invokeExact(_Value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _get_errno {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_get_errno");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _get_errno(int *_Value)
     * }
     */
    public static FunctionDescriptor _get_errno$descriptor() {
        return _get_errno.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _get_errno(int *_Value)
     * }
     */
    public static MethodHandle _get_errno$handle() {
        return _get_errno.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _get_errno(int *_Value)
     * }
     */
    public static MemorySegment _get_errno$address() {
        return _get_errno.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _get_errno(int *_Value)
     * }
     */
    public static int _get_errno(MemorySegment _Value) {
        var mh$ = _get_errno.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_get_errno", _Value);
            }
            return (int)mh$.invokeExact(_Value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __doserrno {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("__doserrno");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long *__doserrno()
     * }
     */
    public static FunctionDescriptor __doserrno$descriptor() {
        return __doserrno.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long *__doserrno()
     * }
     */
    public static MethodHandle __doserrno$handle() {
        return __doserrno.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long *__doserrno()
     * }
     */
    public static MemorySegment __doserrno$address() {
        return __doserrno.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long *__doserrno()
     * }
     */
    public static MemorySegment __doserrno() {
        var mh$ = __doserrno.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__doserrno");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _set_doserrno {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_set_doserrno");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _set_doserrno(unsigned long _Value)
     * }
     */
    public static FunctionDescriptor _set_doserrno$descriptor() {
        return _set_doserrno.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _set_doserrno(unsigned long _Value)
     * }
     */
    public static MethodHandle _set_doserrno$handle() {
        return _set_doserrno.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _set_doserrno(unsigned long _Value)
     * }
     */
    public static MemorySegment _set_doserrno$address() {
        return _set_doserrno.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _set_doserrno(unsigned long _Value)
     * }
     */
    public static int _set_doserrno(int _Value) {
        var mh$ = _set_doserrno.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_set_doserrno", _Value);
            }
            return (int)mh$.invokeExact(_Value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _get_doserrno {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_get_doserrno");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _get_doserrno(unsigned long *_Value)
     * }
     */
    public static FunctionDescriptor _get_doserrno$descriptor() {
        return _get_doserrno.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _get_doserrno(unsigned long *_Value)
     * }
     */
    public static MethodHandle _get_doserrno$handle() {
        return _get_doserrno.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _get_doserrno(unsigned long *_Value)
     * }
     */
    public static MemorySegment _get_doserrno$address() {
        return _get_doserrno.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _get_doserrno(unsigned long *_Value)
     * }
     */
    public static int _get_doserrno(MemorySegment _Value) {
        var mh$ = _get_doserrno.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_get_doserrno", _Value);
            }
            return (int)mh$.invokeExact(_Value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memchr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("memchr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *memchr(const void *_Buf, int _Val, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor memchr$descriptor() {
        return memchr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *memchr(const void *_Buf, int _Val, size_t _MaxCount)
     * }
     */
    public static MethodHandle memchr$handle() {
        return memchr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *memchr(const void *_Buf, int _Val, size_t _MaxCount)
     * }
     */
    public static MemorySegment memchr$address() {
        return memchr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *memchr(const void *_Buf, int _Val, size_t _MaxCount)
     * }
     */
    public static MemorySegment memchr(MemorySegment _Buf, int _Val, long _MaxCount) {
        var mh$ = memchr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memchr", _Buf, _Val, _MaxCount);
            }
            return (MemorySegment)mh$.invokeExact(_Buf, _Val, _MaxCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memcmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("memcmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int memcmp(const void *_Buf1, const void *_Buf2, size_t _Size)
     * }
     */
    public static FunctionDescriptor memcmp$descriptor() {
        return memcmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int memcmp(const void *_Buf1, const void *_Buf2, size_t _Size)
     * }
     */
    public static MethodHandle memcmp$handle() {
        return memcmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int memcmp(const void *_Buf1, const void *_Buf2, size_t _Size)
     * }
     */
    public static MemorySegment memcmp$address() {
        return memcmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int memcmp(const void *_Buf1, const void *_Buf2, size_t _Size)
     * }
     */
    public static int memcmp(MemorySegment _Buf1, MemorySegment _Buf2, long _Size) {
        var mh$ = memcmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memcmp", _Buf1, _Buf2, _Size);
            }
            return (int)mh$.invokeExact(_Buf1, _Buf2, _Size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memcpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("memcpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *memcpy(void *_Dst, const void *_Src, size_t _Size)
     * }
     */
    public static FunctionDescriptor memcpy$descriptor() {
        return memcpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *memcpy(void *_Dst, const void *_Src, size_t _Size)
     * }
     */
    public static MethodHandle memcpy$handle() {
        return memcpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *memcpy(void *_Dst, const void *_Src, size_t _Size)
     * }
     */
    public static MemorySegment memcpy$address() {
        return memcpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *memcpy(void *_Dst, const void *_Src, size_t _Size)
     * }
     */
    public static MemorySegment memcpy(MemorySegment _Dst, MemorySegment _Src, long _Size) {
        var mh$ = memcpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memcpy", _Dst, _Src, _Size);
            }
            return (MemorySegment)mh$.invokeExact(_Dst, _Src, _Size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memmove {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("memmove");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *memmove(void *_Dst, const void *_Src, size_t _Size)
     * }
     */
    public static FunctionDescriptor memmove$descriptor() {
        return memmove.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *memmove(void *_Dst, const void *_Src, size_t _Size)
     * }
     */
    public static MethodHandle memmove$handle() {
        return memmove.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *memmove(void *_Dst, const void *_Src, size_t _Size)
     * }
     */
    public static MemorySegment memmove$address() {
        return memmove.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *memmove(void *_Dst, const void *_Src, size_t _Size)
     * }
     */
    public static MemorySegment memmove(MemorySegment _Dst, MemorySegment _Src, long _Size) {
        var mh$ = memmove.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memmove", _Dst, _Src, _Size);
            }
            return (MemorySegment)mh$.invokeExact(_Dst, _Src, _Size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("memset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *memset(void *_Dst, int _Val, size_t _Size)
     * }
     */
    public static FunctionDescriptor memset$descriptor() {
        return memset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *memset(void *_Dst, int _Val, size_t _Size)
     * }
     */
    public static MethodHandle memset$handle() {
        return memset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *memset(void *_Dst, int _Val, size_t _Size)
     * }
     */
    public static MemorySegment memset$address() {
        return memset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *memset(void *_Dst, int _Val, size_t _Size)
     * }
     */
    public static MemorySegment memset(MemorySegment _Dst, int _Val, long _Size) {
        var mh$ = memset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memset", _Dst, _Val, _Size);
            }
            return (MemorySegment)mh$.invokeExact(_Dst, _Val, _Size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strchr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("strchr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strchr(const char *_Str, int _Val)
     * }
     */
    public static FunctionDescriptor strchr$descriptor() {
        return strchr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strchr(const char *_Str, int _Val)
     * }
     */
    public static MethodHandle strchr$handle() {
        return strchr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strchr(const char *_Str, int _Val)
     * }
     */
    public static MemorySegment strchr$address() {
        return strchr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strchr(const char *_Str, int _Val)
     * }
     */
    public static MemorySegment strchr(MemorySegment _Str, int _Val) {
        var mh$ = strchr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strchr", _Str, _Val);
            }
            return (MemorySegment)mh$.invokeExact(_Str, _Val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strrchr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("strrchr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strrchr(const char *_Str, int _Ch)
     * }
     */
    public static FunctionDescriptor strrchr$descriptor() {
        return strrchr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strrchr(const char *_Str, int _Ch)
     * }
     */
    public static MethodHandle strrchr$handle() {
        return strrchr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strrchr(const char *_Str, int _Ch)
     * }
     */
    public static MemorySegment strrchr$address() {
        return strrchr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strrchr(const char *_Str, int _Ch)
     * }
     */
    public static MemorySegment strrchr(MemorySegment _Str, int _Ch) {
        var mh$ = strrchr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strrchr", _Str, _Ch);
            }
            return (MemorySegment)mh$.invokeExact(_Str, _Ch);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strstr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("strstr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strstr(const char *_Str, const char *_SubStr)
     * }
     */
    public static FunctionDescriptor strstr$descriptor() {
        return strstr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strstr(const char *_Str, const char *_SubStr)
     * }
     */
    public static MethodHandle strstr$handle() {
        return strstr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strstr(const char *_Str, const char *_SubStr)
     * }
     */
    public static MemorySegment strstr$address() {
        return strstr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strstr(const char *_Str, const char *_SubStr)
     * }
     */
    public static MemorySegment strstr(MemorySegment _Str, MemorySegment _SubStr) {
        var mh$ = strstr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strstr", _Str, _SubStr);
            }
            return (MemorySegment)mh$.invokeExact(_Str, _SubStr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcschr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_SHORT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcschr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned short *wcschr(const wchar_t *_Str, wchar_t _Ch)
     * }
     */
    public static FunctionDescriptor wcschr$descriptor() {
        return wcschr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned short *wcschr(const wchar_t *_Str, wchar_t _Ch)
     * }
     */
    public static MethodHandle wcschr$handle() {
        return wcschr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned short *wcschr(const wchar_t *_Str, wchar_t _Ch)
     * }
     */
    public static MemorySegment wcschr$address() {
        return wcschr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned short *wcschr(const wchar_t *_Str, wchar_t _Ch)
     * }
     */
    public static MemorySegment wcschr(MemorySegment _Str, short _Ch) {
        var mh$ = wcschr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcschr", _Str, _Ch);
            }
            return (MemorySegment)mh$.invokeExact(_Str, _Ch);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsrchr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_SHORT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcsrchr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *wcsrchr(const wchar_t *_Str, wchar_t _Ch)
     * }
     */
    public static FunctionDescriptor wcsrchr$descriptor() {
        return wcsrchr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *wcsrchr(const wchar_t *_Str, wchar_t _Ch)
     * }
     */
    public static MethodHandle wcsrchr$handle() {
        return wcsrchr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *wcsrchr(const wchar_t *_Str, wchar_t _Ch)
     * }
     */
    public static MemorySegment wcsrchr$address() {
        return wcsrchr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *wcsrchr(const wchar_t *_Str, wchar_t _Ch)
     * }
     */
    public static MemorySegment wcsrchr(MemorySegment _Str, short _Ch) {
        var mh$ = wcsrchr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsrchr", _Str, _Ch);
            }
            return (MemorySegment)mh$.invokeExact(_Str, _Ch);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsstr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcsstr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *wcsstr(const wchar_t *_Str, const wchar_t *_SubStr)
     * }
     */
    public static FunctionDescriptor wcsstr$descriptor() {
        return wcsstr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *wcsstr(const wchar_t *_Str, const wchar_t *_SubStr)
     * }
     */
    public static MethodHandle wcsstr$handle() {
        return wcsstr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *wcsstr(const wchar_t *_Str, const wchar_t *_SubStr)
     * }
     */
    public static MemorySegment wcsstr$address() {
        return wcsstr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *wcsstr(const wchar_t *_Str, const wchar_t *_SubStr)
     * }
     */
    public static MemorySegment wcsstr(MemorySegment _Str, MemorySegment _SubStr) {
        var mh$ = wcsstr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsstr", _Str, _SubStr);
            }
            return (MemorySegment)mh$.invokeExact(_Str, _SubStr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _cgetws_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_cgetws_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _cgetws_s(wchar_t *_Buffer, size_t _BufferCount, size_t *_SizeRead)
     * }
     */
    public static FunctionDescriptor _cgetws_s$descriptor() {
        return _cgetws_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _cgetws_s(wchar_t *_Buffer, size_t _BufferCount, size_t *_SizeRead)
     * }
     */
    public static MethodHandle _cgetws_s$handle() {
        return _cgetws_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _cgetws_s(wchar_t *_Buffer, size_t _BufferCount, size_t *_SizeRead)
     * }
     */
    public static MemorySegment _cgetws_s$address() {
        return _cgetws_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _cgetws_s(wchar_t *_Buffer, size_t _BufferCount, size_t *_SizeRead)
     * }
     */
    public static int _cgetws_s(MemorySegment _Buffer, long _BufferCount, MemorySegment _SizeRead) {
        var mh$ = _cgetws_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_cgetws_s", _Buffer, _BufferCount, _SizeRead);
            }
            return (int)mh$.invokeExact(_Buffer, _BufferCount, _SizeRead);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _cputws {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_cputws");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _cputws(const wchar_t *_Buffer)
     * }
     */
    public static FunctionDescriptor _cputws$descriptor() {
        return _cputws.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _cputws(const wchar_t *_Buffer)
     * }
     */
    public static MethodHandle _cputws$handle() {
        return _cputws.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _cputws(const wchar_t *_Buffer)
     * }
     */
    public static MemorySegment _cputws$address() {
        return _cputws.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _cputws(const wchar_t *_Buffer)
     * }
     */
    public static int _cputws(MemorySegment _Buffer) {
        var mh$ = _cputws.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_cputws", _Buffer);
            }
            return (int)mh$.invokeExact(_Buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _getwch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_SHORT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_getwch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wint_t _getwch()
     * }
     */
    public static FunctionDescriptor _getwch$descriptor() {
        return _getwch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wint_t _getwch()
     * }
     */
    public static MethodHandle _getwch$handle() {
        return _getwch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wint_t _getwch()
     * }
     */
    public static MemorySegment _getwch$address() {
        return _getwch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wint_t _getwch()
     * }
     */
    public static short _getwch() {
        var mh$ = _getwch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_getwch");
            }
            return (short)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _getwche {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_SHORT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_getwche");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wint_t _getwche()
     * }
     */
    public static FunctionDescriptor _getwche$descriptor() {
        return _getwche.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wint_t _getwche()
     * }
     */
    public static MethodHandle _getwche$handle() {
        return _getwche.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wint_t _getwche()
     * }
     */
    public static MemorySegment _getwche$address() {
        return _getwche.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wint_t _getwche()
     * }
     */
    public static short _getwche() {
        var mh$ = _getwche.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_getwche");
            }
            return (short)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _putwch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_SHORT,
            Python_h.C_SHORT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_putwch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wint_t _putwch(wchar_t _Character)
     * }
     */
    public static FunctionDescriptor _putwch$descriptor() {
        return _putwch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wint_t _putwch(wchar_t _Character)
     * }
     */
    public static MethodHandle _putwch$handle() {
        return _putwch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wint_t _putwch(wchar_t _Character)
     * }
     */
    public static MemorySegment _putwch$address() {
        return _putwch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wint_t _putwch(wchar_t _Character)
     * }
     */
    public static short _putwch(short _Character) {
        var mh$ = _putwch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_putwch", _Character);
            }
            return (short)mh$.invokeExact(_Character);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ungetwch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_SHORT,
            Python_h.C_SHORT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_ungetwch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wint_t _ungetwch(wint_t _Character)
     * }
     */
    public static FunctionDescriptor _ungetwch$descriptor() {
        return _ungetwch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wint_t _ungetwch(wint_t _Character)
     * }
     */
    public static MethodHandle _ungetwch$handle() {
        return _ungetwch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wint_t _ungetwch(wint_t _Character)
     * }
     */
    public static MemorySegment _ungetwch$address() {
        return _ungetwch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wint_t _ungetwch(wint_t _Character)
     * }
     */
    public static short _ungetwch(short _Character) {
        var mh$ = _ungetwch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ungetwch", _Character);
            }
            return (short)mh$.invokeExact(_Character);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _getwch_nolock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_SHORT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_getwch_nolock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wint_t _getwch_nolock()
     * }
     */
    public static FunctionDescriptor _getwch_nolock$descriptor() {
        return _getwch_nolock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wint_t _getwch_nolock()
     * }
     */
    public static MethodHandle _getwch_nolock$handle() {
        return _getwch_nolock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wint_t _getwch_nolock()
     * }
     */
    public static MemorySegment _getwch_nolock$address() {
        return _getwch_nolock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wint_t _getwch_nolock()
     * }
     */
    public static short _getwch_nolock() {
        var mh$ = _getwch_nolock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_getwch_nolock");
            }
            return (short)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _getwche_nolock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_SHORT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_getwche_nolock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wint_t _getwche_nolock()
     * }
     */
    public static FunctionDescriptor _getwche_nolock$descriptor() {
        return _getwche_nolock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wint_t _getwche_nolock()
     * }
     */
    public static MethodHandle _getwche_nolock$handle() {
        return _getwche_nolock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wint_t _getwche_nolock()
     * }
     */
    public static MemorySegment _getwche_nolock$address() {
        return _getwche_nolock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wint_t _getwche_nolock()
     * }
     */
    public static short _getwche_nolock() {
        var mh$ = _getwche_nolock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_getwche_nolock");
            }
            return (short)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _putwch_nolock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_SHORT,
            Python_h.C_SHORT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_putwch_nolock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wint_t _putwch_nolock(wchar_t _Character)
     * }
     */
    public static FunctionDescriptor _putwch_nolock$descriptor() {
        return _putwch_nolock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wint_t _putwch_nolock(wchar_t _Character)
     * }
     */
    public static MethodHandle _putwch_nolock$handle() {
        return _putwch_nolock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wint_t _putwch_nolock(wchar_t _Character)
     * }
     */
    public static MemorySegment _putwch_nolock$address() {
        return _putwch_nolock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wint_t _putwch_nolock(wchar_t _Character)
     * }
     */
    public static short _putwch_nolock(short _Character) {
        var mh$ = _putwch_nolock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_putwch_nolock", _Character);
            }
            return (short)mh$.invokeExact(_Character);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ungetwch_nolock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_SHORT,
            Python_h.C_SHORT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_ungetwch_nolock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wint_t _ungetwch_nolock(wint_t _Character)
     * }
     */
    public static FunctionDescriptor _ungetwch_nolock$descriptor() {
        return _ungetwch_nolock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wint_t _ungetwch_nolock(wint_t _Character)
     * }
     */
    public static MethodHandle _ungetwch_nolock$handle() {
        return _ungetwch_nolock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wint_t _ungetwch_nolock(wint_t _Character)
     * }
     */
    public static MemorySegment _ungetwch_nolock$address() {
        return _ungetwch_nolock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wint_t _ungetwch_nolock(wint_t _Character)
     * }
     */
    public static short _ungetwch_nolock(short _Character) {
        var mh$ = _ungetwch_nolock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ungetwch_nolock", _Character);
            }
            return (short)mh$.invokeExact(_Character);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __conio_common_vcwprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("__conio_common_vcwprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __conio_common_vcwprintf(unsigned long long _Options, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static FunctionDescriptor __conio_common_vcwprintf$descriptor() {
        return __conio_common_vcwprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __conio_common_vcwprintf(unsigned long long _Options, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MethodHandle __conio_common_vcwprintf$handle() {
        return __conio_common_vcwprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __conio_common_vcwprintf(unsigned long long _Options, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MemorySegment __conio_common_vcwprintf$address() {
        return __conio_common_vcwprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __conio_common_vcwprintf(unsigned long long _Options, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static int __conio_common_vcwprintf(long _Options, MemorySegment _Format, MemorySegment _Locale, MemorySegment _ArgList) {
        var mh$ = __conio_common_vcwprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__conio_common_vcwprintf", _Options, _Format, _Locale, _ArgList);
            }
            return (int)mh$.invokeExact(_Options, _Format, _Locale, _ArgList);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __conio_common_vcwprintf_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("__conio_common_vcwprintf_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __conio_common_vcwprintf_s(unsigned long long _Options, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static FunctionDescriptor __conio_common_vcwprintf_s$descriptor() {
        return __conio_common_vcwprintf_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __conio_common_vcwprintf_s(unsigned long long _Options, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MethodHandle __conio_common_vcwprintf_s$handle() {
        return __conio_common_vcwprintf_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __conio_common_vcwprintf_s(unsigned long long _Options, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MemorySegment __conio_common_vcwprintf_s$address() {
        return __conio_common_vcwprintf_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __conio_common_vcwprintf_s(unsigned long long _Options, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static int __conio_common_vcwprintf_s(long _Options, MemorySegment _Format, MemorySegment _Locale, MemorySegment _ArgList) {
        var mh$ = __conio_common_vcwprintf_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__conio_common_vcwprintf_s", _Options, _Format, _Locale, _ArgList);
            }
            return (int)mh$.invokeExact(_Options, _Format, _Locale, _ArgList);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __conio_common_vcwprintf_p {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("__conio_common_vcwprintf_p");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __conio_common_vcwprintf_p(unsigned long long _Options, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static FunctionDescriptor __conio_common_vcwprintf_p$descriptor() {
        return __conio_common_vcwprintf_p.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __conio_common_vcwprintf_p(unsigned long long _Options, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MethodHandle __conio_common_vcwprintf_p$handle() {
        return __conio_common_vcwprintf_p.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __conio_common_vcwprintf_p(unsigned long long _Options, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MemorySegment __conio_common_vcwprintf_p$address() {
        return __conio_common_vcwprintf_p.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __conio_common_vcwprintf_p(unsigned long long _Options, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static int __conio_common_vcwprintf_p(long _Options, MemorySegment _Format, MemorySegment _Locale, MemorySegment _ArgList) {
        var mh$ = __conio_common_vcwprintf_p.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__conio_common_vcwprintf_p", _Options, _Format, _Locale, _ArgList);
            }
            return (int)mh$.invokeExact(_Options, _Format, _Locale, _ArgList);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __conio_common_vcwscanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("__conio_common_vcwscanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __conio_common_vcwscanf(unsigned long long _Options, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static FunctionDescriptor __conio_common_vcwscanf$descriptor() {
        return __conio_common_vcwscanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __conio_common_vcwscanf(unsigned long long _Options, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MethodHandle __conio_common_vcwscanf$handle() {
        return __conio_common_vcwscanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __conio_common_vcwscanf(unsigned long long _Options, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MemorySegment __conio_common_vcwscanf$address() {
        return __conio_common_vcwscanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __conio_common_vcwscanf(unsigned long long _Options, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static int __conio_common_vcwscanf(long _Options, MemorySegment _Format, MemorySegment _Locale, MemorySegment _ArgList) {
        var mh$ = __conio_common_vcwscanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__conio_common_vcwscanf", _Options, _Format, _Locale, _ArgList);
            }
            return (int)mh$.invokeExact(_Options, _Format, _Locale, _ArgList);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __pctype_func {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("__pctype_func");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const unsigned short *__pctype_func()
     * }
     */
    public static FunctionDescriptor __pctype_func$descriptor() {
        return __pctype_func.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const unsigned short *__pctype_func()
     * }
     */
    public static MethodHandle __pctype_func$handle() {
        return __pctype_func.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const unsigned short *__pctype_func()
     * }
     */
    public static MemorySegment __pctype_func$address() {
        return __pctype_func.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const unsigned short *__pctype_func()
     * }
     */
    public static MemorySegment __pctype_func() {
        var mh$ = __pctype_func.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__pctype_func");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __pwctype_func {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("__pwctype_func");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const wctype_t *__pwctype_func()
     * }
     */
    public static FunctionDescriptor __pwctype_func$descriptor() {
        return __pwctype_func.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const wctype_t *__pwctype_func()
     * }
     */
    public static MethodHandle __pwctype_func$handle() {
        return __pwctype_func.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const wctype_t *__pwctype_func()
     * }
     */
    public static MemorySegment __pwctype_func$address() {
        return __pwctype_func.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const wctype_t *__pwctype_func()
     * }
     */
    public static MemorySegment __pwctype_func() {
        var mh$ = __pwctype_func.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__pwctype_func");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class iswalnum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_SHORT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("iswalnum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int iswalnum(wint_t _C)
     * }
     */
    public static FunctionDescriptor iswalnum$descriptor() {
        return iswalnum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int iswalnum(wint_t _C)
     * }
     */
    public static MethodHandle iswalnum$handle() {
        return iswalnum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int iswalnum(wint_t _C)
     * }
     */
    public static MemorySegment iswalnum$address() {
        return iswalnum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int iswalnum(wint_t _C)
     * }
     */
    public static int iswalnum(short _C) {
        var mh$ = iswalnum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("iswalnum", _C);
            }
            return (int)mh$.invokeExact(_C);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class iswalpha {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_SHORT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("iswalpha");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int iswalpha(wint_t _C)
     * }
     */
    public static FunctionDescriptor iswalpha$descriptor() {
        return iswalpha.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int iswalpha(wint_t _C)
     * }
     */
    public static MethodHandle iswalpha$handle() {
        return iswalpha.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int iswalpha(wint_t _C)
     * }
     */
    public static MemorySegment iswalpha$address() {
        return iswalpha.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int iswalpha(wint_t _C)
     * }
     */
    public static int iswalpha(short _C) {
        var mh$ = iswalpha.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("iswalpha", _C);
            }
            return (int)mh$.invokeExact(_C);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class iswascii {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_SHORT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("iswascii");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int iswascii(wint_t _C)
     * }
     */
    public static FunctionDescriptor iswascii$descriptor() {
        return iswascii.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int iswascii(wint_t _C)
     * }
     */
    public static MethodHandle iswascii$handle() {
        return iswascii.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int iswascii(wint_t _C)
     * }
     */
    public static MemorySegment iswascii$address() {
        return iswascii.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int iswascii(wint_t _C)
     * }
     */
    public static int iswascii(short _C) {
        var mh$ = iswascii.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("iswascii", _C);
            }
            return (int)mh$.invokeExact(_C);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class iswblank {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_SHORT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("iswblank");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int iswblank(wint_t _C)
     * }
     */
    public static FunctionDescriptor iswblank$descriptor() {
        return iswblank.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int iswblank(wint_t _C)
     * }
     */
    public static MethodHandle iswblank$handle() {
        return iswblank.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int iswblank(wint_t _C)
     * }
     */
    public static MemorySegment iswblank$address() {
        return iswblank.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int iswblank(wint_t _C)
     * }
     */
    public static int iswblank(short _C) {
        var mh$ = iswblank.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("iswblank", _C);
            }
            return (int)mh$.invokeExact(_C);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class iswcntrl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_SHORT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("iswcntrl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int iswcntrl(wint_t _C)
     * }
     */
    public static FunctionDescriptor iswcntrl$descriptor() {
        return iswcntrl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int iswcntrl(wint_t _C)
     * }
     */
    public static MethodHandle iswcntrl$handle() {
        return iswcntrl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int iswcntrl(wint_t _C)
     * }
     */
    public static MemorySegment iswcntrl$address() {
        return iswcntrl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int iswcntrl(wint_t _C)
     * }
     */
    public static int iswcntrl(short _C) {
        var mh$ = iswcntrl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("iswcntrl", _C);
            }
            return (int)mh$.invokeExact(_C);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class iswdigit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_SHORT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("iswdigit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int iswdigit(wint_t _C)
     * }
     */
    public static FunctionDescriptor iswdigit$descriptor() {
        return iswdigit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int iswdigit(wint_t _C)
     * }
     */
    public static MethodHandle iswdigit$handle() {
        return iswdigit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int iswdigit(wint_t _C)
     * }
     */
    public static MemorySegment iswdigit$address() {
        return iswdigit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int iswdigit(wint_t _C)
     * }
     */
    public static int iswdigit(short _C) {
        var mh$ = iswdigit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("iswdigit", _C);
            }
            return (int)mh$.invokeExact(_C);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class iswgraph {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_SHORT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("iswgraph");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int iswgraph(wint_t _C)
     * }
     */
    public static FunctionDescriptor iswgraph$descriptor() {
        return iswgraph.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int iswgraph(wint_t _C)
     * }
     */
    public static MethodHandle iswgraph$handle() {
        return iswgraph.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int iswgraph(wint_t _C)
     * }
     */
    public static MemorySegment iswgraph$address() {
        return iswgraph.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int iswgraph(wint_t _C)
     * }
     */
    public static int iswgraph(short _C) {
        var mh$ = iswgraph.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("iswgraph", _C);
            }
            return (int)mh$.invokeExact(_C);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class iswlower {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_SHORT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("iswlower");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int iswlower(wint_t _C)
     * }
     */
    public static FunctionDescriptor iswlower$descriptor() {
        return iswlower.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int iswlower(wint_t _C)
     * }
     */
    public static MethodHandle iswlower$handle() {
        return iswlower.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int iswlower(wint_t _C)
     * }
     */
    public static MemorySegment iswlower$address() {
        return iswlower.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int iswlower(wint_t _C)
     * }
     */
    public static int iswlower(short _C) {
        var mh$ = iswlower.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("iswlower", _C);
            }
            return (int)mh$.invokeExact(_C);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class iswprint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_SHORT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("iswprint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int iswprint(wint_t _C)
     * }
     */
    public static FunctionDescriptor iswprint$descriptor() {
        return iswprint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int iswprint(wint_t _C)
     * }
     */
    public static MethodHandle iswprint$handle() {
        return iswprint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int iswprint(wint_t _C)
     * }
     */
    public static MemorySegment iswprint$address() {
        return iswprint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int iswprint(wint_t _C)
     * }
     */
    public static int iswprint(short _C) {
        var mh$ = iswprint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("iswprint", _C);
            }
            return (int)mh$.invokeExact(_C);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class iswpunct {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_SHORT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("iswpunct");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int iswpunct(wint_t _C)
     * }
     */
    public static FunctionDescriptor iswpunct$descriptor() {
        return iswpunct.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int iswpunct(wint_t _C)
     * }
     */
    public static MethodHandle iswpunct$handle() {
        return iswpunct.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int iswpunct(wint_t _C)
     * }
     */
    public static MemorySegment iswpunct$address() {
        return iswpunct.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int iswpunct(wint_t _C)
     * }
     */
    public static int iswpunct(short _C) {
        var mh$ = iswpunct.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("iswpunct", _C);
            }
            return (int)mh$.invokeExact(_C);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class iswspace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_SHORT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("iswspace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int iswspace(wint_t _C)
     * }
     */
    public static FunctionDescriptor iswspace$descriptor() {
        return iswspace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int iswspace(wint_t _C)
     * }
     */
    public static MethodHandle iswspace$handle() {
        return iswspace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int iswspace(wint_t _C)
     * }
     */
    public static MemorySegment iswspace$address() {
        return iswspace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int iswspace(wint_t _C)
     * }
     */
    public static int iswspace(short _C) {
        var mh$ = iswspace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("iswspace", _C);
            }
            return (int)mh$.invokeExact(_C);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class iswupper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_SHORT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("iswupper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int iswupper(wint_t _C)
     * }
     */
    public static FunctionDescriptor iswupper$descriptor() {
        return iswupper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int iswupper(wint_t _C)
     * }
     */
    public static MethodHandle iswupper$handle() {
        return iswupper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int iswupper(wint_t _C)
     * }
     */
    public static MemorySegment iswupper$address() {
        return iswupper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int iswupper(wint_t _C)
     * }
     */
    public static int iswupper(short _C) {
        var mh$ = iswupper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("iswupper", _C);
            }
            return (int)mh$.invokeExact(_C);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class iswxdigit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_SHORT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("iswxdigit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int iswxdigit(wint_t _C)
     * }
     */
    public static FunctionDescriptor iswxdigit$descriptor() {
        return iswxdigit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int iswxdigit(wint_t _C)
     * }
     */
    public static MethodHandle iswxdigit$handle() {
        return iswxdigit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int iswxdigit(wint_t _C)
     * }
     */
    public static MemorySegment iswxdigit$address() {
        return iswxdigit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int iswxdigit(wint_t _C)
     * }
     */
    public static int iswxdigit(short _C) {
        var mh$ = iswxdigit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("iswxdigit", _C);
            }
            return (int)mh$.invokeExact(_C);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __iswcsymf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_SHORT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("__iswcsymf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __iswcsymf(wint_t _C)
     * }
     */
    public static FunctionDescriptor __iswcsymf$descriptor() {
        return __iswcsymf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __iswcsymf(wint_t _C)
     * }
     */
    public static MethodHandle __iswcsymf$handle() {
        return __iswcsymf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __iswcsymf(wint_t _C)
     * }
     */
    public static MemorySegment __iswcsymf$address() {
        return __iswcsymf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __iswcsymf(wint_t _C)
     * }
     */
    public static int __iswcsymf(short _C) {
        var mh$ = __iswcsymf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__iswcsymf", _C);
            }
            return (int)mh$.invokeExact(_C);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __iswcsym {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_SHORT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("__iswcsym");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __iswcsym(wint_t _C)
     * }
     */
    public static FunctionDescriptor __iswcsym$descriptor() {
        return __iswcsym.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __iswcsym(wint_t _C)
     * }
     */
    public static MethodHandle __iswcsym$handle() {
        return __iswcsym.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __iswcsym(wint_t _C)
     * }
     */
    public static MemorySegment __iswcsym$address() {
        return __iswcsym.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __iswcsym(wint_t _C)
     * }
     */
    public static int __iswcsym(short _C) {
        var mh$ = __iswcsym.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__iswcsym", _C);
            }
            return (int)mh$.invokeExact(_C);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _iswalnum_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_SHORT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_iswalnum_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _iswalnum_l(wint_t _C, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _iswalnum_l$descriptor() {
        return _iswalnum_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _iswalnum_l(wint_t _C, _locale_t _Locale)
     * }
     */
    public static MethodHandle _iswalnum_l$handle() {
        return _iswalnum_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _iswalnum_l(wint_t _C, _locale_t _Locale)
     * }
     */
    public static MemorySegment _iswalnum_l$address() {
        return _iswalnum_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _iswalnum_l(wint_t _C, _locale_t _Locale)
     * }
     */
    public static int _iswalnum_l(short _C, MemorySegment _Locale) {
        var mh$ = _iswalnum_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_iswalnum_l", _C, _Locale);
            }
            return (int)mh$.invokeExact(_C, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _iswalpha_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_SHORT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_iswalpha_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _iswalpha_l(wint_t _C, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _iswalpha_l$descriptor() {
        return _iswalpha_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _iswalpha_l(wint_t _C, _locale_t _Locale)
     * }
     */
    public static MethodHandle _iswalpha_l$handle() {
        return _iswalpha_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _iswalpha_l(wint_t _C, _locale_t _Locale)
     * }
     */
    public static MemorySegment _iswalpha_l$address() {
        return _iswalpha_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _iswalpha_l(wint_t _C, _locale_t _Locale)
     * }
     */
    public static int _iswalpha_l(short _C, MemorySegment _Locale) {
        var mh$ = _iswalpha_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_iswalpha_l", _C, _Locale);
            }
            return (int)mh$.invokeExact(_C, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _iswblank_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_SHORT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_iswblank_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _iswblank_l(wint_t _C, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _iswblank_l$descriptor() {
        return _iswblank_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _iswblank_l(wint_t _C, _locale_t _Locale)
     * }
     */
    public static MethodHandle _iswblank_l$handle() {
        return _iswblank_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _iswblank_l(wint_t _C, _locale_t _Locale)
     * }
     */
    public static MemorySegment _iswblank_l$address() {
        return _iswblank_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _iswblank_l(wint_t _C, _locale_t _Locale)
     * }
     */
    public static int _iswblank_l(short _C, MemorySegment _Locale) {
        var mh$ = _iswblank_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_iswblank_l", _C, _Locale);
            }
            return (int)mh$.invokeExact(_C, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _iswcntrl_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_SHORT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_iswcntrl_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _iswcntrl_l(wint_t _C, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _iswcntrl_l$descriptor() {
        return _iswcntrl_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _iswcntrl_l(wint_t _C, _locale_t _Locale)
     * }
     */
    public static MethodHandle _iswcntrl_l$handle() {
        return _iswcntrl_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _iswcntrl_l(wint_t _C, _locale_t _Locale)
     * }
     */
    public static MemorySegment _iswcntrl_l$address() {
        return _iswcntrl_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _iswcntrl_l(wint_t _C, _locale_t _Locale)
     * }
     */
    public static int _iswcntrl_l(short _C, MemorySegment _Locale) {
        var mh$ = _iswcntrl_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_iswcntrl_l", _C, _Locale);
            }
            return (int)mh$.invokeExact(_C, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _iswdigit_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_SHORT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_iswdigit_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _iswdigit_l(wint_t _C, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _iswdigit_l$descriptor() {
        return _iswdigit_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _iswdigit_l(wint_t _C, _locale_t _Locale)
     * }
     */
    public static MethodHandle _iswdigit_l$handle() {
        return _iswdigit_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _iswdigit_l(wint_t _C, _locale_t _Locale)
     * }
     */
    public static MemorySegment _iswdigit_l$address() {
        return _iswdigit_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _iswdigit_l(wint_t _C, _locale_t _Locale)
     * }
     */
    public static int _iswdigit_l(short _C, MemorySegment _Locale) {
        var mh$ = _iswdigit_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_iswdigit_l", _C, _Locale);
            }
            return (int)mh$.invokeExact(_C, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _iswgraph_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_SHORT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_iswgraph_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _iswgraph_l(wint_t _C, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _iswgraph_l$descriptor() {
        return _iswgraph_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _iswgraph_l(wint_t _C, _locale_t _Locale)
     * }
     */
    public static MethodHandle _iswgraph_l$handle() {
        return _iswgraph_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _iswgraph_l(wint_t _C, _locale_t _Locale)
     * }
     */
    public static MemorySegment _iswgraph_l$address() {
        return _iswgraph_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _iswgraph_l(wint_t _C, _locale_t _Locale)
     * }
     */
    public static int _iswgraph_l(short _C, MemorySegment _Locale) {
        var mh$ = _iswgraph_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_iswgraph_l", _C, _Locale);
            }
            return (int)mh$.invokeExact(_C, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _iswlower_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_SHORT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_iswlower_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _iswlower_l(wint_t _C, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _iswlower_l$descriptor() {
        return _iswlower_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _iswlower_l(wint_t _C, _locale_t _Locale)
     * }
     */
    public static MethodHandle _iswlower_l$handle() {
        return _iswlower_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _iswlower_l(wint_t _C, _locale_t _Locale)
     * }
     */
    public static MemorySegment _iswlower_l$address() {
        return _iswlower_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _iswlower_l(wint_t _C, _locale_t _Locale)
     * }
     */
    public static int _iswlower_l(short _C, MemorySegment _Locale) {
        var mh$ = _iswlower_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_iswlower_l", _C, _Locale);
            }
            return (int)mh$.invokeExact(_C, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _iswprint_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_SHORT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_iswprint_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _iswprint_l(wint_t _C, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _iswprint_l$descriptor() {
        return _iswprint_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _iswprint_l(wint_t _C, _locale_t _Locale)
     * }
     */
    public static MethodHandle _iswprint_l$handle() {
        return _iswprint_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _iswprint_l(wint_t _C, _locale_t _Locale)
     * }
     */
    public static MemorySegment _iswprint_l$address() {
        return _iswprint_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _iswprint_l(wint_t _C, _locale_t _Locale)
     * }
     */
    public static int _iswprint_l(short _C, MemorySegment _Locale) {
        var mh$ = _iswprint_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_iswprint_l", _C, _Locale);
            }
            return (int)mh$.invokeExact(_C, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _iswpunct_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_SHORT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_iswpunct_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _iswpunct_l(wint_t _C, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _iswpunct_l$descriptor() {
        return _iswpunct_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _iswpunct_l(wint_t _C, _locale_t _Locale)
     * }
     */
    public static MethodHandle _iswpunct_l$handle() {
        return _iswpunct_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _iswpunct_l(wint_t _C, _locale_t _Locale)
     * }
     */
    public static MemorySegment _iswpunct_l$address() {
        return _iswpunct_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _iswpunct_l(wint_t _C, _locale_t _Locale)
     * }
     */
    public static int _iswpunct_l(short _C, MemorySegment _Locale) {
        var mh$ = _iswpunct_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_iswpunct_l", _C, _Locale);
            }
            return (int)mh$.invokeExact(_C, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _iswspace_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_SHORT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_iswspace_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _iswspace_l(wint_t _C, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _iswspace_l$descriptor() {
        return _iswspace_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _iswspace_l(wint_t _C, _locale_t _Locale)
     * }
     */
    public static MethodHandle _iswspace_l$handle() {
        return _iswspace_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _iswspace_l(wint_t _C, _locale_t _Locale)
     * }
     */
    public static MemorySegment _iswspace_l$address() {
        return _iswspace_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _iswspace_l(wint_t _C, _locale_t _Locale)
     * }
     */
    public static int _iswspace_l(short _C, MemorySegment _Locale) {
        var mh$ = _iswspace_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_iswspace_l", _C, _Locale);
            }
            return (int)mh$.invokeExact(_C, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _iswupper_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_SHORT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_iswupper_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _iswupper_l(wint_t _C, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _iswupper_l$descriptor() {
        return _iswupper_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _iswupper_l(wint_t _C, _locale_t _Locale)
     * }
     */
    public static MethodHandle _iswupper_l$handle() {
        return _iswupper_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _iswupper_l(wint_t _C, _locale_t _Locale)
     * }
     */
    public static MemorySegment _iswupper_l$address() {
        return _iswupper_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _iswupper_l(wint_t _C, _locale_t _Locale)
     * }
     */
    public static int _iswupper_l(short _C, MemorySegment _Locale) {
        var mh$ = _iswupper_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_iswupper_l", _C, _Locale);
            }
            return (int)mh$.invokeExact(_C, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _iswxdigit_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_SHORT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_iswxdigit_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _iswxdigit_l(wint_t _C, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _iswxdigit_l$descriptor() {
        return _iswxdigit_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _iswxdigit_l(wint_t _C, _locale_t _Locale)
     * }
     */
    public static MethodHandle _iswxdigit_l$handle() {
        return _iswxdigit_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _iswxdigit_l(wint_t _C, _locale_t _Locale)
     * }
     */
    public static MemorySegment _iswxdigit_l$address() {
        return _iswxdigit_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _iswxdigit_l(wint_t _C, _locale_t _Locale)
     * }
     */
    public static int _iswxdigit_l(short _C, MemorySegment _Locale) {
        var mh$ = _iswxdigit_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_iswxdigit_l", _C, _Locale);
            }
            return (int)mh$.invokeExact(_C, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _iswcsymf_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_SHORT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_iswcsymf_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _iswcsymf_l(wint_t _C, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _iswcsymf_l$descriptor() {
        return _iswcsymf_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _iswcsymf_l(wint_t _C, _locale_t _Locale)
     * }
     */
    public static MethodHandle _iswcsymf_l$handle() {
        return _iswcsymf_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _iswcsymf_l(wint_t _C, _locale_t _Locale)
     * }
     */
    public static MemorySegment _iswcsymf_l$address() {
        return _iswcsymf_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _iswcsymf_l(wint_t _C, _locale_t _Locale)
     * }
     */
    public static int _iswcsymf_l(short _C, MemorySegment _Locale) {
        var mh$ = _iswcsymf_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_iswcsymf_l", _C, _Locale);
            }
            return (int)mh$.invokeExact(_C, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _iswcsym_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_SHORT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_iswcsym_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _iswcsym_l(wint_t _C, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _iswcsym_l$descriptor() {
        return _iswcsym_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _iswcsym_l(wint_t _C, _locale_t _Locale)
     * }
     */
    public static MethodHandle _iswcsym_l$handle() {
        return _iswcsym_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _iswcsym_l(wint_t _C, _locale_t _Locale)
     * }
     */
    public static MemorySegment _iswcsym_l$address() {
        return _iswcsym_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _iswcsym_l(wint_t _C, _locale_t _Locale)
     * }
     */
    public static int _iswcsym_l(short _C, MemorySegment _Locale) {
        var mh$ = _iswcsym_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_iswcsym_l", _C, _Locale);
            }
            return (int)mh$.invokeExact(_C, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class towupper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_SHORT,
            Python_h.C_SHORT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("towupper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wint_t towupper(wint_t _C)
     * }
     */
    public static FunctionDescriptor towupper$descriptor() {
        return towupper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wint_t towupper(wint_t _C)
     * }
     */
    public static MethodHandle towupper$handle() {
        return towupper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wint_t towupper(wint_t _C)
     * }
     */
    public static MemorySegment towupper$address() {
        return towupper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wint_t towupper(wint_t _C)
     * }
     */
    public static short towupper(short _C) {
        var mh$ = towupper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("towupper", _C);
            }
            return (short)mh$.invokeExact(_C);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class towlower {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_SHORT,
            Python_h.C_SHORT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("towlower");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wint_t towlower(wint_t _C)
     * }
     */
    public static FunctionDescriptor towlower$descriptor() {
        return towlower.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wint_t towlower(wint_t _C)
     * }
     */
    public static MethodHandle towlower$handle() {
        return towlower.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wint_t towlower(wint_t _C)
     * }
     */
    public static MemorySegment towlower$address() {
        return towlower.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wint_t towlower(wint_t _C)
     * }
     */
    public static short towlower(short _C) {
        var mh$ = towlower.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("towlower", _C);
            }
            return (short)mh$.invokeExact(_C);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class iswctype {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_SHORT,
            Python_h.C_SHORT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("iswctype");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int iswctype(wint_t _C, wctype_t _Type)
     * }
     */
    public static FunctionDescriptor iswctype$descriptor() {
        return iswctype.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int iswctype(wint_t _C, wctype_t _Type)
     * }
     */
    public static MethodHandle iswctype$handle() {
        return iswctype.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int iswctype(wint_t _C, wctype_t _Type)
     * }
     */
    public static MemorySegment iswctype$address() {
        return iswctype.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int iswctype(wint_t _C, wctype_t _Type)
     * }
     */
    public static int iswctype(short _C, short _Type) {
        var mh$ = iswctype.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("iswctype", _C, _Type);
            }
            return (int)mh$.invokeExact(_C, _Type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _towupper_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_SHORT,
            Python_h.C_SHORT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_towupper_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wint_t _towupper_l(wint_t _C, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _towupper_l$descriptor() {
        return _towupper_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wint_t _towupper_l(wint_t _C, _locale_t _Locale)
     * }
     */
    public static MethodHandle _towupper_l$handle() {
        return _towupper_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wint_t _towupper_l(wint_t _C, _locale_t _Locale)
     * }
     */
    public static MemorySegment _towupper_l$address() {
        return _towupper_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wint_t _towupper_l(wint_t _C, _locale_t _Locale)
     * }
     */
    public static short _towupper_l(short _C, MemorySegment _Locale) {
        var mh$ = _towupper_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_towupper_l", _C, _Locale);
            }
            return (short)mh$.invokeExact(_C, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _towlower_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_SHORT,
            Python_h.C_SHORT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_towlower_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wint_t _towlower_l(wint_t _C, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _towlower_l$descriptor() {
        return _towlower_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wint_t _towlower_l(wint_t _C, _locale_t _Locale)
     * }
     */
    public static MethodHandle _towlower_l$handle() {
        return _towlower_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wint_t _towlower_l(wint_t _C, _locale_t _Locale)
     * }
     */
    public static MemorySegment _towlower_l$address() {
        return _towlower_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wint_t _towlower_l(wint_t _C, _locale_t _Locale)
     * }
     */
    public static short _towlower_l(short _C, MemorySegment _Locale) {
        var mh$ = _towlower_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_towlower_l", _C, _Locale);
            }
            return (short)mh$.invokeExact(_C, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _iswctype_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_SHORT,
            Python_h.C_SHORT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_iswctype_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _iswctype_l(wint_t _C, wctype_t _Type, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _iswctype_l$descriptor() {
        return _iswctype_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _iswctype_l(wint_t _C, wctype_t _Type, _locale_t _Locale)
     * }
     */
    public static MethodHandle _iswctype_l$handle() {
        return _iswctype_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _iswctype_l(wint_t _C, wctype_t _Type, _locale_t _Locale)
     * }
     */
    public static MemorySegment _iswctype_l$address() {
        return _iswctype_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _iswctype_l(wint_t _C, wctype_t _Type, _locale_t _Locale)
     * }
     */
    public static int _iswctype_l(short _C, short _Type, MemorySegment _Locale) {
        var mh$ = _iswctype_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_iswctype_l", _C, _Type, _Locale);
            }
            return (int)mh$.invokeExact(_C, _Type, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class isleadbyte {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("isleadbyte");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int isleadbyte(int _C)
     * }
     */
    public static FunctionDescriptor isleadbyte$descriptor() {
        return isleadbyte.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int isleadbyte(int _C)
     * }
     */
    public static MethodHandle isleadbyte$handle() {
        return isleadbyte.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int isleadbyte(int _C)
     * }
     */
    public static MemorySegment isleadbyte$address() {
        return isleadbyte.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int isleadbyte(int _C)
     * }
     */
    public static int isleadbyte(int _C) {
        var mh$ = isleadbyte.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("isleadbyte", _C);
            }
            return (int)mh$.invokeExact(_C);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _isleadbyte_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_isleadbyte_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _isleadbyte_l(int _C, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _isleadbyte_l$descriptor() {
        return _isleadbyte_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _isleadbyte_l(int _C, _locale_t _Locale)
     * }
     */
    public static MethodHandle _isleadbyte_l$handle() {
        return _isleadbyte_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _isleadbyte_l(int _C, _locale_t _Locale)
     * }
     */
    public static MemorySegment _isleadbyte_l$address() {
        return _isleadbyte_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _isleadbyte_l(int _C, _locale_t _Locale)
     * }
     */
    public static int _isleadbyte_l(int _C, MemorySegment _Locale) {
        var mh$ = _isleadbyte_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_isleadbyte_l", _C, _Locale);
            }
            return (int)mh$.invokeExact(_C, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class is_wctype {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_SHORT,
            Python_h.C_SHORT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("is_wctype");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int is_wctype(wint_t _C, wctype_t _Type)
     * }
     */
    public static FunctionDescriptor is_wctype$descriptor() {
        return is_wctype.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int is_wctype(wint_t _C, wctype_t _Type)
     * }
     */
    public static MethodHandle is_wctype$handle() {
        return is_wctype.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int is_wctype(wint_t _C, wctype_t _Type)
     * }
     */
    public static MemorySegment is_wctype$address() {
        return is_wctype.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int is_wctype(wint_t _C, wctype_t _Type)
     * }
     */
    public static int is_wctype(short _C, short _Type) {
        var mh$ = is_wctype.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("is_wctype", _C, _Type);
            }
            return (int)mh$.invokeExact(_C, _Type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wgetcwd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wgetcwd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *_wgetcwd(wchar_t *_DstBuf, int _SizeInWords)
     * }
     */
    public static FunctionDescriptor _wgetcwd$descriptor() {
        return _wgetcwd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *_wgetcwd(wchar_t *_DstBuf, int _SizeInWords)
     * }
     */
    public static MethodHandle _wgetcwd$handle() {
        return _wgetcwd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *_wgetcwd(wchar_t *_DstBuf, int _SizeInWords)
     * }
     */
    public static MemorySegment _wgetcwd$address() {
        return _wgetcwd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *_wgetcwd(wchar_t *_DstBuf, int _SizeInWords)
     * }
     */
    public static MemorySegment _wgetcwd(MemorySegment _DstBuf, int _SizeInWords) {
        var mh$ = _wgetcwd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wgetcwd", _DstBuf, _SizeInWords);
            }
            return (MemorySegment)mh$.invokeExact(_DstBuf, _SizeInWords);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wgetdcwd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wgetdcwd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *_wgetdcwd(int _Drive, wchar_t *_DstBuf, int _SizeInWords)
     * }
     */
    public static FunctionDescriptor _wgetdcwd$descriptor() {
        return _wgetdcwd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *_wgetdcwd(int _Drive, wchar_t *_DstBuf, int _SizeInWords)
     * }
     */
    public static MethodHandle _wgetdcwd$handle() {
        return _wgetdcwd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *_wgetdcwd(int _Drive, wchar_t *_DstBuf, int _SizeInWords)
     * }
     */
    public static MemorySegment _wgetdcwd$address() {
        return _wgetdcwd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *_wgetdcwd(int _Drive, wchar_t *_DstBuf, int _SizeInWords)
     * }
     */
    public static MemorySegment _wgetdcwd(int _Drive, MemorySegment _DstBuf, int _SizeInWords) {
        var mh$ = _wgetdcwd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wgetdcwd", _Drive, _DstBuf, _SizeInWords);
            }
            return (MemorySegment)mh$.invokeExact(_Drive, _DstBuf, _SizeInWords);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wchdir {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wchdir");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _wchdir(const wchar_t *_Path)
     * }
     */
    public static FunctionDescriptor _wchdir$descriptor() {
        return _wchdir.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _wchdir(const wchar_t *_Path)
     * }
     */
    public static MethodHandle _wchdir$handle() {
        return _wchdir.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _wchdir(const wchar_t *_Path)
     * }
     */
    public static MemorySegment _wchdir$address() {
        return _wchdir.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _wchdir(const wchar_t *_Path)
     * }
     */
    public static int _wchdir(MemorySegment _Path) {
        var mh$ = _wchdir.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wchdir", _Path);
            }
            return (int)mh$.invokeExact(_Path);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wmkdir {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wmkdir");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _wmkdir(const wchar_t *_Path)
     * }
     */
    public static FunctionDescriptor _wmkdir$descriptor() {
        return _wmkdir.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _wmkdir(const wchar_t *_Path)
     * }
     */
    public static MethodHandle _wmkdir$handle() {
        return _wmkdir.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _wmkdir(const wchar_t *_Path)
     * }
     */
    public static MemorySegment _wmkdir$address() {
        return _wmkdir.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _wmkdir(const wchar_t *_Path)
     * }
     */
    public static int _wmkdir(MemorySegment _Path) {
        var mh$ = _wmkdir.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wmkdir", _Path);
            }
            return (int)mh$.invokeExact(_Path);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wrmdir {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wrmdir");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _wrmdir(const wchar_t *_Path)
     * }
     */
    public static FunctionDescriptor _wrmdir$descriptor() {
        return _wrmdir.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _wrmdir(const wchar_t *_Path)
     * }
     */
    public static MethodHandle _wrmdir$handle() {
        return _wrmdir.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _wrmdir(const wchar_t *_Path)
     * }
     */
    public static MemorySegment _wrmdir$address() {
        return _wrmdir.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _wrmdir(const wchar_t *_Path)
     * }
     */
    public static int _wrmdir(MemorySegment _Path) {
        var mh$ = _wrmdir.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wrmdir", _Path);
            }
            return (int)mh$.invokeExact(_Path);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * intptr_t _wexecl(const wchar_t *_FileName, const wchar_t *_ArgList, ...)
     * }
     */
    public static class _wexecl {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_LONG_LONG,
                Python_h.C_POINTER,
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("_wexecl");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private _wexecl(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * intptr_t _wexecl(const wchar_t *_FileName, const wchar_t *_ArgList, ...)
         * }
         */
        public static _wexecl makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new _wexecl(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public long apply(MemorySegment _FileName, MemorySegment _ArgList, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("_wexecl", _FileName, _ArgList, x2);
                }
                return (long)spreader.invokeExact(_FileName, _ArgList, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * intptr_t _wexecle(const wchar_t *_FileName, const wchar_t *_ArgList, ...)
     * }
     */
    public static class _wexecle {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_LONG_LONG,
                Python_h.C_POINTER,
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("_wexecle");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private _wexecle(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * intptr_t _wexecle(const wchar_t *_FileName, const wchar_t *_ArgList, ...)
         * }
         */
        public static _wexecle makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new _wexecle(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public long apply(MemorySegment _FileName, MemorySegment _ArgList, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("_wexecle", _FileName, _ArgList, x2);
                }
                return (long)spreader.invokeExact(_FileName, _ArgList, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * intptr_t _wexeclp(const wchar_t *_FileName, const wchar_t *_ArgList, ...)
     * }
     */
    public static class _wexeclp {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_LONG_LONG,
                Python_h.C_POINTER,
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("_wexeclp");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private _wexeclp(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * intptr_t _wexeclp(const wchar_t *_FileName, const wchar_t *_ArgList, ...)
         * }
         */
        public static _wexeclp makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new _wexeclp(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public long apply(MemorySegment _FileName, MemorySegment _ArgList, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("_wexeclp", _FileName, _ArgList, x2);
                }
                return (long)spreader.invokeExact(_FileName, _ArgList, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * intptr_t _wexeclpe(const wchar_t *_FileName, const wchar_t *_ArgList, ...)
     * }
     */
    public static class _wexeclpe {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_LONG_LONG,
                Python_h.C_POINTER,
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("_wexeclpe");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private _wexeclpe(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * intptr_t _wexeclpe(const wchar_t *_FileName, const wchar_t *_ArgList, ...)
         * }
         */
        public static _wexeclpe makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new _wexeclpe(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public long apply(MemorySegment _FileName, MemorySegment _ArgList, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("_wexeclpe", _FileName, _ArgList, x2);
                }
                return (long)spreader.invokeExact(_FileName, _ArgList, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class _wexecv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wexecv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * intptr_t _wexecv(const wchar_t *_FileName, const wchar_t *const *_ArgList)
     * }
     */
    public static FunctionDescriptor _wexecv$descriptor() {
        return _wexecv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * intptr_t _wexecv(const wchar_t *_FileName, const wchar_t *const *_ArgList)
     * }
     */
    public static MethodHandle _wexecv$handle() {
        return _wexecv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * intptr_t _wexecv(const wchar_t *_FileName, const wchar_t *const *_ArgList)
     * }
     */
    public static MemorySegment _wexecv$address() {
        return _wexecv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * intptr_t _wexecv(const wchar_t *_FileName, const wchar_t *const *_ArgList)
     * }
     */
    public static long _wexecv(MemorySegment _FileName, MemorySegment _ArgList) {
        var mh$ = _wexecv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wexecv", _FileName, _ArgList);
            }
            return (long)mh$.invokeExact(_FileName, _ArgList);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wexecve {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wexecve");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * intptr_t _wexecve(const wchar_t *_FileName, const wchar_t *const *_ArgList, const wchar_t *const *_Env)
     * }
     */
    public static FunctionDescriptor _wexecve$descriptor() {
        return _wexecve.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * intptr_t _wexecve(const wchar_t *_FileName, const wchar_t *const *_ArgList, const wchar_t *const *_Env)
     * }
     */
    public static MethodHandle _wexecve$handle() {
        return _wexecve.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * intptr_t _wexecve(const wchar_t *_FileName, const wchar_t *const *_ArgList, const wchar_t *const *_Env)
     * }
     */
    public static MemorySegment _wexecve$address() {
        return _wexecve.ADDR;
    }

    /**
     * {@snippet lang=c :
     * intptr_t _wexecve(const wchar_t *_FileName, const wchar_t *const *_ArgList, const wchar_t *const *_Env)
     * }
     */
    public static long _wexecve(MemorySegment _FileName, MemorySegment _ArgList, MemorySegment _Env) {
        var mh$ = _wexecve.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wexecve", _FileName, _ArgList, _Env);
            }
            return (long)mh$.invokeExact(_FileName, _ArgList, _Env);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wexecvp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wexecvp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * intptr_t _wexecvp(const wchar_t *_FileName, const wchar_t *const *_ArgList)
     * }
     */
    public static FunctionDescriptor _wexecvp$descriptor() {
        return _wexecvp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * intptr_t _wexecvp(const wchar_t *_FileName, const wchar_t *const *_ArgList)
     * }
     */
    public static MethodHandle _wexecvp$handle() {
        return _wexecvp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * intptr_t _wexecvp(const wchar_t *_FileName, const wchar_t *const *_ArgList)
     * }
     */
    public static MemorySegment _wexecvp$address() {
        return _wexecvp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * intptr_t _wexecvp(const wchar_t *_FileName, const wchar_t *const *_ArgList)
     * }
     */
    public static long _wexecvp(MemorySegment _FileName, MemorySegment _ArgList) {
        var mh$ = _wexecvp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wexecvp", _FileName, _ArgList);
            }
            return (long)mh$.invokeExact(_FileName, _ArgList);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wexecvpe {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wexecvpe");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * intptr_t _wexecvpe(const wchar_t *_FileName, const wchar_t *const *_ArgList, const wchar_t *const *_Env)
     * }
     */
    public static FunctionDescriptor _wexecvpe$descriptor() {
        return _wexecvpe.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * intptr_t _wexecvpe(const wchar_t *_FileName, const wchar_t *const *_ArgList, const wchar_t *const *_Env)
     * }
     */
    public static MethodHandle _wexecvpe$handle() {
        return _wexecvpe.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * intptr_t _wexecvpe(const wchar_t *_FileName, const wchar_t *const *_ArgList, const wchar_t *const *_Env)
     * }
     */
    public static MemorySegment _wexecvpe$address() {
        return _wexecvpe.ADDR;
    }

    /**
     * {@snippet lang=c :
     * intptr_t _wexecvpe(const wchar_t *_FileName, const wchar_t *const *_ArgList, const wchar_t *const *_Env)
     * }
     */
    public static long _wexecvpe(MemorySegment _FileName, MemorySegment _ArgList, MemorySegment _Env) {
        var mh$ = _wexecvpe.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wexecvpe", _FileName, _ArgList, _Env);
            }
            return (long)mh$.invokeExact(_FileName, _ArgList, _Env);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * intptr_t _wspawnl(int _Mode, const wchar_t *_FileName, const wchar_t *_ArgList, ...)
     * }
     */
    public static class _wspawnl {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_LONG_LONG,
                Python_h.C_INT,
                Python_h.C_POINTER,
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("_wspawnl");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private _wspawnl(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * intptr_t _wspawnl(int _Mode, const wchar_t *_FileName, const wchar_t *_ArgList, ...)
         * }
         */
        public static _wspawnl makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new _wspawnl(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public long apply(int _Mode, MemorySegment _FileName, MemorySegment _ArgList, Object... x3) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("_wspawnl", _Mode, _FileName, _ArgList, x3);
                }
                return (long)spreader.invokeExact(_Mode, _FileName, _ArgList, x3);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * intptr_t _wspawnle(int _Mode, const wchar_t *_FileName, const wchar_t *_ArgList, ...)
     * }
     */
    public static class _wspawnle {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_LONG_LONG,
                Python_h.C_INT,
                Python_h.C_POINTER,
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("_wspawnle");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private _wspawnle(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * intptr_t _wspawnle(int _Mode, const wchar_t *_FileName, const wchar_t *_ArgList, ...)
         * }
         */
        public static _wspawnle makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new _wspawnle(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public long apply(int _Mode, MemorySegment _FileName, MemorySegment _ArgList, Object... x3) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("_wspawnle", _Mode, _FileName, _ArgList, x3);
                }
                return (long)spreader.invokeExact(_Mode, _FileName, _ArgList, x3);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * intptr_t _wspawnlp(int _Mode, const wchar_t *_FileName, const wchar_t *_ArgList, ...)
     * }
     */
    public static class _wspawnlp {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_LONG_LONG,
                Python_h.C_INT,
                Python_h.C_POINTER,
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("_wspawnlp");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private _wspawnlp(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * intptr_t _wspawnlp(int _Mode, const wchar_t *_FileName, const wchar_t *_ArgList, ...)
         * }
         */
        public static _wspawnlp makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new _wspawnlp(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public long apply(int _Mode, MemorySegment _FileName, MemorySegment _ArgList, Object... x3) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("_wspawnlp", _Mode, _FileName, _ArgList, x3);
                }
                return (long)spreader.invokeExact(_Mode, _FileName, _ArgList, x3);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * intptr_t _wspawnlpe(int _Mode, const wchar_t *_FileName, const wchar_t *_ArgList, ...)
     * }
     */
    public static class _wspawnlpe {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_LONG_LONG,
                Python_h.C_INT,
                Python_h.C_POINTER,
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("_wspawnlpe");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private _wspawnlpe(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * intptr_t _wspawnlpe(int _Mode, const wchar_t *_FileName, const wchar_t *_ArgList, ...)
         * }
         */
        public static _wspawnlpe makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new _wspawnlpe(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public long apply(int _Mode, MemorySegment _FileName, MemorySegment _ArgList, Object... x3) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("_wspawnlpe", _Mode, _FileName, _ArgList, x3);
                }
                return (long)spreader.invokeExact(_Mode, _FileName, _ArgList, x3);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class _wspawnv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wspawnv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * intptr_t _wspawnv(int _Mode, const wchar_t *_FileName, const wchar_t *const *_ArgList)
     * }
     */
    public static FunctionDescriptor _wspawnv$descriptor() {
        return _wspawnv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * intptr_t _wspawnv(int _Mode, const wchar_t *_FileName, const wchar_t *const *_ArgList)
     * }
     */
    public static MethodHandle _wspawnv$handle() {
        return _wspawnv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * intptr_t _wspawnv(int _Mode, const wchar_t *_FileName, const wchar_t *const *_ArgList)
     * }
     */
    public static MemorySegment _wspawnv$address() {
        return _wspawnv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * intptr_t _wspawnv(int _Mode, const wchar_t *_FileName, const wchar_t *const *_ArgList)
     * }
     */
    public static long _wspawnv(int _Mode, MemorySegment _FileName, MemorySegment _ArgList) {
        var mh$ = _wspawnv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wspawnv", _Mode, _FileName, _ArgList);
            }
            return (long)mh$.invokeExact(_Mode, _FileName, _ArgList);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wspawnve {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wspawnve");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * intptr_t _wspawnve(int _Mode, const wchar_t *_FileName, const wchar_t *const *_ArgList, const wchar_t *const *_Env)
     * }
     */
    public static FunctionDescriptor _wspawnve$descriptor() {
        return _wspawnve.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * intptr_t _wspawnve(int _Mode, const wchar_t *_FileName, const wchar_t *const *_ArgList, const wchar_t *const *_Env)
     * }
     */
    public static MethodHandle _wspawnve$handle() {
        return _wspawnve.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * intptr_t _wspawnve(int _Mode, const wchar_t *_FileName, const wchar_t *const *_ArgList, const wchar_t *const *_Env)
     * }
     */
    public static MemorySegment _wspawnve$address() {
        return _wspawnve.ADDR;
    }

    /**
     * {@snippet lang=c :
     * intptr_t _wspawnve(int _Mode, const wchar_t *_FileName, const wchar_t *const *_ArgList, const wchar_t *const *_Env)
     * }
     */
    public static long _wspawnve(int _Mode, MemorySegment _FileName, MemorySegment _ArgList, MemorySegment _Env) {
        var mh$ = _wspawnve.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wspawnve", _Mode, _FileName, _ArgList, _Env);
            }
            return (long)mh$.invokeExact(_Mode, _FileName, _ArgList, _Env);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wspawnvp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wspawnvp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * intptr_t _wspawnvp(int _Mode, const wchar_t *_FileName, const wchar_t *const *_ArgList)
     * }
     */
    public static FunctionDescriptor _wspawnvp$descriptor() {
        return _wspawnvp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * intptr_t _wspawnvp(int _Mode, const wchar_t *_FileName, const wchar_t *const *_ArgList)
     * }
     */
    public static MethodHandle _wspawnvp$handle() {
        return _wspawnvp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * intptr_t _wspawnvp(int _Mode, const wchar_t *_FileName, const wchar_t *const *_ArgList)
     * }
     */
    public static MemorySegment _wspawnvp$address() {
        return _wspawnvp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * intptr_t _wspawnvp(int _Mode, const wchar_t *_FileName, const wchar_t *const *_ArgList)
     * }
     */
    public static long _wspawnvp(int _Mode, MemorySegment _FileName, MemorySegment _ArgList) {
        var mh$ = _wspawnvp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wspawnvp", _Mode, _FileName, _ArgList);
            }
            return (long)mh$.invokeExact(_Mode, _FileName, _ArgList);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wspawnvpe {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wspawnvpe");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * intptr_t _wspawnvpe(int _Mode, const wchar_t *_FileName, const wchar_t *const *_ArgList, const wchar_t *const *_Env)
     * }
     */
    public static FunctionDescriptor _wspawnvpe$descriptor() {
        return _wspawnvpe.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * intptr_t _wspawnvpe(int _Mode, const wchar_t *_FileName, const wchar_t *const *_ArgList, const wchar_t *const *_Env)
     * }
     */
    public static MethodHandle _wspawnvpe$handle() {
        return _wspawnvpe.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * intptr_t _wspawnvpe(int _Mode, const wchar_t *_FileName, const wchar_t *const *_ArgList, const wchar_t *const *_Env)
     * }
     */
    public static MemorySegment _wspawnvpe$address() {
        return _wspawnvpe.ADDR;
    }

    /**
     * {@snippet lang=c :
     * intptr_t _wspawnvpe(int _Mode, const wchar_t *_FileName, const wchar_t *const *_ArgList, const wchar_t *const *_Env)
     * }
     */
    public static long _wspawnvpe(int _Mode, MemorySegment _FileName, MemorySegment _ArgList, MemorySegment _Env) {
        var mh$ = _wspawnvpe.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wspawnvpe", _Mode, _FileName, _ArgList, _Env);
            }
            return (long)mh$.invokeExact(_Mode, _FileName, _ArgList, _Env);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wsystem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wsystem");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _wsystem(const wchar_t *_Command)
     * }
     */
    public static FunctionDescriptor _wsystem$descriptor() {
        return _wsystem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _wsystem(const wchar_t *_Command)
     * }
     */
    public static MethodHandle _wsystem$handle() {
        return _wsystem.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _wsystem(const wchar_t *_Command)
     * }
     */
    public static MemorySegment _wsystem$address() {
        return _wsystem.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _wsystem(const wchar_t *_Command)
     * }
     */
    public static int _wsystem(MemorySegment _Command) {
        var mh$ = _wsystem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wsystem", _Command);
            }
            return (int)mh$.invokeExact(_Command);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _itow_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_itow_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _itow_s(int _Value, wchar_t *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static FunctionDescriptor _itow_s$descriptor() {
        return _itow_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _itow_s(int _Value, wchar_t *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static MethodHandle _itow_s$handle() {
        return _itow_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _itow_s(int _Value, wchar_t *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static MemorySegment _itow_s$address() {
        return _itow_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _itow_s(int _Value, wchar_t *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static int _itow_s(int _Value, MemorySegment _Buffer, long _BufferCount, int _Radix) {
        var mh$ = _itow_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_itow_s", _Value, _Buffer, _BufferCount, _Radix);
            }
            return (int)mh$.invokeExact(_Value, _Buffer, _BufferCount, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _itow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_itow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *_itow(int _Value, wchar_t *_Buffer, int _Radix)
     * }
     */
    public static FunctionDescriptor _itow$descriptor() {
        return _itow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *_itow(int _Value, wchar_t *_Buffer, int _Radix)
     * }
     */
    public static MethodHandle _itow$handle() {
        return _itow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *_itow(int _Value, wchar_t *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment _itow$address() {
        return _itow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *_itow(int _Value, wchar_t *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment _itow(int _Value, MemorySegment _Buffer, int _Radix) {
        var mh$ = _itow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_itow", _Value, _Buffer, _Radix);
            }
            return (MemorySegment)mh$.invokeExact(_Value, _Buffer, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ltow_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_ltow_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _ltow_s(long _Value, wchar_t *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static FunctionDescriptor _ltow_s$descriptor() {
        return _ltow_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _ltow_s(long _Value, wchar_t *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static MethodHandle _ltow_s$handle() {
        return _ltow_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _ltow_s(long _Value, wchar_t *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static MemorySegment _ltow_s$address() {
        return _ltow_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _ltow_s(long _Value, wchar_t *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static int _ltow_s(int _Value, MemorySegment _Buffer, long _BufferCount, int _Radix) {
        var mh$ = _ltow_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ltow_s", _Value, _Buffer, _BufferCount, _Radix);
            }
            return (int)mh$.invokeExact(_Value, _Buffer, _BufferCount, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ltow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_ltow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *_ltow(long _Value, wchar_t *_Buffer, int _Radix)
     * }
     */
    public static FunctionDescriptor _ltow$descriptor() {
        return _ltow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *_ltow(long _Value, wchar_t *_Buffer, int _Radix)
     * }
     */
    public static MethodHandle _ltow$handle() {
        return _ltow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *_ltow(long _Value, wchar_t *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment _ltow$address() {
        return _ltow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *_ltow(long _Value, wchar_t *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment _ltow(int _Value, MemorySegment _Buffer, int _Radix) {
        var mh$ = _ltow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ltow", _Value, _Buffer, _Radix);
            }
            return (MemorySegment)mh$.invokeExact(_Value, _Buffer, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ultow_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_ultow_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _ultow_s(unsigned long _Value, wchar_t *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static FunctionDescriptor _ultow_s$descriptor() {
        return _ultow_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _ultow_s(unsigned long _Value, wchar_t *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static MethodHandle _ultow_s$handle() {
        return _ultow_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _ultow_s(unsigned long _Value, wchar_t *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static MemorySegment _ultow_s$address() {
        return _ultow_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _ultow_s(unsigned long _Value, wchar_t *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static int _ultow_s(int _Value, MemorySegment _Buffer, long _BufferCount, int _Radix) {
        var mh$ = _ultow_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ultow_s", _Value, _Buffer, _BufferCount, _Radix);
            }
            return (int)mh$.invokeExact(_Value, _Buffer, _BufferCount, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ultow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_ultow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *_ultow(unsigned long _Value, wchar_t *_Buffer, int _Radix)
     * }
     */
    public static FunctionDescriptor _ultow$descriptor() {
        return _ultow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *_ultow(unsigned long _Value, wchar_t *_Buffer, int _Radix)
     * }
     */
    public static MethodHandle _ultow$handle() {
        return _ultow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *_ultow(unsigned long _Value, wchar_t *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment _ultow$address() {
        return _ultow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *_ultow(unsigned long _Value, wchar_t *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment _ultow(int _Value, MemorySegment _Buffer, int _Radix) {
        var mh$ = _ultow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ultow", _Value, _Buffer, _Radix);
            }
            return (MemorySegment)mh$.invokeExact(_Value, _Buffer, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcstod {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcstod");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double wcstod(const wchar_t *_String, wchar_t **_EndPtr)
     * }
     */
    public static FunctionDescriptor wcstod$descriptor() {
        return wcstod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double wcstod(const wchar_t *_String, wchar_t **_EndPtr)
     * }
     */
    public static MethodHandle wcstod$handle() {
        return wcstod.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double wcstod(const wchar_t *_String, wchar_t **_EndPtr)
     * }
     */
    public static MemorySegment wcstod$address() {
        return wcstod.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double wcstod(const wchar_t *_String, wchar_t **_EndPtr)
     * }
     */
    public static double wcstod(MemorySegment _String, MemorySegment _EndPtr) {
        var mh$ = wcstod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcstod", _String, _EndPtr);
            }
            return (double)mh$.invokeExact(_String, _EndPtr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcstod_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wcstod_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double _wcstod_l(const wchar_t *_String, wchar_t **_EndPtr, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcstod_l$descriptor() {
        return _wcstod_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double _wcstod_l(const wchar_t *_String, wchar_t **_EndPtr, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcstod_l$handle() {
        return _wcstod_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double _wcstod_l(const wchar_t *_String, wchar_t **_EndPtr, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcstod_l$address() {
        return _wcstod_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double _wcstod_l(const wchar_t *_String, wchar_t **_EndPtr, _locale_t _Locale)
     * }
     */
    public static double _wcstod_l(MemorySegment _String, MemorySegment _EndPtr, MemorySegment _Locale) {
        var mh$ = _wcstod_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcstod_l", _String, _EndPtr, _Locale);
            }
            return (double)mh$.invokeExact(_String, _EndPtr, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcstol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcstol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long wcstol(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static FunctionDescriptor wcstol$descriptor() {
        return wcstol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long wcstol(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static MethodHandle wcstol$handle() {
        return wcstol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long wcstol(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static MemorySegment wcstol$address() {
        return wcstol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long wcstol(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static int wcstol(MemorySegment _String, MemorySegment _EndPtr, int _Radix) {
        var mh$ = wcstol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcstol", _String, _EndPtr, _Radix);
            }
            return (int)mh$.invokeExact(_String, _EndPtr, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcstol_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wcstol_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long _wcstol_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcstol_l$descriptor() {
        return _wcstol_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long _wcstol_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcstol_l$handle() {
        return _wcstol_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long _wcstol_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcstol_l$address() {
        return _wcstol_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long _wcstol_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static int _wcstol_l(MemorySegment _String, MemorySegment _EndPtr, int _Radix, MemorySegment _Locale) {
        var mh$ = _wcstol_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcstol_l", _String, _EndPtr, _Radix, _Locale);
            }
            return (int)mh$.invokeExact(_String, _EndPtr, _Radix, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcstoll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcstoll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long wcstoll(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static FunctionDescriptor wcstoll$descriptor() {
        return wcstoll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long wcstoll(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static MethodHandle wcstoll$handle() {
        return wcstoll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long wcstoll(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static MemorySegment wcstoll$address() {
        return wcstoll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long wcstoll(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static long wcstoll(MemorySegment _String, MemorySegment _EndPtr, int _Radix) {
        var mh$ = wcstoll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcstoll", _String, _EndPtr, _Radix);
            }
            return (long)mh$.invokeExact(_String, _EndPtr, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcstoll_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wcstoll_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long _wcstoll_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcstoll_l$descriptor() {
        return _wcstoll_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long _wcstoll_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcstoll_l$handle() {
        return _wcstoll_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long _wcstoll_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcstoll_l$address() {
        return _wcstoll_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long _wcstoll_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static long _wcstoll_l(MemorySegment _String, MemorySegment _EndPtr, int _Radix, MemorySegment _Locale) {
        var mh$ = _wcstoll_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcstoll_l", _String, _EndPtr, _Radix, _Locale);
            }
            return (long)mh$.invokeExact(_String, _EndPtr, _Radix, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcstoul {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcstoul");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long wcstoul(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static FunctionDescriptor wcstoul$descriptor() {
        return wcstoul.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long wcstoul(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static MethodHandle wcstoul$handle() {
        return wcstoul.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long wcstoul(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static MemorySegment wcstoul$address() {
        return wcstoul.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long wcstoul(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static int wcstoul(MemorySegment _String, MemorySegment _EndPtr, int _Radix) {
        var mh$ = wcstoul.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcstoul", _String, _EndPtr, _Radix);
            }
            return (int)mh$.invokeExact(_String, _EndPtr, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcstoul_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wcstoul_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long _wcstoul_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcstoul_l$descriptor() {
        return _wcstoul_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long _wcstoul_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcstoul_l$handle() {
        return _wcstoul_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long _wcstoul_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcstoul_l$address() {
        return _wcstoul_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long _wcstoul_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static int _wcstoul_l(MemorySegment _String, MemorySegment _EndPtr, int _Radix, MemorySegment _Locale) {
        var mh$ = _wcstoul_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcstoul_l", _String, _EndPtr, _Radix, _Locale);
            }
            return (int)mh$.invokeExact(_String, _EndPtr, _Radix, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcstoull {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcstoull");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long long wcstoull(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static FunctionDescriptor wcstoull$descriptor() {
        return wcstoull.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long long wcstoull(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static MethodHandle wcstoull$handle() {
        return wcstoull.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long long wcstoull(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static MemorySegment wcstoull$address() {
        return wcstoull.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long long wcstoull(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static long wcstoull(MemorySegment _String, MemorySegment _EndPtr, int _Radix) {
        var mh$ = wcstoull.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcstoull", _String, _EndPtr, _Radix);
            }
            return (long)mh$.invokeExact(_String, _EndPtr, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcstoull_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wcstoull_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long long _wcstoull_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcstoull_l$descriptor() {
        return _wcstoull_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long long _wcstoull_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcstoull_l$handle() {
        return _wcstoull_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long long _wcstoull_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcstoull_l$address() {
        return _wcstoull_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long long _wcstoull_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static long _wcstoull_l(MemorySegment _String, MemorySegment _EndPtr, int _Radix, MemorySegment _Locale) {
        var mh$ = _wcstoull_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcstoull_l", _String, _EndPtr, _Radix, _Locale);
            }
            return (long)mh$.invokeExact(_String, _EndPtr, _Radix, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcstold {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_DOUBLE,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcstold");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double wcstold(const wchar_t *_String, wchar_t **_EndPtr)
     * }
     */
    public static FunctionDescriptor wcstold$descriptor() {
        return wcstold.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double wcstold(const wchar_t *_String, wchar_t **_EndPtr)
     * }
     */
    public static MethodHandle wcstold$handle() {
        return wcstold.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double wcstold(const wchar_t *_String, wchar_t **_EndPtr)
     * }
     */
    public static MemorySegment wcstold$address() {
        return wcstold.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double wcstold(const wchar_t *_String, wchar_t **_EndPtr)
     * }
     */
    public static double wcstold(MemorySegment _String, MemorySegment _EndPtr) {
        var mh$ = wcstold.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcstold", _String, _EndPtr);
            }
            return (double)mh$.invokeExact(_String, _EndPtr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcstold_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_DOUBLE,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wcstold_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double _wcstold_l(const wchar_t *_String, wchar_t **_EndPtr, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcstold_l$descriptor() {
        return _wcstold_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double _wcstold_l(const wchar_t *_String, wchar_t **_EndPtr, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcstold_l$handle() {
        return _wcstold_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double _wcstold_l(const wchar_t *_String, wchar_t **_EndPtr, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcstold_l$address() {
        return _wcstold_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double _wcstold_l(const wchar_t *_String, wchar_t **_EndPtr, _locale_t _Locale)
     * }
     */
    public static double _wcstold_l(MemorySegment _String, MemorySegment _EndPtr, MemorySegment _Locale) {
        var mh$ = _wcstold_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcstold_l", _String, _EndPtr, _Locale);
            }
            return (double)mh$.invokeExact(_String, _EndPtr, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcstof {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcstof");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float wcstof(const wchar_t *_String, wchar_t **_EndPtr)
     * }
     */
    public static FunctionDescriptor wcstof$descriptor() {
        return wcstof.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float wcstof(const wchar_t *_String, wchar_t **_EndPtr)
     * }
     */
    public static MethodHandle wcstof$handle() {
        return wcstof.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float wcstof(const wchar_t *_String, wchar_t **_EndPtr)
     * }
     */
    public static MemorySegment wcstof$address() {
        return wcstof.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float wcstof(const wchar_t *_String, wchar_t **_EndPtr)
     * }
     */
    public static float wcstof(MemorySegment _String, MemorySegment _EndPtr) {
        var mh$ = wcstof.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcstof", _String, _EndPtr);
            }
            return (float)mh$.invokeExact(_String, _EndPtr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcstof_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wcstof_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float _wcstof_l(const wchar_t *_String, wchar_t **_EndPtr, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcstof_l$descriptor() {
        return _wcstof_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float _wcstof_l(const wchar_t *_String, wchar_t **_EndPtr, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcstof_l$handle() {
        return _wcstof_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float _wcstof_l(const wchar_t *_String, wchar_t **_EndPtr, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcstof_l$address() {
        return _wcstof_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float _wcstof_l(const wchar_t *_String, wchar_t **_EndPtr, _locale_t _Locale)
     * }
     */
    public static float _wcstof_l(MemorySegment _String, MemorySegment _EndPtr, MemorySegment _Locale) {
        var mh$ = _wcstof_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcstof_l", _String, _EndPtr, _Locale);
            }
            return (float)mh$.invokeExact(_String, _EndPtr, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wtof {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wtof");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double _wtof(const wchar_t *_String)
     * }
     */
    public static FunctionDescriptor _wtof$descriptor() {
        return _wtof.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double _wtof(const wchar_t *_String)
     * }
     */
    public static MethodHandle _wtof$handle() {
        return _wtof.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double _wtof(const wchar_t *_String)
     * }
     */
    public static MemorySegment _wtof$address() {
        return _wtof.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double _wtof(const wchar_t *_String)
     * }
     */
    public static double _wtof(MemorySegment _String) {
        var mh$ = _wtof.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wtof", _String);
            }
            return (double)mh$.invokeExact(_String);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wtof_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wtof_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double _wtof_l(const wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wtof_l$descriptor() {
        return _wtof_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double _wtof_l(const wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wtof_l$handle() {
        return _wtof_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double _wtof_l(const wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wtof_l$address() {
        return _wtof_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double _wtof_l(const wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static double _wtof_l(MemorySegment _String, MemorySegment _Locale) {
        var mh$ = _wtof_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wtof_l", _String, _Locale);
            }
            return (double)mh$.invokeExact(_String, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wtoi {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wtoi");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _wtoi(const wchar_t *_String)
     * }
     */
    public static FunctionDescriptor _wtoi$descriptor() {
        return _wtoi.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _wtoi(const wchar_t *_String)
     * }
     */
    public static MethodHandle _wtoi$handle() {
        return _wtoi.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _wtoi(const wchar_t *_String)
     * }
     */
    public static MemorySegment _wtoi$address() {
        return _wtoi.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _wtoi(const wchar_t *_String)
     * }
     */
    public static int _wtoi(MemorySegment _String) {
        var mh$ = _wtoi.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wtoi", _String);
            }
            return (int)mh$.invokeExact(_String);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wtoi_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wtoi_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _wtoi_l(const wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wtoi_l$descriptor() {
        return _wtoi_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _wtoi_l(const wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wtoi_l$handle() {
        return _wtoi_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _wtoi_l(const wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wtoi_l$address() {
        return _wtoi_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _wtoi_l(const wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static int _wtoi_l(MemorySegment _String, MemorySegment _Locale) {
        var mh$ = _wtoi_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wtoi_l", _String, _Locale);
            }
            return (int)mh$.invokeExact(_String, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wtol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wtol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long _wtol(const wchar_t *_String)
     * }
     */
    public static FunctionDescriptor _wtol$descriptor() {
        return _wtol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long _wtol(const wchar_t *_String)
     * }
     */
    public static MethodHandle _wtol$handle() {
        return _wtol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long _wtol(const wchar_t *_String)
     * }
     */
    public static MemorySegment _wtol$address() {
        return _wtol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long _wtol(const wchar_t *_String)
     * }
     */
    public static int _wtol(MemorySegment _String) {
        var mh$ = _wtol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wtol", _String);
            }
            return (int)mh$.invokeExact(_String);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wtol_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wtol_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long _wtol_l(const wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wtol_l$descriptor() {
        return _wtol_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long _wtol_l(const wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wtol_l$handle() {
        return _wtol_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long _wtol_l(const wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wtol_l$address() {
        return _wtol_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long _wtol_l(const wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static int _wtol_l(MemorySegment _String, MemorySegment _Locale) {
        var mh$ = _wtol_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wtol_l", _String, _Locale);
            }
            return (int)mh$.invokeExact(_String, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wtoll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wtoll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long _wtoll(const wchar_t *_String)
     * }
     */
    public static FunctionDescriptor _wtoll$descriptor() {
        return _wtoll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long _wtoll(const wchar_t *_String)
     * }
     */
    public static MethodHandle _wtoll$handle() {
        return _wtoll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long _wtoll(const wchar_t *_String)
     * }
     */
    public static MemorySegment _wtoll$address() {
        return _wtoll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long _wtoll(const wchar_t *_String)
     * }
     */
    public static long _wtoll(MemorySegment _String) {
        var mh$ = _wtoll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wtoll", _String);
            }
            return (long)mh$.invokeExact(_String);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wtoll_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wtoll_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long _wtoll_l(const wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wtoll_l$descriptor() {
        return _wtoll_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long _wtoll_l(const wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wtoll_l$handle() {
        return _wtoll_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long _wtoll_l(const wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wtoll_l$address() {
        return _wtoll_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long _wtoll_l(const wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static long _wtoll_l(MemorySegment _String, MemorySegment _Locale) {
        var mh$ = _wtoll_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wtoll_l", _String, _Locale);
            }
            return (long)mh$.invokeExact(_String, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _i64tow_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_i64tow_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _i64tow_s(long long _Value, wchar_t *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static FunctionDescriptor _i64tow_s$descriptor() {
        return _i64tow_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _i64tow_s(long long _Value, wchar_t *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static MethodHandle _i64tow_s$handle() {
        return _i64tow_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _i64tow_s(long long _Value, wchar_t *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static MemorySegment _i64tow_s$address() {
        return _i64tow_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _i64tow_s(long long _Value, wchar_t *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static int _i64tow_s(long _Value, MemorySegment _Buffer, long _BufferCount, int _Radix) {
        var mh$ = _i64tow_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_i64tow_s", _Value, _Buffer, _BufferCount, _Radix);
            }
            return (int)mh$.invokeExact(_Value, _Buffer, _BufferCount, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _i64tow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_i64tow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *_i64tow(long long _Value, wchar_t *_Buffer, int _Radix)
     * }
     */
    public static FunctionDescriptor _i64tow$descriptor() {
        return _i64tow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *_i64tow(long long _Value, wchar_t *_Buffer, int _Radix)
     * }
     */
    public static MethodHandle _i64tow$handle() {
        return _i64tow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *_i64tow(long long _Value, wchar_t *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment _i64tow$address() {
        return _i64tow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *_i64tow(long long _Value, wchar_t *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment _i64tow(long _Value, MemorySegment _Buffer, int _Radix) {
        var mh$ = _i64tow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_i64tow", _Value, _Buffer, _Radix);
            }
            return (MemorySegment)mh$.invokeExact(_Value, _Buffer, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ui64tow_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_ui64tow_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _ui64tow_s(unsigned long long _Value, wchar_t *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static FunctionDescriptor _ui64tow_s$descriptor() {
        return _ui64tow_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _ui64tow_s(unsigned long long _Value, wchar_t *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static MethodHandle _ui64tow_s$handle() {
        return _ui64tow_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _ui64tow_s(unsigned long long _Value, wchar_t *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static MemorySegment _ui64tow_s$address() {
        return _ui64tow_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _ui64tow_s(unsigned long long _Value, wchar_t *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static int _ui64tow_s(long _Value, MemorySegment _Buffer, long _BufferCount, int _Radix) {
        var mh$ = _ui64tow_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ui64tow_s", _Value, _Buffer, _BufferCount, _Radix);
            }
            return (int)mh$.invokeExact(_Value, _Buffer, _BufferCount, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ui64tow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_ui64tow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *_ui64tow(unsigned long long _Value, wchar_t *_Buffer, int _Radix)
     * }
     */
    public static FunctionDescriptor _ui64tow$descriptor() {
        return _ui64tow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *_ui64tow(unsigned long long _Value, wchar_t *_Buffer, int _Radix)
     * }
     */
    public static MethodHandle _ui64tow$handle() {
        return _ui64tow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *_ui64tow(unsigned long long _Value, wchar_t *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment _ui64tow$address() {
        return _ui64tow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *_ui64tow(unsigned long long _Value, wchar_t *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment _ui64tow(long _Value, MemorySegment _Buffer, int _Radix) {
        var mh$ = _ui64tow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ui64tow", _Value, _Buffer, _Radix);
            }
            return (MemorySegment)mh$.invokeExact(_Value, _Buffer, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wtoi64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wtoi64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long _wtoi64(const wchar_t *_String)
     * }
     */
    public static FunctionDescriptor _wtoi64$descriptor() {
        return _wtoi64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long _wtoi64(const wchar_t *_String)
     * }
     */
    public static MethodHandle _wtoi64$handle() {
        return _wtoi64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long _wtoi64(const wchar_t *_String)
     * }
     */
    public static MemorySegment _wtoi64$address() {
        return _wtoi64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long _wtoi64(const wchar_t *_String)
     * }
     */
    public static long _wtoi64(MemorySegment _String) {
        var mh$ = _wtoi64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wtoi64", _String);
            }
            return (long)mh$.invokeExact(_String);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wtoi64_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wtoi64_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long _wtoi64_l(const wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wtoi64_l$descriptor() {
        return _wtoi64_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long _wtoi64_l(const wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wtoi64_l$handle() {
        return _wtoi64_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long _wtoi64_l(const wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wtoi64_l$address() {
        return _wtoi64_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long _wtoi64_l(const wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static long _wtoi64_l(MemorySegment _String, MemorySegment _Locale) {
        var mh$ = _wtoi64_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wtoi64_l", _String, _Locale);
            }
            return (long)mh$.invokeExact(_String, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcstoi64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wcstoi64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long _wcstoi64(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static FunctionDescriptor _wcstoi64$descriptor() {
        return _wcstoi64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long _wcstoi64(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static MethodHandle _wcstoi64$handle() {
        return _wcstoi64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long _wcstoi64(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static MemorySegment _wcstoi64$address() {
        return _wcstoi64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long _wcstoi64(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static long _wcstoi64(MemorySegment _String, MemorySegment _EndPtr, int _Radix) {
        var mh$ = _wcstoi64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcstoi64", _String, _EndPtr, _Radix);
            }
            return (long)mh$.invokeExact(_String, _EndPtr, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcstoi64_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wcstoi64_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long _wcstoi64_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcstoi64_l$descriptor() {
        return _wcstoi64_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long _wcstoi64_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcstoi64_l$handle() {
        return _wcstoi64_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long _wcstoi64_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcstoi64_l$address() {
        return _wcstoi64_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long _wcstoi64_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static long _wcstoi64_l(MemorySegment _String, MemorySegment _EndPtr, int _Radix, MemorySegment _Locale) {
        var mh$ = _wcstoi64_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcstoi64_l", _String, _EndPtr, _Radix, _Locale);
            }
            return (long)mh$.invokeExact(_String, _EndPtr, _Radix, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcstoui64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wcstoui64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long long _wcstoui64(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static FunctionDescriptor _wcstoui64$descriptor() {
        return _wcstoui64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long long _wcstoui64(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static MethodHandle _wcstoui64$handle() {
        return _wcstoui64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long long _wcstoui64(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static MemorySegment _wcstoui64$address() {
        return _wcstoui64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long long _wcstoui64(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static long _wcstoui64(MemorySegment _String, MemorySegment _EndPtr, int _Radix) {
        var mh$ = _wcstoui64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcstoui64", _String, _EndPtr, _Radix);
            }
            return (long)mh$.invokeExact(_String, _EndPtr, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcstoui64_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wcstoui64_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long long _wcstoui64_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcstoui64_l$descriptor() {
        return _wcstoui64_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long long _wcstoui64_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcstoui64_l$handle() {
        return _wcstoui64_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long long _wcstoui64_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcstoui64_l$address() {
        return _wcstoui64_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long long _wcstoui64_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static long _wcstoui64_l(MemorySegment _String, MemorySegment _EndPtr, int _Radix, MemorySegment _Locale) {
        var mh$ = _wcstoui64_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcstoui64_l", _String, _EndPtr, _Radix, _Locale);
            }
            return (long)mh$.invokeExact(_String, _EndPtr, _Radix, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wfullpath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wfullpath");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *_wfullpath(wchar_t *_Buffer, const wchar_t *_Path, size_t _BufferCount)
     * }
     */
    public static FunctionDescriptor _wfullpath$descriptor() {
        return _wfullpath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *_wfullpath(wchar_t *_Buffer, const wchar_t *_Path, size_t _BufferCount)
     * }
     */
    public static MethodHandle _wfullpath$handle() {
        return _wfullpath.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *_wfullpath(wchar_t *_Buffer, const wchar_t *_Path, size_t _BufferCount)
     * }
     */
    public static MemorySegment _wfullpath$address() {
        return _wfullpath.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *_wfullpath(wchar_t *_Buffer, const wchar_t *_Path, size_t _BufferCount)
     * }
     */
    public static MemorySegment _wfullpath(MemorySegment _Buffer, MemorySegment _Path, long _BufferCount) {
        var mh$ = _wfullpath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wfullpath", _Buffer, _Path, _BufferCount);
            }
            return (MemorySegment)mh$.invokeExact(_Buffer, _Path, _BufferCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wmakepath_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wmakepath_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _wmakepath_s(wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_Drive, const wchar_t *_Dir, const wchar_t *_Filename, const wchar_t *_Ext)
     * }
     */
    public static FunctionDescriptor _wmakepath_s$descriptor() {
        return _wmakepath_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _wmakepath_s(wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_Drive, const wchar_t *_Dir, const wchar_t *_Filename, const wchar_t *_Ext)
     * }
     */
    public static MethodHandle _wmakepath_s$handle() {
        return _wmakepath_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _wmakepath_s(wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_Drive, const wchar_t *_Dir, const wchar_t *_Filename, const wchar_t *_Ext)
     * }
     */
    public static MemorySegment _wmakepath_s$address() {
        return _wmakepath_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _wmakepath_s(wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_Drive, const wchar_t *_Dir, const wchar_t *_Filename, const wchar_t *_Ext)
     * }
     */
    public static int _wmakepath_s(MemorySegment _Buffer, long _BufferCount, MemorySegment _Drive, MemorySegment _Dir, MemorySegment _Filename, MemorySegment _Ext) {
        var mh$ = _wmakepath_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wmakepath_s", _Buffer, _BufferCount, _Drive, _Dir, _Filename, _Ext);
            }
            return (int)mh$.invokeExact(_Buffer, _BufferCount, _Drive, _Dir, _Filename, _Ext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wmakepath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wmakepath");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _wmakepath(wchar_t *_Buffer, const wchar_t *_Drive, const wchar_t *_Dir, const wchar_t *_Filename, const wchar_t *_Ext)
     * }
     */
    public static FunctionDescriptor _wmakepath$descriptor() {
        return _wmakepath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _wmakepath(wchar_t *_Buffer, const wchar_t *_Drive, const wchar_t *_Dir, const wchar_t *_Filename, const wchar_t *_Ext)
     * }
     */
    public static MethodHandle _wmakepath$handle() {
        return _wmakepath.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _wmakepath(wchar_t *_Buffer, const wchar_t *_Drive, const wchar_t *_Dir, const wchar_t *_Filename, const wchar_t *_Ext)
     * }
     */
    public static MemorySegment _wmakepath$address() {
        return _wmakepath.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _wmakepath(wchar_t *_Buffer, const wchar_t *_Drive, const wchar_t *_Dir, const wchar_t *_Filename, const wchar_t *_Ext)
     * }
     */
    public static void _wmakepath(MemorySegment _Buffer, MemorySegment _Drive, MemorySegment _Dir, MemorySegment _Filename, MemorySegment _Ext) {
        var mh$ = _wmakepath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wmakepath", _Buffer, _Drive, _Dir, _Filename, _Ext);
            }
            mh$.invokeExact(_Buffer, _Drive, _Dir, _Filename, _Ext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wsplitpath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wsplitpath");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _wsplitpath(const wchar_t *_FullPath, wchar_t *_Drive, wchar_t *_Dir, wchar_t *_Filename, wchar_t *_Ext)
     * }
     */
    public static FunctionDescriptor _wsplitpath$descriptor() {
        return _wsplitpath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _wsplitpath(const wchar_t *_FullPath, wchar_t *_Drive, wchar_t *_Dir, wchar_t *_Filename, wchar_t *_Ext)
     * }
     */
    public static MethodHandle _wsplitpath$handle() {
        return _wsplitpath.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _wsplitpath(const wchar_t *_FullPath, wchar_t *_Drive, wchar_t *_Dir, wchar_t *_Filename, wchar_t *_Ext)
     * }
     */
    public static MemorySegment _wsplitpath$address() {
        return _wsplitpath.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _wsplitpath(const wchar_t *_FullPath, wchar_t *_Drive, wchar_t *_Dir, wchar_t *_Filename, wchar_t *_Ext)
     * }
     */
    public static void _wsplitpath(MemorySegment _FullPath, MemorySegment _Drive, MemorySegment _Dir, MemorySegment _Filename, MemorySegment _Ext) {
        var mh$ = _wsplitpath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wsplitpath", _FullPath, _Drive, _Dir, _Filename, _Ext);
            }
            mh$.invokeExact(_FullPath, _Drive, _Dir, _Filename, _Ext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wsplitpath_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wsplitpath_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _wsplitpath_s(const wchar_t *_FullPath, wchar_t *_Drive, size_t _DriveCount, wchar_t *_Dir, size_t _DirCount, wchar_t *_Filename, size_t _FilenameCount, wchar_t *_Ext, size_t _ExtCount)
     * }
     */
    public static FunctionDescriptor _wsplitpath_s$descriptor() {
        return _wsplitpath_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _wsplitpath_s(const wchar_t *_FullPath, wchar_t *_Drive, size_t _DriveCount, wchar_t *_Dir, size_t _DirCount, wchar_t *_Filename, size_t _FilenameCount, wchar_t *_Ext, size_t _ExtCount)
     * }
     */
    public static MethodHandle _wsplitpath_s$handle() {
        return _wsplitpath_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _wsplitpath_s(const wchar_t *_FullPath, wchar_t *_Drive, size_t _DriveCount, wchar_t *_Dir, size_t _DirCount, wchar_t *_Filename, size_t _FilenameCount, wchar_t *_Ext, size_t _ExtCount)
     * }
     */
    public static MemorySegment _wsplitpath_s$address() {
        return _wsplitpath_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _wsplitpath_s(const wchar_t *_FullPath, wchar_t *_Drive, size_t _DriveCount, wchar_t *_Dir, size_t _DirCount, wchar_t *_Filename, size_t _FilenameCount, wchar_t *_Ext, size_t _ExtCount)
     * }
     */
    public static int _wsplitpath_s(MemorySegment _FullPath, MemorySegment _Drive, long _DriveCount, MemorySegment _Dir, long _DirCount, MemorySegment _Filename, long _FilenameCount, MemorySegment _Ext, long _ExtCount) {
        var mh$ = _wsplitpath_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wsplitpath_s", _FullPath, _Drive, _DriveCount, _Dir, _DirCount, _Filename, _FilenameCount, _Ext, _ExtCount);
            }
            return (int)mh$.invokeExact(_FullPath, _Drive, _DriveCount, _Dir, _DirCount, _Filename, _FilenameCount, _Ext, _ExtCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wdupenv_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wdupenv_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _wdupenv_s(wchar_t **_Buffer, size_t *_BufferCount, const wchar_t *_VarName)
     * }
     */
    public static FunctionDescriptor _wdupenv_s$descriptor() {
        return _wdupenv_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _wdupenv_s(wchar_t **_Buffer, size_t *_BufferCount, const wchar_t *_VarName)
     * }
     */
    public static MethodHandle _wdupenv_s$handle() {
        return _wdupenv_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _wdupenv_s(wchar_t **_Buffer, size_t *_BufferCount, const wchar_t *_VarName)
     * }
     */
    public static MemorySegment _wdupenv_s$address() {
        return _wdupenv_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _wdupenv_s(wchar_t **_Buffer, size_t *_BufferCount, const wchar_t *_VarName)
     * }
     */
    public static int _wdupenv_s(MemorySegment _Buffer, MemorySegment _BufferCount, MemorySegment _VarName) {
        var mh$ = _wdupenv_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wdupenv_s", _Buffer, _BufferCount, _VarName);
            }
            return (int)mh$.invokeExact(_Buffer, _BufferCount, _VarName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wgetenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wgetenv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *_wgetenv(const wchar_t *_VarName)
     * }
     */
    public static FunctionDescriptor _wgetenv$descriptor() {
        return _wgetenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *_wgetenv(const wchar_t *_VarName)
     * }
     */
    public static MethodHandle _wgetenv$handle() {
        return _wgetenv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *_wgetenv(const wchar_t *_VarName)
     * }
     */
    public static MemorySegment _wgetenv$address() {
        return _wgetenv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *_wgetenv(const wchar_t *_VarName)
     * }
     */
    public static MemorySegment _wgetenv(MemorySegment _VarName) {
        var mh$ = _wgetenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wgetenv", _VarName);
            }
            return (MemorySegment)mh$.invokeExact(_VarName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wgetenv_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wgetenv_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _wgetenv_s(size_t *_RequiredCount, wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_VarName)
     * }
     */
    public static FunctionDescriptor _wgetenv_s$descriptor() {
        return _wgetenv_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _wgetenv_s(size_t *_RequiredCount, wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_VarName)
     * }
     */
    public static MethodHandle _wgetenv_s$handle() {
        return _wgetenv_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _wgetenv_s(size_t *_RequiredCount, wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_VarName)
     * }
     */
    public static MemorySegment _wgetenv_s$address() {
        return _wgetenv_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _wgetenv_s(size_t *_RequiredCount, wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_VarName)
     * }
     */
    public static int _wgetenv_s(MemorySegment _RequiredCount, MemorySegment _Buffer, long _BufferCount, MemorySegment _VarName) {
        var mh$ = _wgetenv_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wgetenv_s", _RequiredCount, _Buffer, _BufferCount, _VarName);
            }
            return (int)mh$.invokeExact(_RequiredCount, _Buffer, _BufferCount, _VarName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wputenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wputenv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _wputenv(const wchar_t *_EnvString)
     * }
     */
    public static FunctionDescriptor _wputenv$descriptor() {
        return _wputenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _wputenv(const wchar_t *_EnvString)
     * }
     */
    public static MethodHandle _wputenv$handle() {
        return _wputenv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _wputenv(const wchar_t *_EnvString)
     * }
     */
    public static MemorySegment _wputenv$address() {
        return _wputenv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _wputenv(const wchar_t *_EnvString)
     * }
     */
    public static int _wputenv(MemorySegment _EnvString) {
        var mh$ = _wputenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wputenv", _EnvString);
            }
            return (int)mh$.invokeExact(_EnvString);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wputenv_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wputenv_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _wputenv_s(const wchar_t *_Name, const wchar_t *_Value)
     * }
     */
    public static FunctionDescriptor _wputenv_s$descriptor() {
        return _wputenv_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _wputenv_s(const wchar_t *_Name, const wchar_t *_Value)
     * }
     */
    public static MethodHandle _wputenv_s$handle() {
        return _wputenv_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _wputenv_s(const wchar_t *_Name, const wchar_t *_Value)
     * }
     */
    public static MemorySegment _wputenv_s$address() {
        return _wputenv_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _wputenv_s(const wchar_t *_Name, const wchar_t *_Value)
     * }
     */
    public static int _wputenv_s(MemorySegment _Name, MemorySegment _Value) {
        var mh$ = _wputenv_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wputenv_s", _Name, _Value);
            }
            return (int)mh$.invokeExact(_Name, _Value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wsearchenv_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wsearchenv_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _wsearchenv_s(const wchar_t *_Filename, const wchar_t *_VarName, wchar_t *_Buffer, size_t _BufferCount)
     * }
     */
    public static FunctionDescriptor _wsearchenv_s$descriptor() {
        return _wsearchenv_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _wsearchenv_s(const wchar_t *_Filename, const wchar_t *_VarName, wchar_t *_Buffer, size_t _BufferCount)
     * }
     */
    public static MethodHandle _wsearchenv_s$handle() {
        return _wsearchenv_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _wsearchenv_s(const wchar_t *_Filename, const wchar_t *_VarName, wchar_t *_Buffer, size_t _BufferCount)
     * }
     */
    public static MemorySegment _wsearchenv_s$address() {
        return _wsearchenv_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _wsearchenv_s(const wchar_t *_Filename, const wchar_t *_VarName, wchar_t *_Buffer, size_t _BufferCount)
     * }
     */
    public static int _wsearchenv_s(MemorySegment _Filename, MemorySegment _VarName, MemorySegment _Buffer, long _BufferCount) {
        var mh$ = _wsearchenv_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wsearchenv_s", _Filename, _VarName, _Buffer, _BufferCount);
            }
            return (int)mh$.invokeExact(_Filename, _VarName, _Buffer, _BufferCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wsearchenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wsearchenv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _wsearchenv(const wchar_t *_Filename, const wchar_t *_VarName, wchar_t *_ResultPath)
     * }
     */
    public static FunctionDescriptor _wsearchenv$descriptor() {
        return _wsearchenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _wsearchenv(const wchar_t *_Filename, const wchar_t *_VarName, wchar_t *_ResultPath)
     * }
     */
    public static MethodHandle _wsearchenv$handle() {
        return _wsearchenv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _wsearchenv(const wchar_t *_Filename, const wchar_t *_VarName, wchar_t *_ResultPath)
     * }
     */
    public static MemorySegment _wsearchenv$address() {
        return _wsearchenv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _wsearchenv(const wchar_t *_Filename, const wchar_t *_VarName, wchar_t *_ResultPath)
     * }
     */
    public static void _wsearchenv(MemorySegment _Filename, MemorySegment _VarName, MemorySegment _ResultPath) {
        var mh$ = _wsearchenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wsearchenv", _Filename, _VarName, _ResultPath);
            }
            mh$.invokeExact(_Filename, _VarName, _ResultPath);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcscat_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcscat_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t wcscat_s(wchar_t *_Destination, rsize_t _SizeInWords, const wchar_t *_Source)
     * }
     */
    public static FunctionDescriptor wcscat_s$descriptor() {
        return wcscat_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t wcscat_s(wchar_t *_Destination, rsize_t _SizeInWords, const wchar_t *_Source)
     * }
     */
    public static MethodHandle wcscat_s$handle() {
        return wcscat_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t wcscat_s(wchar_t *_Destination, rsize_t _SizeInWords, const wchar_t *_Source)
     * }
     */
    public static MemorySegment wcscat_s$address() {
        return wcscat_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t wcscat_s(wchar_t *_Destination, rsize_t _SizeInWords, const wchar_t *_Source)
     * }
     */
    public static int wcscat_s(MemorySegment _Destination, long _SizeInWords, MemorySegment _Source) {
        var mh$ = wcscat_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcscat_s", _Destination, _SizeInWords, _Source);
            }
            return (int)mh$.invokeExact(_Destination, _SizeInWords, _Source);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcscpy_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcscpy_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t wcscpy_s(wchar_t *_Destination, rsize_t _SizeInWords, const wchar_t *_Source)
     * }
     */
    public static FunctionDescriptor wcscpy_s$descriptor() {
        return wcscpy_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t wcscpy_s(wchar_t *_Destination, rsize_t _SizeInWords, const wchar_t *_Source)
     * }
     */
    public static MethodHandle wcscpy_s$handle() {
        return wcscpy_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t wcscpy_s(wchar_t *_Destination, rsize_t _SizeInWords, const wchar_t *_Source)
     * }
     */
    public static MemorySegment wcscpy_s$address() {
        return wcscpy_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t wcscpy_s(wchar_t *_Destination, rsize_t _SizeInWords, const wchar_t *_Source)
     * }
     */
    public static int wcscpy_s(MemorySegment _Destination, long _SizeInWords, MemorySegment _Source) {
        var mh$ = wcscpy_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcscpy_s", _Destination, _SizeInWords, _Source);
            }
            return (int)mh$.invokeExact(_Destination, _SizeInWords, _Source);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsncat_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcsncat_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t wcsncat_s(wchar_t *_Destination, rsize_t _SizeInWords, const wchar_t *_Source, rsize_t _MaxCount)
     * }
     */
    public static FunctionDescriptor wcsncat_s$descriptor() {
        return wcsncat_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t wcsncat_s(wchar_t *_Destination, rsize_t _SizeInWords, const wchar_t *_Source, rsize_t _MaxCount)
     * }
     */
    public static MethodHandle wcsncat_s$handle() {
        return wcsncat_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t wcsncat_s(wchar_t *_Destination, rsize_t _SizeInWords, const wchar_t *_Source, rsize_t _MaxCount)
     * }
     */
    public static MemorySegment wcsncat_s$address() {
        return wcsncat_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t wcsncat_s(wchar_t *_Destination, rsize_t _SizeInWords, const wchar_t *_Source, rsize_t _MaxCount)
     * }
     */
    public static int wcsncat_s(MemorySegment _Destination, long _SizeInWords, MemorySegment _Source, long _MaxCount) {
        var mh$ = wcsncat_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsncat_s", _Destination, _SizeInWords, _Source, _MaxCount);
            }
            return (int)mh$.invokeExact(_Destination, _SizeInWords, _Source, _MaxCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsncpy_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcsncpy_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t wcsncpy_s(wchar_t *_Destination, rsize_t _SizeInWords, const wchar_t *_Source, rsize_t _MaxCount)
     * }
     */
    public static FunctionDescriptor wcsncpy_s$descriptor() {
        return wcsncpy_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t wcsncpy_s(wchar_t *_Destination, rsize_t _SizeInWords, const wchar_t *_Source, rsize_t _MaxCount)
     * }
     */
    public static MethodHandle wcsncpy_s$handle() {
        return wcsncpy_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t wcsncpy_s(wchar_t *_Destination, rsize_t _SizeInWords, const wchar_t *_Source, rsize_t _MaxCount)
     * }
     */
    public static MemorySegment wcsncpy_s$address() {
        return wcsncpy_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t wcsncpy_s(wchar_t *_Destination, rsize_t _SizeInWords, const wchar_t *_Source, rsize_t _MaxCount)
     * }
     */
    public static int wcsncpy_s(MemorySegment _Destination, long _SizeInWords, MemorySegment _Source, long _MaxCount) {
        var mh$ = wcsncpy_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsncpy_s", _Destination, _SizeInWords, _Source, _MaxCount);
            }
            return (int)mh$.invokeExact(_Destination, _SizeInWords, _Source, _MaxCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcstok_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcstok_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *wcstok_s(wchar_t *_String, const wchar_t *_Delimiter, wchar_t **_Context)
     * }
     */
    public static FunctionDescriptor wcstok_s$descriptor() {
        return wcstok_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *wcstok_s(wchar_t *_String, const wchar_t *_Delimiter, wchar_t **_Context)
     * }
     */
    public static MethodHandle wcstok_s$handle() {
        return wcstok_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *wcstok_s(wchar_t *_String, const wchar_t *_Delimiter, wchar_t **_Context)
     * }
     */
    public static MemorySegment wcstok_s$address() {
        return wcstok_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *wcstok_s(wchar_t *_String, const wchar_t *_Delimiter, wchar_t **_Context)
     * }
     */
    public static MemorySegment wcstok_s(MemorySegment _String, MemorySegment _Delimiter, MemorySegment _Context) {
        var mh$ = wcstok_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcstok_s", _String, _Delimiter, _Context);
            }
            return (MemorySegment)mh$.invokeExact(_String, _Delimiter, _Context);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcsdup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wcsdup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *_wcsdup(const wchar_t *_String)
     * }
     */
    public static FunctionDescriptor _wcsdup$descriptor() {
        return _wcsdup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *_wcsdup(const wchar_t *_String)
     * }
     */
    public static MethodHandle _wcsdup$handle() {
        return _wcsdup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *_wcsdup(const wchar_t *_String)
     * }
     */
    public static MemorySegment _wcsdup$address() {
        return _wcsdup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *_wcsdup(const wchar_t *_String)
     * }
     */
    public static MemorySegment _wcsdup(MemorySegment _String) {
        var mh$ = _wcsdup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcsdup", _String);
            }
            return (MemorySegment)mh$.invokeExact(_String);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcscat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcscat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *wcscat(wchar_t *_Destination, const wchar_t *_Source)
     * }
     */
    public static FunctionDescriptor wcscat$descriptor() {
        return wcscat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *wcscat(wchar_t *_Destination, const wchar_t *_Source)
     * }
     */
    public static MethodHandle wcscat$handle() {
        return wcscat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *wcscat(wchar_t *_Destination, const wchar_t *_Source)
     * }
     */
    public static MemorySegment wcscat$address() {
        return wcscat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *wcscat(wchar_t *_Destination, const wchar_t *_Source)
     * }
     */
    public static MemorySegment wcscat(MemorySegment _Destination, MemorySegment _Source) {
        var mh$ = wcscat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcscat", _Destination, _Source);
            }
            return (MemorySegment)mh$.invokeExact(_Destination, _Source);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcscmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcscmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int wcscmp(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static FunctionDescriptor wcscmp$descriptor() {
        return wcscmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int wcscmp(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static MethodHandle wcscmp$handle() {
        return wcscmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int wcscmp(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static MemorySegment wcscmp$address() {
        return wcscmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int wcscmp(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static int wcscmp(MemorySegment _String1, MemorySegment _String2) {
        var mh$ = wcscmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcscmp", _String1, _String2);
            }
            return (int)mh$.invokeExact(_String1, _String2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcscpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcscpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *wcscpy(wchar_t *_Destination, const wchar_t *_Source)
     * }
     */
    public static FunctionDescriptor wcscpy$descriptor() {
        return wcscpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *wcscpy(wchar_t *_Destination, const wchar_t *_Source)
     * }
     */
    public static MethodHandle wcscpy$handle() {
        return wcscpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *wcscpy(wchar_t *_Destination, const wchar_t *_Source)
     * }
     */
    public static MemorySegment wcscpy$address() {
        return wcscpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *wcscpy(wchar_t *_Destination, const wchar_t *_Source)
     * }
     */
    public static MemorySegment wcscpy(MemorySegment _Destination, MemorySegment _Source) {
        var mh$ = wcscpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcscpy", _Destination, _Source);
            }
            return (MemorySegment)mh$.invokeExact(_Destination, _Source);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcscspn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcscspn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t wcscspn(const wchar_t *_String, const wchar_t *_Control)
     * }
     */
    public static FunctionDescriptor wcscspn$descriptor() {
        return wcscspn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t wcscspn(const wchar_t *_String, const wchar_t *_Control)
     * }
     */
    public static MethodHandle wcscspn$handle() {
        return wcscspn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t wcscspn(const wchar_t *_String, const wchar_t *_Control)
     * }
     */
    public static MemorySegment wcscspn$address() {
        return wcscspn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t wcscspn(const wchar_t *_String, const wchar_t *_Control)
     * }
     */
    public static long wcscspn(MemorySegment _String, MemorySegment _Control) {
        var mh$ = wcscspn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcscspn", _String, _Control);
            }
            return (long)mh$.invokeExact(_String, _Control);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcslen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcslen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long long wcslen(const wchar_t *_String)
     * }
     */
    public static FunctionDescriptor wcslen$descriptor() {
        return wcslen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long long wcslen(const wchar_t *_String)
     * }
     */
    public static MethodHandle wcslen$handle() {
        return wcslen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long long wcslen(const wchar_t *_String)
     * }
     */
    public static MemorySegment wcslen$address() {
        return wcslen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long long wcslen(const wchar_t *_String)
     * }
     */
    public static long wcslen(MemorySegment _String) {
        var mh$ = wcslen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcslen", _String);
            }
            return (long)mh$.invokeExact(_String);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsnlen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcsnlen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t wcsnlen(const wchar_t *_Source, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor wcsnlen$descriptor() {
        return wcsnlen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t wcsnlen(const wchar_t *_Source, size_t _MaxCount)
     * }
     */
    public static MethodHandle wcsnlen$handle() {
        return wcsnlen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t wcsnlen(const wchar_t *_Source, size_t _MaxCount)
     * }
     */
    public static MemorySegment wcsnlen$address() {
        return wcsnlen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t wcsnlen(const wchar_t *_Source, size_t _MaxCount)
     * }
     */
    public static long wcsnlen(MemorySegment _Source, long _MaxCount) {
        var mh$ = wcsnlen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsnlen", _Source, _MaxCount);
            }
            return (long)mh$.invokeExact(_Source, _MaxCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsncat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcsncat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *wcsncat(wchar_t *_Destination, const wchar_t *_Source, size_t _Count)
     * }
     */
    public static FunctionDescriptor wcsncat$descriptor() {
        return wcsncat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *wcsncat(wchar_t *_Destination, const wchar_t *_Source, size_t _Count)
     * }
     */
    public static MethodHandle wcsncat$handle() {
        return wcsncat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *wcsncat(wchar_t *_Destination, const wchar_t *_Source, size_t _Count)
     * }
     */
    public static MemorySegment wcsncat$address() {
        return wcsncat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *wcsncat(wchar_t *_Destination, const wchar_t *_Source, size_t _Count)
     * }
     */
    public static MemorySegment wcsncat(MemorySegment _Destination, MemorySegment _Source, long _Count) {
        var mh$ = wcsncat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsncat", _Destination, _Source, _Count);
            }
            return (MemorySegment)mh$.invokeExact(_Destination, _Source, _Count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsncmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcsncmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int wcsncmp(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor wcsncmp$descriptor() {
        return wcsncmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int wcsncmp(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount)
     * }
     */
    public static MethodHandle wcsncmp$handle() {
        return wcsncmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int wcsncmp(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount)
     * }
     */
    public static MemorySegment wcsncmp$address() {
        return wcsncmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int wcsncmp(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount)
     * }
     */
    public static int wcsncmp(MemorySegment _String1, MemorySegment _String2, long _MaxCount) {
        var mh$ = wcsncmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsncmp", _String1, _String2, _MaxCount);
            }
            return (int)mh$.invokeExact(_String1, _String2, _MaxCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsncpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcsncpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *wcsncpy(wchar_t *_Destination, const wchar_t *_Source, size_t _Count)
     * }
     */
    public static FunctionDescriptor wcsncpy$descriptor() {
        return wcsncpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *wcsncpy(wchar_t *_Destination, const wchar_t *_Source, size_t _Count)
     * }
     */
    public static MethodHandle wcsncpy$handle() {
        return wcsncpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *wcsncpy(wchar_t *_Destination, const wchar_t *_Source, size_t _Count)
     * }
     */
    public static MemorySegment wcsncpy$address() {
        return wcsncpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *wcsncpy(wchar_t *_Destination, const wchar_t *_Source, size_t _Count)
     * }
     */
    public static MemorySegment wcsncpy(MemorySegment _Destination, MemorySegment _Source, long _Count) {
        var mh$ = wcsncpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsncpy", _Destination, _Source, _Count);
            }
            return (MemorySegment)mh$.invokeExact(_Destination, _Source, _Count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcspbrk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcspbrk");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *wcspbrk(const wchar_t *_String, const wchar_t *_Control)
     * }
     */
    public static FunctionDescriptor wcspbrk$descriptor() {
        return wcspbrk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *wcspbrk(const wchar_t *_String, const wchar_t *_Control)
     * }
     */
    public static MethodHandle wcspbrk$handle() {
        return wcspbrk.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *wcspbrk(const wchar_t *_String, const wchar_t *_Control)
     * }
     */
    public static MemorySegment wcspbrk$address() {
        return wcspbrk.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *wcspbrk(const wchar_t *_String, const wchar_t *_Control)
     * }
     */
    public static MemorySegment wcspbrk(MemorySegment _String, MemorySegment _Control) {
        var mh$ = wcspbrk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcspbrk", _String, _Control);
            }
            return (MemorySegment)mh$.invokeExact(_String, _Control);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsspn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcsspn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t wcsspn(const wchar_t *_String, const wchar_t *_Control)
     * }
     */
    public static FunctionDescriptor wcsspn$descriptor() {
        return wcsspn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t wcsspn(const wchar_t *_String, const wchar_t *_Control)
     * }
     */
    public static MethodHandle wcsspn$handle() {
        return wcsspn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t wcsspn(const wchar_t *_String, const wchar_t *_Control)
     * }
     */
    public static MemorySegment wcsspn$address() {
        return wcsspn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t wcsspn(const wchar_t *_String, const wchar_t *_Control)
     * }
     */
    public static long wcsspn(MemorySegment _String, MemorySegment _Control) {
        var mh$ = wcsspn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsspn", _String, _Control);
            }
            return (long)mh$.invokeExact(_String, _Control);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcstok {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcstok");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *wcstok(wchar_t *_String, const wchar_t *_Delimiter, wchar_t **_Context)
     * }
     */
    public static FunctionDescriptor wcstok$descriptor() {
        return wcstok.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *wcstok(wchar_t *_String, const wchar_t *_Delimiter, wchar_t **_Context)
     * }
     */
    public static MethodHandle wcstok$handle() {
        return wcstok.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *wcstok(wchar_t *_String, const wchar_t *_Delimiter, wchar_t **_Context)
     * }
     */
    public static MemorySegment wcstok$address() {
        return wcstok.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *wcstok(wchar_t *_String, const wchar_t *_Delimiter, wchar_t **_Context)
     * }
     */
    public static MemorySegment wcstok(MemorySegment _String, MemorySegment _Delimiter, MemorySegment _Context) {
        var mh$ = wcstok.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcstok", _String, _Delimiter, _Context);
            }
            return (MemorySegment)mh$.invokeExact(_String, _Delimiter, _Context);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcserror {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wcserror");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *_wcserror(int _ErrorNumber)
     * }
     */
    public static FunctionDescriptor _wcserror$descriptor() {
        return _wcserror.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *_wcserror(int _ErrorNumber)
     * }
     */
    public static MethodHandle _wcserror$handle() {
        return _wcserror.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *_wcserror(int _ErrorNumber)
     * }
     */
    public static MemorySegment _wcserror$address() {
        return _wcserror.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *_wcserror(int _ErrorNumber)
     * }
     */
    public static MemorySegment _wcserror(int _ErrorNumber) {
        var mh$ = _wcserror.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcserror", _ErrorNumber);
            }
            return (MemorySegment)mh$.invokeExact(_ErrorNumber);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcserror_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wcserror_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _wcserror_s(wchar_t *_Buffer, size_t _SizeInWords, int _ErrorNumber)
     * }
     */
    public static FunctionDescriptor _wcserror_s$descriptor() {
        return _wcserror_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _wcserror_s(wchar_t *_Buffer, size_t _SizeInWords, int _ErrorNumber)
     * }
     */
    public static MethodHandle _wcserror_s$handle() {
        return _wcserror_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _wcserror_s(wchar_t *_Buffer, size_t _SizeInWords, int _ErrorNumber)
     * }
     */
    public static MemorySegment _wcserror_s$address() {
        return _wcserror_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _wcserror_s(wchar_t *_Buffer, size_t _SizeInWords, int _ErrorNumber)
     * }
     */
    public static int _wcserror_s(MemorySegment _Buffer, long _SizeInWords, int _ErrorNumber) {
        var mh$ = _wcserror_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcserror_s", _Buffer, _SizeInWords, _ErrorNumber);
            }
            return (int)mh$.invokeExact(_Buffer, _SizeInWords, _ErrorNumber);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __wcserror {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("__wcserror");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *__wcserror(const wchar_t *_String)
     * }
     */
    public static FunctionDescriptor __wcserror$descriptor() {
        return __wcserror.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *__wcserror(const wchar_t *_String)
     * }
     */
    public static MethodHandle __wcserror$handle() {
        return __wcserror.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *__wcserror(const wchar_t *_String)
     * }
     */
    public static MemorySegment __wcserror$address() {
        return __wcserror.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *__wcserror(const wchar_t *_String)
     * }
     */
    public static MemorySegment __wcserror(MemorySegment _String) {
        var mh$ = __wcserror.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__wcserror", _String);
            }
            return (MemorySegment)mh$.invokeExact(_String);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __wcserror_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("__wcserror_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t __wcserror_s(wchar_t *_Buffer, size_t _SizeInWords, const wchar_t *_ErrorMessage)
     * }
     */
    public static FunctionDescriptor __wcserror_s$descriptor() {
        return __wcserror_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t __wcserror_s(wchar_t *_Buffer, size_t _SizeInWords, const wchar_t *_ErrorMessage)
     * }
     */
    public static MethodHandle __wcserror_s$handle() {
        return __wcserror_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t __wcserror_s(wchar_t *_Buffer, size_t _SizeInWords, const wchar_t *_ErrorMessage)
     * }
     */
    public static MemorySegment __wcserror_s$address() {
        return __wcserror_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t __wcserror_s(wchar_t *_Buffer, size_t _SizeInWords, const wchar_t *_ErrorMessage)
     * }
     */
    public static int __wcserror_s(MemorySegment _Buffer, long _SizeInWords, MemorySegment _ErrorMessage) {
        var mh$ = __wcserror_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__wcserror_s", _Buffer, _SizeInWords, _ErrorMessage);
            }
            return (int)mh$.invokeExact(_Buffer, _SizeInWords, _ErrorMessage);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcsicmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wcsicmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _wcsicmp(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static FunctionDescriptor _wcsicmp$descriptor() {
        return _wcsicmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _wcsicmp(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static MethodHandle _wcsicmp$handle() {
        return _wcsicmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _wcsicmp(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static MemorySegment _wcsicmp$address() {
        return _wcsicmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _wcsicmp(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static int _wcsicmp(MemorySegment _String1, MemorySegment _String2) {
        var mh$ = _wcsicmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcsicmp", _String1, _String2);
            }
            return (int)mh$.invokeExact(_String1, _String2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcsicmp_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wcsicmp_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _wcsicmp_l(const wchar_t *_String1, const wchar_t *_String2, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcsicmp_l$descriptor() {
        return _wcsicmp_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _wcsicmp_l(const wchar_t *_String1, const wchar_t *_String2, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcsicmp_l$handle() {
        return _wcsicmp_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _wcsicmp_l(const wchar_t *_String1, const wchar_t *_String2, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcsicmp_l$address() {
        return _wcsicmp_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _wcsicmp_l(const wchar_t *_String1, const wchar_t *_String2, _locale_t _Locale)
     * }
     */
    public static int _wcsicmp_l(MemorySegment _String1, MemorySegment _String2, MemorySegment _Locale) {
        var mh$ = _wcsicmp_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcsicmp_l", _String1, _String2, _Locale);
            }
            return (int)mh$.invokeExact(_String1, _String2, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcsnicmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wcsnicmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _wcsnicmp(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor _wcsnicmp$descriptor() {
        return _wcsnicmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _wcsnicmp(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount)
     * }
     */
    public static MethodHandle _wcsnicmp$handle() {
        return _wcsnicmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _wcsnicmp(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount)
     * }
     */
    public static MemorySegment _wcsnicmp$address() {
        return _wcsnicmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _wcsnicmp(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount)
     * }
     */
    public static int _wcsnicmp(MemorySegment _String1, MemorySegment _String2, long _MaxCount) {
        var mh$ = _wcsnicmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcsnicmp", _String1, _String2, _MaxCount);
            }
            return (int)mh$.invokeExact(_String1, _String2, _MaxCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcsnicmp_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wcsnicmp_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _wcsnicmp_l(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcsnicmp_l$descriptor() {
        return _wcsnicmp_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _wcsnicmp_l(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcsnicmp_l$handle() {
        return _wcsnicmp_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _wcsnicmp_l(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcsnicmp_l$address() {
        return _wcsnicmp_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _wcsnicmp_l(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static int _wcsnicmp_l(MemorySegment _String1, MemorySegment _String2, long _MaxCount, MemorySegment _Locale) {
        var mh$ = _wcsnicmp_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcsnicmp_l", _String1, _String2, _MaxCount, _Locale);
            }
            return (int)mh$.invokeExact(_String1, _String2, _MaxCount, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcsnset_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_SHORT,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wcsnset_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _wcsnset_s(wchar_t *_Destination, size_t _SizeInWords, wchar_t _Value, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor _wcsnset_s$descriptor() {
        return _wcsnset_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _wcsnset_s(wchar_t *_Destination, size_t _SizeInWords, wchar_t _Value, size_t _MaxCount)
     * }
     */
    public static MethodHandle _wcsnset_s$handle() {
        return _wcsnset_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _wcsnset_s(wchar_t *_Destination, size_t _SizeInWords, wchar_t _Value, size_t _MaxCount)
     * }
     */
    public static MemorySegment _wcsnset_s$address() {
        return _wcsnset_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _wcsnset_s(wchar_t *_Destination, size_t _SizeInWords, wchar_t _Value, size_t _MaxCount)
     * }
     */
    public static int _wcsnset_s(MemorySegment _Destination, long _SizeInWords, short _Value, long _MaxCount) {
        var mh$ = _wcsnset_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcsnset_s", _Destination, _SizeInWords, _Value, _MaxCount);
            }
            return (int)mh$.invokeExact(_Destination, _SizeInWords, _Value, _MaxCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcsnset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_SHORT,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wcsnset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *_wcsnset(wchar_t *_String, wchar_t _Value, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor _wcsnset$descriptor() {
        return _wcsnset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *_wcsnset(wchar_t *_String, wchar_t _Value, size_t _MaxCount)
     * }
     */
    public static MethodHandle _wcsnset$handle() {
        return _wcsnset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *_wcsnset(wchar_t *_String, wchar_t _Value, size_t _MaxCount)
     * }
     */
    public static MemorySegment _wcsnset$address() {
        return _wcsnset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *_wcsnset(wchar_t *_String, wchar_t _Value, size_t _MaxCount)
     * }
     */
    public static MemorySegment _wcsnset(MemorySegment _String, short _Value, long _MaxCount) {
        var mh$ = _wcsnset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcsnset", _String, _Value, _MaxCount);
            }
            return (MemorySegment)mh$.invokeExact(_String, _Value, _MaxCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcsrev {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wcsrev");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *_wcsrev(wchar_t *_String)
     * }
     */
    public static FunctionDescriptor _wcsrev$descriptor() {
        return _wcsrev.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *_wcsrev(wchar_t *_String)
     * }
     */
    public static MethodHandle _wcsrev$handle() {
        return _wcsrev.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *_wcsrev(wchar_t *_String)
     * }
     */
    public static MemorySegment _wcsrev$address() {
        return _wcsrev.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *_wcsrev(wchar_t *_String)
     * }
     */
    public static MemorySegment _wcsrev(MemorySegment _String) {
        var mh$ = _wcsrev.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcsrev", _String);
            }
            return (MemorySegment)mh$.invokeExact(_String);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcsset_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_SHORT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wcsset_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _wcsset_s(wchar_t *_Destination, size_t _SizeInWords, wchar_t _Value)
     * }
     */
    public static FunctionDescriptor _wcsset_s$descriptor() {
        return _wcsset_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _wcsset_s(wchar_t *_Destination, size_t _SizeInWords, wchar_t _Value)
     * }
     */
    public static MethodHandle _wcsset_s$handle() {
        return _wcsset_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _wcsset_s(wchar_t *_Destination, size_t _SizeInWords, wchar_t _Value)
     * }
     */
    public static MemorySegment _wcsset_s$address() {
        return _wcsset_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _wcsset_s(wchar_t *_Destination, size_t _SizeInWords, wchar_t _Value)
     * }
     */
    public static int _wcsset_s(MemorySegment _Destination, long _SizeInWords, short _Value) {
        var mh$ = _wcsset_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcsset_s", _Destination, _SizeInWords, _Value);
            }
            return (int)mh$.invokeExact(_Destination, _SizeInWords, _Value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcsset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_SHORT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wcsset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *_wcsset(wchar_t *_String, wchar_t _Value)
     * }
     */
    public static FunctionDescriptor _wcsset$descriptor() {
        return _wcsset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *_wcsset(wchar_t *_String, wchar_t _Value)
     * }
     */
    public static MethodHandle _wcsset$handle() {
        return _wcsset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *_wcsset(wchar_t *_String, wchar_t _Value)
     * }
     */
    public static MemorySegment _wcsset$address() {
        return _wcsset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *_wcsset(wchar_t *_String, wchar_t _Value)
     * }
     */
    public static MemorySegment _wcsset(MemorySegment _String, short _Value) {
        var mh$ = _wcsset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcsset", _String, _Value);
            }
            return (MemorySegment)mh$.invokeExact(_String, _Value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcslwr_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wcslwr_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _wcslwr_s(wchar_t *_String, size_t _SizeInWords)
     * }
     */
    public static FunctionDescriptor _wcslwr_s$descriptor() {
        return _wcslwr_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _wcslwr_s(wchar_t *_String, size_t _SizeInWords)
     * }
     */
    public static MethodHandle _wcslwr_s$handle() {
        return _wcslwr_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _wcslwr_s(wchar_t *_String, size_t _SizeInWords)
     * }
     */
    public static MemorySegment _wcslwr_s$address() {
        return _wcslwr_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _wcslwr_s(wchar_t *_String, size_t _SizeInWords)
     * }
     */
    public static int _wcslwr_s(MemorySegment _String, long _SizeInWords) {
        var mh$ = _wcslwr_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcslwr_s", _String, _SizeInWords);
            }
            return (int)mh$.invokeExact(_String, _SizeInWords);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcslwr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wcslwr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *_wcslwr(wchar_t *_String)
     * }
     */
    public static FunctionDescriptor _wcslwr$descriptor() {
        return _wcslwr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *_wcslwr(wchar_t *_String)
     * }
     */
    public static MethodHandle _wcslwr$handle() {
        return _wcslwr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *_wcslwr(wchar_t *_String)
     * }
     */
    public static MemorySegment _wcslwr$address() {
        return _wcslwr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *_wcslwr(wchar_t *_String)
     * }
     */
    public static MemorySegment _wcslwr(MemorySegment _String) {
        var mh$ = _wcslwr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcslwr", _String);
            }
            return (MemorySegment)mh$.invokeExact(_String);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcslwr_s_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wcslwr_s_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _wcslwr_s_l(wchar_t *_String, size_t _SizeInWords, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcslwr_s_l$descriptor() {
        return _wcslwr_s_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _wcslwr_s_l(wchar_t *_String, size_t _SizeInWords, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcslwr_s_l$handle() {
        return _wcslwr_s_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _wcslwr_s_l(wchar_t *_String, size_t _SizeInWords, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcslwr_s_l$address() {
        return _wcslwr_s_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _wcslwr_s_l(wchar_t *_String, size_t _SizeInWords, _locale_t _Locale)
     * }
     */
    public static int _wcslwr_s_l(MemorySegment _String, long _SizeInWords, MemorySegment _Locale) {
        var mh$ = _wcslwr_s_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcslwr_s_l", _String, _SizeInWords, _Locale);
            }
            return (int)mh$.invokeExact(_String, _SizeInWords, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcslwr_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wcslwr_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *_wcslwr_l(wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcslwr_l$descriptor() {
        return _wcslwr_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *_wcslwr_l(wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcslwr_l$handle() {
        return _wcslwr_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *_wcslwr_l(wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcslwr_l$address() {
        return _wcslwr_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *_wcslwr_l(wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcslwr_l(MemorySegment _String, MemorySegment _Locale) {
        var mh$ = _wcslwr_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcslwr_l", _String, _Locale);
            }
            return (MemorySegment)mh$.invokeExact(_String, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcsupr_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wcsupr_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _wcsupr_s(wchar_t *_String, size_t _Size)
     * }
     */
    public static FunctionDescriptor _wcsupr_s$descriptor() {
        return _wcsupr_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _wcsupr_s(wchar_t *_String, size_t _Size)
     * }
     */
    public static MethodHandle _wcsupr_s$handle() {
        return _wcsupr_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _wcsupr_s(wchar_t *_String, size_t _Size)
     * }
     */
    public static MemorySegment _wcsupr_s$address() {
        return _wcsupr_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _wcsupr_s(wchar_t *_String, size_t _Size)
     * }
     */
    public static int _wcsupr_s(MemorySegment _String, long _Size) {
        var mh$ = _wcsupr_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcsupr_s", _String, _Size);
            }
            return (int)mh$.invokeExact(_String, _Size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcsupr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wcsupr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *_wcsupr(wchar_t *_String)
     * }
     */
    public static FunctionDescriptor _wcsupr$descriptor() {
        return _wcsupr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *_wcsupr(wchar_t *_String)
     * }
     */
    public static MethodHandle _wcsupr$handle() {
        return _wcsupr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *_wcsupr(wchar_t *_String)
     * }
     */
    public static MemorySegment _wcsupr$address() {
        return _wcsupr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *_wcsupr(wchar_t *_String)
     * }
     */
    public static MemorySegment _wcsupr(MemorySegment _String) {
        var mh$ = _wcsupr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcsupr", _String);
            }
            return (MemorySegment)mh$.invokeExact(_String);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcsupr_s_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wcsupr_s_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _wcsupr_s_l(wchar_t *_String, size_t _Size, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcsupr_s_l$descriptor() {
        return _wcsupr_s_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _wcsupr_s_l(wchar_t *_String, size_t _Size, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcsupr_s_l$handle() {
        return _wcsupr_s_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _wcsupr_s_l(wchar_t *_String, size_t _Size, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcsupr_s_l$address() {
        return _wcsupr_s_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _wcsupr_s_l(wchar_t *_String, size_t _Size, _locale_t _Locale)
     * }
     */
    public static int _wcsupr_s_l(MemorySegment _String, long _Size, MemorySegment _Locale) {
        var mh$ = _wcsupr_s_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcsupr_s_l", _String, _Size, _Locale);
            }
            return (int)mh$.invokeExact(_String, _Size, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcsupr_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wcsupr_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *_wcsupr_l(wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcsupr_l$descriptor() {
        return _wcsupr_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *_wcsupr_l(wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcsupr_l$handle() {
        return _wcsupr_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *_wcsupr_l(wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcsupr_l$address() {
        return _wcsupr_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *_wcsupr_l(wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcsupr_l(MemorySegment _String, MemorySegment _Locale) {
        var mh$ = _wcsupr_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcsupr_l", _String, _Locale);
            }
            return (MemorySegment)mh$.invokeExact(_String, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsxfrm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcsxfrm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t wcsxfrm(wchar_t *_Destination, const wchar_t *_Source, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor wcsxfrm$descriptor() {
        return wcsxfrm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t wcsxfrm(wchar_t *_Destination, const wchar_t *_Source, size_t _MaxCount)
     * }
     */
    public static MethodHandle wcsxfrm$handle() {
        return wcsxfrm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t wcsxfrm(wchar_t *_Destination, const wchar_t *_Source, size_t _MaxCount)
     * }
     */
    public static MemorySegment wcsxfrm$address() {
        return wcsxfrm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t wcsxfrm(wchar_t *_Destination, const wchar_t *_Source, size_t _MaxCount)
     * }
     */
    public static long wcsxfrm(MemorySegment _Destination, MemorySegment _Source, long _MaxCount) {
        var mh$ = wcsxfrm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsxfrm", _Destination, _Source, _MaxCount);
            }
            return (long)mh$.invokeExact(_Destination, _Source, _MaxCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcsxfrm_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wcsxfrm_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t _wcsxfrm_l(wchar_t *_Destination, const wchar_t *_Source, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcsxfrm_l$descriptor() {
        return _wcsxfrm_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t _wcsxfrm_l(wchar_t *_Destination, const wchar_t *_Source, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcsxfrm_l$handle() {
        return _wcsxfrm_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t _wcsxfrm_l(wchar_t *_Destination, const wchar_t *_Source, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcsxfrm_l$address() {
        return _wcsxfrm_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t _wcsxfrm_l(wchar_t *_Destination, const wchar_t *_Source, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static long _wcsxfrm_l(MemorySegment _Destination, MemorySegment _Source, long _MaxCount, MemorySegment _Locale) {
        var mh$ = _wcsxfrm_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcsxfrm_l", _Destination, _Source, _MaxCount, _Locale);
            }
            return (long)mh$.invokeExact(_Destination, _Source, _MaxCount, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcscoll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcscoll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int wcscoll(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static FunctionDescriptor wcscoll$descriptor() {
        return wcscoll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int wcscoll(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static MethodHandle wcscoll$handle() {
        return wcscoll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int wcscoll(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static MemorySegment wcscoll$address() {
        return wcscoll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int wcscoll(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static int wcscoll(MemorySegment _String1, MemorySegment _String2) {
        var mh$ = wcscoll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcscoll", _String1, _String2);
            }
            return (int)mh$.invokeExact(_String1, _String2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcscoll_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wcscoll_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _wcscoll_l(const wchar_t *_String1, const wchar_t *_String2, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcscoll_l$descriptor() {
        return _wcscoll_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _wcscoll_l(const wchar_t *_String1, const wchar_t *_String2, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcscoll_l$handle() {
        return _wcscoll_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _wcscoll_l(const wchar_t *_String1, const wchar_t *_String2, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcscoll_l$address() {
        return _wcscoll_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _wcscoll_l(const wchar_t *_String1, const wchar_t *_String2, _locale_t _Locale)
     * }
     */
    public static int _wcscoll_l(MemorySegment _String1, MemorySegment _String2, MemorySegment _Locale) {
        var mh$ = _wcscoll_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcscoll_l", _String1, _String2, _Locale);
            }
            return (int)mh$.invokeExact(_String1, _String2, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcsicoll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wcsicoll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _wcsicoll(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static FunctionDescriptor _wcsicoll$descriptor() {
        return _wcsicoll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _wcsicoll(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static MethodHandle _wcsicoll$handle() {
        return _wcsicoll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _wcsicoll(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static MemorySegment _wcsicoll$address() {
        return _wcsicoll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _wcsicoll(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static int _wcsicoll(MemorySegment _String1, MemorySegment _String2) {
        var mh$ = _wcsicoll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcsicoll", _String1, _String2);
            }
            return (int)mh$.invokeExact(_String1, _String2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcsicoll_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wcsicoll_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _wcsicoll_l(const wchar_t *_String1, const wchar_t *_String2, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcsicoll_l$descriptor() {
        return _wcsicoll_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _wcsicoll_l(const wchar_t *_String1, const wchar_t *_String2, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcsicoll_l$handle() {
        return _wcsicoll_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _wcsicoll_l(const wchar_t *_String1, const wchar_t *_String2, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcsicoll_l$address() {
        return _wcsicoll_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _wcsicoll_l(const wchar_t *_String1, const wchar_t *_String2, _locale_t _Locale)
     * }
     */
    public static int _wcsicoll_l(MemorySegment _String1, MemorySegment _String2, MemorySegment _Locale) {
        var mh$ = _wcsicoll_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcsicoll_l", _String1, _String2, _Locale);
            }
            return (int)mh$.invokeExact(_String1, _String2, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcsncoll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wcsncoll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _wcsncoll(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor _wcsncoll$descriptor() {
        return _wcsncoll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _wcsncoll(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount)
     * }
     */
    public static MethodHandle _wcsncoll$handle() {
        return _wcsncoll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _wcsncoll(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount)
     * }
     */
    public static MemorySegment _wcsncoll$address() {
        return _wcsncoll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _wcsncoll(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount)
     * }
     */
    public static int _wcsncoll(MemorySegment _String1, MemorySegment _String2, long _MaxCount) {
        var mh$ = _wcsncoll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcsncoll", _String1, _String2, _MaxCount);
            }
            return (int)mh$.invokeExact(_String1, _String2, _MaxCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcsncoll_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wcsncoll_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _wcsncoll_l(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcsncoll_l$descriptor() {
        return _wcsncoll_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _wcsncoll_l(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcsncoll_l$handle() {
        return _wcsncoll_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _wcsncoll_l(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcsncoll_l$address() {
        return _wcsncoll_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _wcsncoll_l(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static int _wcsncoll_l(MemorySegment _String1, MemorySegment _String2, long _MaxCount, MemorySegment _Locale) {
        var mh$ = _wcsncoll_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcsncoll_l", _String1, _String2, _MaxCount, _Locale);
            }
            return (int)mh$.invokeExact(_String1, _String2, _MaxCount, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcsnicoll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wcsnicoll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _wcsnicoll(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor _wcsnicoll$descriptor() {
        return _wcsnicoll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _wcsnicoll(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount)
     * }
     */
    public static MethodHandle _wcsnicoll$handle() {
        return _wcsnicoll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _wcsnicoll(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount)
     * }
     */
    public static MemorySegment _wcsnicoll$address() {
        return _wcsnicoll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _wcsnicoll(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount)
     * }
     */
    public static int _wcsnicoll(MemorySegment _String1, MemorySegment _String2, long _MaxCount) {
        var mh$ = _wcsnicoll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcsnicoll", _String1, _String2, _MaxCount);
            }
            return (int)mh$.invokeExact(_String1, _String2, _MaxCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcsnicoll_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wcsnicoll_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _wcsnicoll_l(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcsnicoll_l$descriptor() {
        return _wcsnicoll_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _wcsnicoll_l(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcsnicoll_l$handle() {
        return _wcsnicoll_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _wcsnicoll_l(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcsnicoll_l$address() {
        return _wcsnicoll_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _wcsnicoll_l(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static int _wcsnicoll_l(MemorySegment _String1, MemorySegment _String2, long _MaxCount, MemorySegment _Locale) {
        var mh$ = _wcsnicoll_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcsnicoll_l", _String1, _String2, _MaxCount, _Locale);
            }
            return (int)mh$.invokeExact(_String1, _String2, _MaxCount, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsdup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcsdup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *wcsdup(const wchar_t *_String)
     * }
     */
    public static FunctionDescriptor wcsdup$descriptor() {
        return wcsdup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *wcsdup(const wchar_t *_String)
     * }
     */
    public static MethodHandle wcsdup$handle() {
        return wcsdup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *wcsdup(const wchar_t *_String)
     * }
     */
    public static MemorySegment wcsdup$address() {
        return wcsdup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *wcsdup(const wchar_t *_String)
     * }
     */
    public static MemorySegment wcsdup(MemorySegment _String) {
        var mh$ = wcsdup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsdup", _String);
            }
            return (MemorySegment)mh$.invokeExact(_String);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsicmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcsicmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int wcsicmp(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static FunctionDescriptor wcsicmp$descriptor() {
        return wcsicmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int wcsicmp(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static MethodHandle wcsicmp$handle() {
        return wcsicmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int wcsicmp(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static MemorySegment wcsicmp$address() {
        return wcsicmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int wcsicmp(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static int wcsicmp(MemorySegment _String1, MemorySegment _String2) {
        var mh$ = wcsicmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsicmp", _String1, _String2);
            }
            return (int)mh$.invokeExact(_String1, _String2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsnicmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcsnicmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int wcsnicmp(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor wcsnicmp$descriptor() {
        return wcsnicmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int wcsnicmp(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount)
     * }
     */
    public static MethodHandle wcsnicmp$handle() {
        return wcsnicmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int wcsnicmp(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount)
     * }
     */
    public static MemorySegment wcsnicmp$address() {
        return wcsnicmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int wcsnicmp(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount)
     * }
     */
    public static int wcsnicmp(MemorySegment _String1, MemorySegment _String2, long _MaxCount) {
        var mh$ = wcsnicmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsnicmp", _String1, _String2, _MaxCount);
            }
            return (int)mh$.invokeExact(_String1, _String2, _MaxCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsnset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_SHORT,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcsnset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *wcsnset(wchar_t *_String, wchar_t _Value, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor wcsnset$descriptor() {
        return wcsnset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *wcsnset(wchar_t *_String, wchar_t _Value, size_t _MaxCount)
     * }
     */
    public static MethodHandle wcsnset$handle() {
        return wcsnset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *wcsnset(wchar_t *_String, wchar_t _Value, size_t _MaxCount)
     * }
     */
    public static MemorySegment wcsnset$address() {
        return wcsnset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *wcsnset(wchar_t *_String, wchar_t _Value, size_t _MaxCount)
     * }
     */
    public static MemorySegment wcsnset(MemorySegment _String, short _Value, long _MaxCount) {
        var mh$ = wcsnset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsnset", _String, _Value, _MaxCount);
            }
            return (MemorySegment)mh$.invokeExact(_String, _Value, _MaxCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsrev {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcsrev");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *wcsrev(wchar_t *_String)
     * }
     */
    public static FunctionDescriptor wcsrev$descriptor() {
        return wcsrev.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *wcsrev(wchar_t *_String)
     * }
     */
    public static MethodHandle wcsrev$handle() {
        return wcsrev.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *wcsrev(wchar_t *_String)
     * }
     */
    public static MemorySegment wcsrev$address() {
        return wcsrev.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *wcsrev(wchar_t *_String)
     * }
     */
    public static MemorySegment wcsrev(MemorySegment _String) {
        var mh$ = wcsrev.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsrev", _String);
            }
            return (MemorySegment)mh$.invokeExact(_String);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_SHORT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcsset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *wcsset(wchar_t *_String, wchar_t _Value)
     * }
     */
    public static FunctionDescriptor wcsset$descriptor() {
        return wcsset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *wcsset(wchar_t *_String, wchar_t _Value)
     * }
     */
    public static MethodHandle wcsset$handle() {
        return wcsset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *wcsset(wchar_t *_String, wchar_t _Value)
     * }
     */
    public static MemorySegment wcsset$address() {
        return wcsset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *wcsset(wchar_t *_String, wchar_t _Value)
     * }
     */
    public static MemorySegment wcsset(MemorySegment _String, short _Value) {
        var mh$ = wcsset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsset", _String, _Value);
            }
            return (MemorySegment)mh$.invokeExact(_String, _Value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcslwr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcslwr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *wcslwr(wchar_t *_String)
     * }
     */
    public static FunctionDescriptor wcslwr$descriptor() {
        return wcslwr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *wcslwr(wchar_t *_String)
     * }
     */
    public static MethodHandle wcslwr$handle() {
        return wcslwr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *wcslwr(wchar_t *_String)
     * }
     */
    public static MemorySegment wcslwr$address() {
        return wcslwr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *wcslwr(wchar_t *_String)
     * }
     */
    public static MemorySegment wcslwr(MemorySegment _String) {
        var mh$ = wcslwr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcslwr", _String);
            }
            return (MemorySegment)mh$.invokeExact(_String);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsupr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcsupr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *wcsupr(wchar_t *_String)
     * }
     */
    public static FunctionDescriptor wcsupr$descriptor() {
        return wcsupr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *wcsupr(wchar_t *_String)
     * }
     */
    public static MethodHandle wcsupr$handle() {
        return wcsupr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *wcsupr(wchar_t *_String)
     * }
     */
    public static MemorySegment wcsupr$address() {
        return wcsupr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *wcsupr(wchar_t *_String)
     * }
     */
    public static MemorySegment wcsupr(MemorySegment _String) {
        var mh$ = wcsupr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsupr", _String);
            }
            return (MemorySegment)mh$.invokeExact(_String);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsicoll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcsicoll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int wcsicoll(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static FunctionDescriptor wcsicoll$descriptor() {
        return wcsicoll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int wcsicoll(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static MethodHandle wcsicoll$handle() {
        return wcsicoll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int wcsicoll(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static MemorySegment wcsicoll$address() {
        return wcsicoll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int wcsicoll(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static int wcsicoll(MemorySegment _String1, MemorySegment _String2) {
        var mh$ = wcsicoll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsicoll", _String1, _String2);
            }
            return (int)mh$.invokeExact(_String1, _String2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wasctime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wasctime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *_wasctime(const struct tm *_Tm)
     * }
     */
    public static FunctionDescriptor _wasctime$descriptor() {
        return _wasctime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *_wasctime(const struct tm *_Tm)
     * }
     */
    public static MethodHandle _wasctime$handle() {
        return _wasctime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *_wasctime(const struct tm *_Tm)
     * }
     */
    public static MemorySegment _wasctime$address() {
        return _wasctime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *_wasctime(const struct tm *_Tm)
     * }
     */
    public static MemorySegment _wasctime(MemorySegment _Tm) {
        var mh$ = _wasctime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wasctime", _Tm);
            }
            return (MemorySegment)mh$.invokeExact(_Tm);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wasctime_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wasctime_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _wasctime_s(wchar_t *_Buffer, size_t _SizeInWords, const struct tm *_Tm)
     * }
     */
    public static FunctionDescriptor _wasctime_s$descriptor() {
        return _wasctime_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _wasctime_s(wchar_t *_Buffer, size_t _SizeInWords, const struct tm *_Tm)
     * }
     */
    public static MethodHandle _wasctime_s$handle() {
        return _wasctime_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _wasctime_s(wchar_t *_Buffer, size_t _SizeInWords, const struct tm *_Tm)
     * }
     */
    public static MemorySegment _wasctime_s$address() {
        return _wasctime_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _wasctime_s(wchar_t *_Buffer, size_t _SizeInWords, const struct tm *_Tm)
     * }
     */
    public static int _wasctime_s(MemorySegment _Buffer, long _SizeInWords, MemorySegment _Tm) {
        var mh$ = _wasctime_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wasctime_s", _Buffer, _SizeInWords, _Tm);
            }
            return (int)mh$.invokeExact(_Buffer, _SizeInWords, _Tm);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsftime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcsftime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t wcsftime(wchar_t *_Buffer, size_t _SizeInWords, const wchar_t *_Format, const struct tm *_Tm)
     * }
     */
    public static FunctionDescriptor wcsftime$descriptor() {
        return wcsftime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t wcsftime(wchar_t *_Buffer, size_t _SizeInWords, const wchar_t *_Format, const struct tm *_Tm)
     * }
     */
    public static MethodHandle wcsftime$handle() {
        return wcsftime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t wcsftime(wchar_t *_Buffer, size_t _SizeInWords, const wchar_t *_Format, const struct tm *_Tm)
     * }
     */
    public static MemorySegment wcsftime$address() {
        return wcsftime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t wcsftime(wchar_t *_Buffer, size_t _SizeInWords, const wchar_t *_Format, const struct tm *_Tm)
     * }
     */
    public static long wcsftime(MemorySegment _Buffer, long _SizeInWords, MemorySegment _Format, MemorySegment _Tm) {
        var mh$ = wcsftime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsftime", _Buffer, _SizeInWords, _Format, _Tm);
            }
            return (long)mh$.invokeExact(_Buffer, _SizeInWords, _Format, _Tm);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcsftime_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wcsftime_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t _wcsftime_l(wchar_t *_Buffer, size_t _SizeInWords, const wchar_t *_Format, const struct tm *_Tm, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcsftime_l$descriptor() {
        return _wcsftime_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t _wcsftime_l(wchar_t *_Buffer, size_t _SizeInWords, const wchar_t *_Format, const struct tm *_Tm, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcsftime_l$handle() {
        return _wcsftime_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t _wcsftime_l(wchar_t *_Buffer, size_t _SizeInWords, const wchar_t *_Format, const struct tm *_Tm, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcsftime_l$address() {
        return _wcsftime_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t _wcsftime_l(wchar_t *_Buffer, size_t _SizeInWords, const wchar_t *_Format, const struct tm *_Tm, _locale_t _Locale)
     * }
     */
    public static long _wcsftime_l(MemorySegment _Buffer, long _SizeInWords, MemorySegment _Format, MemorySegment _Tm, MemorySegment _Locale) {
        var mh$ = _wcsftime_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcsftime_l", _Buffer, _SizeInWords, _Format, _Tm, _Locale);
            }
            return (long)mh$.invokeExact(_Buffer, _SizeInWords, _Format, _Tm, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wctime32 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wctime32");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *_wctime32(const __time32_t *_Time)
     * }
     */
    public static FunctionDescriptor _wctime32$descriptor() {
        return _wctime32.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *_wctime32(const __time32_t *_Time)
     * }
     */
    public static MethodHandle _wctime32$handle() {
        return _wctime32.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *_wctime32(const __time32_t *_Time)
     * }
     */
    public static MemorySegment _wctime32$address() {
        return _wctime32.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *_wctime32(const __time32_t *_Time)
     * }
     */
    public static MemorySegment _wctime32(MemorySegment _Time) {
        var mh$ = _wctime32.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wctime32", _Time);
            }
            return (MemorySegment)mh$.invokeExact(_Time);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wctime32_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wctime32_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _wctime32_s(wchar_t *_Buffer, size_t _SizeInWords, const __time32_t *_Time)
     * }
     */
    public static FunctionDescriptor _wctime32_s$descriptor() {
        return _wctime32_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _wctime32_s(wchar_t *_Buffer, size_t _SizeInWords, const __time32_t *_Time)
     * }
     */
    public static MethodHandle _wctime32_s$handle() {
        return _wctime32_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _wctime32_s(wchar_t *_Buffer, size_t _SizeInWords, const __time32_t *_Time)
     * }
     */
    public static MemorySegment _wctime32_s$address() {
        return _wctime32_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _wctime32_s(wchar_t *_Buffer, size_t _SizeInWords, const __time32_t *_Time)
     * }
     */
    public static int _wctime32_s(MemorySegment _Buffer, long _SizeInWords, MemorySegment _Time) {
        var mh$ = _wctime32_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wctime32_s", _Buffer, _SizeInWords, _Time);
            }
            return (int)mh$.invokeExact(_Buffer, _SizeInWords, _Time);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wctime64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wctime64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *_wctime64(const __time64_t *_Time)
     * }
     */
    public static FunctionDescriptor _wctime64$descriptor() {
        return _wctime64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *_wctime64(const __time64_t *_Time)
     * }
     */
    public static MethodHandle _wctime64$handle() {
        return _wctime64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *_wctime64(const __time64_t *_Time)
     * }
     */
    public static MemorySegment _wctime64$address() {
        return _wctime64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *_wctime64(const __time64_t *_Time)
     * }
     */
    public static MemorySegment _wctime64(MemorySegment _Time) {
        var mh$ = _wctime64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wctime64", _Time);
            }
            return (MemorySegment)mh$.invokeExact(_Time);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wctime64_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wctime64_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _wctime64_s(wchar_t *_Buffer, size_t _SizeInWords, const __time64_t *_Time)
     * }
     */
    public static FunctionDescriptor _wctime64_s$descriptor() {
        return _wctime64_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _wctime64_s(wchar_t *_Buffer, size_t _SizeInWords, const __time64_t *_Time)
     * }
     */
    public static MethodHandle _wctime64_s$handle() {
        return _wctime64_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _wctime64_s(wchar_t *_Buffer, size_t _SizeInWords, const __time64_t *_Time)
     * }
     */
    public static MemorySegment _wctime64_s$address() {
        return _wctime64_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _wctime64_s(wchar_t *_Buffer, size_t _SizeInWords, const __time64_t *_Time)
     * }
     */
    public static int _wctime64_s(MemorySegment _Buffer, long _SizeInWords, MemorySegment _Time) {
        var mh$ = _wctime64_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wctime64_s", _Buffer, _SizeInWords, _Time);
            }
            return (int)mh$.invokeExact(_Buffer, _SizeInWords, _Time);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wstrdate_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wstrdate_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _wstrdate_s(wchar_t *_Buffer, size_t _SizeInWords)
     * }
     */
    public static FunctionDescriptor _wstrdate_s$descriptor() {
        return _wstrdate_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _wstrdate_s(wchar_t *_Buffer, size_t _SizeInWords)
     * }
     */
    public static MethodHandle _wstrdate_s$handle() {
        return _wstrdate_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _wstrdate_s(wchar_t *_Buffer, size_t _SizeInWords)
     * }
     */
    public static MemorySegment _wstrdate_s$address() {
        return _wstrdate_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _wstrdate_s(wchar_t *_Buffer, size_t _SizeInWords)
     * }
     */
    public static int _wstrdate_s(MemorySegment _Buffer, long _SizeInWords) {
        var mh$ = _wstrdate_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wstrdate_s", _Buffer, _SizeInWords);
            }
            return (int)mh$.invokeExact(_Buffer, _SizeInWords);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wstrdate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wstrdate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *_wstrdate(wchar_t *_Buffer)
     * }
     */
    public static FunctionDescriptor _wstrdate$descriptor() {
        return _wstrdate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *_wstrdate(wchar_t *_Buffer)
     * }
     */
    public static MethodHandle _wstrdate$handle() {
        return _wstrdate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *_wstrdate(wchar_t *_Buffer)
     * }
     */
    public static MemorySegment _wstrdate$address() {
        return _wstrdate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *_wstrdate(wchar_t *_Buffer)
     * }
     */
    public static MemorySegment _wstrdate(MemorySegment _Buffer) {
        var mh$ = _wstrdate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wstrdate", _Buffer);
            }
            return (MemorySegment)mh$.invokeExact(_Buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wstrtime_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wstrtime_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _wstrtime_s(wchar_t *_Buffer, size_t _SizeInWords)
     * }
     */
    public static FunctionDescriptor _wstrtime_s$descriptor() {
        return _wstrtime_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _wstrtime_s(wchar_t *_Buffer, size_t _SizeInWords)
     * }
     */
    public static MethodHandle _wstrtime_s$handle() {
        return _wstrtime_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _wstrtime_s(wchar_t *_Buffer, size_t _SizeInWords)
     * }
     */
    public static MemorySegment _wstrtime_s$address() {
        return _wstrtime_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _wstrtime_s(wchar_t *_Buffer, size_t _SizeInWords)
     * }
     */
    public static int _wstrtime_s(MemorySegment _Buffer, long _SizeInWords) {
        var mh$ = _wstrtime_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wstrtime_s", _Buffer, _SizeInWords);
            }
            return (int)mh$.invokeExact(_Buffer, _SizeInWords);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wstrtime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wstrtime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *_wstrtime(wchar_t *_Buffer)
     * }
     */
    public static FunctionDescriptor _wstrtime$descriptor() {
        return _wstrtime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *_wstrtime(wchar_t *_Buffer)
     * }
     */
    public static MethodHandle _wstrtime$handle() {
        return _wstrtime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *_wstrtime(wchar_t *_Buffer)
     * }
     */
    public static MemorySegment _wstrtime$address() {
        return _wstrtime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *_wstrtime(wchar_t *_Buffer)
     * }
     */
    public static MemorySegment _wstrtime(MemorySegment _Buffer) {
        var mh$ = _wstrtime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wstrtime", _Buffer);
            }
            return (MemorySegment)mh$.invokeExact(_Buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef unsigned short _ino_t
     * }
     */
    public static final OfShort _ino_t = Python_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef _ino_t ino_t
     * }
     */
    public static final OfShort ino_t = Python_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int _dev_t
     * }
     */
    public static final OfInt _dev_t = Python_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef _dev_t dev_t
     * }
     */
    public static final OfInt dev_t = Python_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long _off_t
     * }
     */
    public static final OfInt _off_t = Python_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef _off_t off_t
     * }
     */
    public static final OfInt off_t = Python_h.C_LONG;

    private static class _fstat32 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_fstat32");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _fstat32(int _FileHandle, struct _stat32 *_Stat)
     * }
     */
    public static FunctionDescriptor _fstat32$descriptor() {
        return _fstat32.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _fstat32(int _FileHandle, struct _stat32 *_Stat)
     * }
     */
    public static MethodHandle _fstat32$handle() {
        return _fstat32.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _fstat32(int _FileHandle, struct _stat32 *_Stat)
     * }
     */
    public static MemorySegment _fstat32$address() {
        return _fstat32.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _fstat32(int _FileHandle, struct _stat32 *_Stat)
     * }
     */
    public static int _fstat32(int _FileHandle, MemorySegment _Stat) {
        var mh$ = _fstat32.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fstat32", _FileHandle, _Stat);
            }
            return (int)mh$.invokeExact(_FileHandle, _Stat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fstat32i64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_fstat32i64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _fstat32i64(int _FileHandle, struct _stat32i64 *_Stat)
     * }
     */
    public static FunctionDescriptor _fstat32i64$descriptor() {
        return _fstat32i64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _fstat32i64(int _FileHandle, struct _stat32i64 *_Stat)
     * }
     */
    public static MethodHandle _fstat32i64$handle() {
        return _fstat32i64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _fstat32i64(int _FileHandle, struct _stat32i64 *_Stat)
     * }
     */
    public static MemorySegment _fstat32i64$address() {
        return _fstat32i64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _fstat32i64(int _FileHandle, struct _stat32i64 *_Stat)
     * }
     */
    public static int _fstat32i64(int _FileHandle, MemorySegment _Stat) {
        var mh$ = _fstat32i64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fstat32i64", _FileHandle, _Stat);
            }
            return (int)mh$.invokeExact(_FileHandle, _Stat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fstat64i32 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_fstat64i32");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _fstat64i32(int _FileHandle, struct _stat64i32 *_Stat)
     * }
     */
    public static FunctionDescriptor _fstat64i32$descriptor() {
        return _fstat64i32.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _fstat64i32(int _FileHandle, struct _stat64i32 *_Stat)
     * }
     */
    public static MethodHandle _fstat64i32$handle() {
        return _fstat64i32.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _fstat64i32(int _FileHandle, struct _stat64i32 *_Stat)
     * }
     */
    public static MemorySegment _fstat64i32$address() {
        return _fstat64i32.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _fstat64i32(int _FileHandle, struct _stat64i32 *_Stat)
     * }
     */
    public static int _fstat64i32(int _FileHandle, MemorySegment _Stat) {
        var mh$ = _fstat64i32.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fstat64i32", _FileHandle, _Stat);
            }
            return (int)mh$.invokeExact(_FileHandle, _Stat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fstat64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_fstat64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _fstat64(int _FileHandle, struct _stat64 *_Stat)
     * }
     */
    public static FunctionDescriptor _fstat64$descriptor() {
        return _fstat64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _fstat64(int _FileHandle, struct _stat64 *_Stat)
     * }
     */
    public static MethodHandle _fstat64$handle() {
        return _fstat64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _fstat64(int _FileHandle, struct _stat64 *_Stat)
     * }
     */
    public static MemorySegment _fstat64$address() {
        return _fstat64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _fstat64(int _FileHandle, struct _stat64 *_Stat)
     * }
     */
    public static int _fstat64(int _FileHandle, MemorySegment _Stat) {
        var mh$ = _fstat64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fstat64", _FileHandle, _Stat);
            }
            return (int)mh$.invokeExact(_FileHandle, _Stat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _stat32 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_stat32");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _stat32(const char *_FileName, struct _stat32 *_Stat)
     * }
     */
    public static FunctionDescriptor _stat32$descriptor() {
        return _stat32.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _stat32(const char *_FileName, struct _stat32 *_Stat)
     * }
     */
    public static MethodHandle _stat32$handle() {
        return _stat32.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _stat32(const char *_FileName, struct _stat32 *_Stat)
     * }
     */
    public static MemorySegment _stat32$address() {
        return _stat32.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _stat32(const char *_FileName, struct _stat32 *_Stat)
     * }
     */
    public static int _stat32(MemorySegment _FileName, MemorySegment _Stat) {
        var mh$ = _stat32.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_stat32", _FileName, _Stat);
            }
            return (int)mh$.invokeExact(_FileName, _Stat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _stat32i64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_stat32i64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _stat32i64(const char *_FileName, struct _stat32i64 *_Stat)
     * }
     */
    public static FunctionDescriptor _stat32i64$descriptor() {
        return _stat32i64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _stat32i64(const char *_FileName, struct _stat32i64 *_Stat)
     * }
     */
    public static MethodHandle _stat32i64$handle() {
        return _stat32i64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _stat32i64(const char *_FileName, struct _stat32i64 *_Stat)
     * }
     */
    public static MemorySegment _stat32i64$address() {
        return _stat32i64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _stat32i64(const char *_FileName, struct _stat32i64 *_Stat)
     * }
     */
    public static int _stat32i64(MemorySegment _FileName, MemorySegment _Stat) {
        var mh$ = _stat32i64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_stat32i64", _FileName, _Stat);
            }
            return (int)mh$.invokeExact(_FileName, _Stat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _stat64i32 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_stat64i32");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _stat64i32(const char *_FileName, struct _stat64i32 *_Stat)
     * }
     */
    public static FunctionDescriptor _stat64i32$descriptor() {
        return _stat64i32.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _stat64i32(const char *_FileName, struct _stat64i32 *_Stat)
     * }
     */
    public static MethodHandle _stat64i32$handle() {
        return _stat64i32.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _stat64i32(const char *_FileName, struct _stat64i32 *_Stat)
     * }
     */
    public static MemorySegment _stat64i32$address() {
        return _stat64i32.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _stat64i32(const char *_FileName, struct _stat64i32 *_Stat)
     * }
     */
    public static int _stat64i32(MemorySegment _FileName, MemorySegment _Stat) {
        var mh$ = _stat64i32.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_stat64i32", _FileName, _Stat);
            }
            return (int)mh$.invokeExact(_FileName, _Stat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _stat64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_stat64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _stat64(const char *_FileName, struct _stat64 *_Stat)
     * }
     */
    public static FunctionDescriptor _stat64$descriptor() {
        return _stat64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _stat64(const char *_FileName, struct _stat64 *_Stat)
     * }
     */
    public static MethodHandle _stat64$handle() {
        return _stat64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _stat64(const char *_FileName, struct _stat64 *_Stat)
     * }
     */
    public static MemorySegment _stat64$address() {
        return _stat64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _stat64(const char *_FileName, struct _stat64 *_Stat)
     * }
     */
    public static int _stat64(MemorySegment _FileName, MemorySegment _Stat) {
        var mh$ = _stat64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_stat64", _FileName, _Stat);
            }
            return (int)mh$.invokeExact(_FileName, _Stat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wstat32 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wstat32");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _wstat32(const wchar_t *_FileName, struct _stat32 *_Stat)
     * }
     */
    public static FunctionDescriptor _wstat32$descriptor() {
        return _wstat32.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _wstat32(const wchar_t *_FileName, struct _stat32 *_Stat)
     * }
     */
    public static MethodHandle _wstat32$handle() {
        return _wstat32.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _wstat32(const wchar_t *_FileName, struct _stat32 *_Stat)
     * }
     */
    public static MemorySegment _wstat32$address() {
        return _wstat32.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _wstat32(const wchar_t *_FileName, struct _stat32 *_Stat)
     * }
     */
    public static int _wstat32(MemorySegment _FileName, MemorySegment _Stat) {
        var mh$ = _wstat32.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wstat32", _FileName, _Stat);
            }
            return (int)mh$.invokeExact(_FileName, _Stat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wstat32i64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wstat32i64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _wstat32i64(const wchar_t *_FileName, struct _stat32i64 *_Stat)
     * }
     */
    public static FunctionDescriptor _wstat32i64$descriptor() {
        return _wstat32i64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _wstat32i64(const wchar_t *_FileName, struct _stat32i64 *_Stat)
     * }
     */
    public static MethodHandle _wstat32i64$handle() {
        return _wstat32i64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _wstat32i64(const wchar_t *_FileName, struct _stat32i64 *_Stat)
     * }
     */
    public static MemorySegment _wstat32i64$address() {
        return _wstat32i64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _wstat32i64(const wchar_t *_FileName, struct _stat32i64 *_Stat)
     * }
     */
    public static int _wstat32i64(MemorySegment _FileName, MemorySegment _Stat) {
        var mh$ = _wstat32i64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wstat32i64", _FileName, _Stat);
            }
            return (int)mh$.invokeExact(_FileName, _Stat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wstat64i32 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wstat64i32");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _wstat64i32(const wchar_t *_FileName, struct _stat64i32 *_Stat)
     * }
     */
    public static FunctionDescriptor _wstat64i32$descriptor() {
        return _wstat64i32.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _wstat64i32(const wchar_t *_FileName, struct _stat64i32 *_Stat)
     * }
     */
    public static MethodHandle _wstat64i32$handle() {
        return _wstat64i32.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _wstat64i32(const wchar_t *_FileName, struct _stat64i32 *_Stat)
     * }
     */
    public static MemorySegment _wstat64i32$address() {
        return _wstat64i32.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _wstat64i32(const wchar_t *_FileName, struct _stat64i32 *_Stat)
     * }
     */
    public static int _wstat64i32(MemorySegment _FileName, MemorySegment _Stat) {
        var mh$ = _wstat64i32.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wstat64i32", _FileName, _Stat);
            }
            return (int)mh$.invokeExact(_FileName, _Stat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wstat64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wstat64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _wstat64(const wchar_t *_FileName, struct _stat64 *_Stat)
     * }
     */
    public static FunctionDescriptor _wstat64$descriptor() {
        return _wstat64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _wstat64(const wchar_t *_FileName, struct _stat64 *_Stat)
     * }
     */
    public static MethodHandle _wstat64$handle() {
        return _wstat64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _wstat64(const wchar_t *_FileName, struct _stat64 *_Stat)
     * }
     */
    public static MemorySegment _wstat64$address() {
        return _wstat64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _wstat64(const wchar_t *_FileName, struct _stat64 *_Stat)
     * }
     */
    public static int _wstat64(MemorySegment _FileName, MemorySegment _Stat) {
        var mh$ = _wstat64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wstat64", _FileName, _Stat);
            }
            return (int)mh$.invokeExact(_FileName, _Stat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef wchar_t _Wint_t
     * }
     */
    public static final OfShort _Wint_t = Python_h.C_SHORT;

    private static class _wsetlocale {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wsetlocale");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *_wsetlocale(int _Category, const wchar_t *_Locale)
     * }
     */
    public static FunctionDescriptor _wsetlocale$descriptor() {
        return _wsetlocale.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *_wsetlocale(int _Category, const wchar_t *_Locale)
     * }
     */
    public static MethodHandle _wsetlocale$handle() {
        return _wsetlocale.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *_wsetlocale(int _Category, const wchar_t *_Locale)
     * }
     */
    public static MemorySegment _wsetlocale$address() {
        return _wsetlocale.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *_wsetlocale(int _Category, const wchar_t *_Locale)
     * }
     */
    public static MemorySegment _wsetlocale(int _Category, MemorySegment _Locale) {
        var mh$ = _wsetlocale.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wsetlocale", _Category, _Locale);
            }
            return (MemorySegment)mh$.invokeExact(_Category, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcreate_locale {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_wcreate_locale");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _locale_t _wcreate_locale(int _Category, const wchar_t *_Locale)
     * }
     */
    public static FunctionDescriptor _wcreate_locale$descriptor() {
        return _wcreate_locale.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _locale_t _wcreate_locale(int _Category, const wchar_t *_Locale)
     * }
     */
    public static MethodHandle _wcreate_locale$handle() {
        return _wcreate_locale.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _locale_t _wcreate_locale(int _Category, const wchar_t *_Locale)
     * }
     */
    public static MemorySegment _wcreate_locale$address() {
        return _wcreate_locale.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _locale_t _wcreate_locale(int _Category, const wchar_t *_Locale)
     * }
     */
    public static MemorySegment _wcreate_locale(int _Category, MemorySegment _Locale) {
        var mh$ = _wcreate_locale.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcreate_locale", _Category, _Locale);
            }
            return (MemorySegment)mh$.invokeExact(_Category, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class btowc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_SHORT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("btowc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wint_t btowc(int _Ch)
     * }
     */
    public static FunctionDescriptor btowc$descriptor() {
        return btowc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wint_t btowc(int _Ch)
     * }
     */
    public static MethodHandle btowc$handle() {
        return btowc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wint_t btowc(int _Ch)
     * }
     */
    public static MemorySegment btowc$address() {
        return btowc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wint_t btowc(int _Ch)
     * }
     */
    public static short btowc(int _Ch) {
        var mh$ = btowc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("btowc", _Ch);
            }
            return (short)mh$.invokeExact(_Ch);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mbrlen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("mbrlen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t mbrlen(const char *_Ch, size_t _SizeInBytes, mbstate_t *_State)
     * }
     */
    public static FunctionDescriptor mbrlen$descriptor() {
        return mbrlen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t mbrlen(const char *_Ch, size_t _SizeInBytes, mbstate_t *_State)
     * }
     */
    public static MethodHandle mbrlen$handle() {
        return mbrlen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t mbrlen(const char *_Ch, size_t _SizeInBytes, mbstate_t *_State)
     * }
     */
    public static MemorySegment mbrlen$address() {
        return mbrlen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t mbrlen(const char *_Ch, size_t _SizeInBytes, mbstate_t *_State)
     * }
     */
    public static long mbrlen(MemorySegment _Ch, long _SizeInBytes, MemorySegment _State) {
        var mh$ = mbrlen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mbrlen", _Ch, _SizeInBytes, _State);
            }
            return (long)mh$.invokeExact(_Ch, _SizeInBytes, _State);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mbrtowc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("mbrtowc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t mbrtowc(wchar_t *_DstCh, const char *_SrcCh, size_t _SizeInBytes, mbstate_t *_State)
     * }
     */
    public static FunctionDescriptor mbrtowc$descriptor() {
        return mbrtowc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t mbrtowc(wchar_t *_DstCh, const char *_SrcCh, size_t _SizeInBytes, mbstate_t *_State)
     * }
     */
    public static MethodHandle mbrtowc$handle() {
        return mbrtowc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t mbrtowc(wchar_t *_DstCh, const char *_SrcCh, size_t _SizeInBytes, mbstate_t *_State)
     * }
     */
    public static MemorySegment mbrtowc$address() {
        return mbrtowc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t mbrtowc(wchar_t *_DstCh, const char *_SrcCh, size_t _SizeInBytes, mbstate_t *_State)
     * }
     */
    public static long mbrtowc(MemorySegment _DstCh, MemorySegment _SrcCh, long _SizeInBytes, MemorySegment _State) {
        var mh$ = mbrtowc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mbrtowc", _DstCh, _SrcCh, _SizeInBytes, _State);
            }
            return (long)mh$.invokeExact(_DstCh, _SrcCh, _SizeInBytes, _State);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mbsrtowcs_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("mbsrtowcs_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t mbsrtowcs_s(size_t *_Retval, wchar_t *_Dst, size_t _Size, const char **_PSrc, size_t _N, mbstate_t *_State)
     * }
     */
    public static FunctionDescriptor mbsrtowcs_s$descriptor() {
        return mbsrtowcs_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t mbsrtowcs_s(size_t *_Retval, wchar_t *_Dst, size_t _Size, const char **_PSrc, size_t _N, mbstate_t *_State)
     * }
     */
    public static MethodHandle mbsrtowcs_s$handle() {
        return mbsrtowcs_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t mbsrtowcs_s(size_t *_Retval, wchar_t *_Dst, size_t _Size, const char **_PSrc, size_t _N, mbstate_t *_State)
     * }
     */
    public static MemorySegment mbsrtowcs_s$address() {
        return mbsrtowcs_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t mbsrtowcs_s(size_t *_Retval, wchar_t *_Dst, size_t _Size, const char **_PSrc, size_t _N, mbstate_t *_State)
     * }
     */
    public static int mbsrtowcs_s(MemorySegment _Retval, MemorySegment _Dst, long _Size, MemorySegment _PSrc, long _N, MemorySegment _State) {
        var mh$ = mbsrtowcs_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mbsrtowcs_s", _Retval, _Dst, _Size, _PSrc, _N, _State);
            }
            return (int)mh$.invokeExact(_Retval, _Dst, _Size, _PSrc, _N, _State);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mbsrtowcs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("mbsrtowcs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t mbsrtowcs(wchar_t *_Dest, const char **_PSrc, size_t _Count, mbstate_t *_State)
     * }
     */
    public static FunctionDescriptor mbsrtowcs$descriptor() {
        return mbsrtowcs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t mbsrtowcs(wchar_t *_Dest, const char **_PSrc, size_t _Count, mbstate_t *_State)
     * }
     */
    public static MethodHandle mbsrtowcs$handle() {
        return mbsrtowcs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t mbsrtowcs(wchar_t *_Dest, const char **_PSrc, size_t _Count, mbstate_t *_State)
     * }
     */
    public static MemorySegment mbsrtowcs$address() {
        return mbsrtowcs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t mbsrtowcs(wchar_t *_Dest, const char **_PSrc, size_t _Count, mbstate_t *_State)
     * }
     */
    public static long mbsrtowcs(MemorySegment _Dest, MemorySegment _PSrc, long _Count, MemorySegment _State) {
        var mh$ = mbsrtowcs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mbsrtowcs", _Dest, _PSrc, _Count, _State);
            }
            return (long)mh$.invokeExact(_Dest, _PSrc, _Count, _State);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcrtomb_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_SHORT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcrtomb_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t wcrtomb_s(size_t *_Retval, char *_Dst, size_t _SizeInBytes, wchar_t _Ch, mbstate_t *_State)
     * }
     */
    public static FunctionDescriptor wcrtomb_s$descriptor() {
        return wcrtomb_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t wcrtomb_s(size_t *_Retval, char *_Dst, size_t _SizeInBytes, wchar_t _Ch, mbstate_t *_State)
     * }
     */
    public static MethodHandle wcrtomb_s$handle() {
        return wcrtomb_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t wcrtomb_s(size_t *_Retval, char *_Dst, size_t _SizeInBytes, wchar_t _Ch, mbstate_t *_State)
     * }
     */
    public static MemorySegment wcrtomb_s$address() {
        return wcrtomb_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t wcrtomb_s(size_t *_Retval, char *_Dst, size_t _SizeInBytes, wchar_t _Ch, mbstate_t *_State)
     * }
     */
    public static int wcrtomb_s(MemorySegment _Retval, MemorySegment _Dst, long _SizeInBytes, short _Ch, MemorySegment _State) {
        var mh$ = wcrtomb_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcrtomb_s", _Retval, _Dst, _SizeInBytes, _Ch, _State);
            }
            return (int)mh$.invokeExact(_Retval, _Dst, _SizeInBytes, _Ch, _State);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcrtomb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_SHORT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcrtomb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t wcrtomb(char *_Dest, wchar_t _Source, mbstate_t *_State)
     * }
     */
    public static FunctionDescriptor wcrtomb$descriptor() {
        return wcrtomb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t wcrtomb(char *_Dest, wchar_t _Source, mbstate_t *_State)
     * }
     */
    public static MethodHandle wcrtomb$handle() {
        return wcrtomb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t wcrtomb(char *_Dest, wchar_t _Source, mbstate_t *_State)
     * }
     */
    public static MemorySegment wcrtomb$address() {
        return wcrtomb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t wcrtomb(char *_Dest, wchar_t _Source, mbstate_t *_State)
     * }
     */
    public static long wcrtomb(MemorySegment _Dest, short _Source, MemorySegment _State) {
        var mh$ = wcrtomb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcrtomb", _Dest, _Source, _State);
            }
            return (long)mh$.invokeExact(_Dest, _Source, _State);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsrtombs_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcsrtombs_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t wcsrtombs_s(size_t *_Retval, char *_Dst, size_t _SizeInBytes, const wchar_t **_Src, size_t _Size, mbstate_t *_State)
     * }
     */
    public static FunctionDescriptor wcsrtombs_s$descriptor() {
        return wcsrtombs_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t wcsrtombs_s(size_t *_Retval, char *_Dst, size_t _SizeInBytes, const wchar_t **_Src, size_t _Size, mbstate_t *_State)
     * }
     */
    public static MethodHandle wcsrtombs_s$handle() {
        return wcsrtombs_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t wcsrtombs_s(size_t *_Retval, char *_Dst, size_t _SizeInBytes, const wchar_t **_Src, size_t _Size, mbstate_t *_State)
     * }
     */
    public static MemorySegment wcsrtombs_s$address() {
        return wcsrtombs_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t wcsrtombs_s(size_t *_Retval, char *_Dst, size_t _SizeInBytes, const wchar_t **_Src, size_t _Size, mbstate_t *_State)
     * }
     */
    public static int wcsrtombs_s(MemorySegment _Retval, MemorySegment _Dst, long _SizeInBytes, MemorySegment _Src, long _Size, MemorySegment _State) {
        var mh$ = wcsrtombs_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsrtombs_s", _Retval, _Dst, _SizeInBytes, _Src, _Size, _State);
            }
            return (int)mh$.invokeExact(_Retval, _Dst, _SizeInBytes, _Src, _Size, _State);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsrtombs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcsrtombs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t wcsrtombs(char *_Dest, const wchar_t **_PSource, size_t _Count, mbstate_t *_State)
     * }
     */
    public static FunctionDescriptor wcsrtombs$descriptor() {
        return wcsrtombs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t wcsrtombs(char *_Dest, const wchar_t **_PSource, size_t _Count, mbstate_t *_State)
     * }
     */
    public static MethodHandle wcsrtombs$handle() {
        return wcsrtombs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t wcsrtombs(char *_Dest, const wchar_t **_PSource, size_t _Count, mbstate_t *_State)
     * }
     */
    public static MemorySegment wcsrtombs$address() {
        return wcsrtombs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t wcsrtombs(char *_Dest, const wchar_t **_PSource, size_t _Count, mbstate_t *_State)
     * }
     */
    public static long wcsrtombs(MemorySegment _Dest, MemorySegment _PSource, long _Count, MemorySegment _State) {
        var mh$ = wcsrtombs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsrtombs", _Dest, _PSource, _Count, _State);
            }
            return (long)mh$.invokeExact(_Dest, _PSource, _Count, _State);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wctob {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_SHORT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wctob");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int wctob(wint_t _WCh)
     * }
     */
    public static FunctionDescriptor wctob$descriptor() {
        return wctob.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int wctob(wint_t _WCh)
     * }
     */
    public static MethodHandle wctob$handle() {
        return wctob.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int wctob(wint_t _WCh)
     * }
     */
    public static MemorySegment wctob$address() {
        return wctob.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int wctob(wint_t _WCh)
     * }
     */
    public static int wctob(short _WCh) {
        var mh$ = wctob.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wctob", _WCh);
            }
            return (int)mh$.invokeExact(_WCh);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wmemcpy_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wmemcpy_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t wmemcpy_s(wchar_t *_S1, rsize_t _N1, const wchar_t *_S2, rsize_t _N)
     * }
     */
    public static FunctionDescriptor wmemcpy_s$descriptor() {
        return wmemcpy_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t wmemcpy_s(wchar_t *_S1, rsize_t _N1, const wchar_t *_S2, rsize_t _N)
     * }
     */
    public static MethodHandle wmemcpy_s$handle() {
        return wmemcpy_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t wmemcpy_s(wchar_t *_S1, rsize_t _N1, const wchar_t *_S2, rsize_t _N)
     * }
     */
    public static MemorySegment wmemcpy_s$address() {
        return wmemcpy_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t wmemcpy_s(wchar_t *_S1, rsize_t _N1, const wchar_t *_S2, rsize_t _N)
     * }
     */
    public static int wmemcpy_s(MemorySegment _S1, long _N1, MemorySegment _S2, long _N) {
        var mh$ = wmemcpy_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wmemcpy_s", _S1, _N1, _S2, _N);
            }
            return (int)mh$.invokeExact(_S1, _N1, _S2, _N);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wmemmove_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wmemmove_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t wmemmove_s(wchar_t *_S1, rsize_t _N1, const wchar_t *_S2, rsize_t _N)
     * }
     */
    public static FunctionDescriptor wmemmove_s$descriptor() {
        return wmemmove_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t wmemmove_s(wchar_t *_S1, rsize_t _N1, const wchar_t *_S2, rsize_t _N)
     * }
     */
    public static MethodHandle wmemmove_s$handle() {
        return wmemmove_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t wmemmove_s(wchar_t *_S1, rsize_t _N1, const wchar_t *_S2, rsize_t _N)
     * }
     */
    public static MemorySegment wmemmove_s$address() {
        return wmemmove_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t wmemmove_s(wchar_t *_S1, rsize_t _N1, const wchar_t *_S2, rsize_t _N)
     * }
     */
    public static int wmemmove_s(MemorySegment _S1, long _N1, MemorySegment _S2, long _N) {
        var mh$ = wmemmove_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wmemmove_s", _S1, _N1, _S2, _N);
            }
            return (int)mh$.invokeExact(_S1, _N1, _S2, _N);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef signed char int8_t
     * }
     */
    public static final OfByte int8_t = Python_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef short int16_t
     * }
     */
    public static final OfShort int16_t = Python_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef int int32_t
     * }
     */
    public static final OfInt int32_t = Python_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long long int64_t
     * }
     */
    public static final OfLong int64_t = Python_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned char uint8_t
     * }
     */
    public static final OfByte uint8_t = Python_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned short uint16_t
     * }
     */
    public static final OfShort uint16_t = Python_h.C_SHORT;
}

